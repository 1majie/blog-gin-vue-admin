import { defineComponent, ref, onMounted, nextTick, onBeforeUnmount, watch } from "vue-demi";
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
function _toPrimitive(input, hint) {
  if (_typeof$2(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$2(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof$2(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$3(o, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest();
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableRest();
}
var Element = /* @__PURE__ */ function() {
  function Element2(tag) {
    var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    _classCallCheck(this, Element2);
    if (typeof tag === "string") {
      this.el = document.createElement(tag);
      this.el.className = className;
    } else {
      this.el = tag;
    }
    this.data = {};
  }
  _createClass(Element2, [{
    key: "data",
    value: function data(key, value) {
      if (value !== void 0) {
        this.data[key] = value;
        return this;
      }
      return this.data[key];
    }
  }, {
    key: "on",
    value: function on(eventNames, handler) {
      var _eventNames$split = eventNames.split("."), _eventNames$split2 = _toArray(_eventNames$split), fen = _eventNames$split2[0], oen = _eventNames$split2.slice(1);
      var eventName = fen;
      if (eventName === "mousewheel" && /Firefox/i.test(window.navigator.userAgent)) {
        eventName = "DOMMouseScroll";
      }
      this.el.addEventListener(eventName, function(evt) {
        handler(evt);
        for (var i = 0; i < oen.length; i += 1) {
          var k = oen[i];
          if (k === "left" && evt.button !== 0) {
            return;
          }
          if (k === "right" && evt.button !== 2) {
            return;
          }
          if (k === "stop") {
            evt.stopPropagation();
          }
        }
      });
      return this;
    }
  }, {
    key: "offset",
    value: function offset(value) {
      var _this = this;
      if (value !== void 0) {
        Object.keys(value).forEach(function(k) {
          _this.css(k, "".concat(value[k], "px"));
        });
        return this;
      }
      var _this$el = this.el, offsetTop = _this$el.offsetTop, offsetLeft = _this$el.offsetLeft, offsetHeight = _this$el.offsetHeight, offsetWidth = _this$el.offsetWidth;
      return {
        top: offsetTop,
        left: offsetLeft,
        height: offsetHeight,
        width: offsetWidth
      };
    }
  }, {
    key: "scroll",
    value: function scroll(v) {
      var el = this.el;
      if (v !== void 0) {
        if (v.left !== void 0) {
          el.scrollLeft = v.left;
        }
        if (v.top !== void 0) {
          el.scrollTop = v.top;
        }
      }
      return {
        left: el.scrollLeft,
        top: el.scrollTop
      };
    }
  }, {
    key: "box",
    value: function box() {
      return this.el.getBoundingClientRect();
    }
  }, {
    key: "parent",
    value: function parent() {
      return new Element2(this.el.parentNode);
    }
  }, {
    key: "children",
    value: function children() {
      var _this2 = this;
      for (var _len = arguments.length, eles = new Array(_len), _key = 0; _key < _len; _key++) {
        eles[_key] = arguments[_key];
      }
      if (arguments.length === 0) {
        return this.el.childNodes;
      }
      eles.forEach(function(ele) {
        return _this2.child(ele);
      });
      return this;
    }
  }, {
    key: "removeChild",
    value: function removeChild(el) {
      this.el.removeChild(el);
    }
    /*
    first() {
      return this.el.firstChild;
    }
     last() {
      return this.el.lastChild;
    }
     remove(ele) {
      return this.el.removeChild(ele);
    }
     prepend(ele) {
      const { el } = this;
      if (el.children.length > 0) {
        el.insertBefore(ele, el.firstChild);
      } else {
        el.appendChild(ele);
      }
      return this;
    }
     prev() {
      return this.el.previousSibling;
    }
     next() {
      return this.el.nextSibling;
    }
    */
  }, {
    key: "child",
    value: function child(arg) {
      var ele = arg;
      if (typeof arg === "string") {
        ele = document.createTextNode(arg);
      } else if (arg instanceof Element2) {
        ele = arg.el;
      }
      this.el.appendChild(ele);
      return this;
    }
  }, {
    key: "contains",
    value: function contains(ele) {
      return this.el.contains(ele);
    }
  }, {
    key: "className",
    value: function className(v) {
      if (v !== void 0) {
        this.el.className = v;
        return this;
      }
      return this.el.className;
    }
  }, {
    key: "addClass",
    value: function addClass(name) {
      this.el.classList.add(name);
      return this;
    }
  }, {
    key: "hasClass",
    value: function hasClass(name) {
      return this.el.classList.contains(name);
    }
  }, {
    key: "removeClass",
    value: function removeClass(name) {
      this.el.classList.remove(name);
      return this;
    }
  }, {
    key: "toggle",
    value: function toggle() {
      var cls = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "active";
      return this.toggleClass(cls);
    }
  }, {
    key: "toggleClass",
    value: function toggleClass(name) {
      return this.el.classList.toggle(name);
    }
  }, {
    key: "active",
    value: function active() {
      var flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var cls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "active";
      if (flag)
        this.addClass(cls);
      else
        this.removeClass(cls);
      return this;
    }
  }, {
    key: "checked",
    value: function checked() {
      var flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this.active(flag, "checked");
      return this;
    }
  }, {
    key: "disabled",
    value: function disabled() {
      var flag = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (flag)
        this.addClass("disabled");
      else
        this.removeClass("disabled");
      return this;
    }
    // key, value
    // key
    // {k, v}...
  }, {
    key: "attr",
    value: function attr(key, value) {
      var _this3 = this;
      if (value !== void 0) {
        this.el.setAttribute(key, value);
      } else {
        if (typeof key === "string") {
          return this.el.getAttribute(key);
        }
        Object.keys(key).forEach(function(k) {
          _this3.el.setAttribute(k, key[k]);
        });
      }
      return this;
    }
  }, {
    key: "removeAttr",
    value: function removeAttr(key) {
      this.el.removeAttribute(key);
      return this;
    }
  }, {
    key: "html",
    value: function html(content) {
      if (content !== void 0) {
        this.el.innerHTML = content;
        return this;
      }
      return this.el.innerHTML;
    }
  }, {
    key: "val",
    value: function val(v) {
      if (v !== void 0) {
        this.el.value = v;
        return this;
      }
      return this.el.value;
    }
  }, {
    key: "focus",
    value: function focus() {
      this.el.focus();
    }
  }, {
    key: "cssRemoveKeys",
    value: function cssRemoveKeys() {
      var _this4 = this;
      for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        keys[_key2] = arguments[_key2];
      }
      keys.forEach(function(k) {
        return _this4.el.style.removeProperty(k);
      });
      return this;
    }
    // css( propertyName )
    // css( propertyName, value )
    // css( properties )
  }, {
    key: "css",
    value: function css(name, value) {
      var _this5 = this;
      if (value === void 0 && typeof name !== "string") {
        Object.keys(name).forEach(function(k) {
          _this5.el.style[k] = name[k];
        });
        return this;
      }
      if (value !== void 0) {
        this.el.style[name] = value;
        return this;
      }
      return this.el.style[name];
    }
  }, {
    key: "computedStyle",
    value: function computedStyle() {
      return window.getComputedStyle(this.el, null);
    }
  }, {
    key: "show",
    value: function show() {
      this.css("display", "block");
      return this;
    }
  }, {
    key: "hide",
    value: function hide() {
      this.css("display", "none");
      return this;
    }
  }]);
  return Element2;
}();
var h = function h2(tag) {
  var className = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return new Element(tag, className);
};
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$3(arr);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread();
}
var alphabets = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
function stringAt(index2) {
  var str = "";
  var cindex = index2;
  while (cindex >= alphabets.length) {
    cindex /= alphabets.length;
    cindex -= 1;
    str += alphabets[parseInt(cindex, 10) % alphabets.length];
  }
  var last = index2 % alphabets.length;
  str += alphabets[last];
  return str;
}
function indexAt(str) {
  var ret = 0;
  for (var i = 0; i < str.length - 1; i += 1) {
    var cindex = str.charCodeAt(i) - 65;
    var exponet = str.length - 1 - i;
    ret += Math.pow(alphabets.length, exponet) + alphabets.length * cindex;
  }
  ret += str.charCodeAt(str.length - 1) - 65;
  return ret;
}
function expr2xy(src) {
  var x = "";
  var y = "";
  for (var i = 0; i < src.length; i += 1) {
    if (src.charAt(i) >= "0" && src.charAt(i) <= "9") {
      y += src.charAt(i);
    } else {
      x += src.charAt(i);
    }
  }
  return [indexAt(x), parseInt(y, 10) - 1];
}
function xy2expr(x, y) {
  return "".concat(stringAt(x)).concat(y + 1);
}
function expr2expr(src, xn, yn) {
  var condition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
    return true;
  };
  if (xn === 0 && yn === 0)
    return src;
  var _expr2xy = expr2xy(src), _expr2xy2 = _slicedToArray(_expr2xy, 2), x = _expr2xy2[0], y = _expr2xy2[1];
  if (!condition(x, y))
    return src;
  return xy2expr(x + xn, y + yn);
}
var CellRange = /* @__PURE__ */ function() {
  function CellRange2(sri, sci, eri, eci) {
    var w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    var h3 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
    _classCallCheck(this, CellRange2);
    this.sri = sri;
    this.sci = sci;
    this.eri = eri;
    this.eci = eci;
    this.w = w;
    this.h = h3;
  }
  _createClass(CellRange2, [{
    key: "set",
    value: function set(sri, sci, eri, eci) {
      this.sri = sri;
      this.sci = sci;
      this.eri = eri;
      this.eci = eci;
    }
  }, {
    key: "multiple",
    value: function multiple() {
      return this.eri - this.sri > 0 || this.eci - this.sci > 0;
    }
    // cell-index: ri, ci
    // cell-ref: A10
  }, {
    key: "includes",
    value: function includes() {
      var ri = 0, ci = 0;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (args.length === 1) {
        var _expr2xy = expr2xy(args[0]);
        var _expr2xy2 = _slicedToArray(_expr2xy, 2);
        ci = _expr2xy2[0];
        ri = _expr2xy2[1];
      } else if (args.length === 2) {
        ri = args[0];
        ci = args[1];
      }
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci;
      return sri <= ri && ri <= eri && sci <= ci && ci <= eci;
    }
  }, {
    key: "each",
    value: function each(cb) {
      var rowFilter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return true;
      };
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci;
      for (var i = sri; i <= eri; i += 1) {
        if (rowFilter(i)) {
          for (var j = sci; j <= eci; j += 1) {
            cb(i, j);
          }
        }
      }
    }
  }, {
    key: "contains",
    value: function contains(other) {
      return this.sri <= other.sri && this.sci <= other.sci && this.eri >= other.eri && this.eci >= other.eci;
    }
    // within
  }, {
    key: "within",
    value: function within(other) {
      return this.sri >= other.sri && this.sci >= other.sci && this.eri <= other.eri && this.eci <= other.eci;
    }
    // disjoint
  }, {
    key: "disjoint",
    value: function disjoint(other) {
      return this.sri > other.eri || this.sci > other.eci || other.sri > this.eri || other.sci > this.eci;
    }
    // intersects
  }, {
    key: "intersects",
    value: function intersects(other) {
      return this.sri <= other.eri && this.sci <= other.eci && other.sri <= this.eri && other.sci <= this.eci;
    }
    // union
  }, {
    key: "union",
    value: function union(other) {
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci;
      return new CellRange2(other.sri < sri ? other.sri : sri, other.sci < sci ? other.sci : sci, other.eri > eri ? other.eri : eri, other.eci > eci ? other.eci : eci);
    }
    // intersection
    // intersection(other) {}
    // Returns Array<CellRange> that represents that part of this that does not intersect with other
    // difference
  }, {
    key: "difference",
    value: function difference(other) {
      var ret = [];
      var addRet = function addRet2(sri2, sci2, eri2, eci2) {
        ret.push(new CellRange2(sri2, sci2, eri2, eci2));
      };
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci;
      var dsr = other.sri - sri;
      var dsc = other.sci - sci;
      var der = eri - other.eri;
      var dec = eci - other.eci;
      if (dsr > 0) {
        addRet(sri, sci, other.sri - 1, eci);
        if (der > 0) {
          addRet(other.eri + 1, sci, eri, eci);
          if (dsc > 0) {
            addRet(other.sri, sci, other.eri, other.sci - 1);
          }
          if (dec > 0) {
            addRet(other.sri, other.eci + 1, other.eri, eci);
          }
        } else {
          if (dsc > 0) {
            addRet(other.sri, sci, eri, other.sci - 1);
          }
          if (dec > 0) {
            addRet(other.sri, other.eci + 1, eri, eci);
          }
        }
      } else if (der > 0) {
        addRet(other.eri + 1, sci, eri, eci);
        if (dsc > 0) {
          addRet(sri, sci, other.eri, other.sci - 1);
        }
        if (dec > 0) {
          addRet(sri, other.eci + 1, other.eri, eci);
        }
      }
      if (dsc > 0) {
        addRet(sri, sci, eri, other.sci - 1);
        if (dec > 0) {
          addRet(sri, other.eri + 1, eri, eci);
          if (dsr > 0) {
            addRet(sri, other.sci, other.sri - 1, other.eci);
          }
          if (der > 0) {
            addRet(other.sri + 1, other.sci, eri, other.eci);
          }
        } else {
          if (dsr > 0) {
            addRet(sri, other.sci, other.sri - 1, eci);
          }
          if (der > 0) {
            addRet(other.sri + 1, other.sci, eri, eci);
          }
        }
      } else if (dec > 0) {
        addRet(eri, other.eci + 1, eri, eci);
        if (dsr > 0) {
          addRet(sri, sci, other.sri - 1, other.eci);
        }
        if (der > 0) {
          addRet(other.eri + 1, sci, eri, other.eci);
        }
      }
      return ret;
    }
  }, {
    key: "size",
    value: function size() {
      return [this.eri - this.sri + 1, this.eci - this.sci + 1];
    }
  }, {
    key: "toString",
    value: function toString2() {
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci;
      var ref2 = xy2expr(sci, sri);
      if (this.multiple()) {
        ref2 = "".concat(ref2, ":").concat(xy2expr(eci, eri));
      }
      return ref2;
    }
  }, {
    key: "clone",
    value: function clone2() {
      var sri = this.sri, sci = this.sci, eri = this.eri, eci = this.eci, w = this.w, h3 = this.h;
      return new CellRange2(sri, sci, eri, eci, w, h3);
    }
    /*
    toJSON() {
      return this.toString();
    }
    */
  }, {
    key: "equals",
    value: function equals2(other) {
      return this.eri === other.eri && this.eci === other.eci && this.sri === other.sri && this.sci === other.sci;
    }
  }], [{
    key: "valueOf",
    value: function valueOf(ref2) {
      var refs = ref2.split(":");
      var _expr2xy3 = expr2xy(refs[0]), _expr2xy4 = _slicedToArray(_expr2xy3, 2), sci = _expr2xy4[0], sri = _expr2xy4[1];
      var eri = sri, eci = sci;
      if (refs.length > 1) {
        var _expr2xy5 = expr2xy(refs[1]);
        var _expr2xy6 = _slicedToArray(_expr2xy5, 2);
        eci = _expr2xy6[0];
        eri = _expr2xy6[1];
      }
      return new CellRange2(sri, sci, eri, eci);
    }
  }]);
  return CellRange2;
}();
var Selector$1 = /* @__PURE__ */ function() {
  function Selector2() {
    _classCallCheck(this, Selector2);
    this.range = new CellRange(0, 0, 0, 0);
    this.ri = 0;
    this.ci = 0;
  }
  _createClass(Selector2, [{
    key: "multiple",
    value: function multiple() {
      return this.range.multiple();
    }
  }, {
    key: "setIndexes",
    value: function setIndexes(ri, ci) {
      this.ri = ri;
      this.ci = ci;
    }
  }, {
    key: "size",
    value: function size() {
      return this.range.size();
    }
  }]);
  return Selector2;
}();
var Scroll = /* @__PURE__ */ _createClass(function Scroll2() {
  _classCallCheck(this, Scroll2);
  this.x = 0;
  this.y = 0;
  this.ri = 0;
  this.ci = 0;
});
var History = /* @__PURE__ */ function() {
  function History2() {
    _classCallCheck(this, History2);
    this.undoItems = [];
    this.redoItems = [];
  }
  _createClass(History2, [{
    key: "add",
    value: function add(data) {
      this.undoItems.push(JSON.stringify(data));
      this.redoItems = [];
    }
  }, {
    key: "canUndo",
    value: function canUndo() {
      return this.undoItems.length > 0;
    }
  }, {
    key: "canRedo",
    value: function canRedo() {
      return this.redoItems.length > 0;
    }
  }, {
    key: "undo",
    value: function undo(currentd, cb) {
      var undoItems = this.undoItems, redoItems = this.redoItems;
      if (this.canUndo()) {
        redoItems.push(JSON.stringify(currentd));
        cb(JSON.parse(undoItems.pop()));
      }
    }
  }, {
    key: "redo",
    value: function redo(currentd, cb) {
      var undoItems = this.undoItems, redoItems = this.redoItems;
      if (this.canRedo()) {
        undoItems.push(JSON.stringify(currentd));
        cb(JSON.parse(redoItems.pop()));
      }
    }
  }]);
  return History2;
}();
var Clipboard = /* @__PURE__ */ function() {
  function Clipboard2() {
    _classCallCheck(this, Clipboard2);
    this.range = null;
    this.state = "clear";
  }
  _createClass(Clipboard2, [{
    key: "copy",
    value: function copy2(cellRange) {
      this.range = cellRange;
      this.state = "copy";
      return this;
    }
  }, {
    key: "cut",
    value: function cut2(cellRange) {
      this.range = cellRange;
      this.state = "cut";
      return this;
    }
  }, {
    key: "isCopy",
    value: function isCopy() {
      return this.state === "copy";
    }
  }, {
    key: "isCut",
    value: function isCut() {
      return this.state === "cut";
    }
  }, {
    key: "isClear",
    value: function isClear() {
      return this.state === "clear";
    }
  }, {
    key: "clear",
    value: function clear() {
      this.range = null;
      this.state = "clear";
    }
  }]);
  return Clipboard2;
}();
var Filter = /* @__PURE__ */ function() {
  function Filter2(ci, operator, value) {
    _classCallCheck(this, Filter2);
    this.ci = ci;
    this.operator = operator;
    this.value = value;
  }
  _createClass(Filter2, [{
    key: "set",
    value: function set(operator, value) {
      this.operator = operator;
      this.value = value;
    }
  }, {
    key: "includes",
    value: function includes(v) {
      var operator = this.operator, value = this.value;
      if (operator === "all") {
        return true;
      }
      if (operator === "in") {
        return value.includes(v);
      }
      return false;
    }
  }, {
    key: "vlength",
    value: function vlength() {
      var operator = this.operator, value = this.value;
      if (operator === "in") {
        return value.length;
      }
      return 0;
    }
  }, {
    key: "getData",
    value: function getData2() {
      var ci = this.ci, operator = this.operator, value = this.value;
      return {
        ci,
        operator,
        value
      };
    }
  }]);
  return Filter2;
}();
var Sort = /* @__PURE__ */ function() {
  function Sort2(ci, order) {
    _classCallCheck(this, Sort2);
    this.ci = ci;
    this.order = order;
  }
  _createClass(Sort2, [{
    key: "asc",
    value: function asc() {
      return this.order === "asc";
    }
  }, {
    key: "desc",
    value: function desc() {
      return this.order === "desc";
    }
  }]);
  return Sort2;
}();
var AutoFilter = /* @__PURE__ */ function() {
  function AutoFilter2() {
    _classCallCheck(this, AutoFilter2);
    this.ref = null;
    this.filters = [];
    this.sort = null;
  }
  _createClass(AutoFilter2, [{
    key: "setData",
    value: function setData(_ref) {
      var ref2 = _ref.ref, filters = _ref.filters, sort = _ref.sort;
      if (ref2 != null) {
        this.ref = ref2;
        this.filters = filters.map(function(it) {
          return new Filter(it.ci, it.operator, it.value);
        });
        if (sort) {
          this.sort = new Sort(sort.ci, sort.order);
        }
      }
    }
  }, {
    key: "getData",
    value: function getData2() {
      if (this.active()) {
        var ref2 = this.ref, filters = this.filters, sort = this.sort;
        return {
          ref: ref2,
          filters: filters.map(function(it) {
            return it.getData();
          }),
          sort
        };
      }
      return {};
    }
  }, {
    key: "addFilter",
    value: function addFilter(ci, operator, value) {
      var filter = this.getFilter(ci);
      if (filter == null) {
        this.filters.push(new Filter(ci, operator, value));
      } else {
        filter.set(operator, value);
      }
    }
  }, {
    key: "setSort",
    value: function setSort(ci, order) {
      this.sort = order ? new Sort(ci, order) : null;
    }
  }, {
    key: "includes",
    value: function includes(ri, ci) {
      if (this.active()) {
        return this.hrange().includes(ri, ci);
      }
      return false;
    }
  }, {
    key: "getSort",
    value: function getSort(ci) {
      var sort = this.sort;
      if (sort && sort.ci === ci) {
        return sort;
      }
      return null;
    }
  }, {
    key: "getFilter",
    value: function getFilter(ci) {
      var filters = this.filters;
      for (var i = 0; i < filters.length; i += 1) {
        if (filters[i].ci === ci) {
          return filters[i];
        }
      }
      return null;
    }
  }, {
    key: "filteredRows",
    value: function filteredRows(getCell) {
      var rset = /* @__PURE__ */ new Set();
      var fset = /* @__PURE__ */ new Set();
      if (this.active()) {
        var _this$range = this.range(), sri = _this$range.sri, eri = _this$range.eri;
        var filters = this.filters;
        for (var ri = sri + 1; ri <= eri; ri += 1) {
          for (var i = 0; i < filters.length; i += 1) {
            var filter = filters[i];
            var cell = getCell(ri, filter.ci);
            var ctext = cell ? cell.text : "";
            if (!filter.includes(ctext)) {
              rset.add(ri);
              break;
            } else {
              fset.add(ri);
            }
          }
        }
      }
      return {
        rset,
        fset
      };
    }
  }, {
    key: "items",
    value: function items(ci, getCell) {
      var m = {};
      if (this.active()) {
        var _this$range2 = this.range(), sri = _this$range2.sri, eri = _this$range2.eri;
        for (var ri = sri + 1; ri <= eri; ri += 1) {
          var cell = getCell(ri, ci);
          if (cell !== null && !/^\s*$/.test(cell.text)) {
            var key = cell.text;
            var cnt = (m[key] || 0) + 1;
            m[key] = cnt;
          } else {
            m[""] = (m[""] || 0) + 1;
          }
        }
      }
      return m;
    }
  }, {
    key: "range",
    value: function range() {
      return CellRange.valueOf(this.ref);
    }
  }, {
    key: "hrange",
    value: function hrange() {
      var r = this.range();
      r.eri = r.sri;
      return r;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.ref = null;
      this.filters = [];
      this.sort = null;
    }
  }, {
    key: "active",
    value: function active() {
      return this.ref !== null;
    }
  }]);
  return AutoFilter2;
}();
var Merges = /* @__PURE__ */ function() {
  function Merges2() {
    var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    _classCallCheck(this, Merges2);
    this._ = d;
  }
  _createClass(Merges2, [{
    key: "forEach",
    value: function forEach(cb) {
      this._.forEach(cb);
    }
  }, {
    key: "deleteWithin",
    value: function deleteWithin(cr) {
      this._ = this._.filter(function(it) {
        return !it.within(cr);
      });
    }
  }, {
    key: "getFirstIncludes",
    value: function getFirstIncludes(ri, ci) {
      for (var i = 0; i < this._.length; i += 1) {
        var it = this._[i];
        if (it.includes(ri, ci)) {
          return it;
        }
      }
      return null;
    }
  }, {
    key: "filterIntersects",
    value: function filterIntersects(cellRange) {
      return new Merges2(this._.filter(function(it) {
        return it.intersects(cellRange);
      }));
    }
  }, {
    key: "intersects",
    value: function intersects(cellRange) {
      for (var i = 0; i < this._.length; i += 1) {
        var it = this._[i];
        if (it.intersects(cellRange)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: "union",
    value: function union(cellRange) {
      var cr = cellRange;
      this._.forEach(function(it) {
        if (it.intersects(cr)) {
          cr = it.union(cr);
        }
      });
      return cr;
    }
  }, {
    key: "add",
    value: function add(cr) {
      this.deleteWithin(cr);
      this._.push(cr);
    }
    // type: row | column
  }, {
    key: "shift",
    value: function shift(type, index2, n, cbWithin) {
      this._.forEach(function(cellRange) {
        var sri = cellRange.sri, sci = cellRange.sci, eri = cellRange.eri, eci = cellRange.eci;
        var range = cellRange;
        if (type === "row") {
          if (sri >= index2) {
            range.sri += n;
            range.eri += n;
          } else if (sri < index2 && index2 <= eri) {
            range.eri += n;
            cbWithin(sri, sci, n, 0);
          }
        } else if (type === "column") {
          if (sci >= index2) {
            range.sci += n;
            range.eci += n;
          } else if (sci < index2 && index2 <= eci) {
            range.eci += n;
            cbWithin(sri, sci, 0, n);
          }
        }
      });
    }
  }, {
    key: "move",
    value: function move(cellRange, rn, cn) {
      this._.forEach(function(it1) {
        var it = it1;
        if (it.within(cellRange)) {
          it.eri += rn;
          it.sri += rn;
          it.sci += cn;
          it.eci += cn;
        }
      });
    }
  }, {
    key: "setData",
    value: function setData(merges) {
      this._ = merges.map(function(merge2) {
        return CellRange.valueOf(merge2);
      });
      return this;
    }
  }, {
    key: "getData",
    value: function getData2() {
      return this._.map(function(merge2) {
        return merge2.toString();
      });
    }
  }]);
  return Merges2;
}();
function cloneDeep(obj) {
  return JSON.parse(JSON.stringify(obj));
}
var mergeDeep = function mergeDeep2() {
  var object = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }
  sources.forEach(function(source) {
    Object.keys(source).forEach(function(key) {
      var v = source[key];
      if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") {
        object[key] = v;
      } else if (typeof v !== "function" && !Array.isArray(v) && v instanceof Object) {
        object[key] = object[key] || {};
        mergeDeep2(object[key], v);
      } else {
        object[key] = v;
      }
    });
  });
  return object;
};
function equals(obj1, obj2) {
  var keys = Object.keys(obj1);
  if (keys.length !== Object.keys(obj2).length)
    return false;
  for (var i = 0; i < keys.length; i += 1) {
    var k = keys[i];
    var v1 = obj1[k];
    var v2 = obj2[k];
    if (v2 === void 0)
      return false;
    if (typeof v1 === "string" || typeof v1 === "number" || typeof v1 === "boolean") {
      if (v1 !== v2)
        return false;
    } else if (Array.isArray(v1)) {
      if (v1.length !== v2.length)
        return false;
      for (var ai = 0; ai < v1.length; ai += 1) {
        if (!equals(v1[ai], v2[ai]))
          return false;
      }
    } else if (typeof v1 !== "function" && !Array.isArray(v1) && v1 instanceof Object) {
      if (!equals(v1, v2))
        return false;
    }
  }
  return true;
}
var sum = function sum2(objOrAry) {
  var cb = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function(value) {
    return value;
  };
  var total = 0;
  var size = 0;
  Object.keys(objOrAry).forEach(function(key) {
    total += cb(objOrAry[key], key);
    size += 1;
  });
  return [total, size];
};
function deleteProperty(obj, property) {
  var oldv = obj["".concat(property)];
  delete obj["".concat(property)];
  return oldv;
}
function rangeReduceIf(min, max, inits, initv, ifv, getv) {
  var s = inits;
  var v = initv;
  var i = min;
  for (; i < max; i += 1) {
    if (s > ifv)
      break;
    v = getv(i);
    s += v;
  }
  return [i, s - v, v];
}
function rangeSum(min, max, getv) {
  var s = 0;
  for (var i = min; i < max; i += 1) {
    s += getv(i);
  }
  return s;
}
function rangeEach(min, max, cb) {
  for (var i = min; i < max; i += 1) {
    cb(i);
  }
}
function arrayEquals(a1, a2) {
  if (a1.length === a2.length) {
    for (var i = 0; i < a1.length; i += 1) {
      if (a1[i] !== a2[i])
        return false;
    }
  } else
    return false;
  return true;
}
function digits(a) {
  var v = "".concat(a);
  var ret = 0;
  var flag = false;
  for (var i = 0; i < v.length; i += 1) {
    if (flag === true)
      ret += 1;
    if (v.charAt(i) === ".")
      flag = true;
  }
  return ret;
}
function numberCalc(type, a1, a2) {
  if (Number.isNaN(a1) || Number.isNaN(a2)) {
    return a1 + type + a2;
  }
  var al1 = digits(a1);
  var al2 = digits(a2);
  var num1 = Number(a1);
  var num2 = Number(a2);
  var ret = 0;
  if (type === "-") {
    ret = num1 - num2;
  } else if (type === "+") {
    ret = num1 + num2;
  } else if (type === "*") {
    ret = num1 * num2;
  } else if (type === "/") {
    ret = num1 / num2;
    if (digits(ret) > 5)
      return ret.toFixed(2);
    return ret;
  }
  return ret.toFixed(Math.max(al1, al2));
}
const helper = {
  cloneDeep,
  merge: function merge() {
    for (var _len2 = arguments.length, sources = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      sources[_key2] = arguments[_key2];
    }
    return mergeDeep.apply(void 0, [{}].concat(sources));
  },
  equals,
  arrayEquals,
  sum,
  rangeEach,
  rangeSum,
  rangeReduceIf,
  deleteProperty,
  numberCalc
};
var Rows = /* @__PURE__ */ function() {
  function Rows2(_ref) {
    var len = _ref.len, height2 = _ref.height;
    _classCallCheck(this, Rows2);
    this._ = {};
    this.len = len;
    this.height = height2;
  }
  _createClass(Rows2, [{
    key: "getHeight",
    value: function getHeight(ri) {
      if (this.isHide(ri))
        return 0;
      var row = this.get(ri);
      if (row && row.height) {
        return row.height;
      }
      return this.height;
    }
  }, {
    key: "setHeight",
    value: function setHeight(ri, v) {
      var row = this.getOrNew(ri);
      row.height = v;
    }
  }, {
    key: "unhide",
    value: function unhide(idx) {
      var index2 = idx;
      while (index2 > 0) {
        index2 -= 1;
        if (this.isHide(index2)) {
          this.setHide(index2, false);
        } else
          break;
      }
    }
  }, {
    key: "isHide",
    value: function isHide(ri) {
      var row = this.get(ri);
      return row && row.hide;
    }
  }, {
    key: "setHide",
    value: function setHide(ri, v) {
      var row = this.getOrNew(ri);
      if (v === true)
        row.hide = true;
      else
        delete row.hide;
    }
  }, {
    key: "setStyle",
    value: function setStyle(ri, style) {
      var row = this.getOrNew(ri);
      row.style = style;
    }
  }, {
    key: "sumHeight",
    value: function sumHeight(min, max, exceptSet) {
      var _this = this;
      return helper.rangeSum(min, max, function(i) {
        if (exceptSet && exceptSet.has(i))
          return 0;
        return _this.getHeight(i);
      });
    }
  }, {
    key: "totalHeight",
    value: function totalHeight() {
      return this.sumHeight(0, this.len);
    }
  }, {
    key: "get",
    value: function get(ri) {
      return this._[ri];
    }
  }, {
    key: "getOrNew",
    value: function getOrNew(ri) {
      this._[ri] = this._[ri] || {
        cells: {}
      };
      return this._[ri];
    }
  }, {
    key: "getCell",
    value: function getCell(ri, ci) {
      var row = this.get(ri);
      if (row !== void 0 && row.cells !== void 0 && row.cells[ci] !== void 0) {
        return row.cells[ci];
      }
      return null;
    }
  }, {
    key: "getCellMerge",
    value: function getCellMerge(ri, ci) {
      var cell = this.getCell(ri, ci);
      if (cell && cell.merge)
        return cell.merge;
      return [0, 0];
    }
  }, {
    key: "getCellOrNew",
    value: function getCellOrNew(ri, ci) {
      var row = this.getOrNew(ri);
      row.cells[ci] = row.cells[ci] || {};
      return row.cells[ci];
    }
    // what: all | text | format
  }, {
    key: "setCell",
    value: function setCell(ri, ci, cell) {
      var what = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "all";
      var row = this.getOrNew(ri);
      if (what === "all") {
        row.cells[ci] = cell;
      } else if (what === "text") {
        row.cells[ci] = row.cells[ci] || {};
        row.cells[ci].text = cell.text;
      } else if (what === "format") {
        row.cells[ci] = row.cells[ci] || {};
        row.cells[ci].style = cell.style;
        if (cell.merge)
          row.cells[ci].merge = cell.merge;
      }
    }
  }, {
    key: "setCellText",
    value: function setCellText(ri, ci, text) {
      var cell = this.getCellOrNew(ri, ci);
      if (cell.editable !== false)
        cell.text = text;
    }
    // what: all | format | text
  }, {
    key: "copyPaste",
    value: function copyPaste2(srcCellRange, dstCellRange, what) {
      var _this2 = this;
      var autofill = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      var cb = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : function() {
      };
      var sri = srcCellRange.sri, sci = srcCellRange.sci, eri = srcCellRange.eri, eci = srcCellRange.eci;
      var dsri = dstCellRange.sri;
      var dsci = dstCellRange.sci;
      var deri = dstCellRange.eri;
      var deci = dstCellRange.eci;
      var _srcCellRange$size = srcCellRange.size(), _srcCellRange$size2 = _slicedToArray(_srcCellRange$size, 2), rn = _srcCellRange$size2[0], cn = _srcCellRange$size2[1];
      var _dstCellRange$size = dstCellRange.size(), _dstCellRange$size2 = _slicedToArray(_dstCellRange$size, 2), drn = _dstCellRange$size2[0], dcn = _dstCellRange$size2[1];
      var isAdd = true;
      var dn = 0;
      if (deri < sri || deci < sci) {
        isAdd = false;
        if (deri < sri)
          dn = drn;
        else
          dn = dcn;
      }
      for (var i = sri; i <= eri; i += 1) {
        if (this._[i]) {
          for (var j = sci; j <= eci; j += 1) {
            if (this._[i].cells && this._[i].cells[j]) {
              for (var ii = dsri; ii <= deri; ii += rn) {
                var _loop = function _loop2() {
                  var nri = ii + (i - sri);
                  var nci = jj + (j - sci);
                  var ncell = helper.cloneDeep(_this2._[i].cells[j]);
                  if (autofill && ncell && ncell.text && ncell.text.length > 0) {
                    var text = ncell.text;
                    var n = jj - dsci + (ii - dsri) + 2;
                    if (!isAdd) {
                      n -= dn + 1;
                    }
                    if (text[0] === "=") {
                      ncell.text = text.replace(/[a-zA-Z]{1,3}\d+/g, function(word) {
                        var xn = 0, yn = 0;
                        if (sri === dsri) {
                          xn = n - 1;
                        } else {
                          yn = n - 1;
                        }
                        if (/^\d+$/.test(word))
                          return word;
                        return expr2expr(word, xn, yn);
                      });
                    } else if (rn <= 1 && cn > 1 && (dsri > eri || deri < sri) || cn <= 1 && rn > 1 && (dsci > eci || deci < sci) || rn <= 1 && cn <= 1) {
                      var result = /[\\.\d]+$/.exec(text);
                      if (result !== null) {
                        var index2 = Number(result[0]) + n - 1;
                        ncell.text = text.substring(0, result.index) + index2;
                      }
                    }
                  }
                  _this2.setCell(nri, nci, ncell, what);
                  cb(nri, nci, ncell);
                };
                for (var jj = dsci; jj <= deci; jj += cn) {
                  _loop();
                }
              }
            }
          }
        }
      }
    }
  }, {
    key: "cutPaste",
    value: function cutPaste2(srcCellRange, dstCellRange) {
      var _this3 = this;
      var ncellmm = {};
      this.each(function(ri) {
        _this3.eachCells(ri, function(ci) {
          var nri = parseInt(ri, 10);
          var nci = parseInt(ci, 10);
          if (srcCellRange.includes(ri, ci)) {
            nri = dstCellRange.sri + (nri - srcCellRange.sri);
            nci = dstCellRange.sci + (nci - srcCellRange.sci);
          }
          ncellmm[nri] = ncellmm[nri] || {
            cells: {}
          };
          ncellmm[nri].cells[nci] = _this3._[ri].cells[ci];
        });
      });
      this._ = ncellmm;
    }
    // src: Array<Array<String>>
  }, {
    key: "paste",
    value: function paste2(src, dstCellRange) {
      var _this4 = this;
      if (src.length <= 0)
        return;
      var sri = dstCellRange.sri, sci = dstCellRange.sci;
      src.forEach(function(row, i) {
        var ri = sri + i;
        row.forEach(function(cell, j) {
          var ci = sci + j;
          _this4.setCellText(ri, ci, cell);
        });
      });
    }
  }, {
    key: "insert",
    value: function insert(sri) {
      var _this5 = this;
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var ndata = {};
      this.each(function(ri, row) {
        var nri = parseInt(ri, 10);
        if (nri >= sri) {
          nri += n;
          _this5.eachCells(ri, function(ci, cell) {
            if (cell.text && cell.text[0] === "=") {
              cell.text = cell.text.replace(/[a-zA-Z]{1,3}\d+/g, function(word) {
                return expr2expr(word, 0, n, function(x, y) {
                  return y >= sri;
                });
              });
            }
          });
        }
        ndata[nri] = row;
      });
      this._ = ndata;
      this.len += n;
    }
  }, {
    key: "delete",
    value: function _delete(sri, eri) {
      var _this6 = this;
      var n = eri - sri + 1;
      var ndata = {};
      this.each(function(ri, row) {
        var nri = parseInt(ri, 10);
        if (nri < sri) {
          ndata[nri] = row;
        } else if (ri > eri) {
          ndata[nri - n] = row;
          _this6.eachCells(ri, function(ci, cell) {
            if (cell.text && cell.text[0] === "=") {
              cell.text = cell.text.replace(/[a-zA-Z]{1,3}\d+/g, function(word) {
                return expr2expr(word, 0, -n, function(x, y) {
                  return y > eri;
                });
              });
            }
          });
        }
      });
      this._ = ndata;
      this.len -= n;
    }
  }, {
    key: "insertColumn",
    value: function insertColumn(sci) {
      var _this7 = this;
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.each(function(ri, row) {
        var rndata = {};
        _this7.eachCells(ri, function(ci, cell) {
          var nci = parseInt(ci, 10);
          if (nci >= sci) {
            nci += n;
            if (cell.text && cell.text[0] === "=") {
              cell.text = cell.text.replace(/[a-zA-Z]{1,3}\d+/g, function(word) {
                return expr2expr(word, n, 0, function(x) {
                  return x >= sci;
                });
              });
            }
          }
          rndata[nci] = cell;
        });
        row.cells = rndata;
      });
    }
  }, {
    key: "deleteColumn",
    value: function deleteColumn(sci, eci) {
      var _this8 = this;
      var n = eci - sci + 1;
      this.each(function(ri, row) {
        var rndata = {};
        _this8.eachCells(ri, function(ci, cell) {
          var nci = parseInt(ci, 10);
          if (nci < sci) {
            rndata[nci] = cell;
          } else if (nci > eci) {
            rndata[nci - n] = cell;
            if (cell.text && cell.text[0] === "=") {
              cell.text = cell.text.replace(/[a-zA-Z]{1,3}\d+/g, function(word) {
                return expr2expr(word, -n, 0, function(x) {
                  return x > eci;
                });
              });
            }
          }
        });
        row.cells = rndata;
      });
    }
    // what: all | text | format | merge
  }, {
    key: "deleteCells",
    value: function deleteCells(cellRange) {
      var _this9 = this;
      var what = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
      cellRange.each(function(i, j) {
        _this9.deleteCell(i, j, what);
      });
    }
    // what: all | text | format | merge
  }, {
    key: "deleteCell",
    value: function deleteCell(ri, ci) {
      var what = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "all";
      var row = this.get(ri);
      if (row !== null) {
        var cell = this.getCell(ri, ci);
        if (cell !== null && cell.editable !== false) {
          if (what === "all") {
            delete row.cells[ci];
          } else if (what === "text") {
            if (cell.text)
              delete cell.text;
            if (cell.value)
              delete cell.value;
          } else if (what === "format") {
            if (cell.style !== void 0)
              delete cell.style;
            if (cell.merge)
              delete cell.merge;
          } else if (what === "merge") {
            if (cell.merge)
              delete cell.merge;
          }
        }
      }
    }
  }, {
    key: "maxCell",
    value: function maxCell() {
      var keys = Object.keys(this._);
      var ri = keys[keys.length - 1];
      var col = this._[ri];
      if (col) {
        var cells = col.cells;
        var ks = Object.keys(cells);
        var ci = ks[ks.length - 1];
        return [parseInt(ri, 10), parseInt(ci, 10)];
      }
      return [0, 0];
    }
  }, {
    key: "each",
    value: function each(cb) {
      Object.entries(this._).forEach(function(_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2), ri = _ref3[0], row = _ref3[1];
        cb(ri, row);
      });
    }
  }, {
    key: "eachCells",
    value: function eachCells(ri, cb) {
      if (this._[ri] && this._[ri].cells) {
        Object.entries(this._[ri].cells).forEach(function(_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2), ci = _ref5[0], cell = _ref5[1];
          cb(ci, cell);
        });
      }
    }
  }, {
    key: "setData",
    value: function setData(d) {
      if (d.len) {
        this.len = d.len;
        delete d.len;
      }
      this._ = d;
    }
  }, {
    key: "getData",
    value: function getData2() {
      var len = this.len;
      return Object.assign({
        len
      }, this._);
    }
  }]);
  return Rows2;
}();
var Cols = /* @__PURE__ */ function() {
  function Cols2(_ref) {
    var len = _ref.len, width2 = _ref.width, indexWidth = _ref.indexWidth, minWidth = _ref.minWidth;
    _classCallCheck(this, Cols2);
    this._ = {};
    this.len = len;
    this.width = width2;
    this.indexWidth = indexWidth;
    this.minWidth = minWidth;
  }
  _createClass(Cols2, [{
    key: "setData",
    value: function setData(d) {
      if (d.len) {
        this.len = d.len;
        delete d.len;
      }
      this._ = d;
    }
  }, {
    key: "getData",
    value: function getData2() {
      var len = this.len;
      return Object.assign({
        len
      }, this._);
    }
  }, {
    key: "getWidth",
    value: function getWidth(i) {
      if (this.isHide(i))
        return 0;
      var col = this._[i];
      if (col && col.width) {
        return col.width;
      }
      return this.width;
    }
  }, {
    key: "getOrNew",
    value: function getOrNew(ci) {
      this._[ci] = this._[ci] || {};
      return this._[ci];
    }
  }, {
    key: "setWidth",
    value: function setWidth(ci, width2) {
      var col = this.getOrNew(ci);
      col.width = width2;
    }
  }, {
    key: "unhide",
    value: function unhide(idx) {
      var index2 = idx;
      while (index2 > 0) {
        index2 -= 1;
        if (this.isHide(index2)) {
          this.setHide(index2, false);
        } else
          break;
      }
    }
  }, {
    key: "isHide",
    value: function isHide(ci) {
      var col = this._[ci];
      return col && col.hide;
    }
  }, {
    key: "setHide",
    value: function setHide(ci, v) {
      var col = this.getOrNew(ci);
      if (v === true)
        col.hide = true;
      else
        delete col.hide;
    }
  }, {
    key: "setStyle",
    value: function setStyle(ci, style) {
      var col = this.getOrNew(ci);
      col.style = style;
    }
  }, {
    key: "sumWidth",
    value: function sumWidth(min, max) {
      var _this = this;
      return helper.rangeSum(min, max, function(i) {
        return _this.getWidth(i);
      });
    }
  }, {
    key: "totalWidth",
    value: function totalWidth() {
      return this.sumWidth(0, this.len);
    }
  }]);
  return Cols2;
}();
const en = {
  toolbar: {
    undo: "Undo",
    redo: "Redo",
    print: "Print",
    paintformat: "Paint format",
    clearformat: "Clear format",
    format: "Format",
    fontName: "Font",
    fontSize: "Font size",
    fontBold: "Font bold",
    fontItalic: "Font italic",
    underline: "Underline",
    strike: "Strike",
    color: "Text color",
    bgcolor: "Fill color",
    border: "Borders",
    merge: "Merge cells",
    align: "Horizontal align",
    valign: "Vertical align",
    textwrap: "Text wrapping",
    freeze: "Freeze cell",
    autofilter: "Filter",
    formula: "Functions",
    more: "More"
  },
  contextmenu: {
    copy: "Copy",
    cut: "Cut",
    paste: "Paste",
    pasteValue: "Paste values only",
    pasteFormat: "Paste format only",
    hide: "Hide",
    insertRow: "Insert row",
    insertColumn: "Insert column",
    deleteSheet: "Delete",
    deleteRow: "Delete row",
    deleteColumn: "Delete column",
    deleteCell: "Delete cell",
    deleteCellText: "Delete cell text",
    validation: "Data validations",
    cellprintable: "Enable export",
    cellnonprintable: "Disable export",
    celleditable: "Enable editing",
    cellnoneditable: "Disable editing"
  },
  print: {
    size: "Paper size",
    orientation: "Page orientation",
    orientations: ["Landscape", "Portrait"]
  },
  format: {
    normal: "Normal",
    text: "Plain Text",
    number: "Number",
    percent: "Percent",
    rmb: "RMB",
    usd: "USD",
    eur: "EUR",
    date: "Date",
    time: "Time",
    datetime: "Date time",
    duration: "Duration"
  },
  formula: {
    sum: "Sum",
    average: "Average",
    max: "Max",
    min: "Min",
    _if: "IF",
    and: "AND",
    or: "OR",
    concat: "Concat"
  },
  validation: {
    required: "it must be required",
    notMatch: "it not match its validation rule",
    between: "it is between {} and {}",
    notBetween: "it is not between {} and {}",
    notIn: "it is not in list",
    equal: "it equal to {}",
    notEqual: "it not equal to {}",
    lessThan: "it less than {}",
    lessThanEqual: "it less than or equal to {}",
    greaterThan: "it greater than {}",
    greaterThanEqual: "it greater than or equal to {}"
  },
  error: {
    pasteForMergedCell: "Unable to do this for merged cells"
  },
  calendar: {
    weeks: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  },
  button: {
    next: "Next",
    cancel: "Cancel",
    remove: "Remove",
    save: "Save",
    ok: "OK"
  },
  sort: {
    desc: "Sort Z -> A",
    asc: "Sort A -> Z"
  },
  filter: {
    empty: "empty"
  },
  dataValidation: {
    mode: "Mode",
    range: "Cell Range",
    criteria: "Criteria",
    modeType: {
      cell: "Cell",
      column: "Colun",
      row: "Row"
    },
    type: {
      list: "List",
      number: "Number",
      date: "Date",
      phone: "Phone",
      email: "Email"
    },
    operator: {
      be: "between",
      nbe: "not betwwen",
      lt: "less than",
      lte: "less than or equal to",
      gt: "greater than",
      gte: "greater than or equal to",
      eq: "equal to",
      neq: "not equal to"
    }
  }
};
function _createForOfIteratorHelper$2(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$2(o, minLen);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var $languages = ["en"];
var $messages = {
  en
};
function translate(key, messages) {
  if (messages) {
    var _iterator = _createForOfIteratorHelper$2($languages), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var lang = _step.value;
        if (!messages[lang])
          break;
        var message = messages[lang];
        var keys = key.match(/(?:\\.|[^.])+/g);
        for (var i = 0; i < keys.length; i += 1) {
          var property = keys[i];
          var value = message[property];
          if (!value)
            break;
          if (i === keys.length - 1)
            return value;
          message = value;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  return void 0;
}
function t(key) {
  var v = translate(key, $messages);
  if (!v && window && window.x_spreadsheet && window.x_spreadsheet.$messages) {
    v = translate(key, window.x_spreadsheet.$messages);
  }
  return v || "";
}
function tf(key) {
  return function() {
    return t(key);
  };
}
function locale(lang, message) {
  var clearLangList = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (clearLangList) {
    $languages = [lang];
  } else {
    $languages.unshift(lang);
  }
  if (message) {
    $messages[lang] = message;
  }
}
var rules = {
  phone: /^[1-9]\d{10}$/,
  email: /w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*/
};
function returnMessage(flag, key) {
  var message = "";
  if (!flag) {
    for (var _len = arguments.length, arg = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      arg[_key - 2] = arguments[_key];
    }
    message = t.apply(void 0, ["validation.".concat(key)].concat(arg));
  }
  return [flag, message];
}
var Validator = /* @__PURE__ */ function() {
  function Validator2(type, required, value, operator) {
    _classCallCheck(this, Validator2);
    this.required = required;
    this.value = value;
    this.type = type;
    this.operator = operator;
    this.message = "";
  }
  _createClass(Validator2, [{
    key: "parseValue",
    value: function parseValue(v) {
      var type = this.type;
      if (type === "date") {
        return new Date(v);
      }
      if (type === "number") {
        return Number(v);
      }
      return v;
    }
  }, {
    key: "equals",
    value: function equals2(other) {
      var flag = this.type === other.type && this.required === other.required && this.operator === other.operator;
      if (flag) {
        if (Array.isArray(this.value)) {
          flag = helper.arrayEquals(this.value, other.value);
        } else {
          flag = this.value === other.value;
        }
      }
      return flag;
    }
  }, {
    key: "values",
    value: function values() {
      return this.value.split(",");
    }
  }, {
    key: "validate",
    value: function validate(v) {
      var required = this.required, operator = this.operator, value = this.value, type = this.type;
      if (required && /^\s*$/.test(v)) {
        return returnMessage(false, "required");
      }
      if (/^\s*$/.test(v))
        return [true];
      if (rules[type] && !rules[type].test(v)) {
        return returnMessage(false, "notMatch");
      }
      if (type === "list") {
        return returnMessage(this.values().includes(v), "notIn");
      }
      if (operator) {
        var v1 = this.parseValue(v);
        if (operator === "be") {
          var _value = _slicedToArray(value, 2), min = _value[0], max = _value[1];
          return returnMessage(v1 >= this.parseValue(min) && v1 <= this.parseValue(max), "between", min, max);
        }
        if (operator === "nbe") {
          var _value2 = _slicedToArray(value, 2), _min = _value2[0], _max = _value2[1];
          return returnMessage(v1 < this.parseValue(_min) || v1 > this.parseValue(_max), "notBetween", _min, _max);
        }
        if (operator === "eq") {
          return returnMessage(v1 === this.parseValue(value), "equal", value);
        }
        if (operator === "neq") {
          return returnMessage(v1 !== this.parseValue(value), "notEqual", value);
        }
        if (operator === "lt") {
          return returnMessage(v1 < this.parseValue(value), "lessThan", value);
        }
        if (operator === "lte") {
          return returnMessage(v1 <= this.parseValue(value), "lessThanEqual", value);
        }
        if (operator === "gt") {
          return returnMessage(v1 > this.parseValue(value), "greaterThan", value);
        }
        if (operator === "gte") {
          return returnMessage(v1 >= this.parseValue(value), "greaterThanEqual", value);
        }
      }
      return [true];
    }
  }]);
  return Validator2;
}();
var Validation = /* @__PURE__ */ function() {
  function Validation2(mode, refs, validator) {
    _classCallCheck(this, Validation2);
    this.refs = refs;
    this.mode = mode;
    this.validator = validator;
  }
  _createClass(Validation2, [{
    key: "includes",
    value: function includes(ri, ci) {
      var refs = this.refs;
      for (var i = 0; i < refs.length; i += 1) {
        var cr = CellRange.valueOf(refs[i]);
        if (cr.includes(ri, ci))
          return true;
      }
      return false;
    }
  }, {
    key: "addRef",
    value: function addRef(ref2) {
      this.remove(CellRange.valueOf(ref2));
      this.refs.push(ref2);
    }
  }, {
    key: "remove",
    value: function remove(cellRange) {
      var nrefs = [];
      this.refs.forEach(function(it) {
        var cr = CellRange.valueOf(it);
        if (cr.intersects(cellRange)) {
          var crs = cr.difference(cellRange);
          crs.forEach(function(it1) {
            return nrefs.push(it1.toString());
          });
        } else {
          nrefs.push(it);
        }
      });
      this.refs = nrefs;
    }
  }, {
    key: "getData",
    value: function getData2() {
      var refs = this.refs, mode = this.mode, validator = this.validator;
      var type = validator.type, required = validator.required, operator = validator.operator, value = validator.value;
      return {
        refs,
        mode,
        type,
        required,
        operator,
        value
      };
    }
  }], [{
    key: "valueOf",
    value: function valueOf(_ref) {
      var refs = _ref.refs, mode = _ref.mode, type = _ref.type, required = _ref.required, operator = _ref.operator, value = _ref.value;
      return new Validation2(mode, refs, new Validator(type, required, value, operator));
    }
  }]);
  return Validation2;
}();
var Validations = /* @__PURE__ */ function() {
  function Validations2() {
    _classCallCheck(this, Validations2);
    this._ = [];
    this.errors = /* @__PURE__ */ new Map();
  }
  _createClass(Validations2, [{
    key: "getError",
    value: function getError(ri, ci) {
      return this.errors.get("".concat(ri, "_").concat(ci));
    }
  }, {
    key: "validate",
    value: function validate(ri, ci, text) {
      var v = this.get(ri, ci);
      var key = "".concat(ri, "_").concat(ci);
      var errors = this.errors;
      if (v !== null) {
        var _v$validator$validate = v.validator.validate(text), _v$validator$validate2 = _slicedToArray(_v$validator$validate, 2), flag = _v$validator$validate2[0], message = _v$validator$validate2[1];
        if (!flag) {
          errors.set(key, message);
        } else {
          errors.delete(key);
        }
      } else {
        errors.delete(key);
      }
      return true;
    }
    // type: date|number|phone|email|list
    // validator: { required, value, operator }
  }, {
    key: "add",
    value: function add(mode, ref2, _ref2) {
      var type = _ref2.type, required = _ref2.required, value = _ref2.value, operator = _ref2.operator;
      var validator = new Validator(type, required, value, operator);
      var v = this.getByValidator(validator);
      if (v !== null) {
        v.addRef(ref2);
      } else {
        this._.push(new Validation(mode, [ref2], validator));
      }
    }
  }, {
    key: "getByValidator",
    value: function getByValidator(validator) {
      for (var i = 0; i < this._.length; i += 1) {
        var v = this._[i];
        if (v.validator.equals(validator)) {
          return v;
        }
      }
      return null;
    }
  }, {
    key: "get",
    value: function get(ri, ci) {
      for (var i = 0; i < this._.length; i += 1) {
        var v = this._[i];
        if (v.includes(ri, ci))
          return v;
      }
      return null;
    }
  }, {
    key: "remove",
    value: function remove(cellRange) {
      this.each(function(it) {
        it.remove(cellRange);
      });
    }
  }, {
    key: "each",
    value: function each(cb) {
      this._.forEach(function(it) {
        return cb(it);
      });
    }
  }, {
    key: "getData",
    value: function getData2() {
      return this._.filter(function(it) {
        return it.refs.length > 0;
      }).map(function(it) {
        return it.getData();
      });
    }
  }, {
    key: "setData",
    value: function setData(d) {
      this._ = d.map(function(it) {
        return Validation.valueOf(it);
      });
    }
  }]);
  return Validations2;
}();
var defaultSettings = {
  mode: "edit",
  // edit | read
  view: {
    height: function height() {
      return document.documentElement.clientHeight;
    },
    width: function width() {
      return document.documentElement.clientWidth;
    }
  },
  showGrid: true,
  showToolbar: true,
  showContextmenu: true,
  showBottomBar: true,
  row: {
    len: 100,
    height: 25
  },
  col: {
    len: 26,
    width: 100,
    indexWidth: 60,
    minWidth: 60
  },
  style: {
    bgcolor: "#ffffff",
    align: "left",
    valign: "middle",
    textwrap: false,
    strike: false,
    underline: false,
    color: "#0a0a0a",
    font: {
      name: "Arial",
      size: 10,
      bold: false,
      italic: false
    },
    format: "normal"
  }
};
var toolbarHeight = 41;
var bottombarHeight = 41;
var hasOwnProperty = function hasOwnProperty2(obj, name) {
  return Object.prototype.hasOwnProperty.call(obj, name);
};
function canPaste(src, dst) {
  var error = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
  };
  var merges = this.merges;
  var cellRange = dst.clone();
  var _src$size = src.size(), _src$size2 = _slicedToArray(_src$size, 2), srn = _src$size2[0], scn = _src$size2[1];
  var _dst$size = dst.size(), _dst$size2 = _slicedToArray(_dst$size, 2), drn = _dst$size2[0], dcn = _dst$size2[1];
  if (srn > drn) {
    cellRange.eri = dst.sri + srn - 1;
  }
  if (scn > dcn) {
    cellRange.eci = dst.sci + scn - 1;
  }
  if (merges.intersects(cellRange)) {
    error(t("error.pasteForMergedCell"));
    return false;
  }
  return true;
}
function copyPaste(srcCellRange, dstCellRange, what) {
  var autofill = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var rows = this.rows, merges = this.merges;
  if (what === "all" || what === "format") {
    rows.deleteCells(dstCellRange, what);
    merges.deleteWithin(dstCellRange);
  }
  rows.copyPaste(srcCellRange, dstCellRange, what, autofill, function(ri, ci, cell) {
    if (cell && cell.merge) {
      var _cell$merge = _slicedToArray(cell.merge, 2), rn = _cell$merge[0], cn = _cell$merge[1];
      if (rn <= 0 && cn <= 0)
        return;
      merges.add(new CellRange(ri, ci, ri + rn, ci + cn));
    }
  });
}
function cutPaste(srcCellRange, dstCellRange) {
  var clipboard = this.clipboard, rows = this.rows, merges = this.merges;
  rows.cutPaste(srcCellRange, dstCellRange);
  merges.move(srcCellRange, dstCellRange.sri - srcCellRange.sri, dstCellRange.sci - srcCellRange.sci);
  clipboard.clear();
}
function setStyleBorder(ri, ci, bss) {
  var styles = this.styles, rows = this.rows;
  var cell = rows.getCellOrNew(ri, ci);
  var cstyle = {};
  if (cell.style !== void 0) {
    cstyle = helper.cloneDeep(styles[cell.style]);
  }
  cstyle = helper.merge(cstyle, {
    border: bss
  });
  cell.style = this.addStyle(cstyle);
}
function setStyleBorders(_ref) {
  var _this = this;
  var mode = _ref.mode, style = _ref.style, color = _ref.color;
  var styles = this.styles, selector = this.selector, rows = this.rows;
  var _selector$range = selector.range, sri = _selector$range.sri, sci = _selector$range.sci, eri = _selector$range.eri, eci = _selector$range.eci;
  var multiple = !this.isSignleSelected();
  if (!multiple) {
    if (mode === "inside" || mode === "horizontal" || mode === "vertical") {
      return;
    }
  }
  if (mode === "outside" && !multiple) {
    setStyleBorder.call(this, sri, sci, {
      top: [style, color],
      bottom: [style, color],
      left: [style, color],
      right: [style, color]
    });
  } else if (mode === "none") {
    selector.range.each(function(ri2, ci2) {
      var cell2 = rows.getCell(ri2, ci2);
      if (cell2 && cell2.style !== void 0) {
        var ns = helper.cloneDeep(styles[cell2.style]);
        delete ns.border;
        cell2.style = _this.addStyle(ns);
      }
    });
  } else if (mode === "all" || mode === "inside" || mode === "outside" || mode === "horizontal" || mode === "vertical") {
    var merges = [];
    for (var ri = sri; ri <= eri; ri += 1) {
      for (var ci = sci; ci <= eci; ci += 1) {
        var mergeIndexes = [];
        for (var ii = 0; ii < merges.length; ii += 1) {
          var _merges$ii = _slicedToArray(merges[ii], 4), mri = _merges$ii[0], mci = _merges$ii[1], _rn = _merges$ii[2], _cn = _merges$ii[3];
          if (ri === mri + _rn + 1)
            mergeIndexes.push(ii);
          if (mri <= ri && ri <= mri + _rn) {
            if (ci === mci) {
              ci += _cn + 1;
              break;
            }
          }
        }
        mergeIndexes.forEach(function(it) {
          return merges.splice(it, 1);
        });
        if (ci > eci)
          break;
        var cell = rows.getCell(ri, ci);
        var rn = 0, cn = 0;
        if (cell && cell.merge) {
          var _cell$merge2 = _slicedToArray(cell.merge, 2);
          rn = _cell$merge2[0];
          cn = _cell$merge2[1];
          merges.push([ri, ci, rn, cn]);
        }
        var mrl = rn > 0 && ri + rn === eri;
        var mcl = cn > 0 && ci + cn === eci;
        var bss = {};
        if (mode === "all") {
          bss = {
            bottom: [style, color],
            top: [style, color],
            left: [style, color],
            right: [style, color]
          };
        } else if (mode === "inside") {
          if (!mcl && ci < eci)
            bss.right = [style, color];
          if (!mrl && ri < eri)
            bss.bottom = [style, color];
        } else if (mode === "horizontal") {
          if (!mrl && ri < eri)
            bss.bottom = [style, color];
        } else if (mode === "vertical") {
          if (!mcl && ci < eci)
            bss.right = [style, color];
        } else if (mode === "outside" && multiple) {
          if (sri === ri)
            bss.top = [style, color];
          if (mrl || eri === ri)
            bss.bottom = [style, color];
          if (sci === ci)
            bss.left = [style, color];
          if (mcl || eci === ci)
            bss.right = [style, color];
        }
        if (Object.keys(bss).length > 0) {
          setStyleBorder.call(this, ri, ci, bss);
        }
        ci += cn;
      }
    }
  } else if (mode === "top" || mode === "bottom") {
    for (var _ci = sci; _ci <= eci; _ci += 1) {
      if (mode === "top") {
        setStyleBorder.call(this, sri, _ci, {
          top: [style, color]
        });
        _ci += rows.getCellMerge(sri, _ci)[1];
      }
      if (mode === "bottom") {
        setStyleBorder.call(this, eri, _ci, {
          bottom: [style, color]
        });
        _ci += rows.getCellMerge(eri, _ci)[1];
      }
    }
  } else if (mode === "left" || mode === "right") {
    for (var _ri = sri; _ri <= eri; _ri += 1) {
      if (mode === "left") {
        setStyleBorder.call(this, _ri, sci, {
          left: [style, color]
        });
        _ri += rows.getCellMerge(_ri, sci)[0];
      }
      if (mode === "right") {
        setStyleBorder.call(this, _ri, eci, {
          right: [style, color]
        });
        _ri += rows.getCellMerge(_ri, eci)[0];
      }
    }
  }
}
function getCellRowByY(y, scrollOffsety) {
  var rows = this.rows;
  var fsh = this.freezeTotalHeight();
  var inits = rows.height;
  if (fsh + rows.height < y)
    inits -= scrollOffsety;
  var frset = this.exceptRowSet;
  var ri = 0;
  var top = inits;
  var height2 = rows.height;
  for (; ri < rows.len; ri += 1) {
    if (top > y)
      break;
    if (!frset.has(ri)) {
      height2 = rows.getHeight(ri);
      top += height2;
    }
  }
  top -= height2;
  if (top <= 0) {
    return {
      ri: -1,
      top: 0,
      height: height2
    };
  }
  return {
    ri: ri - 1,
    top,
    height: height2
  };
}
function getCellColByX(x, scrollOffsetx) {
  var cols = this.cols;
  var fsw = this.freezeTotalWidth();
  var inits = cols.indexWidth;
  if (fsw + cols.indexWidth < x)
    inits -= scrollOffsetx;
  var _helper$rangeReduceIf = helper.rangeReduceIf(0, cols.len, inits, cols.indexWidth, x, function(i) {
    return cols.getWidth(i);
  }), _helper$rangeReduceIf2 = _slicedToArray(_helper$rangeReduceIf, 3), ci = _helper$rangeReduceIf2[0], left = _helper$rangeReduceIf2[1], width2 = _helper$rangeReduceIf2[2];
  if (left <= 0) {
    return {
      ci: -1,
      left: 0,
      width: cols.indexWidth
    };
  }
  return {
    ci: ci - 1,
    left,
    width: width2
  };
}
var DataProxy = /* @__PURE__ */ function() {
  function DataProxy2(name, settings) {
    _classCallCheck(this, DataProxy2);
    this.settings = helper.merge(defaultSettings, settings || {});
    this.name = name || "sheet";
    this.freeze = [0, 0];
    this.styles = [];
    this.merges = new Merges();
    this.rows = new Rows(this.settings.row);
    this.cols = new Cols(this.settings.col);
    this.validations = new Validations();
    this.hyperlinks = {};
    this.comments = {};
    this.selector = new Selector$1();
    this.scroll = new Scroll();
    this.history = new History();
    this.clipboard = new Clipboard();
    this.autoFilter = new AutoFilter();
    this.change = function() {
    };
    this.exceptRowSet = /* @__PURE__ */ new Set();
    this.sortedRowMap = /* @__PURE__ */ new Map();
    this.unsortedRowMap = /* @__PURE__ */ new Map();
  }
  _createClass(DataProxy2, [{
    key: "addValidation",
    value: function addValidation(mode, ref2, validator) {
      var _this2 = this;
      this.changeData(function() {
        _this2.validations.add(mode, ref2, validator);
      });
    }
  }, {
    key: "removeValidation",
    value: function removeValidation() {
      var _this3 = this;
      var range = this.selector.range;
      this.changeData(function() {
        _this3.validations.remove(range);
      });
    }
  }, {
    key: "getSelectedValidator",
    value: function getSelectedValidator() {
      var _this$selector = this.selector, ri = _this$selector.ri, ci = _this$selector.ci;
      var v = this.validations.get(ri, ci);
      return v ? v.validator : null;
    }
  }, {
    key: "getSelectedValidation",
    value: function getSelectedValidation() {
      var _this$selector2 = this.selector, ri = _this$selector2.ri, ci = _this$selector2.ci, range = _this$selector2.range;
      var v = this.validations.get(ri, ci);
      var ret = {
        ref: range.toString()
      };
      if (v !== null) {
        ret.mode = v.mode;
        ret.validator = v.validator;
      }
      return ret;
    }
  }, {
    key: "canUndo",
    value: function canUndo() {
      return this.history.canUndo();
    }
  }, {
    key: "canRedo",
    value: function canRedo() {
      return this.history.canRedo();
    }
  }, {
    key: "undo",
    value: function undo() {
      var _this4 = this;
      this.history.undo(this.getData(), function(d) {
        _this4.setData(d);
      });
    }
  }, {
    key: "redo",
    value: function redo() {
      var _this5 = this;
      this.history.redo(this.getData(), function(d) {
        _this5.setData(d);
      });
    }
  }, {
    key: "copy",
    value: function copy2() {
      this.clipboard.copy(this.selector.range);
    }
  }, {
    key: "copyToSystemClipboard",
    value: function copyToSystemClipboard() {
      if (navigator.clipboard === void 0) {
        return;
      }
      var copyText = "";
      var rowData = this.rows.getData();
      for (var ri = this.selector.range.sri; ri <= this.selector.range.eri; ri += 1) {
        if (hasOwnProperty(rowData, ri)) {
          for (var ci = this.selector.range.sci; ci <= this.selector.range.eci; ci += 1) {
            if (ci > this.selector.range.sci) {
              copyText += "	";
            }
            if (hasOwnProperty(rowData[ri].cells, ci)) {
              var cellText = String(rowData[ri].cells[ci].text);
              if (cellText.indexOf("\n") === -1 && cellText.indexOf("	") === -1 && cellText.indexOf('"') === -1) {
                copyText += cellText;
              } else {
                copyText += '"'.concat(cellText, '"');
              }
            }
          }
        } else {
          for (var _ci2 = this.selector.range.sci; _ci2 <= this.selector.range.eci; _ci2 += 1) {
            copyText += "	";
          }
        }
        copyText += "\n";
      }
      navigator.clipboard.writeText(copyText).then(function() {
      }, function(err) {
        console.log("text copy to the system clipboard error  ", copyText, err);
      });
    }
  }, {
    key: "cut",
    value: function cut2() {
      this.clipboard.cut(this.selector.range);
    }
    // what: all | text | format
  }, {
    key: "paste",
    value: function paste2() {
      var _this6 = this;
      var what = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "all";
      var error = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
      };
      var clipboard = this.clipboard, selector = this.selector;
      if (clipboard.isClear())
        return false;
      if (!canPaste.call(this, clipboard.range, selector.range, error))
        return false;
      this.changeData(function() {
        if (clipboard.isCopy()) {
          copyPaste.call(_this6, clipboard.range, selector.range, what);
        } else if (clipboard.isCut()) {
          cutPaste.call(_this6, clipboard.range, selector.range);
        }
      });
      return true;
    }
  }, {
    key: "pasteFromText",
    value: function pasteFromText(txt) {
      var lines = txt.split("\r\n").map(function(it) {
        return it.replace(/"/g, "").split("	");
      });
      if (lines.length > 0)
        lines.length -= 1;
      var rows = this.rows, selector = this.selector;
      this.changeData(function() {
        rows.paste(lines, selector.range);
      });
    }
  }, {
    key: "autofill",
    value: function autofill(cellRange, what) {
      var _this7 = this;
      var error = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      };
      var srcRange = this.selector.range;
      if (!canPaste.call(this, srcRange, cellRange, error))
        return false;
      this.changeData(function() {
        copyPaste.call(_this7, srcRange, cellRange, what, true);
      });
      return true;
    }
  }, {
    key: "clearClipboard",
    value: function clearClipboard2() {
      this.clipboard.clear();
    }
  }, {
    key: "calSelectedRangeByEnd",
    value: function calSelectedRangeByEnd(ri, ci) {
      var selector = this.selector, rows = this.rows, cols = this.cols, merges = this.merges;
      var _selector$range2 = selector.range, sri = _selector$range2.sri, sci = _selector$range2.sci, eri = _selector$range2.eri, eci = _selector$range2.eci;
      var cri = selector.ri;
      var cci = selector.ci;
      var nri = ri, nci = ci;
      if (ri < 0)
        nri = rows.len - 1;
      if (ci < 0)
        nci = cols.len - 1;
      if (nri > cri) {
        sri = cri;
        eri = nri;
      } else {
        sri = nri;
        eri = cri;
      }
      if (nci > cci) {
        sci = cci;
        eci = nci;
      } else {
        sci = nci;
        eci = cci;
      }
      selector.range = merges.union(new CellRange(sri, sci, eri, eci));
      selector.range = merges.union(selector.range);
      return selector.range;
    }
  }, {
    key: "calSelectedRangeByStart",
    value: function calSelectedRangeByStart(ri, ci) {
      var selector = this.selector, rows = this.rows, cols = this.cols, merges = this.merges;
      var cellRange = merges.getFirstIncludes(ri, ci);
      if (cellRange === null) {
        cellRange = new CellRange(ri, ci, ri, ci);
        if (ri === -1) {
          cellRange.sri = 0;
          cellRange.eri = rows.len - 1;
        }
        if (ci === -1) {
          cellRange.sci = 0;
          cellRange.eci = cols.len - 1;
        }
      }
      selector.range = cellRange;
      return cellRange;
    }
  }, {
    key: "setSelectedCellAttr",
    value: function setSelectedCellAttr(property, value) {
      var _this8 = this;
      this.changeData(function() {
        var selector = _this8.selector, styles = _this8.styles, rows = _this8.rows;
        if (property === "merge") {
          if (value)
            _this8.merge();
          else
            _this8.unmerge();
        } else if (property === "border") {
          setStyleBorders.call(_this8, value);
        } else if (property === "formula") {
          var ri = selector.ri, ci = selector.ci, range = selector.range;
          if (selector.multiple()) {
            var _selector$size = selector.size(), _selector$size2 = _slicedToArray(_selector$size, 2), rn = _selector$size2[0], cn = _selector$size2[1];
            var sri = range.sri, sci = range.sci, eri = range.eri, eci = range.eci;
            if (rn > 1) {
              for (var i = sci; i <= eci; i += 1) {
                var cell = rows.getCellOrNew(eri + 1, i);
                cell.text = "=".concat(value, "(").concat(xy2expr(i, sri), ":").concat(xy2expr(i, eri), ")");
              }
            } else if (cn > 1) {
              var _cell2 = rows.getCellOrNew(ri, eci + 1);
              _cell2.text = "=".concat(value, "(").concat(xy2expr(sci, ri), ":").concat(xy2expr(eci, ri), ")");
            }
          } else {
            var _cell22 = rows.getCellOrNew(ri, ci);
            _cell22.text = "=".concat(value, "()");
          }
        } else {
          selector.range.each(function(ri2, ci2) {
            var cell2 = rows.getCellOrNew(ri2, ci2);
            var cstyle = {};
            if (cell2.style !== void 0) {
              cstyle = helper.cloneDeep(styles[cell2.style]);
            }
            if (property === "format") {
              cstyle.format = value;
              cell2.style = _this8.addStyle(cstyle);
            } else if (property === "font-bold" || property === "font-italic" || property === "font-name" || property === "font-size") {
              var nfont = {};
              nfont[property.split("-")[1]] = value;
              cstyle.font = Object.assign(cstyle.font || {}, nfont);
              cell2.style = _this8.addStyle(cstyle);
            } else if (property === "strike" || property === "textwrap" || property === "underline" || property === "align" || property === "valign" || property === "color" || property === "bgcolor") {
              cstyle[property] = value;
              cell2.style = _this8.addStyle(cstyle);
            } else {
              cell2[property] = value;
            }
          });
        }
      });
    }
    // state: input | finished
  }, {
    key: "setSelectedCellText",
    value: function setSelectedCellText(text) {
      var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "input";
      var autoFilter = this.autoFilter, selector = this.selector, rows = this.rows;
      var ri = selector.ri, ci = selector.ci;
      var nri = ri;
      if (this.unsortedRowMap.has(ri)) {
        nri = this.unsortedRowMap.get(ri);
      }
      var oldCell = rows.getCell(nri, ci);
      var oldText = oldCell ? oldCell.text : "";
      this.setCellText(nri, ci, text, state);
      if (autoFilter.active()) {
        var filter = autoFilter.getFilter(ci);
        if (filter) {
          var vIndex = filter.value.findIndex(function(v) {
            return v === oldText;
          });
          if (vIndex >= 0) {
            filter.value.splice(vIndex, 1, text);
          }
        }
      }
    }
  }, {
    key: "getSelectedCell",
    value: function getSelectedCell() {
      var _this$selector3 = this.selector, ri = _this$selector3.ri, ci = _this$selector3.ci;
      var nri = ri;
      if (this.unsortedRowMap.has(ri)) {
        nri = this.unsortedRowMap.get(ri);
      }
      return this.rows.getCell(nri, ci);
    }
  }, {
    key: "xyInSelectedRect",
    value: function xyInSelectedRect(x, y) {
      var _this$getSelectedRect = this.getSelectedRect(), left = _this$getSelectedRect.left, top = _this$getSelectedRect.top, width2 = _this$getSelectedRect.width, height2 = _this$getSelectedRect.height;
      var x1 = x - this.cols.indexWidth;
      var y1 = y - this.rows.height;
      return x1 > left && x1 < left + width2 && y1 > top && y1 < top + height2;
    }
  }, {
    key: "getSelectedRect",
    value: function getSelectedRect() {
      return this.getRect(this.selector.range);
    }
  }, {
    key: "getClipboardRect",
    value: function getClipboardRect() {
      var clipboard = this.clipboard;
      if (!clipboard.isClear()) {
        return this.getRect(clipboard.range);
      }
      return {
        left: -100,
        top: -100
      };
    }
  }, {
    key: "getRect",
    value: function getRect(cellRange) {
      var scroll = this.scroll, rows = this.rows, cols = this.cols, exceptRowSet = this.exceptRowSet;
      var sri = cellRange.sri, sci = cellRange.sci, eri = cellRange.eri, eci = cellRange.eci;
      if (sri < 0 && sci < 0) {
        return {
          left: 0,
          l: 0,
          top: 0,
          t: 0,
          scroll
        };
      }
      var left = cols.sumWidth(0, sci);
      var top = rows.sumHeight(0, sri, exceptRowSet);
      var height2 = rows.sumHeight(sri, eri + 1, exceptRowSet);
      var width2 = cols.sumWidth(sci, eci + 1);
      var left0 = left - scroll.x;
      var top0 = top - scroll.y;
      var fsh = this.freezeTotalHeight();
      var fsw = this.freezeTotalWidth();
      if (fsw > 0 && fsw > left) {
        left0 = left;
      }
      if (fsh > 0 && fsh > top) {
        top0 = top;
      }
      return {
        l: left,
        t: top,
        left: left0,
        top: top0,
        height: height2,
        width: width2,
        scroll
      };
    }
  }, {
    key: "getCellRectByXY",
    value: function getCellRectByXY(x, y) {
      var scroll = this.scroll, merges = this.merges, rows = this.rows, cols = this.cols;
      var _getCellRowByY$call = getCellRowByY.call(this, y, scroll.y), ri = _getCellRowByY$call.ri, top = _getCellRowByY$call.top, height2 = _getCellRowByY$call.height;
      var _getCellColByX$call = getCellColByX.call(this, x, scroll.x), ci = _getCellColByX$call.ci, left = _getCellColByX$call.left, width2 = _getCellColByX$call.width;
      if (ci === -1) {
        width2 = cols.totalWidth();
      }
      if (ri === -1) {
        height2 = rows.totalHeight();
      }
      if (ri >= 0 || ci >= 0) {
        var merge2 = merges.getFirstIncludes(ri, ci);
        if (merge2) {
          ri = merge2.sri;
          ci = merge2.sci;
          var _this$cellRect = this.cellRect(ri, ci);
          left = _this$cellRect.left;
          top = _this$cellRect.top;
          width2 = _this$cellRect.width;
          height2 = _this$cellRect.height;
        }
      }
      return {
        ri,
        ci,
        left,
        top,
        width: width2,
        height: height2
      };
    }
  }, {
    key: "isSignleSelected",
    value: function isSignleSelected() {
      var _this$selector$range = this.selector.range, sri = _this$selector$range.sri, sci = _this$selector$range.sci, eri = _this$selector$range.eri, eci = _this$selector$range.eci;
      var cell = this.getCell(sri, sci);
      if (cell && cell.merge) {
        var _cell$merge3 = _slicedToArray(cell.merge, 2), rn = _cell$merge3[0], cn = _cell$merge3[1];
        if (sri + rn === eri && sci + cn === eci)
          return true;
      }
      return !this.selector.multiple();
    }
  }, {
    key: "canUnmerge",
    value: function canUnmerge() {
      var _this$selector$range2 = this.selector.range, sri = _this$selector$range2.sri, sci = _this$selector$range2.sci, eri = _this$selector$range2.eri, eci = _this$selector$range2.eci;
      var cell = this.getCell(sri, sci);
      if (cell && cell.merge) {
        var _cell$merge4 = _slicedToArray(cell.merge, 2), rn = _cell$merge4[0], cn = _cell$merge4[1];
        if (sri + rn === eri && sci + cn === eci)
          return true;
      }
      return false;
    }
  }, {
    key: "merge",
    value: function merge2() {
      var _this9 = this;
      var selector = this.selector, rows = this.rows;
      if (this.isSignleSelected())
        return;
      var _selector$size3 = selector.size(), _selector$size4 = _slicedToArray(_selector$size3, 2), rn = _selector$size4[0], cn = _selector$size4[1];
      if (rn > 1 || cn > 1) {
        var _selector$range3 = selector.range, sri = _selector$range3.sri, sci = _selector$range3.sci;
        this.changeData(function() {
          var cell = rows.getCellOrNew(sri, sci);
          cell.merge = [rn - 1, cn - 1];
          _this9.merges.add(selector.range);
          _this9.rows.deleteCells(selector.range);
          _this9.rows.setCell(sri, sci, cell);
        });
      }
    }
  }, {
    key: "unmerge",
    value: function unmerge() {
      var _this10 = this;
      var selector = this.selector;
      if (!this.isSignleSelected())
        return;
      var _selector$range4 = selector.range, sri = _selector$range4.sri, sci = _selector$range4.sci;
      this.changeData(function() {
        _this10.rows.deleteCell(sri, sci, "merge");
        _this10.merges.deleteWithin(selector.range);
      });
    }
  }, {
    key: "canAutofilter",
    value: function canAutofilter() {
      return !this.autoFilter.active();
    }
  }, {
    key: "autofilter",
    value: function autofilter2() {
      var _this11 = this;
      var autoFilter = this.autoFilter, selector = this.selector;
      this.changeData(function() {
        if (autoFilter.active()) {
          autoFilter.clear();
          _this11.exceptRowSet = /* @__PURE__ */ new Set();
          _this11.sortedRowMap = /* @__PURE__ */ new Map();
          _this11.unsortedRowMap = /* @__PURE__ */ new Map();
        } else {
          autoFilter.ref = selector.range.toString();
        }
      });
    }
  }, {
    key: "setAutoFilter",
    value: function setAutoFilter(ci, order, operator, value) {
      var autoFilter = this.autoFilter;
      autoFilter.addFilter(ci, operator, value);
      autoFilter.setSort(ci, order);
      this.resetAutoFilter();
    }
  }, {
    key: "resetAutoFilter",
    value: function resetAutoFilter() {
      var _this12 = this;
      var autoFilter = this.autoFilter, rows = this.rows;
      if (!autoFilter.active())
        return;
      var sort = autoFilter.sort;
      var _autoFilter$filteredR = autoFilter.filteredRows(function(r, c) {
        return rows.getCell(r, c);
      }), rset = _autoFilter$filteredR.rset, fset = _autoFilter$filteredR.fset;
      var fary = Array.from(fset);
      var oldAry = Array.from(fset);
      if (sort) {
        fary.sort(function(a, b) {
          if (sort.order === "asc")
            return a - b;
          if (sort.order === "desc")
            return b - a;
          return 0;
        });
      }
      this.exceptRowSet = rset;
      this.sortedRowMap = /* @__PURE__ */ new Map();
      this.unsortedRowMap = /* @__PURE__ */ new Map();
      fary.forEach(function(it, index2) {
        _this12.sortedRowMap.set(oldAry[index2], it);
        _this12.unsortedRowMap.set(it, oldAry[index2]);
      });
    }
  }, {
    key: "deleteCell",
    value: function deleteCell() {
      var _this13 = this;
      var what = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "all";
      var selector = this.selector;
      this.changeData(function() {
        _this13.rows.deleteCells(selector.range, what);
        if (what === "all" || what === "format") {
          _this13.merges.deleteWithin(selector.range);
        }
      });
    }
    // type: row | column
  }, {
    key: "insert",
    value: function insert(type) {
      var _this14 = this;
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      this.changeData(function() {
        var _this14$selector$rang = _this14.selector.range, sri = _this14$selector$rang.sri, sci = _this14$selector$rang.sci;
        var rows = _this14.rows, merges = _this14.merges, cols = _this14.cols;
        var si = sri;
        if (type === "row") {
          rows.insert(sri, n);
        } else if (type === "column") {
          rows.insertColumn(sci, n);
          si = sci;
          cols.len += 1;
        }
        merges.shift(type, si, n, function(ri, ci, rn, cn) {
          var cell = rows.getCell(ri, ci);
          cell.merge[0] += rn;
          cell.merge[1] += cn;
        });
      });
    }
    // type: row | column
  }, {
    key: "delete",
    value: function _delete(type) {
      var _this15 = this;
      this.changeData(function() {
        var rows = _this15.rows, merges = _this15.merges, selector = _this15.selector, cols = _this15.cols;
        var range = selector.range;
        var _selector$range5 = selector.range, sri = _selector$range5.sri, sci = _selector$range5.sci, eri = _selector$range5.eri, eci = _selector$range5.eci;
        var _selector$range$size = selector.range.size(), _selector$range$size2 = _slicedToArray(_selector$range$size, 2), rsize = _selector$range$size2[0], csize = _selector$range$size2[1];
        var si = sri;
        var size = rsize;
        if (type === "row") {
          rows.delete(sri, eri);
        } else if (type === "column") {
          rows.deleteColumn(sci, eci);
          si = range.sci;
          size = csize;
          cols.len -= 1;
        }
        merges.shift(type, si, -size, function(ri, ci, rn, cn) {
          var cell = rows.getCell(ri, ci);
          cell.merge[0] += rn;
          cell.merge[1] += cn;
          if (cell.merge[0] === 0 && cell.merge[1] === 0) {
            delete cell.merge;
          }
        });
      });
    }
  }, {
    key: "scrollx",
    value: function scrollx(x, cb) {
      var scroll = this.scroll, freeze = this.freeze, cols = this.cols;
      var _freeze = _slicedToArray(freeze, 2), fci = _freeze[1];
      var _helper$rangeReduceIf3 = helper.rangeReduceIf(fci, cols.len, 0, 0, x, function(i) {
        return cols.getWidth(i);
      }), _helper$rangeReduceIf4 = _slicedToArray(_helper$rangeReduceIf3, 3), ci = _helper$rangeReduceIf4[0], left = _helper$rangeReduceIf4[1], width2 = _helper$rangeReduceIf4[2];
      var x1 = left;
      if (x > 0)
        x1 += width2;
      if (scroll.x !== x1) {
        scroll.ci = x > 0 ? ci : 0;
        scroll.x = x1;
        cb();
      }
    }
  }, {
    key: "scrolly",
    value: function scrolly(y, cb) {
      var scroll = this.scroll, freeze = this.freeze, rows = this.rows;
      var _freeze2 = _slicedToArray(freeze, 1), fri = _freeze2[0];
      var _helper$rangeReduceIf5 = helper.rangeReduceIf(fri, rows.len, 0, 0, y, function(i) {
        return rows.getHeight(i);
      }), _helper$rangeReduceIf6 = _slicedToArray(_helper$rangeReduceIf5, 3), ri = _helper$rangeReduceIf6[0], top = _helper$rangeReduceIf6[1], height2 = _helper$rangeReduceIf6[2];
      var y1 = top;
      if (y > 0)
        y1 += height2;
      if (scroll.y !== y1) {
        scroll.ri = y > 0 ? ri : 0;
        scroll.y = y1;
        cb();
      }
    }
  }, {
    key: "cellRect",
    value: function cellRect(ri, ci) {
      var rows = this.rows, cols = this.cols;
      var left = cols.sumWidth(0, ci);
      var top = rows.sumHeight(0, ri);
      var cell = rows.getCell(ri, ci);
      var width2 = cols.getWidth(ci);
      var height2 = rows.getHeight(ri);
      if (cell !== null) {
        if (cell.merge) {
          var _cell$merge5 = _slicedToArray(cell.merge, 2), rn = _cell$merge5[0], cn = _cell$merge5[1];
          if (rn > 0) {
            for (var i = 1; i <= rn; i += 1) {
              height2 += rows.getHeight(ri + i);
            }
          }
          if (cn > 0) {
            for (var _i = 1; _i <= cn; _i += 1) {
              width2 += cols.getWidth(ci + _i);
            }
          }
        }
      }
      return {
        left,
        top,
        width: width2,
        height: height2,
        cell
      };
    }
  }, {
    key: "getCell",
    value: function getCell(ri, ci) {
      return this.rows.getCell(ri, ci);
    }
  }, {
    key: "getCellTextOrDefault",
    value: function getCellTextOrDefault(ri, ci) {
      var cell = this.getCell(ri, ci);
      return cell && cell.text ? cell.text : "";
    }
  }, {
    key: "getCellStyle",
    value: function getCellStyle(ri, ci) {
      var cell = this.getCell(ri, ci);
      if (cell && cell.style !== void 0) {
        return this.styles[cell.style];
      }
      return null;
    }
  }, {
    key: "getCellStyleOrDefault",
    value: function getCellStyleOrDefault(ri, ci) {
      var styles = this.styles, rows = this.rows;
      var cell = rows.getCell(ri, ci);
      var cellStyle = cell && cell.style !== void 0 ? styles[cell.style] : {};
      return helper.merge(this.defaultStyle(), cellStyle);
    }
  }, {
    key: "getSelectedCellStyle",
    value: function getSelectedCellStyle() {
      var _this$selector4 = this.selector, ri = _this$selector4.ri, ci = _this$selector4.ci;
      return this.getCellStyleOrDefault(ri, ci);
    }
    // state: input | finished
  }, {
    key: "setCellText",
    value: function setCellText(ri, ci, text, state) {
      var rows = this.rows, history = this.history, validations = this.validations;
      if (state === "finished") {
        rows.setCellText(ri, ci, "");
        history.add(this.getData());
        rows.setCellText(ri, ci, text);
      } else {
        rows.setCellText(ri, ci, text);
        this.change(this.getData());
      }
      validations.validate(ri, ci, text);
    }
  }, {
    key: "freezeIsActive",
    value: function freezeIsActive() {
      var _this$freeze = _slicedToArray(this.freeze, 2), ri = _this$freeze[0], ci = _this$freeze[1];
      return ri > 0 || ci > 0;
    }
  }, {
    key: "setFreeze",
    value: function setFreeze(ri, ci) {
      var _this16 = this;
      this.changeData(function() {
        _this16.freeze = [ri, ci];
      });
    }
  }, {
    key: "freezeTotalWidth",
    value: function freezeTotalWidth() {
      return this.cols.sumWidth(0, this.freeze[1]);
    }
  }, {
    key: "freezeTotalHeight",
    value: function freezeTotalHeight() {
      return this.rows.sumHeight(0, this.freeze[0]);
    }
  }, {
    key: "setRowHeight",
    value: function setRowHeight(ri, height2) {
      var _this17 = this;
      this.changeData(function() {
        _this17.rows.setHeight(ri, height2);
      });
    }
  }, {
    key: "setColWidth",
    value: function setColWidth(ci, width2) {
      var _this18 = this;
      this.changeData(function() {
        _this18.cols.setWidth(ci, width2);
      });
    }
  }, {
    key: "viewHeight",
    value: function viewHeight() {
      var _this$settings = this.settings, view = _this$settings.view, showToolbar = _this$settings.showToolbar, showBottomBar = _this$settings.showBottomBar;
      var h3 = view.height();
      if (showBottomBar) {
        h3 -= bottombarHeight;
      }
      if (showToolbar) {
        h3 -= toolbarHeight;
      }
      return h3;
    }
  }, {
    key: "viewWidth",
    value: function viewWidth() {
      return this.settings.view.width();
    }
  }, {
    key: "freezeViewRange",
    value: function freezeViewRange() {
      var _this$freeze2 = _slicedToArray(this.freeze, 2), ri = _this$freeze2[0], ci = _this$freeze2[1];
      return new CellRange(0, 0, ri - 1, ci - 1, this.freezeTotalWidth(), this.freezeTotalHeight());
    }
  }, {
    key: "contentRange",
    value: function contentRange() {
      var rows = this.rows, cols = this.cols;
      var _rows$maxCell = rows.maxCell(), _rows$maxCell2 = _slicedToArray(_rows$maxCell, 2), ri = _rows$maxCell2[0], ci = _rows$maxCell2[1];
      var h3 = rows.sumHeight(0, ri + 1);
      var w = cols.sumWidth(0, ci + 1);
      return new CellRange(0, 0, ri, ci, w, h3);
    }
  }, {
    key: "exceptRowTotalHeight",
    value: function exceptRowTotalHeight(sri, eri) {
      var exceptRowSet = this.exceptRowSet, rows = this.rows;
      var exceptRows = Array.from(exceptRowSet);
      var exceptRowTH = 0;
      exceptRows.forEach(function(ri) {
        if (ri < sri || ri > eri) {
          var height2 = rows.getHeight(ri);
          exceptRowTH += height2;
        }
      });
      return exceptRowTH;
    }
  }, {
    key: "viewRange",
    value: function viewRange() {
      var scroll = this.scroll, rows = this.rows, cols = this.cols, freeze = this.freeze, exceptRowSet = this.exceptRowSet;
      var ri = scroll.ri, ci = scroll.ci;
      if (ri <= 0) {
        var _freeze3 = _slicedToArray(freeze, 1);
        ri = _freeze3[0];
      }
      if (ci <= 0) {
        var _freeze4 = _slicedToArray(freeze, 2);
        ci = _freeze4[1];
      }
      var x = 0, y = 0;
      var _ref2 = [rows.len, cols.len], eri = _ref2[0], eci = _ref2[1];
      for (var i = ri; i < rows.len; i += 1) {
        if (!exceptRowSet.has(i)) {
          y += rows.getHeight(i);
          eri = i;
        }
        if (y > this.viewHeight())
          break;
      }
      for (var j = ci; j < cols.len; j += 1) {
        x += cols.getWidth(j);
        eci = j;
        if (x > this.viewWidth())
          break;
      }
      return new CellRange(ri, ci, eri, eci, x, y);
    }
  }, {
    key: "eachMergesInView",
    value: function eachMergesInView(viewRange, cb) {
      this.merges.filterIntersects(viewRange).forEach(function(it) {
        return cb(it);
      });
    }
  }, {
    key: "hideRowsOrCols",
    value: function hideRowsOrCols2() {
      var rows = this.rows, cols = this.cols, selector = this.selector;
      var _selector$size5 = selector.size(), _selector$size6 = _slicedToArray(_selector$size5, 2), rlen = _selector$size6[0], clen = _selector$size6[1];
      var _selector$range6 = selector.range, sri = _selector$range6.sri, sci = _selector$range6.sci, eri = _selector$range6.eri, eci = _selector$range6.eci;
      if (rlen === rows.len) {
        for (var ci = sci; ci <= eci; ci += 1) {
          cols.setHide(ci, true);
        }
      } else if (clen === cols.len) {
        for (var ri = sri; ri <= eri; ri += 1) {
          rows.setHide(ri, true);
        }
      }
    }
    // type: row | col
    // index row-index | col-index
  }, {
    key: "unhideRowsOrCols",
    value: function unhideRowsOrCols2(type, index2) {
      this["".concat(type, "s")].unhide(index2);
    }
  }, {
    key: "rowEach",
    value: function rowEach(min, max, cb) {
      var y = 0;
      var rows = this.rows;
      var frset = this.exceptRowSet;
      var frary = _toConsumableArray(frset);
      var offset = 0;
      for (var i = 0; i < frary.length; i += 1) {
        if (frary[i] < min) {
          offset += 1;
        }
      }
      for (var _i2 = min + offset; _i2 <= max + offset; _i2 += 1) {
        if (frset.has(_i2)) {
          offset += 1;
        } else {
          var rowHeight = rows.getHeight(_i2);
          if (rowHeight > 0) {
            cb(_i2, y, rowHeight);
            y += rowHeight;
            if (y > this.viewHeight())
              break;
          }
        }
      }
    }
  }, {
    key: "colEach",
    value: function colEach(min, max, cb) {
      var x = 0;
      var cols = this.cols;
      for (var i = min; i <= max; i += 1) {
        var colWidth = cols.getWidth(i);
        if (colWidth > 0) {
          cb(i, x, colWidth);
          x += colWidth;
          if (x > this.viewWidth())
            break;
        }
      }
    }
  }, {
    key: "defaultStyle",
    value: function defaultStyle() {
      return this.settings.style;
    }
  }, {
    key: "addStyle",
    value: function addStyle(nstyle) {
      var styles = this.styles;
      for (var i = 0; i < styles.length; i += 1) {
        var style = styles[i];
        if (helper.equals(style, nstyle))
          return i;
      }
      styles.push(nstyle);
      return styles.length - 1;
    }
  }, {
    key: "changeData",
    value: function changeData(cb) {
      this.history.add(this.getData());
      cb();
      this.change(this.getData());
    }
  }, {
    key: "setData",
    value: function setData(d) {
      var _this19 = this;
      Object.keys(d).forEach(function(property) {
        if (property === "merges" || property === "rows" || property === "cols" || property === "validations") {
          _this19[property].setData(d[property]);
        } else if (property === "freeze") {
          var _expr2xy = expr2xy(d[property]), _expr2xy2 = _slicedToArray(_expr2xy, 2), x = _expr2xy2[0], y = _expr2xy2[1];
          _this19.freeze = [y, x];
        } else if (property === "autofilter") {
          _this19.autoFilter.setData(d[property]);
        } else if (d[property] !== void 0) {
          _this19[property] = d[property];
        }
      });
      return this;
    }
  }, {
    key: "getData",
    value: function getData2() {
      var name = this.name, freeze = this.freeze, styles = this.styles, merges = this.merges, rows = this.rows, cols = this.cols, validations = this.validations, autoFilter = this.autoFilter;
      return {
        name,
        freeze: xy2expr(freeze[1], freeze[0]),
        styles,
        merges: merges.getData(),
        rows: rows.getData(),
        cols: cols.getData(),
        validations: validations.getData(),
        autofilter: autoFilter.getData()
      };
    }
  }]);
  return DataProxy2;
}();
function _createForOfIteratorHelper$1(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function bind(target, name, fn) {
  target.addEventListener(name, fn);
}
function unbind(target, name, fn) {
  target.removeEventListener(name, fn);
}
function unbindClickoutside(el) {
  if (el.xclickoutside) {
    unbind(window.document.body, "click", el.xclickoutside);
    delete el.xclickoutside;
  }
}
function bindClickoutside(el, cb) {
  el.xclickoutside = function(evt) {
    if (evt.detail === 2 || el.contains(evt.target))
      return;
    if (cb)
      cb(el);
    else {
      el.hide();
      unbindClickoutside(el);
    }
  };
  bind(window.document.body, "click", el.xclickoutside);
}
function mouseMoveUp(target, movefunc, upfunc) {
  bind(target, "mousemove", movefunc);
  var t2 = target;
  t2.xEvtUp = function(evt) {
    unbind(target, "mousemove", movefunc);
    unbind(target, "mouseup", target.xEvtUp);
    upfunc(evt);
  };
  bind(target, "mouseup", target.xEvtUp);
}
function calTouchDirection(spanx, spany, evt, cb) {
  var direction = "";
  if (Math.abs(spanx) > Math.abs(spany)) {
    direction = spanx > 0 ? "right" : "left";
    cb(direction, spanx, evt);
  } else {
    direction = spany > 0 ? "down" : "up";
    cb(direction, spany, evt);
  }
}
function bindTouch(target, _ref) {
  var move = _ref.move, end = _ref.end;
  var startx = 0;
  var starty = 0;
  bind(target, "touchstart", function(evt) {
    var _evt$touches$ = evt.touches[0], pageX = _evt$touches$.pageX, pageY = _evt$touches$.pageY;
    startx = pageX;
    starty = pageY;
  });
  bind(target, "touchmove", function(evt) {
    if (!move)
      return;
    var _evt$changedTouches$ = evt.changedTouches[0], pageX = _evt$changedTouches$.pageX, pageY = _evt$changedTouches$.pageY;
    var spanx = pageX - startx;
    var spany = pageY - starty;
    if (Math.abs(spanx) > 10 || Math.abs(spany) > 10) {
      calTouchDirection(spanx, spany, evt, move);
      startx = pageX;
      starty = pageY;
    }
    evt.preventDefault();
  });
  bind(target, "touchend", function(evt) {
    if (!end)
      return;
    var _evt$changedTouches$2 = evt.changedTouches[0], pageX = _evt$changedTouches$2.pageX, pageY = _evt$changedTouches$2.pageY;
    var spanx = pageX - startx;
    var spany = pageY - starty;
    calTouchDirection(spanx, spany, evt, end);
  });
}
function createEventEmitter() {
  var listeners = /* @__PURE__ */ new Map();
  function on(eventName, callback) {
    var push = function push2() {
      var currentListener = listeners.get(eventName);
      return Array.isArray(currentListener) && currentListener.push(callback) || false;
    };
    var create = function create2() {
      return listeners.set(eventName, [].concat(callback));
    };
    return listeners.has(eventName) && push() || create();
  }
  function fire(eventName, args) {
    var exec = function exec2() {
      var currentListener = listeners.get(eventName);
      var _iterator = _createForOfIteratorHelper$1(currentListener), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var callback = _step.value;
          callback.call.apply(callback, [null].concat(_toConsumableArray(args)));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    };
    return listeners.has(eventName) && exec();
  }
  function removeListener(eventName, callback) {
    var remove = function remove2() {
      var currentListener = listeners.get(eventName);
      var idx = currentListener.indexOf(callback);
      return idx >= 0 && currentListener.splice(idx, 1) && listeners.get(eventName).length === 0 && listeners.delete(eventName);
    };
    return listeners.has(eventName) && remove();
  }
  function once(eventName, callback) {
    var execCalllback = function execCalllback2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.call.apply(callback, [null].concat(args));
      removeListener(eventName, execCalllback2);
    };
    return on(eventName, execCalllback);
  }
  function removeAllListeners() {
    listeners.clear();
  }
  return {
    get current() {
      return listeners;
    },
    on,
    once,
    fire,
    removeListener,
    removeAllListeners
  };
}
var cssPrefix = "x-spreadsheet";
var Resizer = /* @__PURE__ */ function() {
  function Resizer2() {
    var _this = this;
    var vertical = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var minDistance = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, Resizer2);
    this.moving = false;
    this.vertical = vertical;
    this.el = h("div", "".concat(cssPrefix, "-resizer ").concat(vertical ? "vertical" : "horizontal")).children(this.unhideHoverEl = h("div", "".concat(cssPrefix, "-resizer-hover")).on("dblclick.stop", function(evt) {
      return _this.mousedblclickHandler(evt);
    }).css("position", "absolute").hide(), this.hoverEl = h("div", "".concat(cssPrefix, "-resizer-hover")).on("mousedown.stop", function(evt) {
      return _this.mousedownHandler(evt);
    }), this.lineEl = h("div", "".concat(cssPrefix, "-resizer-line")).hide()).hide();
    this.cRect = null;
    this.finishedFn = null;
    this.minDistance = minDistance;
    this.unhideFn = function() {
    };
  }
  _createClass(Resizer2, [{
    key: "showUnhide",
    value: function showUnhide(index2) {
      this.unhideIndex = index2;
      this.unhideHoverEl.show();
    }
  }, {
    key: "hideUnhide",
    value: function hideUnhide() {
      this.unhideHoverEl.hide();
    }
    // rect : {top, left, width, height}
    // line : {width, height}
  }, {
    key: "show",
    value: function show(rect, line) {
      var moving = this.moving, vertical = this.vertical, hoverEl = this.hoverEl, lineEl = this.lineEl, el = this.el, unhideHoverEl = this.unhideHoverEl;
      if (moving)
        return;
      this.cRect = rect;
      var left = rect.left, top = rect.top, width2 = rect.width, height2 = rect.height;
      el.offset({
        left: vertical ? left + width2 - 5 : left,
        top: vertical ? top : top + height2 - 5
      }).show();
      hoverEl.offset({
        width: vertical ? 5 : width2,
        height: vertical ? height2 : 5
      });
      lineEl.offset({
        width: vertical ? 0 : line.width,
        height: vertical ? line.height : 0
      });
      unhideHoverEl.offset({
        left: vertical ? 5 - width2 : left,
        top: vertical ? top : 5 - height2,
        width: vertical ? 5 : width2,
        height: vertical ? height2 : 5
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.offset({
        left: 0,
        top: 0
      }).hide();
      this.hideUnhide();
    }
  }, {
    key: "mousedblclickHandler",
    value: function mousedblclickHandler() {
      if (this.unhideIndex)
        this.unhideFn(this.unhideIndex);
    }
  }, {
    key: "mousedownHandler",
    value: function mousedownHandler(evt) {
      var _this2 = this;
      var startEvt = evt;
      var el = this.el, lineEl = this.lineEl, cRect = this.cRect, vertical = this.vertical, minDistance = this.minDistance;
      var distance = vertical ? cRect.width : cRect.height;
      lineEl.show();
      mouseMoveUp(window, function(e) {
        _this2.moving = true;
        if (startEvt !== null && e.buttons === 1) {
          if (vertical) {
            distance += e.movementX;
            if (distance > minDistance) {
              el.css("left", "".concat(cRect.left + distance, "px"));
            }
          } else {
            distance += e.movementY;
            if (distance > minDistance) {
              el.css("top", "".concat(cRect.top + distance, "px"));
            }
          }
          startEvt = e;
        }
      }, function() {
        startEvt = null;
        lineEl.hide();
        _this2.moving = false;
        _this2.hide();
        if (_this2.finishedFn) {
          if (distance < minDistance)
            distance = minDistance;
          _this2.finishedFn(cRect, distance);
        }
      });
    }
  }]);
  return Resizer2;
}();
var Scrollbar = /* @__PURE__ */ function() {
  function Scrollbar2(vertical) {
    var _this = this;
    _classCallCheck(this, Scrollbar2);
    this.vertical = vertical;
    this.moveFn = null;
    this.el = h("div", "".concat(cssPrefix, "-scrollbar ").concat(vertical ? "vertical" : "horizontal")).child(this.contentEl = h("div", "")).on("mousemove.stop", function() {
    }).on("scroll.stop", function(evt) {
      var _evt$target = evt.target, scrollTop = _evt$target.scrollTop, scrollLeft = _evt$target.scrollLeft;
      if (_this.moveFn) {
        _this.moveFn(_this.vertical ? scrollTop : scrollLeft, evt);
      }
    });
  }
  _createClass(Scrollbar2, [{
    key: "move",
    value: function move(v) {
      this.el.scroll(v);
      return this;
    }
  }, {
    key: "scroll",
    value: function scroll() {
      return this.el.scroll();
    }
  }, {
    key: "set",
    value: function set(distance, contentDistance) {
      var d = distance - 1;
      if (contentDistance > d) {
        var cssKey = this.vertical ? "height" : "width";
        this.el.css(cssKey, "".concat(d - 15, "px")).show();
        this.contentEl.css(this.vertical ? "width" : "height", "1px").css(cssKey, "".concat(contentDistance, "px"));
      } else {
        this.el.hide();
      }
      return this;
    }
  }]);
  return Scrollbar2;
}();
var selectorHeightBorderWidth = 2 * 2 - 1;
var startZIndex = 10;
var SelectorElement = /* @__PURE__ */ function() {
  function SelectorElement2() {
    var _this = this;
    var useHideInput = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    _classCallCheck(this, SelectorElement2);
    this.useHideInput = useHideInput;
    this.inputChange = function() {
    };
    this.cornerEl = h("div", "".concat(cssPrefix, "-selector-corner"));
    this.areaEl = h("div", "".concat(cssPrefix, "-selector-area")).child(this.cornerEl).hide();
    this.clipboardEl = h("div", "".concat(cssPrefix, "-selector-clipboard")).hide();
    this.autofillEl = h("div", "".concat(cssPrefix, "-selector-autofill")).hide();
    this.el = h("div", "".concat(cssPrefix, "-selector")).css("z-index", "".concat(startZIndex)).children(this.areaEl, this.clipboardEl, this.autofillEl).hide();
    if (useHideInput) {
      this.hideInput = h("input", "").on("compositionend", function(evt) {
        _this.inputChange(evt.target.value);
      });
      this.el.child(this.hideInputDiv = h("div", "hide-input").child(this.hideInput));
      this.el.child(this.hideInputDiv = h("div", "hide-input").child(this.hideInput));
    }
    startZIndex += 1;
  }
  _createClass(SelectorElement2, [{
    key: "setOffset",
    value: function setOffset(v) {
      this.el.offset(v).show();
      return this;
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
      return this;
    }
  }, {
    key: "setAreaOffset",
    value: function setAreaOffset(v) {
      var left = v.left, top = v.top, width2 = v.width, height2 = v.height;
      var of = {
        width: width2 - selectorHeightBorderWidth + 0.8,
        height: height2 - selectorHeightBorderWidth + 0.8,
        left: left - 0.8,
        top: top - 0.8
      };
      this.areaEl.offset(of).show();
      if (this.useHideInput) {
        this.hideInputDiv.offset(of);
        this.hideInput.val("").focus();
      }
    }
  }, {
    key: "setClipboardOffset",
    value: function setClipboardOffset(v) {
      var left = v.left, top = v.top, width2 = v.width, height2 = v.height;
      this.clipboardEl.offset({
        left,
        top,
        width: width2 - 5,
        height: height2 - 5
      });
    }
  }, {
    key: "showAutofill",
    value: function showAutofill(v) {
      var left = v.left, top = v.top, width2 = v.width, height2 = v.height;
      this.autofillEl.offset({
        width: width2 - selectorHeightBorderWidth,
        height: height2 - selectorHeightBorderWidth,
        left,
        top
      }).show();
    }
  }, {
    key: "hideAutofill",
    value: function hideAutofill() {
      this.autofillEl.hide();
    }
  }, {
    key: "showClipboard",
    value: function showClipboard() {
      this.clipboardEl.show();
    }
  }, {
    key: "hideClipboard",
    value: function hideClipboard() {
      this.clipboardEl.hide();
    }
  }]);
  return SelectorElement2;
}();
function calBRAreaOffset(offset) {
  var data = this.data;
  var left = offset.left, top = offset.top, width2 = offset.width, height2 = offset.height, scroll = offset.scroll, l = offset.l, t2 = offset.t;
  var ftwidth = data.freezeTotalWidth();
  var ftheight = data.freezeTotalHeight();
  var left0 = left - ftwidth;
  if (ftwidth > l)
    left0 -= scroll.x;
  var top0 = top - ftheight;
  if (ftheight > t2)
    top0 -= scroll.y;
  return {
    left: left0,
    top: top0,
    width: width2,
    height: height2
  };
}
function calTAreaOffset(offset) {
  var data = this.data;
  var left = offset.left, width2 = offset.width, height2 = offset.height, l = offset.l, t2 = offset.t, scroll = offset.scroll;
  var ftwidth = data.freezeTotalWidth();
  var left0 = left - ftwidth;
  if (ftwidth > l)
    left0 -= scroll.x;
  return {
    left: left0,
    top: t2,
    width: width2,
    height: height2
  };
}
function calLAreaOffset(offset) {
  var data = this.data;
  var top = offset.top, width2 = offset.width, height2 = offset.height, l = offset.l, t2 = offset.t, scroll = offset.scroll;
  var ftheight = data.freezeTotalHeight();
  var top0 = top - ftheight;
  if (ftheight > t2)
    top0 -= scroll.y;
  return {
    left: l,
    top: top0,
    width: width2,
    height: height2
  };
}
function setBRAreaOffset(offset) {
  var br = this.br;
  br.setAreaOffset(calBRAreaOffset.call(this, offset));
}
function setTLAreaOffset(offset) {
  var tl = this.tl;
  tl.setAreaOffset(offset);
}
function setTAreaOffset(offset) {
  var t2 = this.t;
  t2.setAreaOffset(calTAreaOffset.call(this, offset));
}
function setLAreaOffset(offset) {
  var l = this.l;
  l.setAreaOffset(calLAreaOffset.call(this, offset));
}
function setLClipboardOffset(offset) {
  var l = this.l;
  l.setClipboardOffset(calLAreaOffset.call(this, offset));
}
function setBRClipboardOffset(offset) {
  var br = this.br;
  br.setClipboardOffset(calBRAreaOffset.call(this, offset));
}
function setTLClipboardOffset(offset) {
  var tl = this.tl;
  tl.setClipboardOffset(offset);
}
function setTClipboardOffset(offset) {
  var t2 = this.t;
  t2.setClipboardOffset(calTAreaOffset.call(this, offset));
}
function setAllAreaOffset(offset) {
  setBRAreaOffset.call(this, offset);
  setTLAreaOffset.call(this, offset);
  setTAreaOffset.call(this, offset);
  setLAreaOffset.call(this, offset);
}
function setAllClipboardOffset(offset) {
  setBRClipboardOffset.call(this, offset);
  setTLClipboardOffset.call(this, offset);
  setTClipboardOffset.call(this, offset);
  setLClipboardOffset.call(this, offset);
}
var Selector = /* @__PURE__ */ function() {
  function Selector2(data) {
    var _this2 = this;
    _classCallCheck(this, Selector2);
    this.inputChange = function() {
    };
    this.data = data;
    this.br = new SelectorElement(true);
    this.t = new SelectorElement();
    this.l = new SelectorElement();
    this.tl = new SelectorElement();
    this.br.inputChange = function(v) {
      _this2.inputChange(v);
    };
    this.br.el.show();
    this.offset = null;
    this.areaOffset = null;
    this.indexes = null;
    this.range = null;
    this.arange = null;
    this.el = h("div", "".concat(cssPrefix, "-selectors")).children(this.tl.el, this.t.el, this.l.el, this.br.el).hide();
    this.lastri = -1;
    this.lastci = -1;
    startZIndex += 1;
  }
  _createClass(Selector2, [{
    key: "resetData",
    value: function resetData(data) {
      this.data = data;
      this.range = data.selector.range;
      this.resetAreaOffset();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
    }
  }, {
    key: "resetOffset",
    value: function resetOffset() {
      var data = this.data, tl = this.tl, t2 = this.t, l = this.l, br = this.br;
      var freezeHeight = data.freezeTotalHeight();
      var freezeWidth = data.freezeTotalWidth();
      if (freezeHeight > 0 || freezeWidth > 0) {
        tl.setOffset({
          width: freezeWidth,
          height: freezeHeight
        });
        t2.setOffset({
          left: freezeWidth,
          height: freezeHeight
        });
        l.setOffset({
          top: freezeHeight,
          width: freezeWidth
        });
        br.setOffset({
          left: freezeWidth,
          top: freezeHeight
        });
      } else {
        tl.hide();
        t2.hide();
        l.hide();
        br.setOffset({
          left: 0,
          top: 0
        });
      }
    }
  }, {
    key: "resetAreaOffset",
    value: function resetAreaOffset() {
      var offset = this.data.getSelectedRect();
      var coffset = this.data.getClipboardRect();
      setAllAreaOffset.call(this, offset);
      setAllClipboardOffset.call(this, coffset);
      this.resetOffset();
    }
  }, {
    key: "resetBRTAreaOffset",
    value: function resetBRTAreaOffset() {
      var offset = this.data.getSelectedRect();
      var coffset = this.data.getClipboardRect();
      setBRAreaOffset.call(this, offset);
      setTAreaOffset.call(this, offset);
      setBRClipboardOffset.call(this, coffset);
      setTClipboardOffset.call(this, coffset);
      this.resetOffset();
    }
  }, {
    key: "resetBRLAreaOffset",
    value: function resetBRLAreaOffset() {
      var offset = this.data.getSelectedRect();
      var coffset = this.data.getClipboardRect();
      setBRAreaOffset.call(this, offset);
      setLAreaOffset.call(this, offset);
      setBRClipboardOffset.call(this, coffset);
      setLClipboardOffset.call(this, coffset);
      this.resetOffset();
    }
  }, {
    key: "set",
    value: function set(ri, ci) {
      var indexesUpdated = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var data = this.data;
      var cellRange = data.calSelectedRangeByStart(ri, ci);
      var sri = cellRange.sri, sci = cellRange.sci;
      if (indexesUpdated) {
        var cri = ri, cci = ci;
        if (ri < 0)
          cri = 0;
        if (ci < 0)
          cci = 0;
        data.selector.setIndexes(cri, cci);
        this.indexes = [cri, cci];
      }
      this.moveIndexes = [sri, sci];
      this.range = cellRange;
      this.resetAreaOffset();
      this.el.show();
    }
  }, {
    key: "setEnd",
    value: function setEnd(ri, ci) {
      var moving = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      var data = this.data, lastri = this.lastri, lastci = this.lastci;
      if (moving) {
        if (ri === lastri && ci === lastci)
          return;
        this.lastri = ri;
        this.lastci = ci;
      }
      this.range = data.calSelectedRangeByEnd(ri, ci);
      setAllAreaOffset.call(this, this.data.getSelectedRect());
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this$data$selector$r = this.data.selector.range, eri = _this$data$selector$r.eri, eci = _this$data$selector$r.eci;
      this.setEnd(eri, eci);
    }
  }, {
    key: "showAutofill",
    value: function showAutofill(ri, ci) {
      if (ri === -1 && ci === -1)
        return;
      var _this$range = this.range, sri = _this$range.sri, sci = _this$range.sci, eri = _this$range.eri, eci = _this$range.eci;
      var nri = ri, nci = ci;
      var srn = sri - ri;
      var scn = sci - ci;
      var ern = eri - ri;
      var ecn = eci - ci;
      if (scn > 0) {
        this.arange = new CellRange(sri, nci, eri, sci - 1);
      } else if (srn > 0) {
        this.arange = new CellRange(nri, sci, sri - 1, eci);
      } else if (ecn < 0) {
        this.arange = new CellRange(sri, eci + 1, eri, nci);
      } else if (ern < 0) {
        this.arange = new CellRange(eri + 1, sci, nri, eci);
      } else {
        this.arange = null;
        return;
      }
      if (this.arange !== null) {
        var offset = this.data.getRect(this.arange);
        offset.width += 2;
        offset.height += 2;
        var br = this.br, l = this.l, t2 = this.t, tl = this.tl;
        br.showAutofill(calBRAreaOffset.call(this, offset));
        l.showAutofill(calLAreaOffset.call(this, offset));
        t2.showAutofill(calTAreaOffset.call(this, offset));
        tl.showAutofill(offset);
      }
    }
  }, {
    key: "hideAutofill",
    value: function hideAutofill() {
      var _this3 = this;
      ["br", "l", "t", "tl"].forEach(function(property) {
        _this3[property].hideAutofill();
      });
    }
  }, {
    key: "showClipboard",
    value: function showClipboard() {
      var _this4 = this;
      var coffset = this.data.getClipboardRect();
      setAllClipboardOffset.call(this, coffset);
      ["br", "l", "t", "tl"].forEach(function(property) {
        _this4[property].showClipboard();
      });
    }
  }, {
    key: "hideClipboard",
    value: function hideClipboard() {
      var _this5 = this;
      ["br", "l", "t", "tl"].forEach(function(property) {
        _this5[property].hideClipboard();
      });
    }
  }]);
  return Selector2;
}();
function inputMovePrev(evt) {
  evt.preventDefault();
  evt.stopPropagation();
  var filterItems = this.filterItems;
  if (filterItems.length <= 0)
    return;
  if (this.itemIndex >= 0)
    filterItems[this.itemIndex].toggle();
  this.itemIndex -= 1;
  if (this.itemIndex < 0) {
    this.itemIndex = filterItems.length - 1;
  }
  filterItems[this.itemIndex].toggle();
}
function inputMoveNext(evt) {
  evt.stopPropagation();
  var filterItems = this.filterItems;
  if (filterItems.length <= 0)
    return;
  if (this.itemIndex >= 0)
    filterItems[this.itemIndex].toggle();
  this.itemIndex += 1;
  if (this.itemIndex > filterItems.length - 1) {
    this.itemIndex = 0;
  }
  filterItems[this.itemIndex].toggle();
}
function inputEnter(evt) {
  evt.preventDefault();
  var filterItems = this.filterItems;
  if (filterItems.length <= 0)
    return;
  evt.stopPropagation();
  if (this.itemIndex < 0)
    this.itemIndex = 0;
  filterItems[this.itemIndex].el.click();
  this.hide();
}
function inputKeydownHandler(evt) {
  var keyCode = evt.keyCode;
  if (evt.ctrlKey) {
    evt.stopPropagation();
  }
  switch (keyCode) {
    case 37:
      evt.stopPropagation();
      break;
    case 38:
      inputMovePrev.call(this, evt);
      break;
    case 39:
      evt.stopPropagation();
      break;
    case 40:
      inputMoveNext.call(this, evt);
      break;
    case 13:
      inputEnter.call(this, evt);
      break;
    case 9:
      inputEnter.call(this, evt);
      break;
    default:
      evt.stopPropagation();
      break;
  }
}
var Suggest = /* @__PURE__ */ function() {
  function Suggest2(items, itemClick) {
    var width2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "200px";
    _classCallCheck(this, Suggest2);
    this.filterItems = [];
    this.items = items;
    this.el = h("div", "".concat(cssPrefix, "-suggest")).css("width", width2).hide();
    this.itemClick = itemClick;
    this.itemIndex = -1;
  }
  _createClass(Suggest2, [{
    key: "setOffset",
    value: function setOffset(v) {
      this.el.cssRemoveKeys("top", "bottom").offset(v);
    }
  }, {
    key: "hide",
    value: function hide() {
      var el = this.el;
      this.filterItems = [];
      this.itemIndex = -1;
      el.hide();
      unbindClickoutside(this.el.parent());
    }
  }, {
    key: "setItems",
    value: function setItems(items) {
      this.items = items;
    }
  }, {
    key: "search",
    value: function search(word) {
      var _this = this, _el$html;
      var items = this.items;
      if (!/^\s*$/.test(word)) {
        items = items.filter(function(it) {
          return (it.key || it).startsWith(word.toUpperCase());
        });
      }
      items = items.map(function(it) {
        var title = it.title;
        if (title) {
          if (typeof title === "function") {
            title = title();
          }
        } else {
          title = it;
        }
        var item = h("div", "".concat(cssPrefix, "-item")).child(title).on("click.stop", function() {
          _this.itemClick(it);
          _this.hide();
        });
        if (it.label) {
          item.child(h("div", "label").html(it.label));
        }
        return item;
      });
      this.filterItems = items;
      if (items.length <= 0) {
        return;
      }
      var el = this.el;
      (_el$html = el.html("")).children.apply(_el$html, _toConsumableArray(items)).show();
      bindClickoutside(el.parent(), function() {
        _this.hide();
      });
    }
  }, {
    key: "bindInputEvents",
    value: function bindInputEvents(input) {
      var _this2 = this;
      input.on("keydown", function(evt) {
        return inputKeydownHandler.call(_this2, evt);
      });
    }
  }]);
  return Suggest2;
}();
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _createSuper$C(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$C();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$C() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Icon = /* @__PURE__ */ function(_Element) {
  _inherits(Icon2, _Element);
  var _super = _createSuper$C(Icon2);
  function Icon2(name) {
    var _this;
    _classCallCheck(this, Icon2);
    _this = _super.call(this, "div", "".concat(cssPrefix, "-icon"));
    _this.iconNameEl = h("div", "".concat(cssPrefix, "-icon-img ").concat(name));
    _this.child(_this.iconNameEl);
    return _this;
  }
  _createClass(Icon2, [{
    key: "setName",
    value: function setName(name) {
      this.iconNameEl.className("".concat(cssPrefix, "-icon-img ").concat(name));
    }
  }]);
  return Icon2;
}(Element);
function addMonth(date, step) {
  date.setMonth(date.getMonth() + step);
}
function weekday(date, index2) {
  var d = new Date(date);
  d.setDate(index2 - date.getDay() + 1);
  return d;
}
function monthDays(year, month, cdate) {
  var startDate = new Date(year, month, 1, 23, 59, 59);
  var datess = [[], [], [], [], [], []];
  for (var i = 0; i < 6; i += 1) {
    for (var j = 0; j < 7; j += 1) {
      var index2 = i * 7 + j;
      var d = weekday(startDate, index2);
      var disabled = d.getMonth() !== month;
      var active = d.getMonth() === cdate.getMonth() && d.getDate() === cdate.getDate();
      datess[i][j] = {
        d,
        disabled,
        active
      };
    }
  }
  return datess;
}
var Calendar = /* @__PURE__ */ function() {
  function Calendar2(value) {
    var _this = this, _h;
    _classCallCheck(this, Calendar2);
    this.value = value;
    this.cvalue = new Date(value);
    this.headerLeftEl = h("div", "calendar-header-left");
    this.bodyEl = h("tbody", "");
    this.buildAll();
    this.el = h("div", "x-spreadsheet-calendar").children(h("div", "calendar-header").children(this.headerLeftEl, h("div", "calendar-header-right").children(h("a", "calendar-prev").on("click.stop", function() {
      return _this.prev();
    }).child(new Icon("chevron-left")), h("a", "calendar-next").on("click.stop", function() {
      return _this.next();
    }).child(new Icon("chevron-right")))), h("table", "calendar-body").children(h("thead", "").child((_h = h("tr", "")).children.apply(_h, _toConsumableArray(t("calendar.weeks").map(function(week) {
      return h("th", "cell").child(week);
    })))), this.bodyEl));
    this.selectChange = function() {
    };
  }
  _createClass(Calendar2, [{
    key: "setValue",
    value: function setValue(value) {
      this.value = value;
      this.cvalue = new Date(value);
      this.buildAll();
    }
  }, {
    key: "prev",
    value: function prev() {
      var value = this.value;
      addMonth(value, -1);
      this.buildAll();
    }
  }, {
    key: "next",
    value: function next() {
      var value = this.value;
      addMonth(value, 1);
      this.buildAll();
    }
  }, {
    key: "buildAll",
    value: function buildAll() {
      this.buildHeaderLeft();
      this.buildBody();
    }
  }, {
    key: "buildHeaderLeft",
    value: function buildHeaderLeft() {
      var value = this.value;
      this.headerLeftEl.html("".concat(t("calendar.months")[value.getMonth()], " ").concat(value.getFullYear()));
    }
  }, {
    key: "buildBody",
    value: function buildBody() {
      var _this2 = this, _bodyEl$html;
      var value = this.value, cvalue = this.cvalue, bodyEl = this.bodyEl;
      var mDays = monthDays(value.getFullYear(), value.getMonth(), cvalue);
      var trs = mDays.map(function(it) {
        var _h2;
        var tds = it.map(function(it1) {
          var cls = "cell";
          if (it1.disabled)
            cls += " disabled";
          if (it1.active)
            cls += " active";
          return h("td", "").child(h("div", cls).on("click.stop", function() {
            _this2.selectChange(it1.d);
          }).child(it1.d.getDate().toString()));
        });
        return (_h2 = h("tr", "")).children.apply(_h2, _toConsumableArray(tds));
      });
      (_bodyEl$html = bodyEl.html("")).children.apply(_bodyEl$html, _toConsumableArray(trs));
    }
  }]);
  return Calendar2;
}();
var Datepicker = /* @__PURE__ */ function() {
  function Datepicker2() {
    _classCallCheck(this, Datepicker2);
    this.calendar = new Calendar(/* @__PURE__ */ new Date());
    this.el = h("div", "".concat(cssPrefix, "-datepicker")).child(this.calendar.el).hide();
  }
  _createClass(Datepicker2, [{
    key: "setValue",
    value: function setValue(date) {
      var calendar = this.calendar;
      if (typeof date === "string") {
        if (/^\d{4}-\d{1,2}-\d{1,2}$/.test(date)) {
          calendar.setValue(new Date(date.replace(new RegExp("-", "g"), "/")));
        }
      } else if (date instanceof Date) {
        calendar.setValue(date);
      }
      return this;
    }
  }, {
    key: "change",
    value: function change(cb) {
      var _this = this;
      this.calendar.selectChange = function(d) {
        cb(d);
        _this.hide();
      };
    }
  }, {
    key: "show",
    value: function show() {
      this.el.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
    }
  }]);
  return Datepicker2;
}();
function resetTextareaSize() {
  var inputText = this.inputText;
  if (!/^\s*$/.test(inputText)) {
    var textlineEl = this.textlineEl, textEl = this.textEl, areaOffset = this.areaOffset;
    var txts = inputText.split("\n");
    var maxTxtSize = Math.max.apply(Math, _toConsumableArray(txts.map(function(it) {
      return it.length;
    })));
    var tlOffset = textlineEl.offset();
    var fontWidth = tlOffset.width / inputText.length;
    var tlineWidth = (maxTxtSize + 1) * fontWidth + 5;
    var maxWidth = this.viewFn().width - areaOffset.left - fontWidth;
    var h1 = txts.length;
    if (tlineWidth > areaOffset.width) {
      var twidth = tlineWidth;
      if (tlineWidth > maxWidth) {
        twidth = maxWidth;
        h1 += parseInt(tlineWidth / maxWidth, 10);
        h1 += tlineWidth % maxWidth > 0 ? 1 : 0;
      }
      textEl.css("width", "".concat(twidth, "px"));
    }
    h1 *= this.rowHeight;
    if (h1 > areaOffset.height) {
      textEl.css("height", "".concat(h1, "px"));
    }
  }
}
function insertText(_ref, itxt) {
  var target = _ref.target;
  var value = target.value, selectionEnd = target.selectionEnd;
  var ntxt = "".concat(value.slice(0, selectionEnd)).concat(itxt).concat(value.slice(selectionEnd));
  target.value = ntxt;
  target.setSelectionRange(selectionEnd + 1, selectionEnd + 1);
  this.inputText = ntxt;
  this.textlineEl.html(ntxt);
  resetTextareaSize.call(this);
}
function keydownEventHandler(evt) {
  var keyCode = evt.keyCode, altKey = evt.altKey;
  if (keyCode !== 13 && keyCode !== 9)
    evt.stopPropagation();
  if (keyCode === 13 && altKey) {
    insertText.call(this, evt, "\n");
    evt.stopPropagation();
  }
  if (keyCode === 13 && !altKey)
    evt.preventDefault();
}
function inputEventHandler(evt) {
  var v = evt.target.value;
  var suggest = this.suggest, textlineEl = this.textlineEl, validator = this.validator;
  var cell = this.cell;
  if (cell !== null) {
    if ("editable" in cell && cell.editable === true || cell.editable === void 0) {
      this.inputText = v;
      if (validator) {
        if (validator.type === "list") {
          suggest.search(v);
        } else {
          suggest.hide();
        }
      } else {
        var start = v.lastIndexOf("=");
        if (start !== -1) {
          suggest.search(v.substring(start + 1));
        } else {
          suggest.hide();
        }
      }
      textlineEl.html(v);
      resetTextareaSize.call(this);
      this.change("input", v);
    } else {
      evt.target.value = cell.text;
    }
  } else {
    this.inputText = v;
    if (validator) {
      if (validator.type === "list") {
        suggest.search(v);
      } else {
        suggest.hide();
      }
    } else {
      var _start = v.lastIndexOf("=");
      if (_start !== -1) {
        suggest.search(v.substring(_start + 1));
      } else {
        suggest.hide();
      }
    }
    textlineEl.html(v);
    resetTextareaSize.call(this);
    this.change("input", v);
  }
}
function setTextareaRange(position) {
  var el = this.textEl.el;
  setTimeout(function() {
    el.focus();
    el.setSelectionRange(position, position);
  }, 0);
}
function _setText(text, position) {
  var textEl = this.textEl, textlineEl = this.textlineEl;
  textEl.el.blur();
  textEl.val(text);
  textlineEl.html(text);
  setTextareaRange.call(this, position);
}
function suggestItemClick(it) {
  var inputText = this.inputText, validator = this.validator;
  var position = 0;
  if (validator && validator.type === "list") {
    this.inputText = it;
    position = this.inputText.length;
  } else {
    var start = inputText.lastIndexOf("=");
    var sit = inputText.substring(0, start + 1);
    var eit = inputText.substring(start + 1);
    if (eit.indexOf(")") !== -1) {
      eit = eit.substring(eit.indexOf(")"));
    } else {
      eit = "";
    }
    this.inputText = "".concat(sit + it.key, "(");
    position = this.inputText.length;
    this.inputText += ")".concat(eit);
  }
  _setText.call(this, this.inputText, position);
}
function resetSuggestItems() {
  this.suggest.setItems(this.formulas);
}
function dateFormat(d) {
  var month = d.getMonth() + 1;
  var date = d.getDate();
  if (month < 10)
    month = "0".concat(month);
  if (date < 10)
    date = "0".concat(date);
  return "".concat(d.getFullYear(), "-").concat(month, "-").concat(date);
}
var Editor = /* @__PURE__ */ function() {
  function Editor2(formulas2, viewFn, rowHeight) {
    var _this = this;
    _classCallCheck(this, Editor2);
    this.viewFn = viewFn;
    this.rowHeight = rowHeight;
    this.formulas = formulas2;
    this.suggest = new Suggest(formulas2, function(it) {
      suggestItemClick.call(_this, it);
    });
    this.datepicker = new Datepicker();
    this.datepicker.change(function(d) {
      _this.setText(dateFormat(d));
      _this.clear();
    });
    this.areaEl = h("div", "".concat(cssPrefix, "-editor-area")).children(this.textEl = h("textarea", "").on("input", function(evt) {
      return inputEventHandler.call(_this, evt);
    }).on("paste.stop", function() {
    }).on("keydown", function(evt) {
      return keydownEventHandler.call(_this, evt);
    }), this.textlineEl = h("div", "textline"), this.suggest.el, this.datepicker.el).on("mousemove.stop", function() {
    }).on("mousedown.stop", function() {
    });
    this.el = h("div", "".concat(cssPrefix, "-editor")).child(this.areaEl).hide();
    this.suggest.bindInputEvents(this.textEl);
    this.areaOffset = null;
    this.freeze = {
      w: 0,
      h: 0
    };
    this.cell = null;
    this.inputText = "";
    this.change = function() {
    };
  }
  _createClass(Editor2, [{
    key: "setFreezeLengths",
    value: function setFreezeLengths(width2, height2) {
      this.freeze.w = width2;
      this.freeze.h = height2;
    }
  }, {
    key: "clear",
    value: function clear() {
      if (this.inputText !== "") {
        this.change("finished", this.inputText);
      }
      this.cell = null;
      this.areaOffset = null;
      this.inputText = "";
      this.el.hide();
      this.textEl.val("");
      this.textlineEl.html("");
      resetSuggestItems.call(this);
      this.datepicker.hide();
    }
  }, {
    key: "setOffset",
    value: function setOffset(offset) {
      var suggestPosition = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top";
      var textEl = this.textEl, areaEl = this.areaEl, suggest = this.suggest, freeze = this.freeze, el = this.el;
      if (offset) {
        this.areaOffset = offset;
        var left = offset.left, top = offset.top, width2 = offset.width, height2 = offset.height, l = offset.l, t2 = offset.t;
        var elOffset = {
          left: 0,
          top: 0
        };
        if (freeze.w > l && freeze.h > t2)
          ;
        else if (freeze.w < l && freeze.h < t2) {
          elOffset.left = freeze.w;
          elOffset.top = freeze.h;
        } else if (freeze.w > l) {
          elOffset.top = freeze.h;
        } else if (freeze.h > t2) {
          elOffset.left = freeze.w;
        }
        el.offset(elOffset);
        areaEl.offset({
          left: left - elOffset.left - 0.8,
          top: top - elOffset.top - 0.8
        });
        textEl.offset({
          width: width2 - 9 + 0.8,
          height: height2 - 3 + 0.8
        });
        var sOffset = {
          left: 0
        };
        sOffset[suggestPosition] = height2;
        suggest.setOffset(sOffset);
        suggest.hide();
      }
    }
  }, {
    key: "setCell",
    value: function setCell(cell, validator) {
      var el = this.el, datepicker = this.datepicker, suggest = this.suggest;
      el.show();
      this.cell = cell;
      var text = cell && cell.text || "";
      this.setText(text);
      this.validator = validator;
      if (validator) {
        var type = validator.type;
        if (type === "date") {
          datepicker.show();
          if (!/^\s*$/.test(text)) {
            datepicker.setValue(text);
          }
        }
        if (type === "list") {
          suggest.setItems(validator.values());
          suggest.search("");
        }
      }
    }
  }, {
    key: "setText",
    value: function setText(text) {
      this.inputText = text;
      _setText.call(this, text, text.length);
      resetTextareaSize.call(this);
    }
  }]);
  return Editor2;
}();
function _createSuper$B(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$B();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$B() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Button = /* @__PURE__ */ function(_Element) {
  _inherits(Button2, _Element);
  var _super = _createSuper$B(Button2);
  function Button2(title) {
    var _this;
    var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    _classCallCheck(this, Button2);
    _this = _super.call(this, "div", "".concat(cssPrefix, "-button ").concat(type));
    _this.child(t("button.".concat(title)));
    return _this;
  }
  return _createClass(Button2);
}(Element);
function dpr() {
  return window.devicePixelRatio || 1;
}
function thinLineWidth() {
  return dpr() - 0.5;
}
function npx(px) {
  return parseInt(px * dpr(), 10);
}
function npxLine(px) {
  var n = npx(px);
  return n > 0 ? n - 0.5 : 0.5;
}
var DrawBox = /* @__PURE__ */ function() {
  function DrawBox2(x, y, w, h3) {
    var padding = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    _classCallCheck(this, DrawBox2);
    this.x = x;
    this.y = y;
    this.width = w;
    this.height = h3;
    this.padding = padding;
    this.bgcolor = "#ffffff";
    this.borderTop = null;
    this.borderRight = null;
    this.borderBottom = null;
    this.borderLeft = null;
  }
  _createClass(DrawBox2, [{
    key: "setBorders",
    value: function setBorders(_ref) {
      var top = _ref.top, bottom = _ref.bottom, left = _ref.left, right = _ref.right;
      if (top)
        this.borderTop = top;
      if (right)
        this.borderRight = right;
      if (bottom)
        this.borderBottom = bottom;
      if (left)
        this.borderLeft = left;
    }
  }, {
    key: "innerWidth",
    value: function innerWidth() {
      return this.width - this.padding * 2 - 2;
    }
  }, {
    key: "innerHeight",
    value: function innerHeight() {
      return this.height - this.padding * 2 - 2;
    }
  }, {
    key: "textx",
    value: function textx(align) {
      var width2 = this.width, padding = this.padding;
      var x = this.x;
      if (align === "left") {
        x += padding;
      } else if (align === "center") {
        x += width2 / 2;
      } else if (align === "right") {
        x += width2 - padding;
      }
      return x;
    }
  }, {
    key: "texty",
    value: function texty(align, h3) {
      var height2 = this.height, padding = this.padding;
      var y = this.y;
      if (align === "top") {
        y += padding;
      } else if (align === "middle") {
        y += height2 / 2 - h3 / 2;
      } else if (align === "bottom") {
        y += height2 - padding - h3;
      }
      return y;
    }
  }, {
    key: "topxys",
    value: function topxys() {
      var x = this.x, y = this.y, width2 = this.width;
      return [[x, y], [x + width2, y]];
    }
  }, {
    key: "rightxys",
    value: function rightxys() {
      var x = this.x, y = this.y, width2 = this.width, height2 = this.height;
      return [[x + width2, y], [x + width2, y + height2]];
    }
  }, {
    key: "bottomxys",
    value: function bottomxys() {
      var x = this.x, y = this.y, width2 = this.width, height2 = this.height;
      return [[x, y + height2], [x + width2, y + height2]];
    }
  }, {
    key: "leftxys",
    value: function leftxys() {
      var x = this.x, y = this.y, height2 = this.height;
      return [[x, y], [x, y + height2]];
    }
  }]);
  return DrawBox2;
}();
function drawFontLine(type, tx, ty, align, valign, blheight, blwidth) {
  var floffset = {
    x: 0,
    y: 0
  };
  if (type === "underline") {
    if (valign === "bottom") {
      floffset.y = 0;
    } else if (valign === "top") {
      floffset.y = -(blheight + 2);
    } else {
      floffset.y = -blheight / 2;
    }
  } else if (type === "strike") {
    if (valign === "bottom") {
      floffset.y = blheight / 2;
    } else if (valign === "top") {
      floffset.y = -(blheight / 2 + 2);
    }
  }
  if (align === "center") {
    floffset.x = blwidth / 2;
  } else if (align === "right") {
    floffset.x = blwidth;
  }
  this.line([tx - floffset.x, ty - floffset.y], [tx - floffset.x + blwidth, ty - floffset.y]);
}
var Draw = /* @__PURE__ */ function() {
  function Draw2(el, width2, height2) {
    _classCallCheck(this, Draw2);
    this.el = el;
    this.ctx = el.getContext("2d");
    this.resize(width2, height2);
    this.ctx.scale(dpr(), dpr());
  }
  _createClass(Draw2, [{
    key: "resize",
    value: function resize(width2, height2) {
      this.el.style.width = "".concat(width2, "px");
      this.el.style.height = "".concat(height2, "px");
      this.el.width = npx(width2);
      this.el.height = npx(height2);
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this$el = this.el, width2 = _this$el.width, height2 = _this$el.height;
      this.ctx.clearRect(0, 0, width2, height2);
      return this;
    }
  }, {
    key: "attr",
    value: function attr(options) {
      Object.assign(this.ctx, options);
      return this;
    }
  }, {
    key: "save",
    value: function save() {
      this.ctx.save();
      this.ctx.beginPath();
      return this;
    }
  }, {
    key: "restore",
    value: function restore() {
      this.ctx.restore();
      return this;
    }
  }, {
    key: "beginPath",
    value: function beginPath() {
      this.ctx.beginPath();
      return this;
    }
  }, {
    key: "translate",
    value: function translate2(x, y) {
      this.ctx.translate(npx(x), npx(y));
      return this;
    }
  }, {
    key: "scale",
    value: function scale(x, y) {
      this.ctx.scale(x, y);
      return this;
    }
  }, {
    key: "clearRect",
    value: function clearRect(x, y, w, h3) {
      this.ctx.clearRect(x, y, w, h3);
      return this;
    }
  }, {
    key: "fillRect",
    value: function fillRect(x, y, w, h3) {
      this.ctx.fillRect(npx(x) - 0.5, npx(y) - 0.5, npx(w), npx(h3));
      return this;
    }
  }, {
    key: "fillText",
    value: function fillText(text, x, y) {
      this.ctx.fillText(text, npx(x), npx(y));
      return this;
    }
    /*
      txt: render text
      box: DrawBox
      attr: {
        align: left | center | right
        valign: top | middle | bottom
        color: '#333333',
        strike: false,
        font: {
          name: 'Arial',
          size: 14,
          bold: false,
          italic: false,
        }
      }
      textWrap: text wrapping
    */
  }, {
    key: "text",
    value: function text(mtxt, box) {
      var _this = this;
      var attr = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var textWrap = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var ctx = this.ctx;
      var align = attr.align, valign = attr.valign, font = attr.font, color = attr.color, strike = attr.strike, underline = attr.underline;
      var tx = box.textx(align);
      ctx.save();
      ctx.beginPath();
      this.attr({
        textAlign: align,
        textBaseline: valign,
        font: "".concat(font.italic ? "italic" : "", " ").concat(font.bold ? "bold" : "", " ").concat(npx(font.size), "px ").concat(font.name),
        fillStyle: color,
        strokeStyle: color
      });
      var txts = "".concat(mtxt).split("\n");
      var biw = box.innerWidth();
      var ntxts = [];
      txts.forEach(function(it) {
        var txtWidth = ctx.measureText(it).width;
        if (textWrap && txtWidth > npx(biw)) {
          var textLine = {
            w: 0,
            len: 0,
            start: 0
          };
          for (var i = 0; i < it.length; i += 1) {
            if (textLine.w >= npx(biw)) {
              ntxts.push(it.substr(textLine.start, textLine.len));
              textLine = {
                w: 0,
                len: 0,
                start: i
              };
            }
            textLine.len += 1;
            textLine.w += ctx.measureText(it[i]).width + 1;
          }
          if (textLine.len > 0) {
            ntxts.push(it.substr(textLine.start, textLine.len));
          }
        } else {
          ntxts.push(it);
        }
      });
      var txtHeight = (ntxts.length - 1) * (font.size + 2);
      var ty = box.texty(valign, txtHeight);
      ntxts.forEach(function(txt) {
        var txtWidth = ctx.measureText(txt).width;
        _this.fillText(txt, tx, ty);
        if (strike) {
          drawFontLine.call(_this, "strike", tx, ty, align, valign, font.size, txtWidth);
        }
        if (underline) {
          drawFontLine.call(_this, "underline", tx, ty, align, valign, font.size, txtWidth);
        }
        ty += font.size + 2;
      });
      ctx.restore();
      return this;
    }
  }, {
    key: "border",
    value: function border(style, color) {
      var ctx = this.ctx;
      ctx.lineWidth = thinLineWidth;
      ctx.strokeStyle = color;
      if (style === "medium") {
        ctx.lineWidth = npx(2) - 0.5;
      } else if (style === "thick") {
        ctx.lineWidth = npx(3);
      } else if (style === "dashed") {
        ctx.setLineDash([npx(3), npx(2)]);
      } else if (style === "dotted") {
        ctx.setLineDash([npx(1), npx(1)]);
      } else if (style === "double") {
        ctx.setLineDash([npx(2), 0]);
      }
      return this;
    }
  }, {
    key: "line",
    value: function line() {
      var ctx = this.ctx;
      if (arguments.length > 1) {
        ctx.beginPath();
        var _ref2 = arguments.length <= 0 ? void 0 : arguments[0], _ref3 = _slicedToArray(_ref2, 2), x = _ref3[0], y = _ref3[1];
        ctx.moveTo(npxLine(x), npxLine(y));
        for (var i = 1; i < arguments.length; i += 1) {
          var _ref4 = i < 0 || arguments.length <= i ? void 0 : arguments[i], _ref5 = _slicedToArray(_ref4, 2), x1 = _ref5[0], y1 = _ref5[1];
          ctx.lineTo(npxLine(x1), npxLine(y1));
        }
        ctx.stroke();
      }
      return this;
    }
  }, {
    key: "strokeBorders",
    value: function strokeBorders(box) {
      var ctx = this.ctx;
      ctx.save();
      var borderTop = box.borderTop, borderRight = box.borderRight, borderBottom = box.borderBottom, borderLeft = box.borderLeft;
      if (borderTop) {
        this.border.apply(this, _toConsumableArray(borderTop));
        this.line.apply(this, _toConsumableArray(box.topxys()));
      }
      if (borderRight) {
        this.border.apply(this, _toConsumableArray(borderRight));
        this.line.apply(this, _toConsumableArray(box.rightxys()));
      }
      if (borderBottom) {
        this.border.apply(this, _toConsumableArray(borderBottom));
        this.line.apply(this, _toConsumableArray(box.bottomxys()));
      }
      if (borderLeft) {
        this.border.apply(this, _toConsumableArray(borderLeft));
        this.line.apply(this, _toConsumableArray(box.leftxys()));
      }
      ctx.restore();
    }
  }, {
    key: "dropdown",
    value: function dropdown(box) {
      var ctx = this.ctx;
      var x = box.x, y = box.y, width2 = box.width, height2 = box.height;
      var sx = x + width2 - 15;
      var sy = y + height2 - 15;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(npx(sx), npx(sy));
      ctx.lineTo(npx(sx + 8), npx(sy));
      ctx.lineTo(npx(sx + 4), npx(sy + 6));
      ctx.closePath();
      ctx.fillStyle = "rgba(0, 0, 0, .45)";
      ctx.fill();
      ctx.restore();
    }
  }, {
    key: "error",
    value: function error(box) {
      var ctx = this.ctx;
      var x = box.x, y = box.y, width2 = box.width;
      var sx = x + width2 - 1;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(npx(sx - 8), npx(y - 1));
      ctx.lineTo(npx(sx), npx(y - 1));
      ctx.lineTo(npx(sx), npx(y + 8));
      ctx.closePath();
      ctx.fillStyle = "rgba(255, 0, 0, .65)";
      ctx.fill();
      ctx.restore();
    }
  }, {
    key: "frozen",
    value: function frozen(box) {
      var ctx = this.ctx;
      var x = box.x, y = box.y, width2 = box.width;
      var sx = x + width2 - 1;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(npx(sx - 8), npx(y - 1));
      ctx.lineTo(npx(sx), npx(y - 1));
      ctx.lineTo(npx(sx), npx(y + 8));
      ctx.closePath();
      ctx.fillStyle = "rgba(0, 255, 0, .85)";
      ctx.fill();
      ctx.restore();
    }
  }, {
    key: "rect",
    value: function rect(box, dtextcb) {
      var ctx = this.ctx;
      var x = box.x, y = box.y, width2 = box.width, height2 = box.height, bgcolor = box.bgcolor;
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = bgcolor || "#fff";
      ctx.rect(npxLine(x + 1), npxLine(y + 1), npx(width2 - 2), npx(height2 - 2));
      ctx.clip();
      ctx.fill();
      dtextcb();
      ctx.restore();
    }
  }]);
  return Draw2;
}();
var baseFonts = [{
  key: "Arial",
  title: "Arial"
}, {
  key: "Helvetica",
  title: "Helvetica"
}, {
  key: "Source Sans Pro",
  title: "Source Sans Pro"
}, {
  key: "Comic Sans MS",
  title: "Comic Sans MS"
}, {
  key: "Courier New",
  title: "Courier New"
}, {
  key: "Verdana",
  title: "Verdana"
}, {
  key: "Lato",
  title: "Lato"
}];
var fontSizes = [
  {
    pt: 7.5,
    px: 10
  },
  {
    pt: 8,
    px: 11
  },
  {
    pt: 9,
    px: 12
  },
  {
    pt: 10,
    px: 13
  },
  {
    pt: 10.5,
    px: 14
  },
  {
    pt: 11,
    px: 15
  },
  {
    pt: 12,
    px: 16
  },
  {
    pt: 14,
    px: 18.7
  },
  {
    pt: 15,
    px: 20
  },
  {
    pt: 16,
    px: 21.3
  },
  {
    pt: 18,
    px: 24
  },
  {
    pt: 22,
    px: 29.3
  },
  {
    pt: 24,
    px: 32
  },
  {
    pt: 26,
    px: 34.7
  },
  {
    pt: 36,
    px: 48
  },
  {
    pt: 42,
    px: 56
  }
  // { pt: 54, px: 71.7 },
  // { pt: 63, px: 83.7 },
  // { pt: 72, px: 95.6 },
];
function getFontSizePxByPt(pt) {
  for (var i = 0; i < fontSizes.length; i += 1) {
    var fontSize = fontSizes[i];
    if (fontSize.pt === pt) {
      return fontSize.px;
    }
  }
  return pt;
}
var infixExprToSuffixExpr = function infixExprToSuffixExpr2(src) {
  var operatorStack = [];
  var stack = [];
  var subStrs = [];
  var fnArgType = 0;
  var fnArgOperator = "";
  var fnArgsLen = 1;
  var oldc = "";
  for (var i = 0; i < src.length; i += 1) {
    var c = src.charAt(i);
    if (c !== " ") {
      if (c >= "a" && c <= "z") {
        subStrs.push(c.toUpperCase());
      } else if (c >= "0" && c <= "9" || c >= "A" && c <= "Z" || c === ".") {
        subStrs.push(c);
      } else if (c === '"') {
        i += 1;
        while (src.charAt(i) !== '"') {
          subStrs.push(src.charAt(i));
          i += 1;
        }
        stack.push('"'.concat(subStrs.join("")));
        subStrs = [];
      } else if (c === "-" && /[+\-*/,(]/.test(oldc)) {
        subStrs.push(c);
      } else {
        if (c !== "(" && subStrs.length > 0) {
          stack.push(subStrs.join(""));
        }
        if (c === ")") {
          var c1 = operatorStack.pop();
          if (fnArgType === 2) {
            try {
              var _expr2xy = expr2xy(stack.pop()), _expr2xy2 = _slicedToArray(_expr2xy, 2), ex = _expr2xy2[0], ey = _expr2xy2[1];
              var _expr2xy3 = expr2xy(stack.pop()), _expr2xy4 = _slicedToArray(_expr2xy3, 2), sx = _expr2xy4[0], sy = _expr2xy4[1];
              var rangelen = 0;
              for (var x = sx; x <= ex; x += 1) {
                for (var y = sy; y <= ey; y += 1) {
                  stack.push(xy2expr(x, y));
                  rangelen += 1;
                }
              }
              stack.push([c1, rangelen]);
            } catch (e) {
            }
          } else if (fnArgType === 1 || fnArgType === 3) {
            if (fnArgType === 3)
              stack.push(fnArgOperator);
            stack.push([c1, fnArgsLen]);
            fnArgsLen = 1;
          } else {
            while (c1 !== "(") {
              stack.push(c1);
              if (operatorStack.length <= 0)
                break;
              c1 = operatorStack.pop();
            }
          }
          fnArgType = 0;
        } else if (c === "=" || c === ">" || c === "<") {
          var nc = src.charAt(i + 1);
          fnArgOperator = c;
          if (nc === "=" || nc === "-") {
            fnArgOperator += nc;
            i += 1;
          }
          fnArgType = 3;
        } else if (c === ":") {
          fnArgType = 2;
        } else if (c === ",") {
          if (fnArgType === 3) {
            stack.push(fnArgOperator);
          }
          fnArgType = 1;
          fnArgsLen += 1;
        } else if (c === "(" && subStrs.length > 0) {
          operatorStack.push(subStrs.join(""));
        } else {
          if (operatorStack.length > 0 && (c === "+" || c === "-")) {
            var top = operatorStack[operatorStack.length - 1];
            if (top !== "(")
              stack.push(operatorStack.pop());
            if (top === "*" || top === "/") {
              while (operatorStack.length > 0) {
                top = operatorStack[operatorStack.length - 1];
                if (top !== "(")
                  stack.push(operatorStack.pop());
                else
                  break;
              }
            }
          } else if (operatorStack.length > 0) {
            var _top = operatorStack[operatorStack.length - 1];
            if (_top === "*" || _top === "/")
              stack.push(operatorStack.pop());
          }
          operatorStack.push(c);
        }
        subStrs = [];
      }
      oldc = c;
    }
  }
  if (subStrs.length > 0) {
    stack.push(subStrs.join(""));
  }
  while (operatorStack.length > 0) {
    stack.push(operatorStack.pop());
  }
  return stack;
};
var evalSubExpr = function evalSubExpr2(subExpr, cellRender3) {
  var _subExpr = _slicedToArray(subExpr, 1), fl = _subExpr[0];
  var expr = subExpr;
  if (fl === '"') {
    return subExpr.substring(1);
  }
  var ret = 1;
  if (fl === "-") {
    expr = subExpr.substring(1);
    ret = -1;
  }
  if (expr[0] >= "0" && expr[0] <= "9") {
    return ret * Number(expr);
  }
  var _expr2xy5 = expr2xy(expr), _expr2xy6 = _slicedToArray(_expr2xy5, 2), x = _expr2xy6[0], y = _expr2xy6[1];
  return ret * cellRender3(x, y);
};
var evalSuffixExpr = function evalSuffixExpr2(srcStack, formulaMap, cellRender3, cellList) {
  var stack = [];
  for (var i = 0; i < srcStack.length; i += 1) {
    var expr = srcStack[i];
    var fc = expr[0];
    if (expr === "+") {
      var top = stack.pop();
      stack.push(numberCalc("+", stack.pop(), top));
    } else if (expr === "-") {
      if (stack.length === 1) {
        var _top2 = stack.pop();
        stack.push(numberCalc("*", _top2, -1));
      } else {
        var _top3 = stack.pop();
        stack.push(numberCalc("-", stack.pop(), _top3));
      }
    } else if (expr === "*") {
      stack.push(numberCalc("*", stack.pop(), stack.pop()));
    } else if (expr === "/") {
      var _top4 = stack.pop();
      stack.push(numberCalc("/", stack.pop(), _top4));
    } else if (fc === "=" || fc === ">" || fc === "<") {
      var _top5 = stack.pop();
      if (!Number.isNaN(_top5))
        _top5 = Number(_top5);
      var left = stack.pop();
      if (!Number.isNaN(left))
        left = Number(left);
      var ret = false;
      if (fc === "=") {
        ret = left === _top5;
      } else if (expr === ">") {
        ret = left > _top5;
      } else if (expr === ">=") {
        ret = left >= _top5;
      } else if (expr === "<") {
        ret = left < _top5;
      } else if (expr === "<=") {
        ret = left <= _top5;
      }
      stack.push(ret);
    } else if (Array.isArray(expr)) {
      var _expr = _slicedToArray(expr, 2), formula = _expr[0], len = _expr[1];
      var params = [];
      for (var j = 0; j < len; j += 1) {
        params.push(stack.pop());
      }
      stack.push(formulaMap[formula].render(params.reverse()));
    } else {
      if (cellList.includes(expr)) {
        return 0;
      }
      if (fc >= "a" && fc <= "z" || fc >= "A" && fc <= "Z") {
        cellList.push(expr);
      }
      stack.push(evalSubExpr(expr, cellRender3));
      cellList.pop();
    }
  }
  return stack[0];
};
var cellRender = function cellRender2(src, formulaMap, getCellText2) {
  var cellList = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  if (src[0] === "=") {
    var stack = infixExprToSuffixExpr(src.substring(1));
    if (stack.length <= 0)
      return src;
    return evalSuffixExpr(stack, formulaMap, function(x, y) {
      return cellRender2(getCellText2(x, y), formulaMap, getCellText2, cellList);
    }, cellList);
  }
  return src;
};
const _cell = {
  render: cellRender
};
var baseFormulas = [
  {
    key: "SUM",
    title: tf("formula.sum"),
    render: function render(ary) {
      return ary.reduce(function(a, b) {
        return numberCalc("+", a, b);
      }, 0);
    }
  },
  {
    key: "AVERAGE",
    title: tf("formula.average"),
    render: function render2(ary) {
      return ary.reduce(function(a, b) {
        return Number(a) + Number(b);
      }, 0) / ary.length;
    }
  },
  {
    key: "MAX",
    title: tf("formula.max"),
    render: function render3(ary) {
      return Math.max.apply(Math, _toConsumableArray(ary.map(function(v) {
        return Number(v);
      })));
    }
  },
  {
    key: "MIN",
    title: tf("formula.min"),
    render: function render4(ary) {
      return Math.min.apply(Math, _toConsumableArray(ary.map(function(v) {
        return Number(v);
      })));
    }
  },
  {
    key: "IF",
    title: tf("formula._if"),
    render: function render5(_ref) {
      var _ref2 = _slicedToArray(_ref, 3), b = _ref2[0], t2 = _ref2[1], f = _ref2[2];
      return b ? t2 : f;
    }
  },
  {
    key: "AND",
    title: tf("formula.and"),
    render: function render6(ary) {
      return ary.every(function(it) {
        return it;
      });
    }
  },
  {
    key: "OR",
    title: tf("formula.or"),
    render: function render7(ary) {
      return ary.some(function(it) {
        return it;
      });
    }
  },
  {
    key: "CONCAT",
    title: tf("formula.concat"),
    render: function render8(ary) {
      return ary.join("");
    }
  }
  /* support:  1 + A1 + B2 * 3
  {
    key: 'DIVIDE',
    title: tf('formula.divide'),
    render: ary => ary.reduce((a, b) => Number(a) / Number(b)),
  },
  {
    key: 'PRODUCT',
    title: tf('formula.product'),
    render: ary => ary.reduce((a, b) => Number(a) * Number(b),1),
  },
  {
    key: 'SUBTRACT',
    title: tf('formula.subtract'),
    render: ary => ary.reduce((a, b) => Number(a) - Number(b)),
  },
  */
];
var formulas = baseFormulas;
var formulam = {};
baseFormulas.forEach(function(f) {
  formulam[f.key] = f;
});
var formatStringRender = function formatStringRender2(v) {
  return v;
};
var formatNumberRender = function formatNumberRender2(v) {
  if (/^(-?\d*.?\d*)$/.test(v)) {
    var v1 = Number(v).toFixed(2).toString();
    var _v1$split = v1.split("\\."), _v1$split2 = _toArray(_v1$split), first = _v1$split2[0], parts = _v1$split2.slice(1);
    return [first.replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,")].concat(_toConsumableArray(parts));
  }
  return v;
};
var baseFormats = [{
  key: "normal",
  title: tf("format.normal"),
  type: "string",
  render: formatStringRender
}, {
  key: "text",
  title: tf("format.text"),
  type: "string",
  render: formatStringRender
}, {
  key: "number",
  title: tf("format.number"),
  type: "number",
  label: "1,000.12",
  render: formatNumberRender
}, {
  key: "percent",
  title: tf("format.percent"),
  type: "number",
  label: "10.12%",
  render: function render9(v) {
    return "".concat(v, "%");
  }
}, {
  key: "rmb",
  title: tf("format.rmb"),
  type: "number",
  label: "10.00",
  render: function render10(v) {
    return "".concat(formatNumberRender(v));
  }
}, {
  key: "usd",
  title: tf("format.usd"),
  type: "number",
  label: "$10.00",
  render: function render11(v) {
    return "$".concat(formatNumberRender(v));
  }
}, {
  key: "eur",
  title: tf("format.eur"),
  type: "number",
  label: "10.00",
  render: function render12(v) {
    return "".concat(formatNumberRender(v));
  }
}, {
  key: "date",
  title: tf("format.date"),
  type: "date",
  label: "26/09/2008",
  render: formatStringRender
}, {
  key: "time",
  title: tf("format.time"),
  type: "date",
  label: "15:59:00",
  render: formatStringRender
}, {
  key: "datetime",
  title: tf("format.datetime"),
  type: "date",
  label: "26/09/2008 15:59:00",
  render: formatStringRender
}, {
  key: "duration",
  title: tf("format.duration"),
  type: "date",
  label: "24:01:00",
  render: formatStringRender
}];
var formatm = {};
baseFormats.forEach(function(f) {
  formatm[f.key] = f;
});
var cellPaddingWidth = 5;
var tableFixedHeaderCleanStyle = {
  fillStyle: "#f4f5f8"
};
var tableGridStyle = {
  fillStyle: "#fff",
  lineWidth: thinLineWidth,
  strokeStyle: "#e6e6e6"
};
function tableFixedHeaderStyle() {
  return {
    textAlign: "center",
    textBaseline: "middle",
    font: "500 ".concat(npx(12), "px Source Sans Pro"),
    fillStyle: "#585757",
    lineWidth: thinLineWidth(),
    strokeStyle: "#e6e6e6"
  };
}
function getDrawBox(data, rindex, cindex) {
  var yoffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  var _data$cellRect = data.cellRect(rindex, cindex), left = _data$cellRect.left, top = _data$cellRect.top, width2 = _data$cellRect.width, height2 = _data$cellRect.height;
  return new DrawBox(left, top + yoffset, width2, height2, cellPaddingWidth);
}
function renderCell(draw, data, rindex, cindex) {
  var yoffset = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  var sortedRowMap = data.sortedRowMap, rows = data.rows, cols = data.cols;
  if (rows.isHide(rindex) || cols.isHide(cindex))
    return;
  var nrindex = rindex;
  if (sortedRowMap.has(rindex)) {
    nrindex = sortedRowMap.get(rindex);
  }
  var cell = data.getCell(nrindex, cindex);
  if (cell === null)
    return;
  var frozen = false;
  if ("editable" in cell && cell.editable === false) {
    frozen = true;
  }
  var style = data.getCellStyleOrDefault(nrindex, cindex);
  var dbox = getDrawBox(data, rindex, cindex, yoffset);
  dbox.bgcolor = style.bgcolor;
  if (style.border !== void 0) {
    dbox.setBorders(style.border);
    draw.strokeBorders(dbox);
  }
  draw.rect(dbox, function() {
    var cellText = "";
    if (!data.settings.evalPaused) {
      cellText = _cell.render(cell.text || "", formulam, function(y, x) {
        return data.getCellTextOrDefault(x, y);
      });
    } else {
      cellText = cell.text || "";
    }
    if (style.format) {
      cellText = formatm[style.format].render(cellText);
    }
    var font = Object.assign({}, style.font);
    font.size = getFontSizePxByPt(font.size);
    draw.text(cellText, dbox, {
      align: style.align,
      valign: style.valign,
      font,
      color: style.color,
      strike: style.strike,
      underline: style.underline
    }, style.textwrap);
    var error = data.validations.getError(rindex, cindex);
    if (error) {
      draw.error(dbox);
    }
    if (frozen) {
      draw.frozen(dbox);
    }
  });
}
function renderAutofilter(viewRange) {
  var data = this.data, draw = this.draw;
  if (viewRange) {
    var autoFilter = data.autoFilter;
    if (!autoFilter.active())
      return;
    var afRange = autoFilter.hrange();
    if (viewRange.intersects(afRange)) {
      afRange.each(function(ri, ci) {
        var dbox = getDrawBox(data, ri, ci);
        draw.dropdown(dbox);
      });
    }
  }
}
function renderContent(viewRange, fw, fh, tx, ty) {
  var draw = this.draw, data = this.data;
  draw.save();
  draw.translate(fw, fh).translate(tx, ty);
  var exceptRowSet = data.exceptRowSet;
  var filteredTranslateFunc = function filteredTranslateFunc2(ri) {
    var ret = exceptRowSet.has(ri);
    if (ret) {
      var height2 = data.rows.getHeight(ri);
      draw.translate(0, -height2);
    }
    return !ret;
  };
  var exceptRowTotalHeight = data.exceptRowTotalHeight(viewRange.sri, viewRange.eri);
  draw.save();
  draw.translate(0, -exceptRowTotalHeight);
  viewRange.each(function(ri, ci) {
    renderCell(draw, data, ri, ci);
  }, function(ri) {
    return filteredTranslateFunc(ri);
  });
  draw.restore();
  var rset = /* @__PURE__ */ new Set();
  draw.save();
  draw.translate(0, -exceptRowTotalHeight);
  data.eachMergesInView(viewRange, function(_ref) {
    var sri = _ref.sri, sci = _ref.sci, eri = _ref.eri;
    if (!exceptRowSet.has(sri)) {
      renderCell(draw, data, sri, sci);
    } else if (!rset.has(sri)) {
      rset.add(sri);
      var height2 = data.rows.sumHeight(sri, eri + 1);
      draw.translate(0, -height2);
    }
  });
  draw.restore();
  renderAutofilter.call(this, viewRange);
  draw.restore();
}
function renderSelectedHeaderCell(x, y, w, h3) {
  var draw = this.draw;
  draw.save();
  draw.attr({
    fillStyle: "rgba(75, 137, 255, 0.08)"
  }).fillRect(x, y, w, h3);
  draw.restore();
}
function renderFixedHeaders(type, viewRange, w, h3, tx, ty) {
  var _this = this;
  var draw = this.draw, data = this.data;
  var sumHeight = viewRange.h;
  var sumWidth = viewRange.w;
  var nty = ty + h3;
  var ntx = tx + w;
  draw.save();
  draw.attr(tableFixedHeaderCleanStyle);
  if (type === "all" || type === "left")
    draw.fillRect(0, nty, w, sumHeight);
  if (type === "all" || type === "top")
    draw.fillRect(ntx, 0, sumWidth, h3);
  var _data$selector$range = data.selector.range, sri = _data$selector$range.sri, sci = _data$selector$range.sci, eri = _data$selector$range.eri, eci = _data$selector$range.eci;
  draw.attr(tableFixedHeaderStyle());
  if (type === "all" || type === "left") {
    data.rowEach(viewRange.sri, viewRange.eri, function(i, y1, rowHeight) {
      var y = nty + y1;
      var ii = i;
      draw.line([0, y], [w, y]);
      if (sri <= ii && ii < eri + 1) {
        renderSelectedHeaderCell.call(_this, 0, y, w, rowHeight);
      }
      draw.fillText(ii + 1, w / 2, y + rowHeight / 2);
      if (i > 0 && data.rows.isHide(i - 1)) {
        draw.save();
        draw.attr({
          strokeStyle: "#c6c6c6"
        });
        draw.line([5, y + 5], [w - 5, y + 5]);
        draw.restore();
      }
    });
    draw.line([0, sumHeight + nty], [w, sumHeight + nty]);
    draw.line([w, nty], [w, sumHeight + nty]);
  }
  if (type === "all" || type === "top") {
    data.colEach(viewRange.sci, viewRange.eci, function(i, x1, colWidth) {
      var x = ntx + x1;
      var ii = i;
      draw.line([x, 0], [x, h3]);
      if (sci <= ii && ii < eci + 1) {
        renderSelectedHeaderCell.call(_this, x, 0, colWidth, h3);
      }
      draw.fillText(stringAt(ii), x + colWidth / 2, h3 / 2);
      if (i > 0 && data.cols.isHide(i - 1)) {
        draw.save();
        draw.attr({
          strokeStyle: "#c6c6c6"
        });
        draw.line([x + 5, 5], [x + 5, h3 - 5]);
        draw.restore();
      }
    });
    draw.line([sumWidth + ntx, 0], [sumWidth + ntx, h3]);
    draw.line([0, h3], [sumWidth + ntx, h3]);
  }
  draw.restore();
}
function renderFixedLeftTopCell(fw, fh) {
  var draw = this.draw;
  draw.save();
  draw.attr({
    fillStyle: "#f4f5f8"
  }).fillRect(0, 0, fw, fh);
  draw.restore();
}
function renderContentGrid(_ref2, fw, fh, tx, ty) {
  var sri = _ref2.sri, sci = _ref2.sci, eri = _ref2.eri, eci = _ref2.eci, w = _ref2.w, h3 = _ref2.h;
  var draw = this.draw, data = this.data;
  var settings = data.settings;
  draw.save();
  draw.attr(tableGridStyle).translate(fw + tx, fh + ty);
  if (!settings.showGrid) {
    draw.restore();
    return;
  }
  data.rowEach(sri, eri, function(i, y, ch) {
    if (i !== sri)
      draw.line([0, y], [w, y]);
    if (i === eri)
      draw.line([0, y + ch], [w, y + ch]);
  });
  data.colEach(sci, eci, function(i, x, cw) {
    if (i !== sci)
      draw.line([x, 0], [x, h3]);
    if (i === eci)
      draw.line([x + cw, 0], [x + cw, h3]);
  });
  draw.restore();
}
function renderFreezeHighlightLine(fw, fh, ftw, fth) {
  var draw = this.draw, data = this.data;
  var twidth = data.viewWidth() - fw;
  var theight = data.viewHeight() - fh;
  draw.save().translate(fw, fh).attr({
    strokeStyle: "rgba(75, 137, 255, .6)"
  });
  draw.line([0, fth], [twidth, fth]);
  draw.line([ftw, 0], [ftw, theight]);
  draw.restore();
}
var Table = /* @__PURE__ */ function() {
  function Table2(el, data) {
    _classCallCheck(this, Table2);
    this.el = el;
    this.draw = new Draw(el, data.viewWidth(), data.viewHeight());
    this.data = data;
  }
  _createClass(Table2, [{
    key: "resetData",
    value: function resetData(data) {
      this.data = data;
      this.render();
    }
  }, {
    key: "render",
    value: function render15() {
      var data = this.data;
      var rows = data.rows, cols = data.cols;
      var fw = cols.indexWidth;
      var fh = rows.height;
      this.draw.resize(data.viewWidth(), data.viewHeight());
      this.clear();
      var viewRange = data.viewRange();
      var tx = data.freezeTotalWidth();
      var ty = data.freezeTotalHeight();
      var _data$scroll = data.scroll, x = _data$scroll.x, y = _data$scroll.y;
      renderContentGrid.call(this, viewRange, fw, fh, tx, ty);
      renderContent.call(this, viewRange, fw, fh, -x, -y);
      renderFixedHeaders.call(this, "all", viewRange, fw, fh, tx, ty);
      renderFixedLeftTopCell.call(this, fw, fh);
      var _data$freeze = _slicedToArray(data.freeze, 2), fri = _data$freeze[0], fci = _data$freeze[1];
      if (fri > 0 || fci > 0) {
        if (fri > 0) {
          var vr = viewRange.clone();
          vr.sri = 0;
          vr.eri = fri - 1;
          vr.h = ty;
          renderContentGrid.call(this, vr, fw, fh, tx, 0);
          renderContent.call(this, vr, fw, fh, -x, 0);
          renderFixedHeaders.call(this, "top", vr, fw, fh, tx, 0);
        }
        if (fci > 0) {
          var _vr = viewRange.clone();
          _vr.sci = 0;
          _vr.eci = fci - 1;
          _vr.w = tx;
          renderContentGrid.call(this, _vr, fw, fh, 0, ty);
          renderFixedHeaders.call(this, "left", _vr, fw, fh, 0, ty);
          renderContent.call(this, _vr, fw, fh, 0, -y);
        }
        var freezeViewRange = data.freezeViewRange();
        renderContentGrid.call(this, freezeViewRange, fw, fh, 0, 0);
        renderFixedHeaders.call(this, "all", freezeViewRange, fw, fh, 0, 0);
        renderContent.call(this, freezeViewRange, fw, fh, 0, 0);
        renderFreezeHighlightLine.call(this, fw, fh, tx, ty);
      }
    }
  }, {
    key: "clear",
    value: function clear() {
      this.draw.clear();
    }
  }]);
  return Table2;
}();
var PAGER_SIZES = [["A3", 11.69, 16.54], ["A4", 8.27, 11.69], ["A5", 5.83, 8.27], ["B4", 9.84, 13.9], ["B5", 6.93, 9.84]];
var PAGER_ORIENTATIONS = ["landscape", "portrait"];
function inches2px(inc) {
  return parseInt(96 * inc, 10);
}
function btnClick(type) {
  if (type === "cancel") {
    this.el.hide();
  } else {
    this.toPrint();
  }
}
function pagerSizeChange(evt) {
  var paper = this.paper;
  var value = evt.target.value;
  var ps = PAGER_SIZES[value];
  paper.w = inches2px(ps[1]);
  paper.h = inches2px(ps[2]);
  this.preview();
}
function pagerOrientationChange(evt) {
  var paper = this.paper;
  var value = evt.target.value;
  var v = PAGER_ORIENTATIONS[value];
  paper.orientation = v;
  this.preview();
}
var Print$1 = /* @__PURE__ */ function() {
  function Print2(data) {
    var _h, _h2;
    _classCallCheck(this, Print2);
    this.paper = {
      w: inches2px(PAGER_SIZES[0][1]),
      h: inches2px(PAGER_SIZES[0][2]),
      padding: 50,
      orientation: PAGER_ORIENTATIONS[0],
      get width() {
        return this.orientation === "landscape" ? this.h : this.w;
      },
      get height() {
        return this.orientation === "landscape" ? this.w : this.h;
      }
    };
    this.data = data;
    this.el = h("div", "".concat(cssPrefix, "-print")).children(h("div", "".concat(cssPrefix, "-print-bar")).children(h("div", "-title").child("Print settings"), h("div", "-right").children(h("div", "".concat(cssPrefix, "-buttons")).children(new Button("cancel").on("click", btnClick.bind(this, "cancel")), new Button("next", "primary").on("click", btnClick.bind(this, "next"))))), h("div", "".concat(cssPrefix, "-print-content")).children(this.contentEl = h("div", "-content"), h("div", "-sider").child(h("form", "").children(h("fieldset", "").children(h("label", "").child("".concat(t("print.size"))), (_h = h("select", "")).children.apply(_h, _toConsumableArray(PAGER_SIZES.map(function(it, index2) {
      return h("option", "").attr("value", index2).child("".concat(it[0], " ( ").concat(it[1], "''x").concat(it[2], "'' )"));
    }))).on("change", pagerSizeChange.bind(this))), h("fieldset", "").children(h("label", "").child("".concat(t("print.orientation"))), (_h2 = h("select", "")).children.apply(_h2, _toConsumableArray(PAGER_ORIENTATIONS.map(function(it, index2) {
      return h("option", "").attr("value", index2).child("".concat(t("print.orientations")[index2]));
    }))).on("change", pagerOrientationChange.bind(this))))))).hide();
  }
  _createClass(Print2, [{
    key: "resetData",
    value: function resetData(data) {
      this.data = data;
    }
  }, {
    key: "preview",
    value: function preview() {
      var _this = this;
      var data = this.data, paper = this.paper;
      var width2 = paper.width, height2 = paper.height, padding = paper.padding;
      var iwidth = width2 - padding * 2;
      var iheight = height2 - padding * 2;
      var cr = data.contentRange();
      var pages = parseInt(cr.h / iheight, 10) + 1;
      var scale = iwidth / cr.w;
      var left = padding;
      var top = padding;
      if (scale > 1) {
        left += (iwidth - cr.w) / 2;
      }
      var ri = 0;
      var yoffset = 0;
      this.contentEl.html("");
      this.canvases = [];
      var mViewRange = {
        sri: 0,
        sci: 0,
        eri: 0,
        eci: 0
      };
      var _loop = function _loop2() {
        var th = 0;
        var yo = 0;
        var wrap = h("div", "".concat(cssPrefix, "-canvas-card"));
        var canvas = h("canvas", "".concat(cssPrefix, "-canvas"));
        _this.canvases.push(canvas.el);
        var draw = new Draw(canvas.el, width2, height2);
        draw.save();
        draw.translate(left, top);
        if (scale < 1)
          draw.scale(scale, scale);
        for (; ri <= cr.eri; ri += 1) {
          var rh = data.rows.getHeight(ri);
          th += rh;
          if (th < iheight) {
            for (var ci = 0; ci <= cr.eci; ci += 1) {
              renderCell(draw, data, ri, ci, yoffset);
              mViewRange.eci = ci;
            }
          } else {
            yo = -(th - rh);
            break;
          }
        }
        mViewRange.eri = ri;
        draw.restore();
        draw.save();
        draw.translate(left, top);
        if (scale < 1)
          draw.scale(scale, scale);
        var yof = yoffset;
        data.eachMergesInView(mViewRange, function(_ref) {
          var sri = _ref.sri, sci = _ref.sci;
          renderCell(draw, data, sri, sci, yof);
        });
        draw.restore();
        mViewRange.sri = mViewRange.eri;
        mViewRange.sci = mViewRange.eci;
        yoffset += yo;
        _this.contentEl.child(h("div", "".concat(cssPrefix, "-canvas-card-wraper")).child(wrap.child(canvas)));
      };
      for (var i = 0; i < pages; i += 1) {
        _loop();
      }
      this.el.show();
    }
  }, {
    key: "toPrint",
    value: function toPrint() {
      this.el.hide();
      var paper = this.paper;
      var iframe = h("iframe", "").hide();
      var el = iframe.el;
      window.document.body.appendChild(el);
      var contentWindow = el.contentWindow;
      var idoc = contentWindow.document;
      var style = document.createElement("style");
      style.innerHTML = "\n      @page { size: ".concat(paper.width, "px ").concat(paper.height, "px; };\n      canvas {\n        page-break-before: auto;        \n        page-break-after: always;\n        image-rendering: pixelated;\n      };\n    ");
      idoc.head.appendChild(style);
      this.canvases.forEach(function(it) {
        var cn = it.cloneNode(false);
        var ctx = cn.getContext("2d");
        ctx.drawImage(it, 0, 0);
        idoc.body.appendChild(cn);
      });
      contentWindow.print();
    }
  }]);
  return Print2;
}();
var menuItems$1 = [{
  key: "copy",
  title: tf("contextmenu.copy"),
  label: "Ctrl+C"
}, {
  key: "cut",
  title: tf("contextmenu.cut"),
  label: "Ctrl+X"
}, {
  key: "paste",
  title: tf("contextmenu.paste"),
  label: "Ctrl+V"
}, {
  key: "paste-value",
  title: tf("contextmenu.pasteValue"),
  label: "Ctrl+Shift+V"
}, {
  key: "paste-format",
  title: tf("contextmenu.pasteFormat"),
  label: "Ctrl+Alt+V"
}, {
  key: "divider"
}, {
  key: "insert-row",
  title: tf("contextmenu.insertRow")
}, {
  key: "insert-column",
  title: tf("contextmenu.insertColumn")
}, {
  key: "divider"
}, {
  key: "delete-row",
  title: tf("contextmenu.deleteRow")
}, {
  key: "delete-column",
  title: tf("contextmenu.deleteColumn")
}, {
  key: "delete-cell-text",
  title: tf("contextmenu.deleteCellText")
}, {
  key: "hide",
  title: tf("contextmenu.hide")
}, {
  key: "divider"
}, {
  key: "validation",
  title: tf("contextmenu.validation")
}, {
  key: "divider"
}, {
  key: "cell-printable",
  title: tf("contextmenu.cellprintable")
}, {
  key: "cell-non-printable",
  title: tf("contextmenu.cellnonprintable")
}, {
  key: "divider"
}, {
  key: "cell-editable",
  title: tf("contextmenu.celleditable")
}, {
  key: "cell-non-editable",
  title: tf("contextmenu.cellnoneditable")
}];
function buildMenuItem$1(item) {
  var _this = this;
  if (item.key === "divider") {
    return h("div", "".concat(cssPrefix, "-item divider"));
  }
  return h("div", "".concat(cssPrefix, "-item")).on("click", function() {
    _this.itemClick(item.key);
    _this.hide();
  }).children(item.title(), h("div", "label").child(item.label || ""));
}
function buildMenu$2() {
  var _this2 = this;
  return menuItems$1.map(function(it) {
    return buildMenuItem$1.call(_this2, it);
  });
}
var ContextMenu$1 = /* @__PURE__ */ function() {
  function ContextMenu2(viewFn) {
    var _h;
    var isHide = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    _classCallCheck(this, ContextMenu2);
    this.menuItems = buildMenu$2.call(this);
    this.el = (_h = h("div", "".concat(cssPrefix, "-contextmenu"))).children.apply(_h, _toConsumableArray(this.menuItems)).hide();
    this.viewFn = viewFn;
    this.itemClick = function() {
    };
    this.isHide = isHide;
    this.setMode("range");
  }
  _createClass(ContextMenu2, [{
    key: "setMode",
    value: function setMode(mode) {
      var hideEl = this.menuItems[12];
      if (mode === "row-col") {
        hideEl.show();
      } else {
        hideEl.hide();
      }
    }
  }, {
    key: "hide",
    value: function hide() {
      var el = this.el;
      el.hide();
      unbindClickoutside(el);
    }
  }, {
    key: "setPosition",
    value: function setPosition(x, y) {
      if (this.isHide)
        return;
      var el = this.el;
      var _el$show$offset = el.show().offset(), width2 = _el$show$offset.width;
      var view = this.viewFn();
      var vhf = view.height / 2;
      var left = x;
      if (view.width - x <= width2) {
        left -= width2;
      }
      el.css("left", "".concat(left, "px"));
      if (y > vhf) {
        el.css("bottom", "".concat(view.height - y, "px")).css("max-height", "".concat(y, "px")).css("top", "auto");
      } else {
        el.css("top", "".concat(y, "px")).css("max-height", "".concat(view.height - y, "px")).css("bottom", "auto");
      }
      bindClickoutside(el);
    }
  }]);
  return ContextMenu2;
}();
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get.bind();
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
function tooltip(html, target) {
  if (target.classList.contains("active")) {
    return;
  }
  var _target$getBoundingCl = target.getBoundingClientRect(), left = _target$getBoundingCl.left, top = _target$getBoundingCl.top, width2 = _target$getBoundingCl.width, height2 = _target$getBoundingCl.height;
  var el = h("div", "".concat(cssPrefix, "-tooltip")).html(html).show();
  document.body.appendChild(el.el);
  var elBox = el.box();
  el.css("left", "".concat(left + width2 / 2 - elBox.width / 2, "px")).css("top", "".concat(top + height2 + 2, "px"));
  bind(target, "mouseleave", function() {
    if (document.body.contains(el.el)) {
      document.body.removeChild(el.el);
    }
  });
  bind(target, "click", function() {
    if (document.body.contains(el.el)) {
      document.body.removeChild(el.el);
    }
  });
}
var Item = /* @__PURE__ */ function() {
  function Item2(tag, shortcut, value) {
    _classCallCheck(this, Item2);
    this.tip = t("toolbar.".concat(tag.replace(/-[a-z]/g, function(c) {
      return c[1].toUpperCase();
    })));
    if (shortcut)
      this.tip += " (".concat(shortcut, ")");
    this.tag = tag;
    this.shortcut = shortcut;
    this.value = value;
    this.el = this.element();
    this.change = function() {
    };
  }
  _createClass(Item2, [{
    key: "element",
    value: function element() {
      var tip = this.tip;
      return h("div", "".concat(cssPrefix, "-toolbar-btn")).on("mouseenter", function(evt) {
        tooltip(tip, evt.target);
      }).attr("data-tooltip", tip);
    }
  }, {
    key: "setState",
    value: function setState() {
    }
  }]);
  return Item2;
}();
function _createSuper$A(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$A();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$A() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownItem = /* @__PURE__ */ function(_Item) {
  _inherits(DropdownItem2, _Item);
  var _super = _createSuper$A(DropdownItem2);
  function DropdownItem2() {
    _classCallCheck(this, DropdownItem2);
    return _super.apply(this, arguments);
  }
  _createClass(DropdownItem2, [{
    key: "dropdown",
    value: function dropdown() {
    }
  }, {
    key: "getValue",
    value: function getValue(v) {
      return v;
    }
  }, {
    key: "element",
    value: function element() {
      var _this = this;
      var tag = this.tag;
      this.dd = this.dropdown();
      this.dd.change = function(it) {
        return _this.change(tag, _this.getValue(it));
      };
      return _get(_getPrototypeOf(DropdownItem2.prototype), "element", this).call(this).child(this.dd);
    }
  }, {
    key: "setState",
    value: function setState(v) {
      if (v) {
        this.value = v;
        this.dd.setTitle(v);
      }
    }
  }]);
  return DropdownItem2;
}(Item);
function _createSuper$z(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$z();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$z() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Dropdown = /* @__PURE__ */ function(_Element) {
  _inherits(Dropdown2, _Element);
  var _super = _createSuper$z(Dropdown2);
  function Dropdown2(title, width2, showArrow, placement) {
    var _this2;
    var _this;
    _classCallCheck(this, Dropdown2);
    _this = _super.call(this, "div", "".concat(cssPrefix, "-dropdown ").concat(placement));
    _this.title = title;
    _this.change = function() {
    };
    _this.headerClick = function() {
    };
    if (typeof title === "string") {
      _this.title = h("div", "".concat(cssPrefix, "-dropdown-title")).child(title);
    } else if (showArrow) {
      _this.title.addClass("arrow-left");
    }
    _this.contentEl = h("div", "".concat(cssPrefix, "-dropdown-content")).css("width", width2).hide();
    for (var _len = arguments.length, children = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {
      children[_key - 4] = arguments[_key];
    }
    (_this2 = _this).setContentChildren.apply(_this2, children);
    _this.headerEl = h("div", "".concat(cssPrefix, "-dropdown-header"));
    _this.headerEl.on("click", function() {
      if (_this.contentEl.css("display") !== "block") {
        _this.show();
      } else {
        _this.hide();
      }
    }).children(_this.title, showArrow ? h("div", "".concat(cssPrefix, "-icon arrow-right")).child(h("div", "".concat(cssPrefix, "-icon-img arrow-down"))) : "");
    _this.children(_this.headerEl, _this.contentEl);
    return _this;
  }
  _createClass(Dropdown2, [{
    key: "setContentChildren",
    value: function setContentChildren() {
      this.contentEl.html("");
      if (arguments.length > 0) {
        var _this$contentEl;
        (_this$contentEl = this.contentEl).children.apply(_this$contentEl, arguments);
      }
    }
  }, {
    key: "setTitle",
    value: function setTitle(title) {
      this.title.html(title);
      this.hide();
    }
  }, {
    key: "show",
    value: function show() {
      var _this3 = this;
      var contentEl = this.contentEl;
      contentEl.show();
      this.parent().active();
      bindClickoutside(this.parent(), function() {
        _this3.hide();
      });
    }
  }, {
    key: "hide",
    value: function hide() {
      this.parent().active(false);
      this.contentEl.hide();
      unbindClickoutside(this.parent());
    }
  }]);
  return Dropdown2;
}(Element);
function _createSuper$y(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$y();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$y() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function buildItemWithIcon(iconName) {
  return h("div", "".concat(cssPrefix, "-item")).child(new Icon(iconName));
}
var DropdownAlign = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownAlign2, _Dropdown);
  var _super = _createSuper$y(DropdownAlign2);
  function DropdownAlign2(aligns, align) {
    var _this;
    _classCallCheck(this, DropdownAlign2);
    var icon = new Icon("align-".concat(align));
    var naligns = aligns.map(function(it) {
      return buildItemWithIcon("align-".concat(it)).on("click", function() {
        _this.setTitle(it);
        _this.change(it);
      });
    });
    return _this = _super.call.apply(_super, [this, icon, "auto", true, "bottom-left"].concat(_toConsumableArray(naligns)));
  }
  _createClass(DropdownAlign2, [{
    key: "setTitle",
    value: function setTitle(align) {
      this.title.setName("align-".concat(align));
      this.hide();
    }
  }]);
  return DropdownAlign2;
}(Dropdown);
function _createSuper$x(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$x();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$x() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Align = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Align2, _DropdownItem);
  var _super = _createSuper$x(Align2);
  function Align2(value) {
    _classCallCheck(this, Align2);
    return _super.call(this, "align", "", value);
  }
  _createClass(Align2, [{
    key: "dropdown",
    value: function dropdown() {
      var value = this.value;
      return new DropdownAlign(["left", "center", "right"], value);
    }
  }]);
  return Align2;
}(DropdownItem);
function _createSuper$w(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$w();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$w() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Valign = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Valign2, _DropdownItem);
  var _super = _createSuper$w(Valign2);
  function Valign2(value) {
    _classCallCheck(this, Valign2);
    return _super.call(this, "valign", "", value);
  }
  _createClass(Valign2, [{
    key: "dropdown",
    value: function dropdown() {
      var value = this.value;
      return new DropdownAlign(["top", "middle", "bottom"], value);
    }
  }]);
  return Valign2;
}(DropdownItem);
function _createSuper$v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$v() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var ToggleItem = /* @__PURE__ */ function(_Item) {
  _inherits(ToggleItem2, _Item);
  var _super = _createSuper$v(ToggleItem2);
  function ToggleItem2() {
    _classCallCheck(this, ToggleItem2);
    return _super.apply(this, arguments);
  }
  _createClass(ToggleItem2, [{
    key: "element",
    value: function element() {
      var _this = this;
      var tag = this.tag;
      return _get(_getPrototypeOf(ToggleItem2.prototype), "element", this).call(this).child(new Icon(tag)).on("click", function() {
        return _this.click();
      });
    }
  }, {
    key: "click",
    value: function click() {
      this.change(this.tag, this.toggle());
    }
  }, {
    key: "setState",
    value: function setState(active) {
      this.el.active(active);
    }
  }, {
    key: "toggle",
    value: function toggle() {
      return this.el.toggle();
    }
  }, {
    key: "active",
    value: function active() {
      return this.el.hasClass("active");
    }
  }]);
  return ToggleItem2;
}(Item);
function _createSuper$u(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$u() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Autofilter = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Autofilter2, _ToggleItem);
  var _super = _createSuper$u(Autofilter2);
  function Autofilter2() {
    _classCallCheck(this, Autofilter2);
    return _super.call(this, "autofilter");
  }
  _createClass(Autofilter2, [{
    key: "setState",
    value: function setState() {
    }
  }]);
  return Autofilter2;
}(ToggleItem);
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Bold = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Bold2, _ToggleItem);
  var _super = _createSuper$t(Bold2);
  function Bold2() {
    _classCallCheck(this, Bold2);
    return _super.call(this, "font-bold", "Ctrl+B");
  }
  return _createClass(Bold2);
}(ToggleItem);
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Italic = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Italic2, _ToggleItem);
  var _super = _createSuper$s(Italic2);
  function Italic2() {
    _classCallCheck(this, Italic2);
    return _super.call(this, "font-italic", "Ctrl+I");
  }
  return _createClass(Italic2);
}(ToggleItem);
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Strike = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Strike2, _ToggleItem);
  var _super = _createSuper$r(Strike2);
  function Strike2() {
    _classCallCheck(this, Strike2);
    return _super.call(this, "strike", "Ctrl+U");
  }
  return _createClass(Strike2);
}(ToggleItem);
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Underline = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Underline2, _ToggleItem);
  var _super = _createSuper$q(Underline2);
  function Underline2() {
    _classCallCheck(this, Underline2);
    return _super.call(this, "underline", "Ctrl+U");
  }
  return _createClass(Underline2);
}(ToggleItem);
var themeColorPlaceHolders = ["#ffffff", "#000100", "#e7e5e6", "#445569", "#5b9cd6", "#ed7d31", "#a5a5a5", "#ffc001", "#4371c6", "#71ae47"];
var themeColors = [["#f2f2f2", "#7f7f7f", "#d0cecf", "#d5dce4", "#deeaf6", "#fce5d5", "#ededed", "#fff2cd", "#d9e2f3", "#e3efd9"], ["#d8d8d8", "#595959", "#afabac", "#adb8ca", "#bdd7ee", "#f7ccac", "#dbdbdb", "#ffe59a", "#b3c6e7", "#c5e0b3"], ["#bfbfbf", "#3f3f3f", "#756f6f", "#8596b0", "#9cc2e6", "#f4b184", "#c9c9c9", "#fed964", "#8eaada", "#a7d08c"], ["#a5a5a5", "#262626", "#3a3839", "#333f4f", "#2e75b5", "#c45a10", "#7b7b7b", "#bf8e01", "#2f5596", "#538136"], ["#7f7f7f", "#0c0c0c", "#171516", "#222a35", "#1f4e7a", "#843c0a", "#525252", "#7e6000", "#203864", "#365624"]];
var standardColors = ["#c00000", "#fe0000", "#fdc101", "#ffff01", "#93d051", "#00b04e", "#01b0f1", "#0170c1", "#012060", "#7030a0"];
function buildTd$1(bgcolor) {
  var _this = this;
  return h("td", "").child(h("div", "".concat(cssPrefix, "-color-palette-cell")).on("click.stop", function() {
    return _this.change(bgcolor);
  }).css("background-color", bgcolor));
}
var ColorPalette = /* @__PURE__ */ _createClass(function ColorPalette2() {
  var _h, _h2, _this2 = this, _h4;
  _classCallCheck(this, ColorPalette2);
  this.el = h("div", "".concat(cssPrefix, "-color-palette"));
  this.change = function() {
  };
  var table = h("table", "").children((_h = h("tbody", "")).children.apply(_h, [(_h2 = h("tr", "".concat(cssPrefix, "-theme-color-placeholders"))).children.apply(_h2, _toConsumableArray(themeColorPlaceHolders.map(function(color) {
    return buildTd$1.call(_this2, color);
  })))].concat(_toConsumableArray(themeColors.map(function(it) {
    var _h3;
    return (_h3 = h("tr", "".concat(cssPrefix, "-theme-colors"))).children.apply(_h3, _toConsumableArray(it.map(function(color) {
      return buildTd$1.call(_this2, color);
    })));
  })), [(_h4 = h("tr", "".concat(cssPrefix, "-standard-colors"))).children.apply(_h4, _toConsumableArray(standardColors.map(function(color) {
    return buildTd$1.call(_this2, color);
  })))])));
  this.el.child(table);
});
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownColor = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownColor2, _Dropdown);
  var _super = _createSuper$p(DropdownColor2);
  function DropdownColor2(iconName, color) {
    var _this;
    _classCallCheck(this, DropdownColor2);
    var icon = new Icon(iconName).css("height", "16px").css("border-bottom", "3px solid ".concat(color));
    var colorPalette = new ColorPalette();
    colorPalette.change = function(v) {
      _this.setTitle(v);
      _this.change(v);
    };
    return _this = _super.call(this, icon, "auto", false, "bottom-left", colorPalette.el);
  }
  _createClass(DropdownColor2, [{
    key: "setTitle",
    value: function setTitle(color) {
      this.title.css("border-color", color);
      this.hide();
    }
  }]);
  return DropdownColor2;
}(Dropdown);
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var lineTypes = [
  ["thin", '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="1" style="user-select: none;"><line x1="0" y1="0.5" x2="50" y2="0.5" stroke-width="1" stroke="black" style="user-select: none;"></line></svg>'],
  ["medium", '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="2" style="user-select: none;"><line x1="0" y1="1.0" x2="50" y2="1.0" stroke-width="2" stroke="black" style="user-select: none;"></line></svg>'],
  ["thick", '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="3" style="user-select: none;"><line x1="0" y1="1.5" x2="50" y2="1.5" stroke-width="3" stroke="black" style="user-select: none;"></line></svg>'],
  ["dashed", '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="1" style="user-select: none;"><line x1="0" y1="0.5" x2="50" y2="0.5" stroke-width="1" stroke="black" stroke-dasharray="2" style="user-select: none;"></line></svg>'],
  ["dotted", '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="1" style="user-select: none;"><line x1="0" y1="0.5" x2="50" y2="0.5" stroke-width="1" stroke="black" stroke-dasharray="1" style="user-select: none;"></line></svg>']
  // ['double', '<svg xmlns="http://www.w3.org/2000/svg" width="50" height="3" style="user-select: none;"><line x1="0" y1="0.5" x2="50" y2="0.5" stroke-width="1" stroke="black" style="user-select: none;"></line><line x1="0" y1="2.5" x2="50" y2="2.5" stroke-width="1" stroke="black" style="user-select: none;"></line></svg>'],
];
var DropdownLineType = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownLineType2, _Dropdown);
  var _super = _createSuper$o(DropdownLineType2);
  function DropdownLineType2(type) {
    var _this;
    _classCallCheck(this, DropdownLineType2);
    var icon = new Icon("line-type");
    var beforei = 0;
    var lineTypeEls = lineTypes.map(function(it, iti) {
      return h("div", "".concat(cssPrefix, "-item state ").concat(type === it[0] ? "checked" : "")).on("click", function() {
        lineTypeEls[beforei].toggle("checked");
        lineTypeEls[iti].toggle("checked");
        beforei = iti;
        _this.hide();
        _this.change(it);
      }).child(h("div", "".concat(cssPrefix, "-line-type")).html(it[1]));
    });
    return _this = _super.call.apply(_super, [this, icon, "auto", false, "bottom-left"].concat(_toConsumableArray(lineTypeEls)));
  }
  return _createClass(DropdownLineType2);
}(Dropdown);
function buildTable() {
  var _h;
  return h("table", "").child((_h = h("tbody", "")).children.apply(_h, arguments));
}
function buildTd(iconName) {
  var _this = this;
  return h("td", "").child(h("div", "".concat(cssPrefix, "-border-palette-cell")).child(new Icon("border-".concat(iconName))).on("click", function() {
    _this.mode = iconName;
    var mode = _this.mode, style = _this.style, color = _this.color;
    _this.change({
      mode,
      style,
      color
    });
  }));
}
var BorderPalette = /* @__PURE__ */ _createClass(function BorderPalette2() {
  var _this2 = this, _h2, _h3;
  _classCallCheck(this, BorderPalette2);
  this.color = "#000";
  this.style = "thin";
  this.mode = "all";
  this.change = function() {
  };
  this.ddColor = new DropdownColor("line-color", this.color);
  this.ddColor.change = function(color) {
    _this2.color = color;
  };
  this.ddType = new DropdownLineType(this.style);
  this.ddType.change = function(_ref) {
    var _ref2 = _slicedToArray(_ref, 1), s = _ref2[0];
    _this2.style = s;
  };
  this.el = h("div", "".concat(cssPrefix, "-border-palette"));
  var table = buildTable(h("tr", "").children(h("td", "".concat(cssPrefix, "-border-palette-left")).child(buildTable((_h2 = h("tr", "")).children.apply(_h2, _toConsumableArray(["all", "inside", "horizontal", "vertical", "outside"].map(function(it) {
    return buildTd.call(_this2, it);
  }))), (_h3 = h("tr", "")).children.apply(_h3, _toConsumableArray(["left", "top", "right", "bottom", "none"].map(function(it) {
    return buildTd.call(_this2, it);
  }))))), h("td", "".concat(cssPrefix, "-border-palette-right")).children(h("div", "".concat(cssPrefix, "-toolbar-btn")).child(this.ddColor.el), h("div", "".concat(cssPrefix, "-toolbar-btn")).child(this.ddType.el))));
  this.el.child(table);
});
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownBorder = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownBorder2, _Dropdown);
  var _super = _createSuper$n(DropdownBorder2);
  function DropdownBorder2() {
    var _this;
    _classCallCheck(this, DropdownBorder2);
    var icon = new Icon("border-all");
    var borderPalette = new BorderPalette();
    borderPalette.change = function(v) {
      _this.change(v);
      _this.hide();
    };
    return _this = _super.call(this, icon, "auto", false, "bottom-left", borderPalette.el);
  }
  return _createClass(DropdownBorder2);
}(Dropdown);
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Border = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Border2, _DropdownItem);
  var _super = _createSuper$m(Border2);
  function Border2() {
    _classCallCheck(this, Border2);
    return _super.call(this, "border");
  }
  _createClass(Border2, [{
    key: "dropdown",
    value: function dropdown() {
      return new DropdownBorder();
    }
  }]);
  return Border2;
}(DropdownItem);
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var IconItem = /* @__PURE__ */ function(_Item) {
  _inherits(IconItem2, _Item);
  var _super = _createSuper$l(IconItem2);
  function IconItem2() {
    _classCallCheck(this, IconItem2);
    return _super.apply(this, arguments);
  }
  _createClass(IconItem2, [{
    key: "element",
    value: function element() {
      var _this = this;
      return _get(_getPrototypeOf(IconItem2.prototype), "element", this).call(this).child(new Icon(this.tag)).on("click", function() {
        return _this.change(_this.tag);
      });
    }
  }, {
    key: "setState",
    value: function setState(disabled) {
      this.el.disabled(disabled);
    }
  }]);
  return IconItem2;
}(Item);
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Clearformat = /* @__PURE__ */ function(_IconItem) {
  _inherits(Clearformat2, _IconItem);
  var _super = _createSuper$k(Clearformat2);
  function Clearformat2() {
    _classCallCheck(this, Clearformat2);
    return _super.call(this, "clearformat");
  }
  return _createClass(Clearformat2);
}(IconItem);
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Paintformat = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Paintformat2, _ToggleItem);
  var _super = _createSuper$j(Paintformat2);
  function Paintformat2() {
    _classCallCheck(this, Paintformat2);
    return _super.call(this, "paintformat");
  }
  _createClass(Paintformat2, [{
    key: "setState",
    value: function setState() {
    }
  }]);
  return Paintformat2;
}(ToggleItem);
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var TextColor = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(TextColor2, _DropdownItem);
  var _super = _createSuper$i(TextColor2);
  function TextColor2(color) {
    _classCallCheck(this, TextColor2);
    return _super.call(this, "color", void 0, color);
  }
  _createClass(TextColor2, [{
    key: "dropdown",
    value: function dropdown() {
      var tag = this.tag, value = this.value;
      return new DropdownColor(tag, value);
    }
  }]);
  return TextColor2;
}(DropdownItem);
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var FillColor = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(FillColor2, _DropdownItem);
  var _super = _createSuper$h(FillColor2);
  function FillColor2(color) {
    _classCallCheck(this, FillColor2);
    return _super.call(this, "bgcolor", void 0, color);
  }
  _createClass(FillColor2, [{
    key: "dropdown",
    value: function dropdown() {
      var tag = this.tag, value = this.value;
      return new DropdownColor(tag, value);
    }
  }]);
  return FillColor2;
}(DropdownItem);
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownFontSize = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownFontSize2, _Dropdown);
  var _super = _createSuper$g(DropdownFontSize2);
  function DropdownFontSize2() {
    var _this;
    _classCallCheck(this, DropdownFontSize2);
    var nfontSizes = fontSizes.map(function(it) {
      return h("div", "".concat(cssPrefix, "-item")).on("click", function() {
        _this.setTitle("".concat(it.pt));
        _this.change(it);
      }).child("".concat(it.pt));
    });
    return _this = _super.call.apply(_super, [this, "10", "60px", true, "bottom-left"].concat(_toConsumableArray(nfontSizes)));
  }
  return _createClass(DropdownFontSize2);
}(Dropdown);
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Format$2 = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Format2, _DropdownItem);
  var _super = _createSuper$f(Format2);
  function Format2() {
    _classCallCheck(this, Format2);
    return _super.call(this, "font-size");
  }
  _createClass(Format2, [{
    key: "getValue",
    value: function getValue(it) {
      return it.pt;
    }
  }, {
    key: "dropdown",
    value: function dropdown() {
      return new DropdownFontSize();
    }
  }]);
  return Format2;
}(DropdownItem);
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownFont = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownFont2, _Dropdown);
  var _super = _createSuper$e(DropdownFont2);
  function DropdownFont2() {
    var _this;
    _classCallCheck(this, DropdownFont2);
    var nfonts = baseFonts.map(function(it) {
      return h("div", "".concat(cssPrefix, "-item")).on("click", function() {
        _this.setTitle(it.title);
        _this.change(it);
      }).child(it.title);
    });
    return _this = _super.call.apply(_super, [this, baseFonts[0].title, "160px", true, "bottom-left"].concat(_toConsumableArray(nfonts)));
  }
  return _createClass(DropdownFont2);
}(Dropdown);
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Font = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Font2, _DropdownItem);
  var _super = _createSuper$d(Font2);
  function Font2() {
    _classCallCheck(this, Font2);
    return _super.call(this, "font-name");
  }
  _createClass(Font2, [{
    key: "getValue",
    value: function getValue(it) {
      return it.key;
    }
  }, {
    key: "dropdown",
    value: function dropdown() {
      return new DropdownFont();
    }
  }]);
  return Font2;
}(DropdownItem);
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownFormat = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownFormat2, _Dropdown);
  var _super = _createSuper$c(DropdownFormat2);
  function DropdownFormat2() {
    var _this;
    _classCallCheck(this, DropdownFormat2);
    var nformats = baseFormats.slice(0);
    nformats.splice(2, 0, {
      key: "divider"
    });
    nformats.splice(8, 0, {
      key: "divider"
    });
    nformats = nformats.map(function(it) {
      var item = h("div", "".concat(cssPrefix, "-item"));
      if (it.key === "divider") {
        item.addClass("divider");
      } else {
        item.child(it.title()).on("click", function() {
          _this.setTitle(it.title());
          _this.change(it);
        });
        if (it.label)
          item.child(h("div", "label").html(it.label));
      }
      return item;
    });
    return _this = _super.call.apply(_super, [this, "Normal", "220px", true, "bottom-left"].concat(_toConsumableArray(nformats)));
  }
  _createClass(DropdownFormat2, [{
    key: "setTitle",
    value: function setTitle(key) {
      for (var i = 0; i < baseFormats.length; i += 1) {
        if (baseFormats[i].key === key) {
          this.title.html(baseFormats[i].title());
        }
      }
      this.hide();
    }
  }]);
  return DropdownFormat2;
}(Dropdown);
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Format$1 = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Format2, _DropdownItem);
  var _super = _createSuper$b(Format2);
  function Format2() {
    _classCallCheck(this, Format2);
    return _super.call(this, "format");
  }
  _createClass(Format2, [{
    key: "getValue",
    value: function getValue(it) {
      return it.key;
    }
  }, {
    key: "dropdown",
    value: function dropdown() {
      return new DropdownFormat();
    }
  }]);
  return Format2;
}(DropdownItem);
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownFormula = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownFormula2, _Dropdown);
  var _super = _createSuper$a(DropdownFormula2);
  function DropdownFormula2() {
    var _this;
    _classCallCheck(this, DropdownFormula2);
    var nformulas = baseFormulas.map(function(it) {
      return h("div", "".concat(cssPrefix, "-item")).on("click", function() {
        _this.hide();
        _this.change(it);
      }).child(it.key);
    });
    return _this = _super.call.apply(_super, [this, new Icon("formula"), "180px", true, "bottom-left"].concat(_toConsumableArray(nformulas)));
  }
  return _createClass(DropdownFormula2);
}(Dropdown);
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Format = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(Format2, _DropdownItem);
  var _super = _createSuper$9(Format2);
  function Format2() {
    _classCallCheck(this, Format2);
    return _super.call(this, "formula");
  }
  _createClass(Format2, [{
    key: "getValue",
    value: function getValue(it) {
      return it.key;
    }
  }, {
    key: "dropdown",
    value: function dropdown() {
      return new DropdownFormula();
    }
  }]);
  return Format2;
}(DropdownItem);
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Freeze = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Freeze2, _ToggleItem);
  var _super = _createSuper$8(Freeze2);
  function Freeze2() {
    _classCallCheck(this, Freeze2);
    return _super.call(this, "freeze");
  }
  return _createClass(Freeze2);
}(ToggleItem);
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Merge = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Merge2, _ToggleItem);
  var _super = _createSuper$7(Merge2);
  function Merge2() {
    _classCallCheck(this, Merge2);
    return _super.call(this, "merge");
  }
  _createClass(Merge2, [{
    key: "setState",
    value: function setState(active, disabled) {
      this.el.active(active).disabled(disabled);
    }
  }]);
  return Merge2;
}(ToggleItem);
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Redo = /* @__PURE__ */ function(_IconItem) {
  _inherits(Redo2, _IconItem);
  var _super = _createSuper$6(Redo2);
  function Redo2() {
    _classCallCheck(this, Redo2);
    return _super.call(this, "redo", "Ctrl+Y");
  }
  return _createClass(Redo2);
}(IconItem);
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Undo = /* @__PURE__ */ function(_IconItem) {
  _inherits(Undo2, _IconItem);
  var _super = _createSuper$5(Undo2);
  function Undo2() {
    _classCallCheck(this, Undo2);
    return _super.call(this, "undo", "Ctrl+Z");
  }
  return _createClass(Undo2);
}(IconItem);
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Print = /* @__PURE__ */ function(_IconItem) {
  _inherits(Print2, _IconItem);
  var _super = _createSuper$4(Print2);
  function Print2() {
    _classCallCheck(this, Print2);
    return _super.call(this, "print", "Ctrl+P");
  }
  return _createClass(Print2);
}(IconItem);
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var Textwrap = /* @__PURE__ */ function(_ToggleItem) {
  _inherits(Textwrap2, _ToggleItem);
  var _super = _createSuper$3(Textwrap2);
  function Textwrap2() {
    _classCallCheck(this, Textwrap2);
    return _super.call(this, "textwrap");
  }
  return _createClass(Textwrap2);
}(ToggleItem);
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownMore$1 = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownMore2, _Dropdown);
  var _super = _createSuper$2(DropdownMore2);
  function DropdownMore2() {
    var _this;
    _classCallCheck(this, DropdownMore2);
    var icon = new Icon("ellipsis");
    var moreBtns = h("div", "".concat(cssPrefix, "-toolbar-more"));
    _this = _super.call(this, icon, "auto", false, "bottom-right", moreBtns);
    _this.moreBtns = moreBtns;
    _this.contentEl.css("max-width", "420px");
    return _this;
  }
  return _createClass(DropdownMore2);
}(Dropdown);
var More = /* @__PURE__ */ function(_DropdownItem) {
  _inherits(More2, _DropdownItem);
  var _super2 = _createSuper$2(More2);
  function More2() {
    var _this2;
    _classCallCheck(this, More2);
    _this2 = _super2.call(this, "more");
    _this2.el.hide();
    return _this2;
  }
  _createClass(More2, [{
    key: "dropdown",
    value: function dropdown() {
      return new DropdownMore$1();
    }
  }, {
    key: "show",
    value: function show() {
      this.el.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
    }
  }]);
  return More2;
}(DropdownItem);
function buildDivider() {
  return h("div", "".concat(cssPrefix, "-toolbar-divider"));
}
function initBtns2() {
  var _this = this;
  this.btns2 = [];
  this.items.forEach(function(it) {
    if (Array.isArray(it)) {
      it.forEach(function(_ref) {
        var el = _ref.el;
        var rect2 = el.box();
        var _el$computedStyle = el.computedStyle(), marginLeft2 = _el$computedStyle.marginLeft, marginRight2 = _el$computedStyle.marginRight;
        _this.btns2.push([el, rect2.width + parseInt(marginLeft2, 10) + parseInt(marginRight2, 10)]);
      });
    } else {
      var rect = it.box();
      var _it$computedStyle = it.computedStyle(), marginLeft = _it$computedStyle.marginLeft, marginRight = _it$computedStyle.marginRight;
      _this.btns2.push([it, rect.width + parseInt(marginLeft, 10) + parseInt(marginRight, 10)]);
    }
  });
}
function moreResize() {
  var _btns$html, _moreBtns$html;
  var el = this.el, btns = this.btns, moreEl = this.moreEl, btns2 = this.btns2;
  var _moreEl$dd = moreEl.dd, moreBtns = _moreEl$dd.moreBtns, contentEl = _moreEl$dd.contentEl;
  el.css("width", "".concat(this.widthFn() - 60, "px"));
  var elBox = el.box();
  var sumWidth = 160;
  var sumWidth2 = 12;
  var list1 = [];
  var list2 = [];
  btns2.forEach(function(_ref2, index2) {
    var _ref3 = _slicedToArray(_ref2, 2), it = _ref3[0], w = _ref3[1];
    sumWidth += w;
    if (index2 === btns2.length - 1 || sumWidth < elBox.width) {
      list1.push(it);
    } else {
      sumWidth2 += w;
      list2.push(it);
    }
  });
  (_btns$html = btns.html("")).children.apply(_btns$html, list1);
  (_moreBtns$html = moreBtns.html("")).children.apply(_moreBtns$html, list2);
  contentEl.css("width", "".concat(sumWidth2, "px"));
  if (list2.length > 0) {
    moreEl.show();
  } else {
    moreEl.hide();
  }
}
var Toolbar = /* @__PURE__ */ function() {
  function Toolbar2(data, widthFn) {
    var _this2 = this;
    var isHide = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    _classCallCheck(this, Toolbar2);
    this.data = data;
    this.change = function() {
    };
    this.widthFn = widthFn;
    this.isHide = isHide;
    var style = data.defaultStyle();
    this.items = [[this.undoEl = new Undo(), this.redoEl = new Redo(), new Print(), this.paintformatEl = new Paintformat(), this.clearformatEl = new Clearformat()], buildDivider(), [this.formatEl = new Format$1()], buildDivider(), [this.fontEl = new Font(), this.fontSizeEl = new Format$2()], buildDivider(), [this.boldEl = new Bold(), this.italicEl = new Italic(), this.underlineEl = new Underline(), this.strikeEl = new Strike(), this.textColorEl = new TextColor(style.color)], buildDivider(), [this.fillColorEl = new FillColor(style.bgcolor), this.borderEl = new Border(), this.mergeEl = new Merge()], buildDivider(), [this.alignEl = new Align(style.align), this.valignEl = new Valign(style.valign), this.textwrapEl = new Textwrap()], buildDivider(), [this.freezeEl = new Freeze(), this.autofilterEl = new Autofilter(), this.formulaEl = new Format(), this.moreEl = new More()]];
    this.el = h("div", "".concat(cssPrefix, "-toolbar"));
    this.btns = h("div", "".concat(cssPrefix, "-toolbar-btns"));
    this.items.forEach(function(it) {
      if (Array.isArray(it)) {
        it.forEach(function(i) {
          _this2.btns.child(i.el);
          i.change = function() {
            _this2.change.apply(_this2, arguments);
          };
        });
      } else {
        _this2.btns.child(it.el);
      }
    });
    this.el.child(this.btns);
    if (isHide) {
      this.el.hide();
    } else {
      this.reset();
      setTimeout(function() {
        initBtns2.call(_this2);
        moreResize.call(_this2);
      }, 0);
      bind(window, "resize", function() {
        moreResize.call(_this2);
      });
    }
  }
  _createClass(Toolbar2, [{
    key: "paintformatActive",
    value: function paintformatActive() {
      return this.paintformatEl.active();
    }
  }, {
    key: "paintformatToggle",
    value: function paintformatToggle() {
      this.paintformatEl.toggle();
    }
  }, {
    key: "trigger",
    value: function trigger(type) {
      this["".concat(type, "El")].click();
    }
  }, {
    key: "resetData",
    value: function resetData(data) {
      this.data = data;
      this.reset();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.isHide)
        return;
      var data = this.data;
      var style = data.getSelectedCellStyle();
      this.undoEl.setState(!data.canUndo());
      this.redoEl.setState(!data.canRedo());
      this.mergeEl.setState(data.canUnmerge(), !data.selector.multiple());
      this.autofilterEl.setState(!data.canAutofilter());
      var font = style.font, format = style.format;
      this.formatEl.setState(format);
      this.fontEl.setState(font.name);
      this.fontSizeEl.setState(font.size);
      this.boldEl.setState(font.bold);
      this.italicEl.setState(font.italic);
      this.underlineEl.setState(style.underline);
      this.strikeEl.setState(style.strike);
      this.textColorEl.setState(style.color);
      this.fillColorEl.setState(style.bgcolor);
      this.alignEl.setState(style.align);
      this.valignEl.setState(style.valign);
      this.textwrapEl.setState(style.textwrap);
      this.freezeEl.setState(data.freezeIsActive());
    }
  }]);
  return Toolbar2;
}();
var Modal = /* @__PURE__ */ function() {
  function Modal2(title, content) {
    var _this = this, _h;
    var width2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "600px";
    _classCallCheck(this, Modal2);
    this.title = title;
    this.el = h("div", "".concat(cssPrefix, "-modal")).css("width", width2).children(h("div", "".concat(cssPrefix, "-modal-header")).children(new Icon("close").on("click.stop", function() {
      return _this.hide();
    }), this.title), (_h = h("div", "".concat(cssPrefix, "-modal-content"))).children.apply(_h, _toConsumableArray(content))).hide();
  }
  _createClass(Modal2, [{
    key: "show",
    value: function show() {
      var _this2 = this;
      this.dimmer = h("div", "".concat(cssPrefix, "-dimmer active"));
      document.body.appendChild(this.dimmer.el);
      var _this$el$show$box = this.el.show().box(), width2 = _this$el$show$box.width, height2 = _this$el$show$box.height;
      var _document$documentEle = document.documentElement, clientHeight = _document$documentEle.clientHeight, clientWidth = _document$documentEle.clientWidth;
      this.el.offset({
        left: (clientWidth - width2) / 2,
        top: (clientHeight - height2) / 3
      });
      window.xkeydownEsc = function(evt) {
        if (evt.keyCode === 27) {
          _this2.hide();
        }
      };
      bind(window, "keydown", window.xkeydownEsc);
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
      document.body.removeChild(this.dimmer.el);
      unbind(window, "keydown", window.xkeydownEsc);
      delete window.xkeydownEsc;
    }
  }]);
  return Modal2;
}();
var FormInput = /* @__PURE__ */ function() {
  function FormInput2(width2, hint) {
    var _this = this;
    _classCallCheck(this, FormInput2);
    this.vchange = function() {
    };
    this.el = h("div", "".concat(cssPrefix, "-form-input"));
    this.input = h("input", "").css("width", width2).on("input", function(evt) {
      return _this.vchange(evt);
    }).attr("placeholder", hint);
    this.el.child(this.input);
  }
  _createClass(FormInput2, [{
    key: "focus",
    value: function focus() {
      var _this2 = this;
      setTimeout(function() {
        _this2.input.el.focus();
      }, 10);
    }
  }, {
    key: "hint",
    value: function hint(v) {
      this.input.attr("placeholder", v);
    }
  }, {
    key: "val",
    value: function val(v) {
      return this.input.val(v);
    }
  }]);
  return FormInput2;
}();
var FormSelect = /* @__PURE__ */ function() {
  function FormSelect2(key, items, width2) {
    var _this = this;
    var getTitle = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function(it) {
      return it;
    };
    var change = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : function() {
    };
    _classCallCheck(this, FormSelect2);
    this.key = key;
    this.getTitle = getTitle;
    this.vchange = function() {
    };
    this.el = h("div", "".concat(cssPrefix, "-form-select"));
    this.suggest = new Suggest(items.map(function(it) {
      return {
        key: it,
        title: _this.getTitle(it)
      };
    }), function(it) {
      _this.itemClick(it.key);
      change(it.key);
      _this.vchange(it.key);
    }, width2, this.el);
    this.el.children(this.itemEl = h("div", "input-text").html(this.getTitle(key)), this.suggest.el).on("click", function() {
      return _this.show();
    });
  }
  _createClass(FormSelect2, [{
    key: "show",
    value: function show() {
      this.suggest.search("");
    }
  }, {
    key: "itemClick",
    value: function itemClick(it) {
      this.key = it;
      this.itemEl.html(this.getTitle(it));
    }
  }, {
    key: "val",
    value: function val(v) {
      if (v !== void 0) {
        this.key = v;
        this.itemEl.html(this.getTitle(v));
        return this;
      }
      return this.key;
    }
  }]);
  return FormSelect2;
}();
var patterns = {
  number: /(^\d+$)|(^\d+(\.\d{0,4})?$)/,
  date: /^\d{4}-\d{1,2}-\d{1,2}$/
};
var FormField = /* @__PURE__ */ function() {
  function FormField2(input, rule, label, labelWidth) {
    var _this = this;
    _classCallCheck(this, FormField2);
    this.label = "";
    this.rule = rule;
    if (label) {
      this.label = h("label", "label").css("width", "".concat(labelWidth, "px")).html(label);
    }
    this.tip = h("div", "tip").child("tip").hide();
    this.input = input;
    this.input.vchange = function() {
      return _this.validate();
    };
    this.el = h("div", "".concat(cssPrefix, "-form-field")).children(this.label, input.el, this.tip);
  }
  _createClass(FormField2, [{
    key: "isShow",
    value: function isShow() {
      return this.el.css("display") !== "none";
    }
  }, {
    key: "show",
    value: function show() {
      this.el.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
      return this;
    }
  }, {
    key: "val",
    value: function val(v) {
      return this.input.val(v);
    }
  }, {
    key: "hint",
    value: function hint(_hint) {
      this.input.hint(_hint);
    }
  }, {
    key: "validate",
    value: function validate() {
      var input = this.input, rule = this.rule, tip = this.tip, el = this.el;
      var v = input.val();
      if (rule.required) {
        if (/^\s*$/.test(v)) {
          tip.html(t("validation.required"));
          el.addClass("error");
          return false;
        }
      }
      if (rule.type || rule.pattern) {
        var pattern = rule.pattern || patterns[rule.type];
        if (!pattern.test(v)) {
          tip.html(t("validation.notMatch"));
          el.addClass("error");
          return false;
        }
      }
      el.removeClass("error");
      return true;
    }
  }]);
  return FormField2;
}();
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var fieldLabelWidth = 100;
var ModalValidation = /* @__PURE__ */ function(_Modal) {
  _inherits(ModalValidation2, _Modal);
  var _super = _createSuper$1(ModalValidation2);
  function ModalValidation2() {
    var _this;
    _classCallCheck(this, ModalValidation2);
    var mf = new FormField(new FormSelect(
      "cell",
      ["cell"],
      // cell|row|column
      "100%",
      function(it) {
        return t("dataValidation.modeType.".concat(it));
      }
    ), {
      required: true
    }, "".concat(t("dataValidation.range"), ":"), fieldLabelWidth);
    var rf = new FormField(new FormInput("120px", "E3 or E3:F12"), {
      required: true,
      pattern: /^([A-Z]{1,2}[1-9]\d*)(:[A-Z]{1,2}[1-9]\d*)?$/
    });
    var cf = new FormField(new FormSelect("list", ["list", "number", "date", "phone", "email"], "100%", function(it) {
      return t("dataValidation.type.".concat(it));
    }, function(it) {
      return _this.criteriaSelected(it);
    }), {
      required: true
    }, "".concat(t("dataValidation.criteria"), ":"), fieldLabelWidth);
    var of = new FormField(new FormSelect("be", ["be", "nbe", "eq", "neq", "lt", "lte", "gt", "gte"], "160px", function(it) {
      return t("dataValidation.operator.".concat(it));
    }, function(it) {
      return _this.criteriaOperatorSelected(it);
    }), {
      required: true
    }).hide();
    var minvf = new FormField(new FormInput("70px", "10"), {
      required: true
    }).hide();
    var maxvf = new FormField(new FormInput("70px", "100"), {
      required: true,
      type: "number"
    }).hide();
    var svf = new FormField(new FormInput("120px", "a,b,c"), {
      required: true
    });
    var vf = new FormField(new FormInput("70px", "10"), {
      required: true,
      type: "number"
    }).hide();
    _this = _super.call(this, t("contextmenu.validation"), [h("div", "".concat(cssPrefix, "-form-fields")).children(mf.el, rf.el), h("div", "".concat(cssPrefix, "-form-fields")).children(cf.el, of.el, minvf.el, maxvf.el, vf.el, svf.el), h("div", "".concat(cssPrefix, "-buttons")).children(new Button("cancel").on("click", function() {
      return _this.btnClick("cancel");
    }), new Button("remove").on("click", function() {
      return _this.btnClick("remove");
    }), new Button("save", "primary").on("click", function() {
      return _this.btnClick("save");
    }))]);
    _this.mf = mf;
    _this.rf = rf;
    _this.cf = cf;
    _this.of = of;
    _this.minvf = minvf;
    _this.maxvf = maxvf;
    _this.vf = vf;
    _this.svf = svf;
    _this.change = function() {
    };
    return _this;
  }
  _createClass(ModalValidation2, [{
    key: "showVf",
    value: function showVf(it) {
      var hint = it === "date" ? "2018-11-12" : "10";
      var vf = this.vf;
      vf.input.hint(hint);
      vf.show();
    }
  }, {
    key: "criteriaSelected",
    value: function criteriaSelected(it) {
      var of = this.of, minvf = this.minvf, maxvf = this.maxvf, vf = this.vf, svf = this.svf;
      if (it === "date" || it === "number") {
        of.show();
        minvf.rule.type = it;
        maxvf.rule.type = it;
        if (it === "date") {
          minvf.hint("2018-11-12");
          maxvf.hint("2019-11-12");
        } else {
          minvf.hint("10");
          maxvf.hint("100");
        }
        minvf.show();
        maxvf.show();
        vf.hide();
        svf.hide();
      } else {
        if (it === "list") {
          svf.show();
        } else {
          svf.hide();
        }
        vf.hide();
        of.hide();
        minvf.hide();
        maxvf.hide();
      }
    }
  }, {
    key: "criteriaOperatorSelected",
    value: function criteriaOperatorSelected(it) {
      if (!it)
        return;
      var minvf = this.minvf, maxvf = this.maxvf, vf = this.vf;
      if (it === "be" || it === "nbe") {
        minvf.show();
        maxvf.show();
        vf.hide();
      } else {
        var type = this.cf.val();
        vf.rule.type = type;
        if (type === "date") {
          vf.hint("2018-11-12");
        } else {
          vf.hint("10");
        }
        vf.show();
        minvf.hide();
        maxvf.hide();
      }
    }
  }, {
    key: "btnClick",
    value: function btnClick2(action) {
      if (action === "cancel") {
        this.hide();
      } else if (action === "remove") {
        this.change("remove");
        this.hide();
      } else if (action === "save") {
        var attrs = ["mf", "rf", "cf", "of", "svf", "vf", "minvf", "maxvf"];
        for (var i = 0; i < attrs.length; i += 1) {
          var field = this[attrs[i]];
          if (field.isShow()) {
            if (!field.validate())
              return;
          }
        }
        var mode = this.mf.val();
        var ref2 = this.rf.val();
        var type = this.cf.val();
        var operator = this.of.val();
        var value = this.svf.val();
        if (type === "number" || type === "date") {
          if (operator === "be" || operator === "nbe") {
            value = [this.minvf.val(), this.maxvf.val()];
          } else {
            value = this.vf.val();
          }
        }
        this.change("save", mode, ref2, {
          type,
          operator,
          required: false,
          value
        });
        this.hide();
      }
    }
    // validation: { mode, ref, validator }
  }, {
    key: "setValue",
    value: function setValue(v) {
      if (v) {
        var mf = this.mf, rf = this.rf, cf = this.cf, of = this.of, svf = this.svf, vf = this.vf, minvf = this.minvf, maxvf = this.maxvf;
        var mode = v.mode, ref2 = v.ref, validator = v.validator;
        var _ref = validator || {
          type: "list"
        }, type = _ref.type, operator = _ref.operator, value = _ref.value;
        mf.val(mode || "cell");
        rf.val(ref2);
        cf.val(type);
        of.val(operator);
        if (Array.isArray(value)) {
          minvf.val(value[0]);
          maxvf.val(value[1]);
        } else {
          svf.val(value || "");
          vf.val(value || "");
        }
        this.criteriaSelected(type);
        this.criteriaOperatorSelected(operator);
      }
      this.show();
    }
  }]);
  return ModalValidation2;
}(Modal);
function buildMenu$1(clsName) {
  return h("div", "".concat(cssPrefix, "-item ").concat(clsName));
}
function buildSortItem(it) {
  var _this = this;
  return buildMenu$1("state").child(t("sort.".concat(it))).on("click.stop", function() {
    return _this.itemClick(it);
  });
}
function buildFilterBody(items) {
  var _this2 = this;
  var filterbEl = this.filterbEl, filterValues = this.filterValues;
  filterbEl.html("");
  var itemKeys = Object.keys(items);
  itemKeys.forEach(function(it, index2) {
    var cnt = items[it];
    var active = filterValues.includes(it) ? "checked" : "";
    filterbEl.child(h("div", "".concat(cssPrefix, "-item state ").concat(active)).on("click.stop", function() {
      return _this2.filterClick(index2, it);
    }).children(it === "" ? t("filter.empty") : it, h("div", "label").html("(".concat(cnt, ")"))));
  });
}
function resetFilterHeader() {
  var filterhEl = this.filterhEl, filterValues = this.filterValues, values = this.values;
  filterhEl.html("".concat(filterValues.length, " / ").concat(values.length));
  filterhEl.checked(filterValues.length === values.length);
}
var SortFilter = /* @__PURE__ */ function() {
  function SortFilter2() {
    var _this3 = this;
    _classCallCheck(this, SortFilter2);
    this.filterbEl = h("div", "".concat(cssPrefix, "-body"));
    this.filterhEl = h("div", "".concat(cssPrefix, "-header state")).on("click.stop", function() {
      return _this3.filterClick(0, "all");
    });
    this.el = h("div", "".concat(cssPrefix, "-sort-filter")).children(this.sortAscEl = buildSortItem.call(this, "asc"), this.sortDescEl = buildSortItem.call(this, "desc"), buildMenu$1("divider"), h("div", "".concat(cssPrefix, "-filter")).children(this.filterhEl, this.filterbEl), h("div", "".concat(cssPrefix, "-buttons")).children(new Button("cancel").on("click", function() {
      return _this3.btnClick("cancel");
    }), new Button("ok", "primary").on("click", function() {
      return _this3.btnClick("ok");
    }))).hide();
    this.ci = null;
    this.sortDesc = null;
    this.values = null;
    this.filterValues = [];
  }
  _createClass(SortFilter2, [{
    key: "btnClick",
    value: function btnClick2(it) {
      if (it === "ok") {
        var ci = this.ci, sort = this.sort, filterValues = this.filterValues;
        if (this.ok) {
          this.ok(ci, sort, "in", filterValues);
        }
      }
      this.hide();
    }
  }, {
    key: "itemClick",
    value: function itemClick(it) {
      this.sort = it;
      var sortAscEl = this.sortAscEl, sortDescEl = this.sortDescEl;
      sortAscEl.checked(it === "asc");
      sortDescEl.checked(it === "desc");
    }
  }, {
    key: "filterClick",
    value: function filterClick(index2, it) {
      var filterbEl = this.filterbEl, filterValues = this.filterValues, values = this.values;
      var children = filterbEl.children();
      if (it === "all") {
        if (children.length === filterValues.length) {
          this.filterValues = [];
          children.forEach(function(i) {
            return h(i).checked(false);
          });
        } else {
          this.filterValues = Array.from(values);
          children.forEach(function(i) {
            return h(i).checked(true);
          });
        }
      } else {
        var checked = h(children[index2]).toggle("checked");
        if (checked) {
          filterValues.push(it);
        } else {
          filterValues.splice(filterValues.findIndex(function(i) {
            return i === it;
          }), 1);
        }
      }
      resetFilterHeader.call(this);
    }
    // v: autoFilter
    // items: {value: cnt}
    // sort { ci, order }
  }, {
    key: "set",
    value: function set(ci, items, filter, sort) {
      this.ci = ci;
      var sortAscEl = this.sortAscEl, sortDescEl = this.sortDescEl;
      if (sort !== null) {
        this.sort = sort.order;
        sortAscEl.checked(sort.asc());
        sortDescEl.checked(sort.desc());
      } else {
        this.sortDesc = null;
        sortAscEl.checked(false);
        sortDescEl.checked(false);
      }
      this.values = Object.keys(items);
      this.filterValues = filter ? Array.from(filter.value) : Object.keys(items);
      buildFilterBody.call(this, items, filter);
      resetFilterHeader.call(this);
    }
  }, {
    key: "setOffset",
    value: function setOffset(v) {
      var _this4 = this;
      this.el.offset(v).show();
      var tindex = 1;
      bindClickoutside(this.el, function() {
        if (tindex <= 0) {
          _this4.hide();
        }
        tindex -= 1;
      });
    }
  }, {
    key: "show",
    value: function show() {
      this.el.show();
    }
  }, {
    key: "hide",
    value: function hide() {
      this.el.hide();
      unbindClickoutside(this.el);
    }
  }]);
  return SortFilter2;
}();
function xtoast(title, content) {
  var el = h("div", "".concat(cssPrefix, "-toast"));
  var dimmer = h("div", "".concat(cssPrefix, "-dimmer active"));
  var remove = function remove2() {
    document.body.removeChild(el.el);
    document.body.removeChild(dimmer.el);
  };
  el.children(h("div", "".concat(cssPrefix, "-toast-header")).children(new Icon("close").on("click.stop", function() {
    return remove();
  }), title), h("div", "".concat(cssPrefix, "-toast-content")).html(content));
  document.body.appendChild(el.el);
  document.body.appendChild(dimmer.el);
  var _el$box = el.box(), width2 = _el$box.width, height2 = _el$box.height;
  var _document$documentEle = document.documentElement, clientHeight = _document$documentEle.clientHeight, clientWidth = _document$documentEle.clientWidth;
  el.offset({
    left: (clientWidth - width2) / 2,
    top: (clientHeight - height2) / 3
  });
}
function throttle(func, wait) {
  var _this = this;
  var timeout;
  return function() {
    var that = _this;
    for (var _len = arguments.length, arg = new Array(_len), _key = 0; _key < _len; _key++) {
      arg[_key] = arguments[_key];
    }
    var args = arg;
    if (!timeout) {
      timeout = setTimeout(function() {
        timeout = null;
        func.apply(that, args);
      }, wait);
    }
  };
}
function scrollbarMove() {
  var data = this.data, verticalScrollbar = this.verticalScrollbar, horizontalScrollbar = this.horizontalScrollbar;
  var _data$getSelectedRect = data.getSelectedRect(), l = _data$getSelectedRect.l, t2 = _data$getSelectedRect.t, left = _data$getSelectedRect.left, top = _data$getSelectedRect.top, width2 = _data$getSelectedRect.width, height2 = _data$getSelectedRect.height;
  var tableOffset = this.getTableOffset();
  if (Math.abs(left) + width2 > tableOffset.width) {
    horizontalScrollbar.move({
      left: l + width2 - tableOffset.width
    });
  } else {
    var fsw = data.freezeTotalWidth();
    if (left < fsw) {
      horizontalScrollbar.move({
        left: l - 1 - fsw
      });
    }
  }
  if (Math.abs(top) + height2 > tableOffset.height) {
    verticalScrollbar.move({
      top: t2 + height2 - tableOffset.height - 1
    });
  } else {
    var fsh = data.freezeTotalHeight();
    if (top < fsh) {
      verticalScrollbar.move({
        top: t2 - 1 - fsh
      });
    }
  }
}
function selectorSet(multiple, ri, ci) {
  var indexesUpdated = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var moving = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  if (ri === -1 && ci === -1)
    return;
  var table = this.table, selector = this.selector, toolbar = this.toolbar, data = this.data, contextMenu = this.contextMenu;
  contextMenu.setMode(ri === -1 || ci === -1 ? "row-col" : "range");
  var cell = data.getCell(ri, ci);
  if (multiple) {
    selector.setEnd(ri, ci, moving);
    this.trigger("cells-selected", cell, selector.range);
  } else {
    selector.set(ri, ci, indexesUpdated);
    this.trigger("cell-selected", cell, ri, ci);
  }
  toolbar.reset();
  table.render();
}
function selectorMove(multiple, direction) {
  var selector = this.selector, data = this.data;
  var rows = data.rows, cols = data.cols;
  var _selector$indexes = _slicedToArray(selector.indexes, 2), ri = _selector$indexes[0], ci = _selector$indexes[1];
  var _selector$range = selector.range, eri = _selector$range.eri, eci = _selector$range.eci;
  if (multiple) {
    var _selector$moveIndexes = _slicedToArray(selector.moveIndexes, 2);
    ri = _selector$moveIndexes[0];
    ci = _selector$moveIndexes[1];
  }
  if (direction === "left") {
    if (ci > 0)
      ci -= 1;
  } else if (direction === "right") {
    if (eci !== ci)
      ci = eci;
    if (ci < cols.len - 1)
      ci += 1;
  } else if (direction === "up") {
    if (ri > 0)
      ri -= 1;
  } else if (direction === "down") {
    if (eri !== ri)
      ri = eri;
    if (ri < rows.len - 1)
      ri += 1;
  } else if (direction === "row-first") {
    ci = 0;
  } else if (direction === "row-last") {
    ci = cols.len - 1;
  } else if (direction === "col-first") {
    ri = 0;
  } else if (direction === "col-last") {
    ri = rows.len - 1;
  }
  if (multiple) {
    selector.moveIndexes = [ri, ci];
  }
  selectorSet.call(this, multiple, ri, ci);
  scrollbarMove.call(this);
}
function overlayerMousemove(evt) {
  if (evt.buttons !== 0)
    return;
  if (evt.target.className === "".concat(cssPrefix, "-resizer-hover"))
    return;
  var offsetX = evt.offsetX, offsetY = evt.offsetY;
  var rowResizer = this.rowResizer, colResizer = this.colResizer, tableEl = this.tableEl, data = this.data;
  var rows = data.rows, cols = data.cols;
  if (offsetX > cols.indexWidth && offsetY > rows.height) {
    rowResizer.hide();
    colResizer.hide();
    return;
  }
  var tRect = tableEl.box();
  var cRect = data.getCellRectByXY(evt.offsetX, evt.offsetY);
  if (cRect.ri >= 0 && cRect.ci === -1) {
    cRect.width = cols.indexWidth;
    rowResizer.show(cRect, {
      width: tRect.width
    });
    if (rows.isHide(cRect.ri - 1)) {
      rowResizer.showUnhide(cRect.ri);
    } else {
      rowResizer.hideUnhide();
    }
  } else {
    rowResizer.hide();
  }
  if (cRect.ri === -1 && cRect.ci >= 0) {
    cRect.height = rows.height;
    colResizer.show(cRect, {
      height: tRect.height
    });
    if (cols.isHide(cRect.ci - 1)) {
      colResizer.showUnhide(cRect.ci);
    } else {
      colResizer.hideUnhide();
    }
  } else {
    colResizer.hide();
  }
}
function overlayerMousescroll(evt) {
  var verticalScrollbar = this.verticalScrollbar, horizontalScrollbar = this.horizontalScrollbar, data = this.data;
  var _verticalScrollbar$sc = verticalScrollbar.scroll(), top = _verticalScrollbar$sc.top;
  var _horizontalScrollbar$ = horizontalScrollbar.scroll(), left = _horizontalScrollbar$.left;
  var rows = data.rows, cols = data.cols;
  var deltaY = evt.deltaY, deltaX = evt.deltaX;
  var loopValue = function loopValue2(ii, vFunc) {
    var i = ii;
    var v = 0;
    do {
      v = vFunc(i);
      i += 1;
    } while (v <= 0);
    return v;
  };
  var moveY = function moveY2(vertical) {
    if (vertical > 0) {
      var ri = data.scroll.ri + 1;
      if (ri < rows.len) {
        var rh = loopValue(ri, function(i) {
          return rows.getHeight(i);
        });
        verticalScrollbar.move({
          top: top + rh - 1
        });
      }
    } else {
      var _ri = data.scroll.ri - 1;
      if (_ri >= 0) {
        var _rh = loopValue(_ri, function(i) {
          return rows.getHeight(i);
        });
        verticalScrollbar.move({
          top: _ri === 0 ? 0 : top - _rh
        });
      }
    }
  };
  var moveX = function moveX2(horizontal) {
    if (horizontal > 0) {
      var ci = data.scroll.ci + 1;
      if (ci < cols.len) {
        var cw = loopValue(ci, function(i) {
          return cols.getWidth(i);
        });
        horizontalScrollbar.move({
          left: left + cw - 1
        });
      }
    } else {
      var _ci = data.scroll.ci - 1;
      if (_ci >= 0) {
        var _cw = loopValue(_ci, function(i) {
          return cols.getWidth(i);
        });
        horizontalScrollbar.move({
          left: _ci === 0 ? 0 : left - _cw
        });
      }
    }
  };
  var tempY = Math.abs(deltaY);
  var tempX = Math.abs(deltaX);
  var temp = Math.max(tempY, tempX);
  if (/Firefox/i.test(window.navigator.userAgent))
    throttle(moveY(evt.detail), 50);
  if (temp === tempX)
    throttle(moveX(deltaX), 50);
  if (temp === tempY)
    throttle(moveY(deltaY), 50);
}
function overlayerTouch(direction, distance) {
  var verticalScrollbar = this.verticalScrollbar, horizontalScrollbar = this.horizontalScrollbar;
  var _verticalScrollbar$sc2 = verticalScrollbar.scroll(), top = _verticalScrollbar$sc2.top;
  var _horizontalScrollbar$2 = horizontalScrollbar.scroll(), left = _horizontalScrollbar$2.left;
  if (direction === "left" || direction === "right") {
    horizontalScrollbar.move({
      left: left - distance
    });
  } else if (direction === "up" || direction === "down") {
    verticalScrollbar.move({
      top: top - distance
    });
  }
}
function verticalScrollbarSet() {
  var data = this.data, verticalScrollbar = this.verticalScrollbar;
  var _this$getTableOffset = this.getTableOffset(), height2 = _this$getTableOffset.height;
  var erth = data.exceptRowTotalHeight(0, -1);
  verticalScrollbar.set(height2, data.rows.totalHeight() - erth);
}
function horizontalScrollbarSet() {
  var data = this.data, horizontalScrollbar = this.horizontalScrollbar;
  var _this$getTableOffset2 = this.getTableOffset(), width2 = _this$getTableOffset2.width;
  if (data) {
    horizontalScrollbar.set(width2, data.cols.totalWidth());
  }
}
function sheetFreeze() {
  var selector = this.selector, data = this.data, editor = this.editor;
  var _data$freeze = _slicedToArray(data.freeze, 2), ri = _data$freeze[0], ci = _data$freeze[1];
  if (ri > 0 || ci > 0) {
    var fwidth = data.freezeTotalWidth();
    var fheight = data.freezeTotalHeight();
    editor.setFreezeLengths(fwidth, fheight);
  }
  selector.resetAreaOffset();
}
function sheetReset() {
  var tableEl = this.tableEl, overlayerEl = this.overlayerEl, overlayerCEl = this.overlayerCEl, table = this.table, toolbar = this.toolbar, selector = this.selector, el = this.el;
  var tOffset = this.getTableOffset();
  var vRect = this.getRect();
  tableEl.attr(vRect);
  overlayerEl.offset(vRect);
  overlayerCEl.offset(tOffset);
  el.css("width", "".concat(vRect.width, "px"));
  verticalScrollbarSet.call(this);
  horizontalScrollbarSet.call(this);
  sheetFreeze.call(this);
  table.render();
  toolbar.reset();
  selector.reset();
}
function clearClipboard() {
  var data = this.data, selector = this.selector;
  data.clearClipboard();
  selector.hideClipboard();
}
function copy() {
  var data = this.data, selector = this.selector;
  data.copy();
  data.copyToSystemClipboard();
  selector.showClipboard();
}
function cut() {
  var data = this.data, selector = this.selector;
  data.cut();
  selector.showClipboard();
}
function paste(what, evt) {
  var data = this.data;
  if (data.settings.mode === "read")
    return;
  if (data.paste(what, function(msg) {
    return xtoast("Tip", msg);
  })) {
    sheetReset.call(this);
  } else if (evt) {
    var cdata = evt.clipboardData.getData("text/plain");
    this.data.pasteFromText(cdata);
    sheetReset.call(this);
  }
}
function hideRowsOrCols() {
  this.data.hideRowsOrCols();
  sheetReset.call(this);
}
function unhideRowsOrCols(type, index2) {
  this.data.unhideRowsOrCols(type, index2);
  sheetReset.call(this);
}
function autofilter() {
  var data = this.data;
  data.autofilter();
  sheetReset.call(this);
}
function toolbarChangePaintformatPaste() {
  var toolbar = this.toolbar;
  if (toolbar.paintformatActive()) {
    paste.call(this, "format");
    clearClipboard.call(this);
    toolbar.paintformatToggle();
  }
}
function overlayerMousedown(evt) {
  var _this2 = this;
  var selector = this.selector, data = this.data, table = this.table, sortFilter = this.sortFilter;
  var offsetX = evt.offsetX, offsetY = evt.offsetY;
  var isAutofillEl = evt.target.className === "".concat(cssPrefix, "-selector-corner");
  var cellRect = data.getCellRectByXY(offsetX, offsetY);
  var left = cellRect.left, top = cellRect.top, width2 = cellRect.width, height2 = cellRect.height;
  var ri = cellRect.ri, ci = cellRect.ci;
  var autoFilter = data.autoFilter;
  if (autoFilter.includes(ri, ci)) {
    if (left + width2 - 20 < offsetX && top + height2 - 20 < offsetY) {
      var items = autoFilter.items(ci, function(r, c) {
        return data.rows.getCell(r, c);
      });
      sortFilter.hide();
      sortFilter.set(ci, items, autoFilter.getFilter(ci), autoFilter.getSort(ci));
      sortFilter.setOffset({
        left,
        top: top + height2 + 2
      });
      return;
    }
  }
  if (!evt.shiftKey) {
    if (isAutofillEl) {
      selector.showAutofill(ri, ci);
    } else {
      selectorSet.call(this, false, ri, ci);
    }
    mouseMoveUp(window, function(e) {
      var _data$getCellRectByXY = data.getCellRectByXY(e.offsetX, e.offsetY);
      ri = _data$getCellRectByXY.ri;
      ci = _data$getCellRectByXY.ci;
      if (isAutofillEl) {
        selector.showAutofill(ri, ci);
      } else if (e.buttons === 1 && !e.shiftKey) {
        selectorSet.call(_this2, true, ri, ci, true, true);
      }
    }, function() {
      if (isAutofillEl && selector.arange && data.settings.mode !== "read") {
        if (data.autofill(selector.arange, "all", function(msg) {
          return xtoast("Tip", msg);
        })) {
          table.render();
        }
      }
      selector.hideAutofill();
      toolbarChangePaintformatPaste.call(_this2);
    });
  }
  if (!isAutofillEl && evt.buttons === 1) {
    if (evt.shiftKey) {
      selectorSet.call(this, true, ri, ci);
    }
  }
}
function editorSetOffset() {
  var editor = this.editor, data = this.data;
  var sOffset = data.getSelectedRect();
  var tOffset = this.getTableOffset();
  var sPosition = "top";
  if (sOffset.top > tOffset.height / 2) {
    sPosition = "bottom";
  }
  editor.setOffset(sOffset, sPosition);
}
function editorSet() {
  var editor = this.editor, data = this.data;
  if (data.settings.mode === "read")
    return;
  editorSetOffset.call(this);
  editor.setCell(data.getSelectedCell(), data.getSelectedValidator());
  clearClipboard.call(this);
}
function verticalScrollbarMove(distance) {
  var _this3 = this;
  var data = this.data, table = this.table, selector = this.selector;
  data.scrolly(distance, function() {
    selector.resetBRLAreaOffset();
    editorSetOffset.call(_this3);
    table.render();
  });
}
function horizontalScrollbarMove(distance) {
  var _this4 = this;
  var data = this.data, table = this.table, selector = this.selector;
  data.scrollx(distance, function() {
    selector.resetBRTAreaOffset();
    editorSetOffset.call(_this4);
    table.render();
  });
}
function rowResizerFinished(cRect, distance) {
  var ri = cRect.ri;
  var table = this.table, selector = this.selector, data = this.data;
  data.rows.setHeight(ri, distance);
  table.render();
  selector.resetAreaOffset();
  verticalScrollbarSet.call(this);
  editorSetOffset.call(this);
}
function colResizerFinished(cRect, distance) {
  var ci = cRect.ci;
  var table = this.table, selector = this.selector, data = this.data;
  data.cols.setWidth(ci, distance);
  table.render();
  selector.resetAreaOffset();
  horizontalScrollbarSet.call(this);
  editorSetOffset.call(this);
}
function dataSetCellText(text) {
  var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "finished";
  var data = this.data, table = this.table;
  if (data.settings.mode === "read")
    return;
  data.setSelectedCellText(text, state);
  var _data$selector = data.selector, ri = _data$selector.ri, ci = _data$selector.ci;
  if (state === "finished") {
    table.render();
  } else {
    this.trigger("cell-edited", text, ri, ci);
  }
}
function insertDeleteRowColumn(type) {
  var data = this.data;
  if (data.settings.mode === "read")
    return;
  if (type === "insert-row") {
    data.insert("row");
  } else if (type === "delete-row") {
    data.delete("row");
  } else if (type === "insert-column") {
    data.insert("column");
  } else if (type === "delete-column") {
    data.delete("column");
  } else if (type === "delete-cell") {
    data.deleteCell();
  } else if (type === "delete-cell-format") {
    data.deleteCell("format");
  } else if (type === "delete-cell-text") {
    data.deleteCell("text");
  } else if (type === "cell-printable") {
    data.setSelectedCellAttr("printable", true);
  } else if (type === "cell-non-printable") {
    data.setSelectedCellAttr("printable", false);
  } else if (type === "cell-editable") {
    data.setSelectedCellAttr("editable", true);
  } else if (type === "cell-non-editable") {
    data.setSelectedCellAttr("editable", false);
  }
  clearClipboard.call(this);
  sheetReset.call(this);
}
function toolbarChange(type, value) {
  var data = this.data;
  if (type === "undo") {
    this.undo();
  } else if (type === "redo") {
    this.redo();
  } else if (type === "print") {
    this.print.preview();
  } else if (type === "paintformat") {
    if (value === true)
      copy.call(this);
    else
      clearClipboard.call(this);
  } else if (type === "clearformat") {
    insertDeleteRowColumn.call(this, "delete-cell-format");
  } else if (type === "link")
    ;
  else if (type === "chart")
    ;
  else if (type === "autofilter") {
    autofilter.call(this);
  } else if (type === "freeze") {
    if (value) {
      var _data$selector2 = data.selector, ri = _data$selector2.ri, ci = _data$selector2.ci;
      this.freeze(ri, ci);
    } else {
      this.freeze(0, 0);
    }
  } else {
    data.setSelectedCellAttr(type, value);
    if (type === "formula" && !data.selector.multiple()) {
      editorSet.call(this);
    }
    sheetReset.call(this);
  }
}
function sortFilterChange(ci, order, operator, value) {
  this.data.setAutoFilter(ci, order, operator, value);
  sheetReset.call(this);
}
function sheetInitEvents() {
  var _this5 = this;
  var selector = this.selector, overlayerEl = this.overlayerEl, rowResizer = this.rowResizer, colResizer = this.colResizer, verticalScrollbar = this.verticalScrollbar, horizontalScrollbar = this.horizontalScrollbar, editor = this.editor, contextMenu = this.contextMenu, toolbar = this.toolbar, modalValidation = this.modalValidation, sortFilter = this.sortFilter;
  overlayerEl.on("mousemove", function(evt) {
    overlayerMousemove.call(_this5, evt);
  }).on("mousedown", function(evt) {
    editor.clear();
    contextMenu.hide();
    if (evt.buttons === 2) {
      if (_this5.data.xyInSelectedRect(evt.offsetX, evt.offsetY)) {
        contextMenu.setPosition(evt.offsetX, evt.offsetY);
      } else {
        overlayerMousedown.call(_this5, evt);
        contextMenu.setPosition(evt.offsetX, evt.offsetY);
      }
      evt.stopPropagation();
    } else if (evt.detail === 2) {
      editorSet.call(_this5);
    } else {
      overlayerMousedown.call(_this5, evt);
    }
  }).on("mousewheel.stop", function(evt) {
    overlayerMousescroll.call(_this5, evt);
  }).on("mouseout", function(evt) {
    var offsetX = evt.offsetX, offsetY = evt.offsetY;
    if (offsetY <= 0)
      colResizer.hide();
    if (offsetX <= 0)
      rowResizer.hide();
  });
  selector.inputChange = function(v) {
    dataSetCellText.call(_this5, v, "input");
    editorSet.call(_this5);
  };
  bindTouch(overlayerEl.el, {
    move: function move(direction, d) {
      overlayerTouch.call(_this5, direction, d);
    }
  });
  toolbar.change = function(type, value) {
    return toolbarChange.call(_this5, type, value);
  };
  sortFilter.ok = function(ci, order, o, v) {
    return sortFilterChange.call(_this5, ci, order, o, v);
  };
  rowResizer.finishedFn = function(cRect, distance) {
    rowResizerFinished.call(_this5, cRect, distance);
  };
  colResizer.finishedFn = function(cRect, distance) {
    colResizerFinished.call(_this5, cRect, distance);
  };
  rowResizer.unhideFn = function(index2) {
    unhideRowsOrCols.call(_this5, "row", index2);
  };
  colResizer.unhideFn = function(index2) {
    unhideRowsOrCols.call(_this5, "col", index2);
  };
  verticalScrollbar.moveFn = function(distance, evt) {
    verticalScrollbarMove.call(_this5, distance, evt);
  };
  horizontalScrollbar.moveFn = function(distance, evt) {
    horizontalScrollbarMove.call(_this5, distance, evt);
  };
  editor.change = function(state, itext) {
    dataSetCellText.call(_this5, itext, state);
  };
  modalValidation.change = function(action) {
    if (action === "save") {
      var _this5$data;
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      (_this5$data = _this5.data).addValidation.apply(_this5$data, args);
    } else {
      _this5.data.removeValidation();
    }
  };
  contextMenu.itemClick = function(type) {
    if (type === "validation") {
      modalValidation.setValue(_this5.data.getSelectedValidation());
    } else if (type === "copy") {
      copy.call(_this5);
    } else if (type === "cut") {
      cut.call(_this5);
    } else if (type === "paste") {
      paste.call(_this5, "all");
    } else if (type === "paste-value") {
      paste.call(_this5, "text");
    } else if (type === "paste-format") {
      paste.call(_this5, "format");
    } else if (type === "hide") {
      hideRowsOrCols.call(_this5);
    } else {
      insertDeleteRowColumn.call(_this5, type);
    }
  };
  bind(window, "resize", function() {
    _this5.reload();
  });
  bind(window, "click", function(evt) {
    _this5.focusing = overlayerEl.contains(evt.target);
  });
  bind(window, "paste", function(evt) {
    if (!_this5.focusing)
      return;
    paste.call(_this5, "all", evt);
    evt.preventDefault();
  });
  bind(window, "keydown", function(evt) {
    if (!_this5.focusing)
      return;
    var keyCode = evt.keyCode || evt.which;
    var key = evt.key, ctrlKey = evt.ctrlKey, shiftKey = evt.shiftKey, metaKey = evt.metaKey;
    if (ctrlKey || metaKey) {
      switch (keyCode) {
        case 90:
          _this5.undo();
          evt.preventDefault();
          break;
        case 89:
          _this5.redo();
          evt.preventDefault();
          break;
        case 67:
          copy.call(_this5);
          evt.preventDefault();
          break;
        case 88:
          cut.call(_this5);
          evt.preventDefault();
          break;
        case 85:
          toolbar.trigger("underline");
          evt.preventDefault();
          break;
        case 86:
          break;
        case 37:
          selectorMove.call(_this5, shiftKey, "row-first");
          evt.preventDefault();
          break;
        case 38:
          selectorMove.call(_this5, shiftKey, "col-first");
          evt.preventDefault();
          break;
        case 39:
          selectorMove.call(_this5, shiftKey, "row-last");
          evt.preventDefault();
          break;
        case 40:
          selectorMove.call(_this5, shiftKey, "col-last");
          evt.preventDefault();
          break;
        case 32:
          selectorSet.call(_this5, false, -1, _this5.data.selector.ci, false);
          evt.preventDefault();
          break;
        case 66:
          toolbar.trigger("bold");
          break;
        case 73:
          toolbar.trigger("italic");
          break;
      }
    } else {
      switch (keyCode) {
        case 32:
          if (shiftKey) {
            selectorSet.call(_this5, false, _this5.data.selector.ri, -1, false);
          }
          break;
        case 27:
          contextMenu.hide();
          clearClipboard.call(_this5);
          break;
        case 37:
          selectorMove.call(_this5, shiftKey, "left");
          evt.preventDefault();
          break;
        case 38:
          selectorMove.call(_this5, shiftKey, "up");
          evt.preventDefault();
          break;
        case 39:
          selectorMove.call(_this5, shiftKey, "right");
          evt.preventDefault();
          break;
        case 40:
          selectorMove.call(_this5, shiftKey, "down");
          evt.preventDefault();
          break;
        case 9:
          editor.clear();
          selectorMove.call(_this5, false, shiftKey ? "left" : "right");
          evt.preventDefault();
          break;
        case 13:
          editor.clear();
          selectorMove.call(_this5, false, shiftKey ? "up" : "down");
          evt.preventDefault();
          break;
        case 8:
          insertDeleteRowColumn.call(_this5, "delete-cell-text");
          evt.preventDefault();
          break;
      }
      if (key === "Delete") {
        insertDeleteRowColumn.call(_this5, "delete-cell-text");
        evt.preventDefault();
      } else if (keyCode >= 65 && keyCode <= 90 || keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105 || evt.key === "=") {
        dataSetCellText.call(_this5, evt.key, "input");
        editorSet.call(_this5);
      } else if (keyCode === 113) {
        editorSet.call(_this5);
      }
    }
  });
}
var Sheet = /* @__PURE__ */ function() {
  function Sheet2(targetEl, data) {
    var _this6 = this;
    _classCallCheck(this, Sheet2);
    this.eventMap = createEventEmitter();
    var _data$settings = data.settings, view = _data$settings.view, showToolbar = _data$settings.showToolbar, showContextmenu = _data$settings.showContextmenu;
    this.el = h("div", "".concat(cssPrefix, "-sheet"));
    this.toolbar = new Toolbar(data, view.width, !showToolbar);
    this.print = new Print$1(data);
    targetEl.children(this.toolbar.el, this.el, this.print.el);
    this.data = data;
    this.tableEl = h("canvas", "".concat(cssPrefix, "-table"));
    this.rowResizer = new Resizer(false, data.rows.height);
    this.colResizer = new Resizer(true, data.cols.minWidth);
    this.verticalScrollbar = new Scrollbar(true);
    this.horizontalScrollbar = new Scrollbar(false);
    this.editor = new Editor(formulas, function() {
      return _this6.getTableOffset();
    }, data.rows.height);
    this.modalValidation = new ModalValidation();
    this.contextMenu = new ContextMenu$1(function() {
      return _this6.getRect();
    }, !showContextmenu);
    this.selector = new Selector(data);
    this.overlayerCEl = h("div", "".concat(cssPrefix, "-overlayer-content")).children(this.editor.el, this.selector.el);
    this.overlayerEl = h("div", "".concat(cssPrefix, "-overlayer")).child(this.overlayerCEl);
    this.sortFilter = new SortFilter();
    this.el.children(this.tableEl, this.overlayerEl.el, this.rowResizer.el, this.colResizer.el, this.verticalScrollbar.el, this.horizontalScrollbar.el, this.contextMenu.el, this.modalValidation.el, this.sortFilter.el);
    this.table = new Table(this.tableEl.el, data);
    sheetInitEvents.call(this);
    sheetReset.call(this);
    selectorSet.call(this, false, 0, 0);
  }
  _createClass(Sheet2, [{
    key: "on",
    value: function on(eventName, func) {
      this.eventMap.on(eventName, func);
      return this;
    }
  }, {
    key: "trigger",
    value: function trigger(eventName) {
      var eventMap = this.eventMap;
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      eventMap.fire(eventName, args);
    }
  }, {
    key: "resetData",
    value: function resetData(data) {
      this.editor.clear();
      this.data = data;
      verticalScrollbarSet.call(this);
      horizontalScrollbarSet.call(this);
      this.toolbar.resetData(data);
      this.print.resetData(data);
      this.selector.resetData(data);
      this.table.resetData(data);
    }
  }, {
    key: "loadData",
    value: function loadData(data) {
      this.data.setData(data);
      sheetReset.call(this);
      return this;
    }
    // freeze rows or cols
  }, {
    key: "freeze",
    value: function freeze(ri, ci) {
      var data = this.data;
      data.setFreeze(ri, ci);
      sheetReset.call(this);
      return this;
    }
  }, {
    key: "undo",
    value: function undo() {
      this.data.undo();
      sheetReset.call(this);
    }
  }, {
    key: "redo",
    value: function redo() {
      this.data.redo();
      sheetReset.call(this);
    }
  }, {
    key: "reload",
    value: function reload() {
      sheetReset.call(this);
      return this;
    }
  }, {
    key: "getRect",
    value: function getRect() {
      var data = this.data;
      return {
        width: data.viewWidth(),
        height: data.viewHeight()
      };
    }
  }, {
    key: "getTableOffset",
    value: function getTableOffset() {
      var _this$data = this.data, rows = _this$data.rows, cols = _this$data.cols;
      var _this$getRect = this.getRect(), width2 = _this$getRect.width, height2 = _this$getRect.height;
      return {
        width: width2 - cols.indexWidth,
        height: height2 - rows.height,
        left: cols.indexWidth,
        top: rows.height
      };
    }
  }]);
  return Sheet2;
}();
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var DropdownMore = /* @__PURE__ */ function(_Dropdown) {
  _inherits(DropdownMore2, _Dropdown);
  var _super = _createSuper(DropdownMore2);
  function DropdownMore2(click) {
    var _this;
    _classCallCheck(this, DropdownMore2);
    var icon = new Icon("ellipsis");
    _this = _super.call(this, icon, "auto", false, "top-left");
    _this.contentClick = click;
    return _this;
  }
  _createClass(DropdownMore2, [{
    key: "reset",
    value: function reset(items) {
      var _this2 = this;
      var eles = items.map(function(it, i) {
        return h("div", "".concat(cssPrefix, "-item")).css("width", "150px").css("font-weight", "normal").on("click", function() {
          _this2.contentClick(i);
          _this2.hide();
        }).child(it);
      });
      this.setContentChildren.apply(this, _toConsumableArray(eles));
    }
  }, {
    key: "setTitle",
    value: function setTitle() {
    }
  }]);
  return DropdownMore2;
}(Dropdown);
var menuItems = [{
  key: "delete",
  title: tf("contextmenu.deleteSheet")
}];
function buildMenuItem(item) {
  var _this3 = this;
  return h("div", "".concat(cssPrefix, "-item")).child(item.title()).on("click", function() {
    _this3.itemClick(item.key);
    _this3.hide();
  });
}
function buildMenu() {
  var _this4 = this;
  return menuItems.map(function(it) {
    return buildMenuItem.call(_this4, it);
  });
}
var ContextMenu = /* @__PURE__ */ function() {
  function ContextMenu2() {
    var _h$css;
    _classCallCheck(this, ContextMenu2);
    this.el = (_h$css = h("div", "".concat(cssPrefix, "-contextmenu")).css("width", "160px")).children.apply(_h$css, _toConsumableArray(buildMenu.call(this))).hide();
    this.itemClick = function() {
    };
  }
  _createClass(ContextMenu2, [{
    key: "hide",
    value: function hide() {
      var el = this.el;
      el.hide();
      unbindClickoutside(el);
    }
  }, {
    key: "setOffset",
    value: function setOffset(offset) {
      var el = this.el;
      el.offset(offset);
      el.show();
      bindClickoutside(el);
    }
  }]);
  return ContextMenu2;
}();
var Bottombar = /* @__PURE__ */ function() {
  function Bottombar2() {
    var _this5 = this;
    var addFunc = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
    };
    var swapFunc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
    };
    var deleteFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
    };
    var updateFunc = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : function() {
    };
    _classCallCheck(this, Bottombar2);
    this.swapFunc = swapFunc;
    this.updateFunc = updateFunc;
    this.dataNames = [];
    this.activeEl = null;
    this.deleteEl = null;
    this.items = [];
    this.moreEl = new DropdownMore(function(i) {
      _this5.clickSwap2(_this5.items[i]);
    });
    this.contextMenu = new ContextMenu();
    this.contextMenu.itemClick = deleteFunc;
    this.el = h("div", "".concat(cssPrefix, "-bottombar")).children(this.contextMenu.el, this.menuEl = h("ul", "".concat(cssPrefix, "-menu")).child(h("li", "").children(new Icon("add").on("click", function() {
      addFunc();
    }), h("span", "").child(this.moreEl))));
  }
  _createClass(Bottombar2, [{
    key: "addItem",
    value: function addItem(name, active) {
      var _this6 = this;
      this.dataNames.push(name);
      var item = h("li", active ? "active" : "").child(name);
      item.on("click", function() {
        _this6.clickSwap2(item);
      }).on("contextmenu", function(evt) {
        var _evt$target = evt.target, offsetLeft = _evt$target.offsetLeft, offsetHeight = _evt$target.offsetHeight;
        _this6.contextMenu.setOffset({
          left: offsetLeft,
          bottom: offsetHeight + 1
        });
        _this6.deleteEl = item;
      }).on("dblclick", function() {
        var v = item.html();
        var input = new FormInput("auto", "");
        input.val(v);
        input.input.on("blur", function(_ref) {
          var target = _ref.target;
          var value = target.value;
          var nindex = _this6.dataNames.findIndex(function(it) {
            return it === v;
          });
          _this6.renameItem(nindex, value);
        });
        item.html("").child(input.el);
        input.focus();
      });
      if (active) {
        this.clickSwap(item);
      }
      this.items.push(item);
      this.menuEl.child(item);
      this.moreEl.reset(this.dataNames);
    }
  }, {
    key: "renameItem",
    value: function renameItem(index2, value) {
      this.dataNames.splice(index2, 1, value);
      this.moreEl.reset(this.dataNames);
      this.items[index2].html("").child(value);
      this.updateFunc(index2, value);
    }
  }, {
    key: "clear",
    value: function clear() {
      var _this7 = this;
      this.items.forEach(function(it) {
        _this7.menuEl.removeChild(it.el);
      });
      this.items = [];
      this.dataNames = [];
      this.moreEl.reset(this.dataNames);
    }
  }, {
    key: "deleteItem",
    value: function deleteItem() {
      var activeEl = this.activeEl, deleteEl = this.deleteEl;
      if (this.items.length > 1) {
        var index2 = this.items.findIndex(function(it) {
          return it === deleteEl;
        });
        this.items.splice(index2, 1);
        this.dataNames.splice(index2, 1);
        this.menuEl.removeChild(deleteEl.el);
        this.moreEl.reset(this.dataNames);
        if (activeEl === deleteEl) {
          var _this$items = _slicedToArray(this.items, 1), f = _this$items[0];
          this.activeEl = f;
          this.activeEl.toggle();
          return [index2, 0];
        }
        return [index2, -1];
      }
      return [-1];
    }
  }, {
    key: "clickSwap2",
    value: function clickSwap2(item) {
      var index2 = this.items.findIndex(function(it) {
        return it === item;
      });
      this.clickSwap(item);
      this.activeEl.toggle();
      this.swapFunc(index2);
    }
  }, {
    key: "clickSwap",
    value: function clickSwap(item) {
      if (this.activeEl !== null) {
        this.activeEl.toggle();
      }
      this.activeEl = item;
    }
  }]);
  return Bottombar2;
}();
const index = "";
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var Spreadsheet = /* @__PURE__ */ function() {
  function Spreadsheet2(selectors) {
    var _this = this;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Spreadsheet2);
    var targetEl = selectors;
    this.options = _objectSpread$2({
      showBottomBar: true
    }, options);
    this.sheetIndex = 1;
    this.datas = [];
    if (typeof selectors === "string") {
      targetEl = document.querySelector(selectors);
    }
    this.bottombar = this.options.showBottomBar ? new Bottombar(function() {
      var d = _this.addSheet();
      _this.sheet.resetData(d);
    }, function(index2) {
      var d = _this.datas[index2];
      _this.sheet.resetData(d);
    }, function() {
      _this.deleteSheet();
    }, function(index2, value) {
      _this.datas[index2].name = value;
    }) : null;
    this.data = this.addSheet();
    var rootEl = h("div", "".concat(cssPrefix)).on("contextmenu", function(evt) {
      return evt.preventDefault();
    });
    targetEl.appendChild(rootEl.el);
    this.sheet = new Sheet(rootEl, this.data);
    if (this.bottombar !== null) {
      rootEl.child(this.bottombar.el);
    }
  }
  _createClass(Spreadsheet2, [{
    key: "addSheet",
    value: function addSheet(name) {
      var _this2 = this;
      var active = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      var n = name || "sheet".concat(this.sheetIndex);
      var d = new DataProxy(n, this.options);
      d.change = function() {
        var _this2$sheet;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        (_this2$sheet = _this2.sheet).trigger.apply(_this2$sheet, ["change"].concat(args));
      };
      this.datas.push(d);
      if (this.bottombar !== null) {
        this.bottombar.addItem(n, active);
      }
      this.sheetIndex += 1;
      return d;
    }
  }, {
    key: "deleteSheet",
    value: function deleteSheet() {
      if (this.bottombar === null)
        return;
      var _this$bottombar$delet = this.bottombar.deleteItem(), _this$bottombar$delet2 = _slicedToArray(_this$bottombar$delet, 2), oldIndex = _this$bottombar$delet2[0], nindex = _this$bottombar$delet2[1];
      if (oldIndex >= 0) {
        this.datas.splice(oldIndex, 1);
        if (nindex >= 0)
          this.sheet.resetData(this.datas[nindex]);
      }
    }
  }, {
    key: "loadData",
    value: function loadData(data) {
      var ds = Array.isArray(data) ? data : [data];
      if (this.bottombar !== null) {
        this.bottombar.clear();
      }
      this.datas = [];
      if (ds.length > 0) {
        for (var i = 0; i < ds.length; i += 1) {
          var it = ds[i];
          var nd = this.addSheet(it.name, i === 0);
          nd.setData(it);
          if (i === 0) {
            this.sheet.resetData(nd);
          }
        }
      }
      return this;
    }
  }, {
    key: "getData",
    value: function getData2() {
      return this.datas.map(function(it) {
        return it.getData();
      });
    }
  }, {
    key: "cellText",
    value: function cellText(ri, ci, text) {
      var sheetIndex = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      this.datas[sheetIndex].setCellText(ri, ci, text, "finished");
      return this;
    }
  }, {
    key: "cell",
    value: function cell(ri, ci) {
      var sheetIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      return this.datas[sheetIndex].getCell(ri, ci);
    }
  }, {
    key: "cellStyle",
    value: function cellStyle(ri, ci) {
      var sheetIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      return this.datas[sheetIndex].getCellStyle(ri, ci);
    }
  }, {
    key: "reRender",
    value: function reRender() {
      this.sheet.table.render();
      return this;
    }
  }, {
    key: "on",
    value: function on(eventName, func) {
      this.sheet.on(eventName, func);
      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var validations = this.data.validations;
      return validations.errors.size <= 0;
    }
  }, {
    key: "change",
    value: function change(cb) {
      this.sheet.on("change", cb);
      return this;
    }
  }], [{
    key: "locale",
    value: function locale$1(lang, message) {
      locale(lang, message);
    }
  }]);
  return Spreadsheet2;
}();
var spreadsheet = function spreadsheet2(el) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new Spreadsheet(el, options);
};
if (window) {
  window.x_spreadsheet = spreadsheet;
  window.x_spreadsheet.locale = function(lang, message) {
    return locale(lang, message);
  };
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var regeneratorRuntimeExports = {};
var regeneratorRuntime$1 = {
  get exports() {
    return regeneratorRuntimeExports;
  },
  set exports(v) {
    regeneratorRuntimeExports = v;
  }
};
var _typeofExports = {};
var _typeof$1 = {
  get exports() {
    return _typeofExports;
  },
  set exports(v) {
    _typeofExports = v;
  }
};
(function(module) {
  function _typeof2(obj) {
    "@babel/helpers - typeof";
    return module.exports = _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof2(obj);
  }
  module.exports = _typeof2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(_typeof$1);
(function(module) {
  var _typeof2 = _typeofExports["default"];
  function _regeneratorRuntime() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    module.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
      return exports;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
      obj[key] = desc.value;
    }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function define2(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
      return defineProperty(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self2, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg, value = result.value;
          return value && "object" == _typeof2(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
            invoke("next", value2, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty(this, "_invoke", {
        value: function value(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self2, context) {
      var state = "suspendedStart";
      return function(method, arg) {
        if ("executing" === state)
          throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method)
            throw arg;
          return {
            value: void 0,
            done: true
          };
        }
        for (context.method = method, context.arg = arg; ; ) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if ("next" === context.method)
            context.sent = context._sent = context.arg;
          else if ("throw" === context.method) {
            if ("suspendedStart" === state)
              throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else
            "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self2, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method, method = delegate.iterator[methodName];
      if (void 0 === method)
        return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type)
        return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(iterable) {
      if (iterable || "" === iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod)
          return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next)
          return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next2() {
            for (; ++i < iterable.length; )
              if (hasOwn.call(iterable, i))
                return next2.value = iterable[i], next2.done = false, next2;
            return next2.value = void 0, next2.done = true, next2;
          };
          return next.next = next;
        }
      }
      throw new TypeError(_typeof2(iterable) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
      return this;
    }), define(Gp, "toString", function() {
      return "[object Generator]";
    }), exports.keys = function(val) {
      var object = Object(val), keys = [];
      for (var key in object)
        keys.push(key);
      return keys.reverse(), function next() {
        for (; keys.length; ) {
          var key2 = keys.pop();
          if (key2 in object)
            return next.value = key2, next.done = false, next;
        }
        return next.done = true, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
          for (var name in this)
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
      },
      stop: function stop() {
        this.done = true;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type)
          throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done)
          throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i], record = entry.completion;
          if ("root" === entry.tryLoc)
            return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
            } else {
              if (!hasFinally)
                throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if ("throw" === record.type)
          throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc)
            return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
      }
    }, exports;
  }
  module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(regeneratorRuntime$1);
var runtime = regeneratorRuntimeExports();
var regenerator = runtime;
try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var exceljsExports = {};
var exceljs = {
  get exports() {
    return exceljsExports;
  },
  set exports(v) {
    exceljsExports = v;
  }
};
(function(module, exports) {
  (function(f) {
    {
      module.exports = f();
    }
  })(function() {
    return function() {
      function r(e, n, t2) {
        function o(i2, f) {
          if (!n[i2]) {
            if (!e[i2]) {
              var c = "function" == typeof commonjsRequire && commonjsRequire;
              if (!f && c)
                return c(i2, true);
              if (u)
                return u(i2, true);
              var a = new Error("Cannot find module '" + i2 + "'");
              throw a.code = "MODULE_NOT_FOUND", a;
            }
            var p = n[i2] = { exports: {} };
            e[i2][0].call(p.exports, function(r2) {
              var n2 = e[i2][1][r2];
              return o(n2 || r2);
            }, p, p.exports, r, e, n, t2);
          }
          return n[i2].exports;
        }
        for (var u = "function" == typeof commonjsRequire && commonjsRequire, i = 0; i < t2.length; i++)
          o(t2[i]);
        return o;
      }
      return r;
    }()({ 1: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator2(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var fs = require2("fs");
      var fastCsv = require2("fast-csv");
      var customParseFormat = require2("dayjs/plugin/customParseFormat");
      var utc = require2("dayjs/plugin/utc");
      var dayjs2 = require2("dayjs").extend(customParseFormat).extend(utc);
      var StreamBuf = require2("../utils/stream-buf");
      var _require = require2("../utils/utils"), exists = _require.fs.exists;
      var SpecialValues = { true: true, false: false, "#N/A": { error: "#N/A" }, "#REF!": { error: "#REF!" }, "#NAME?": { error: "#NAME?" }, "#DIV/0!": { error: "#DIV/0!" }, "#NULL!": { error: "#NULL!" }, "#VALUE!": { error: "#VALUE!" }, "#NUM!": { error: "#NUM!" } };
      var CSV = /* @__PURE__ */ function() {
        function CSV2(workbook) {
          _classCallCheck2(this, CSV2);
          this.workbook = workbook;
          this.worksheet = null;
        }
        _createClass2(CSV2, [{ key: "readFile", value: function() {
          var _readFile = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee(filename, options) {
            var stream, worksheet;
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    options = options || {};
                    _context.next = 3;
                    return exists(filename);
                  case 3:
                    if (_context.sent) {
                      _context.next = 5;
                      break;
                    }
                    throw new Error("File not found: ".concat(filename));
                  case 5:
                    stream = fs.createReadStream(filename);
                    _context.next = 8;
                    return this.read(stream, options);
                  case 8:
                    worksheet = _context.sent;
                    stream.close();
                    return _context.abrupt("return", worksheet);
                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function readFile(_x, _x2) {
            return _readFile.apply(this, arguments);
          }
          return readFile;
        }() }, {
          key: "read",
          value: function read(stream, options) {
            var _this = this;
            options = options || {};
            return new Promise(function(resolve, reject) {
              var worksheet = _this.workbook.addWorksheet(options.sheetName);
              var dateFormats = options.dateFormats || ["YYYY-MM-DD[T]HH:mm:ssZ", "YYYY-MM-DD[T]HH:mm:ss", "MM-DD-YYYY", "YYYY-MM-DD"];
              var map = options.map || function(datum) {
                if (datum === "") {
                  return null;
                }
                var datumNumber = Number(datum);
                if (!Number.isNaN(datumNumber) && datumNumber !== Infinity) {
                  return datumNumber;
                }
                var dt = dateFormats.reduce(function(matchingDate, currentDateFormat) {
                  if (matchingDate) {
                    return matchingDate;
                  }
                  var dayjsObj = dayjs2(datum, currentDateFormat, true);
                  if (dayjsObj.isValid()) {
                    return dayjsObj;
                  }
                  return null;
                }, null);
                if (dt) {
                  return new Date(dt.valueOf());
                }
                var special = SpecialValues[datum];
                if (special !== void 0) {
                  return special;
                }
                return datum;
              };
              var csvStream = fastCsv.parse(options.parserOptions).on("data", function(data) {
                worksheet.addRow(data.map(map));
              }).on("end", function() {
                csvStream.emit("worksheet", worksheet);
              });
              csvStream.on("worksheet", resolve).on("error", reject);
              stream.pipe(csvStream);
            });
          }
          /**
          * @deprecated since version 4.0. You should use `CSV#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
          */
        }, { key: "createInputStream", value: function createInputStream() {
          throw new Error("`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md");
        } }, { key: "write", value: function write(stream, options) {
          var _this2 = this;
          return new Promise(function(resolve, reject) {
            options = options || {};
            var worksheet = _this2.workbook.getWorksheet(options.sheetName || options.sheetId);
            var csvStream = fastCsv.format(options.formatterOptions);
            stream.on("finish", function() {
              resolve();
            });
            csvStream.on("error", reject);
            csvStream.pipe(stream);
            var _options = options, dateFormat2 = _options.dateFormat, dateUTC = _options.dateUTC;
            var map = options.map || function(value) {
              if (value) {
                if (value.text || value.hyperlink) {
                  return value.hyperlink || value.text || "";
                }
                if (value.formula || value.result) {
                  return value.result || "";
                }
                if (value instanceof Date) {
                  if (dateFormat2) {
                    return dateUTC ? dayjs2.utc(value).format(dateFormat2) : dayjs2(value).format(dateFormat2);
                  }
                  return dateUTC ? dayjs2.utc(value).format() : dayjs2(value).format();
                }
                if (value.error) {
                  return value.error;
                }
                if (_typeof2(value) === "object") {
                  return JSON.stringify(value);
                }
              }
              return value;
            };
            var includeEmptyRows = options.includeEmptyRows === void 0 || options.includeEmptyRows;
            var lastRow = 1;
            if (worksheet) {
              worksheet.eachRow(function(row, rowNumber) {
                if (includeEmptyRows) {
                  while (lastRow++ < rowNumber - 1) {
                    csvStream.write([]);
                  }
                }
                var values = row.values;
                values.shift();
                csvStream.write(values.map(map));
                lastRow = rowNumber;
              });
            }
            csvStream.end();
          });
        } }, { key: "writeFile", value: function writeFile(filename, options) {
          options = options || {};
          var streamOptions = { encoding: options.encoding || "utf8" };
          var stream = fs.createWriteStream(filename, streamOptions);
          return this.write(stream, options);
        } }, { key: "writeBuffer", value: function() {
          var _writeBuffer = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee2(options) {
            var stream;
            return regenerator.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    stream = new StreamBuf();
                    _context2.next = 3;
                    return this.write(stream, options);
                  case 3:
                    return _context2.abrupt("return", stream.read());
                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function writeBuffer(_x3) {
            return _writeBuffer.apply(this, arguments);
          }
          return writeBuffer;
        }() }]);
        return CSV2;
      }();
      module2.exports = CSV;
    }, { "../utils/stream-buf": 23, "../utils/utils": 26, "dayjs": 336, "dayjs/plugin/customParseFormat": 337, "dayjs/plugin/utc": 338, "fast-csv": 369, "fs": 215 }], 2: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var colCache = require2("../utils/col-cache");
      var Anchor = /* @__PURE__ */ function() {
        function Anchor2(worksheet, address) {
          var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          _classCallCheck2(this, Anchor2);
          if (!address) {
            this.nativeCol = 0;
            this.nativeColOff = 0;
            this.nativeRow = 0;
            this.nativeRowOff = 0;
          } else if (typeof address === "string") {
            var decoded = colCache.decodeAddress(address);
            this.nativeCol = decoded.col + offset;
            this.nativeColOff = 0;
            this.nativeRow = decoded.row + offset;
            this.nativeRowOff = 0;
          } else if (address.nativeCol !== void 0) {
            this.nativeCol = address.nativeCol || 0;
            this.nativeColOff = address.nativeColOff || 0;
            this.nativeRow = address.nativeRow || 0;
            this.nativeRowOff = address.nativeRowOff || 0;
          } else if (address.col !== void 0) {
            this.col = address.col + offset;
            this.row = address.row + offset;
          } else {
            this.nativeCol = 0;
            this.nativeColOff = 0;
            this.nativeRow = 0;
            this.nativeRowOff = 0;
          }
          this.worksheet = worksheet;
        }
        _createClass2(Anchor2, [{ key: "col", get: function get() {
          return this.nativeCol + Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth;
        }, set: function set(v) {
          this.nativeCol = Math.floor(v);
          this.nativeColOff = Math.floor((v - this.nativeCol) * this.colWidth);
        } }, { key: "row", get: function get() {
          return this.nativeRow + Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight;
        }, set: function set(v) {
          this.nativeRow = Math.floor(v);
          this.nativeRowOff = Math.floor((v - this.nativeRow) * this.rowHeight);
        } }, { key: "colWidth", get: function get() {
          return this.worksheet && this.worksheet.getColumn(this.nativeCol + 1) && this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth ? Math.floor(this.worksheet.getColumn(this.nativeCol + 1).width * 1e4) : 64e4;
        } }, { key: "rowHeight", get: function get() {
          return this.worksheet && this.worksheet.getRow(this.nativeRow + 1) && this.worksheet.getRow(this.nativeRow + 1).height ? Math.floor(this.worksheet.getRow(this.nativeRow + 1).height * 1e4) : 18e4;
        } }, { key: "model", get: function get() {
          return { nativeCol: this.nativeCol, nativeColOff: this.nativeColOff, nativeRow: this.nativeRow, nativeRowOff: this.nativeRowOff };
        }, set: function set(value) {
          this.nativeCol = value.nativeCol;
          this.nativeColOff = value.nativeColOff;
          this.nativeRow = value.nativeRow;
          this.nativeRowOff = value.nativeRowOff;
        } }], [{ key: "asInstance", value: function asInstance(model) {
          return model instanceof Anchor2 || model == null ? model : new Anchor2(model);
        } }]);
        return Anchor2;
      }();
      module2.exports = Anchor;
    }, { "../utils/col-cache": 19 }], 3: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var colCache = require2("../utils/col-cache");
      var _ = require2("../utils/under-dash");
      var Enums = require2("./enums");
      var _require = require2("../utils/shared-formula"), slideFormula = _require.slideFormula;
      var Note = require2("./note");
      var Cell = /* @__PURE__ */ function() {
        function Cell2(row, column, address) {
          _classCallCheck2(this, Cell2);
          if (!row || !column) {
            throw new Error("A Cell needs a Row");
          }
          this._row = row;
          this._column = column;
          colCache.validateAddress(address);
          this._address = address;
          this._value = Value.create(Cell2.Types.Null, this);
          this.style = this._mergeStyle(row.style, column.style, {});
          this._mergeCount = 0;
        }
        _createClass2(Cell2, [{
          key: "destroy",
          // help GC by removing cyclic (and other) references
          value: function destroy() {
            delete this.style;
            delete this._value;
            delete this._row;
            delete this._column;
            delete this._address;
          }
          // =========================================================================
          // Styles stuff
        }, {
          key: "_mergeStyle",
          value: function _mergeStyle(rowStyle, colStyle, style) {
            var numFmt = rowStyle && rowStyle.numFmt || colStyle && colStyle.numFmt;
            if (numFmt)
              style.numFmt = numFmt;
            var font = rowStyle && rowStyle.font || colStyle && colStyle.font;
            if (font)
              style.font = font;
            var alignment = rowStyle && rowStyle.alignment || colStyle && colStyle.alignment;
            if (alignment)
              style.alignment = alignment;
            var border = rowStyle && rowStyle.border || colStyle && colStyle.border;
            if (border)
              style.border = border;
            var fill = rowStyle && rowStyle.fill || colStyle && colStyle.fill;
            if (fill)
              style.fill = fill;
            var protection = rowStyle && rowStyle.protection || colStyle && colStyle.protection;
            if (protection)
              style.protection = protection;
            return style;
          }
          // =========================================================================
          // return the address for this cell
        }, {
          key: "toCsvString",
          value: function toCsvString() {
            return this._value.toCsvString();
          }
          // =========================================================================
          // Merge stuff
        }, { key: "addMergeRef", value: function addMergeRef() {
          this._mergeCount++;
        } }, { key: "releaseMergeRef", value: function releaseMergeRef() {
          this._mergeCount--;
        } }, { key: "merge", value: function merge2(master, ignoreStyle) {
          this._value.release();
          this._value = Value.create(Cell2.Types.Merge, this, master);
          if (!ignoreStyle) {
            this.style = master.style;
          }
        } }, { key: "unmerge", value: function unmerge() {
          if (this.type === Cell2.Types.Merge) {
            this._value.release();
            this._value = Value.create(Cell2.Types.Null, this);
            this.style = this._mergeStyle(this._row.style, this._column.style, {});
          }
        } }, { key: "isMergedTo", value: function isMergedTo(master) {
          if (this._value.type !== Cell2.Types.Merge)
            return false;
          return this._value.isMergedTo(master);
        } }, { key: "toString", value: function toString2() {
          return this.text;
        } }, {
          key: "_upgradeToHyperlink",
          value: function _upgradeToHyperlink(hyperlink) {
            if (this.type === Cell2.Types.String) {
              this._value = Value.create(Cell2.Types.Hyperlink, this, { text: this._value.value, hyperlink });
            }
          }
          // =========================================================================
          // Formula stuff
        }, { key: "addName", value: function addName(name) {
          this.workbook.definedNames.addEx(this.fullAddress, name);
        } }, { key: "removeName", value: function removeName(name) {
          this.workbook.definedNames.removeEx(this.fullAddress, name);
        } }, {
          key: "removeAllNames",
          value: function removeAllNames() {
            this.workbook.definedNames.removeAllNames(this.fullAddress);
          }
          // =========================================================================
          // Data Validation stuff
        }, { key: "worksheet", get: function get() {
          return this._row.worksheet;
        } }, { key: "workbook", get: function get() {
          return this._row.worksheet.workbook;
        } }, { key: "numFmt", get: function get() {
          return this.style.numFmt;
        }, set: function set(value) {
          this.style.numFmt = value;
        } }, { key: "font", get: function get() {
          return this.style.font;
        }, set: function set(value) {
          this.style.font = value;
        } }, { key: "alignment", get: function get() {
          return this.style.alignment;
        }, set: function set(value) {
          this.style.alignment = value;
        } }, { key: "border", get: function get() {
          return this.style.border;
        }, set: function set(value) {
          this.style.border = value;
        } }, { key: "fill", get: function get() {
          return this.style.fill;
        }, set: function set(value) {
          this.style.fill = value;
        } }, { key: "protection", get: function get() {
          return this.style.protection;
        }, set: function set(value) {
          this.style.protection = value;
        } }, { key: "address", get: function get() {
          return this._address;
        } }, { key: "row", get: function get() {
          return this._row.number;
        } }, { key: "col", get: function get() {
          return this._column.number;
        } }, {
          key: "$col$row",
          get: function get() {
            return "$".concat(this._column.letter, "$").concat(this.row);
          }
          // =========================================================================
          // Value stuff
        }, { key: "type", get: function get() {
          return this._value.type;
        } }, { key: "effectiveType", get: function get() {
          return this._value.effectiveType;
        } }, { key: "isMerged", get: function get() {
          return this._mergeCount > 0 || this.type === Cell2.Types.Merge;
        } }, { key: "master", get: function get() {
          if (this.type === Cell2.Types.Merge) {
            return this._value.master;
          }
          return this;
        } }, { key: "isHyperlink", get: function get() {
          return this._value.type === Cell2.Types.Hyperlink;
        } }, {
          key: "hyperlink",
          get: function get() {
            return this._value.hyperlink;
          }
          // return the value
        }, {
          key: "value",
          get: function get() {
            return this._value.value;
          },
          set: function set(v) {
            if (this.type === Cell2.Types.Merge) {
              this._value.master.value = v;
              return;
            }
            this._value.release();
            this._value = Value.create(Value.getType(v), this, v);
          }
        }, { key: "note", get: function get() {
          return this._comment && this._comment.note;
        }, set: function set(note) {
          this._comment = new Note(note);
        } }, { key: "text", get: function get() {
          return this._value.toString();
        } }, { key: "html", get: function get() {
          return _.escapeHtml(this.text);
        } }, { key: "formula", get: function get() {
          return this._value.formula;
        } }, { key: "result", get: function get() {
          return this._value.result;
        } }, {
          key: "formulaType",
          get: function get() {
            return this._value.formulaType;
          }
          // =========================================================================
          // Name stuff
        }, { key: "fullAddress", get: function get() {
          var worksheet = this._row.worksheet;
          return { sheetName: worksheet.name, address: this.address, row: this.row, col: this.col };
        } }, { key: "name", get: function get() {
          return this.names[0];
        }, set: function set(value) {
          this.names = [value];
        } }, { key: "names", get: function get() {
          return this.workbook.definedNames.getNamesEx(this.fullAddress);
        }, set: function set(value) {
          var _this = this;
          var definedNames = this.workbook.definedNames;
          definedNames.removeAllNames(this.fullAddress);
          value.forEach(function(name) {
            definedNames.addEx(_this.fullAddress, name);
          });
        } }, { key: "_dataValidations", get: function get() {
          return this.worksheet.dataValidations;
        } }, {
          key: "dataValidation",
          get: function get() {
            return this._dataValidations.find(this.address);
          },
          set: function set(value) {
            this._dataValidations.add(this.address, value);
          }
          // =========================================================================
          // Model stuff
        }, { key: "model", get: function get() {
          var model = this._value.model;
          model.style = this.style;
          if (this._comment) {
            model.comment = this._comment.model;
          }
          return model;
        }, set: function set(value) {
          this._value.release();
          this._value = Value.create(value.type, this);
          this._value.model = value;
          if (value.comment) {
            switch (value.comment.type) {
              case "note":
                this._comment = Note.fromModel(value.comment);
                break;
            }
          }
          if (value.style) {
            this.style = value.style;
          } else {
            this.style = {};
          }
        } }]);
        return Cell2;
      }();
      Cell.Types = Enums.ValueType;
      var NullValue = /* @__PURE__ */ function() {
        function NullValue2(cell) {
          _classCallCheck2(this, NullValue2);
          this.model = { address: cell.address, type: Cell.Types.Null };
        }
        _createClass2(NullValue2, [{ key: "toCsvString", value: function toCsvString() {
          return "";
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return "";
        } }, { key: "value", get: function get() {
          return null;
        }, set: function set(value) {
        } }, { key: "type", get: function get() {
          return Cell.Types.Null;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Null;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return NullValue2;
      }();
      var NumberValue = /* @__PURE__ */ function() {
        function NumberValue2(cell, value) {
          _classCallCheck2(this, NumberValue2);
          this.model = { address: cell.address, type: Cell.Types.Number, value };
        }
        _createClass2(NumberValue2, [{ key: "toCsvString", value: function toCsvString() {
          return this.model.value.toString();
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value.toString();
        } }, { key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Number;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Number;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return NumberValue2;
      }();
      var StringValue = /* @__PURE__ */ function() {
        function StringValue2(cell, value) {
          _classCallCheck2(this, StringValue2);
          this.model = { address: cell.address, type: Cell.Types.String, value };
        }
        _createClass2(StringValue2, [{ key: "toCsvString", value: function toCsvString() {
          return '"'.concat(this.model.value.replace(/"/g, '""'), '"');
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value;
        } }, { key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.String;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.String;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return StringValue2;
      }();
      var RichTextValue = /* @__PURE__ */ function() {
        function RichTextValue2(cell, value) {
          _classCallCheck2(this, RichTextValue2);
          this.model = { address: cell.address, type: Cell.Types.String, value };
        }
        _createClass2(RichTextValue2, [{ key: "toString", value: function toString2() {
          return this.model.value.richText.map(function(t2) {
            return t2.text;
          }).join("");
        } }, { key: "toCsvString", value: function toCsvString() {
          return '"'.concat(this.text.replace(/"/g, '""'), '"');
        } }, { key: "release", value: function release() {
        } }, { key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.RichText;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.RichText;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return RichTextValue2;
      }();
      var DateValue = /* @__PURE__ */ function() {
        function DateValue2(cell, value) {
          _classCallCheck2(this, DateValue2);
          this.model = { address: cell.address, type: Cell.Types.Date, value };
        }
        _createClass2(DateValue2, [{ key: "toCsvString", value: function toCsvString() {
          return this.model.value.toISOString();
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value.toString();
        } }, { key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Date;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Date;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return DateValue2;
      }();
      var HyperlinkValue = /* @__PURE__ */ function() {
        function HyperlinkValue2(cell, value) {
          _classCallCheck2(this, HyperlinkValue2);
          this.model = { address: cell.address, type: Cell.Types.Hyperlink, text: value ? value.text : void 0, hyperlink: value ? value.hyperlink : void 0 };
          if (value && value.tooltip) {
            this.model.tooltip = value.tooltip;
          }
        }
        _createClass2(HyperlinkValue2, [{ key: "toCsvString", value: function toCsvString() {
          return this.model.hyperlink;
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.text;
        } }, { key: "value", get: function get() {
          var v = { text: this.model.text, hyperlink: this.model.hyperlink };
          if (this.model.tooltip) {
            v.tooltip = this.model.tooltip;
          }
          return v;
        }, set: function set(value) {
          this.model = { text: value.text, hyperlink: value.hyperlink };
          if (value.tooltip) {
            this.model.tooltip = value.tooltip;
          }
        } }, {
          key: "text",
          get: function get() {
            return this.model.text;
          },
          set: function set(value) {
            this.model.text = value;
          }
          /*
          get tooltip() {
            return this.model.tooltip;
          }
            set tooltip(value) {
            this.model.tooltip = value;
          } */
        }, { key: "hyperlink", get: function get() {
          return this.model.hyperlink;
        }, set: function set(value) {
          this.model.hyperlink = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Hyperlink;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Hyperlink;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return HyperlinkValue2;
      }();
      var MergeValue = /* @__PURE__ */ function() {
        function MergeValue2(cell, master) {
          _classCallCheck2(this, MergeValue2);
          this.model = { address: cell.address, type: Cell.Types.Merge, master: master ? master.address : void 0 };
          this._master = master;
          if (master) {
            master.addMergeRef();
          }
        }
        _createClass2(MergeValue2, [{ key: "isMergedTo", value: function isMergedTo(master) {
          return master === this._master;
        } }, { key: "toCsvString", value: function toCsvString() {
          return "";
        } }, { key: "release", value: function release() {
          this._master.releaseMergeRef();
        } }, { key: "toString", value: function toString2() {
          return this.value.toString();
        } }, { key: "value", get: function get() {
          return this._master.value;
        }, set: function set(value) {
          if (value instanceof Cell) {
            if (this._master) {
              this._master.releaseMergeRef();
            }
            value.addMergeRef();
            this._master = value;
          } else {
            this._master.value = value;
          }
        } }, { key: "master", get: function get() {
          return this._master;
        } }, { key: "type", get: function get() {
          return Cell.Types.Merge;
        } }, { key: "effectiveType", get: function get() {
          return this._master.effectiveType;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return MergeValue2;
      }();
      var FormulaValue = /* @__PURE__ */ function() {
        function FormulaValue2(cell, value) {
          _classCallCheck2(this, FormulaValue2);
          this.cell = cell;
          this.model = { address: cell.address, type: Cell.Types.Formula, shareType: value ? value.shareType : void 0, ref: value ? value.ref : void 0, formula: value ? value.formula : void 0, sharedFormula: value ? value.sharedFormula : void 0, result: value ? value.result : void 0 };
        }
        _createClass2(FormulaValue2, [{ key: "_copyModel", value: function _copyModel(model) {
          var copy2 = {};
          var cp = function cp2(name) {
            var value = model[name];
            if (value) {
              copy2[name] = value;
            }
          };
          cp("formula");
          cp("result");
          cp("ref");
          cp("shareType");
          cp("sharedFormula");
          return copy2;
        } }, { key: "validate", value: function validate(value) {
          switch (Value.getType(value)) {
            case Cell.Types.Null:
            case Cell.Types.String:
            case Cell.Types.Number:
            case Cell.Types.Date:
              break;
            case Cell.Types.Hyperlink:
            case Cell.Types.Formula:
            default:
              throw new Error("Cannot process that type of result value");
          }
        } }, { key: "_getTranslatedFormula", value: function _getTranslatedFormula() {
          if (!this._translatedFormula && this.model.sharedFormula) {
            var worksheet = this.cell.worksheet;
            var master = worksheet.findCell(this.model.sharedFormula);
            this._translatedFormula = master && slideFormula(master.formula, master.address, this.model.address);
          }
          return this._translatedFormula;
        } }, { key: "toCsvString", value: function toCsvString() {
          return "".concat(this.model.result || "");
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.result ? this.model.result.toString() : "";
        } }, { key: "value", get: function get() {
          return this._copyModel(this.model);
        }, set: function set(value) {
          this.model = this._copyModel(value);
        } }, { key: "dependencies", get: function get() {
          var ranges = this.formula.match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g);
          var cells = this.formula.replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g, "").match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}/g);
          return { ranges, cells };
        } }, { key: "formula", get: function get() {
          return this.model.formula || this._getTranslatedFormula();
        }, set: function set(value) {
          this.model.formula = value;
        } }, { key: "formulaType", get: function get() {
          if (this.model.formula) {
            return Enums.FormulaType.Master;
          }
          if (this.model.sharedFormula) {
            return Enums.FormulaType.Shared;
          }
          return Enums.FormulaType.None;
        } }, { key: "result", get: function get() {
          return this.model.result;
        }, set: function set(value) {
          this.model.result = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Formula;
        } }, { key: "effectiveType", get: function get() {
          var v = this.model.result;
          if (v === null || v === void 0) {
            return Enums.ValueType.Null;
          }
          if (v instanceof String || typeof v === "string") {
            return Enums.ValueType.String;
          }
          if (typeof v === "number") {
            return Enums.ValueType.Number;
          }
          if (v instanceof Date) {
            return Enums.ValueType.Date;
          }
          if (v.text && v.hyperlink) {
            return Enums.ValueType.Hyperlink;
          }
          if (v.formula) {
            return Enums.ValueType.Formula;
          }
          return Enums.ValueType.Null;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return FormulaValue2;
      }();
      var SharedStringValue = /* @__PURE__ */ function() {
        function SharedStringValue2(cell, value) {
          _classCallCheck2(this, SharedStringValue2);
          this.model = { address: cell.address, type: Cell.Types.SharedString, value };
        }
        _createClass2(SharedStringValue2, [{ key: "toCsvString", value: function toCsvString() {
          return this.model.value.toString();
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value.toString();
        } }, { key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.SharedString;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.SharedString;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return SharedStringValue2;
      }();
      var BooleanValue = /* @__PURE__ */ function() {
        function BooleanValue2(cell, value) {
          _classCallCheck2(this, BooleanValue2);
          this.model = { address: cell.address, type: Cell.Types.Boolean, value };
        }
        _createClass2(BooleanValue2, [{ key: "toCsvString", value: function toCsvString() {
          return this.model.value ? 1 : 0;
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value.toString();
        } }, { key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Boolean;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Boolean;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return BooleanValue2;
      }();
      var ErrorValue = /* @__PURE__ */ function() {
        function ErrorValue2(cell, value) {
          _classCallCheck2(this, ErrorValue2);
          this.model = { address: cell.address, type: Cell.Types.Error, value };
        }
        _createClass2(ErrorValue2, [{ key: "toCsvString", value: function toCsvString() {
          return this.toString();
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value.error.toString();
        } }, { key: "value", get: function get() {
          return this.model.value;
        }, set: function set(value) {
          this.model.value = value;
        } }, { key: "type", get: function get() {
          return Cell.Types.Error;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.Error;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return ErrorValue2;
      }();
      var JSONValue = /* @__PURE__ */ function() {
        function JSONValue2(cell, value) {
          _classCallCheck2(this, JSONValue2);
          this.model = { address: cell.address, type: Cell.Types.String, value: JSON.stringify(value), rawValue: value };
        }
        _createClass2(JSONValue2, [{ key: "toCsvString", value: function toCsvString() {
          return this.model.value;
        } }, { key: "release", value: function release() {
        } }, { key: "toString", value: function toString2() {
          return this.model.value;
        } }, { key: "value", get: function get() {
          return this.model.rawValue;
        }, set: function set(value) {
          this.model.rawValue = value;
          this.model.value = JSON.stringify(value);
        } }, { key: "type", get: function get() {
          return Cell.Types.String;
        } }, { key: "effectiveType", get: function get() {
          return Cell.Types.String;
        } }, { key: "address", get: function get() {
          return this.model.address;
        }, set: function set(value) {
          this.model.address = value;
        } }]);
        return JSONValue2;
      }();
      var Value = {
        getType: function getType(value) {
          if (value === null || value === void 0) {
            return Cell.Types.Null;
          }
          if (value instanceof String || typeof value === "string") {
            return Cell.Types.String;
          }
          if (typeof value === "number") {
            return Cell.Types.Number;
          }
          if (typeof value === "boolean") {
            return Cell.Types.Boolean;
          }
          if (value instanceof Date) {
            return Cell.Types.Date;
          }
          if (value.text && value.hyperlink) {
            return Cell.Types.Hyperlink;
          }
          if (value.formula || value.sharedFormula) {
            return Cell.Types.Formula;
          }
          if (value.richText) {
            return Cell.Types.RichText;
          }
          if (value.sharedString) {
            return Cell.Types.SharedString;
          }
          if (value.error) {
            return Cell.Types.Error;
          }
          return Cell.Types.JSON;
        },
        // map valueType to constructor
        types: [{ t: Cell.Types.Null, f: NullValue }, { t: Cell.Types.Number, f: NumberValue }, { t: Cell.Types.String, f: StringValue }, { t: Cell.Types.Date, f: DateValue }, { t: Cell.Types.Hyperlink, f: HyperlinkValue }, { t: Cell.Types.Formula, f: FormulaValue }, { t: Cell.Types.Merge, f: MergeValue }, { t: Cell.Types.JSON, f: JSONValue }, { t: Cell.Types.SharedString, f: SharedStringValue }, { t: Cell.Types.RichText, f: RichTextValue }, { t: Cell.Types.Boolean, f: BooleanValue }, { t: Cell.Types.Error, f: ErrorValue }].reduce(function(p, t2) {
          p[t2.t] = t2.f;
          return p;
        }, []),
        create: function create(type, cell, value) {
          var T = this.types[type];
          if (!T) {
            throw new Error("Could not create Value of type ".concat(type));
          }
          return new T(cell, value);
        }
      };
      module2.exports = Cell;
    }, { "../utils/col-cache": 19, "../utils/shared-formula": 22, "../utils/under-dash": 25, "./enums": 7, "./note": 9 }], 4: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var _ = require2("../utils/under-dash");
      var Enums = require2("./enums");
      var colCache = require2("../utils/col-cache");
      var DEFAULT_COLUMN_WIDTH = 9;
      var Column = /* @__PURE__ */ function() {
        function Column2(worksheet, number, defn) {
          _classCallCheck2(this, Column2);
          this._worksheet = worksheet;
          this._number = number;
          if (defn !== false) {
            this.defn = defn;
          }
        }
        _createClass2(Column2, [{ key: "toString", value: function toString2() {
          return JSON.stringify({ key: this.key, width: this.width, headers: this.headers.length ? this.headers : void 0 });
        } }, { key: "equivalentTo", value: function equivalentTo(other) {
          return this.width === other.width && this.hidden === other.hidden && this.outlineLevel === other.outlineLevel && _.isEqual(this.style, other.style);
        } }, { key: "eachCell", value: function eachCell(options, iteratee) {
          var colNumber = this.number;
          if (!iteratee) {
            iteratee = options;
            options = null;
          }
          this._worksheet.eachRow(options, function(row, rowNumber) {
            iteratee(row.getCell(colNumber), rowNumber);
          });
        } }, {
          key: "_applyStyle",
          // =========================================================================
          // styles
          value: function _applyStyle(name, value) {
            this.style[name] = value;
            this.eachCell(function(cell) {
              cell[name] = value;
            });
            return value;
          }
        }, { key: "number", get: function get() {
          return this._number;
        } }, { key: "worksheet", get: function get() {
          return this._worksheet;
        } }, { key: "letter", get: function get() {
          return colCache.n2l(this._number);
        } }, { key: "isCustomWidth", get: function get() {
          return this.width !== void 0 && this.width !== DEFAULT_COLUMN_WIDTH;
        } }, { key: "defn", get: function get() {
          return { header: this._header, key: this.key, width: this.width, style: this.style, hidden: this.hidden, outlineLevel: this.outlineLevel };
        }, set: function set(value) {
          if (value) {
            this.key = value.key;
            this.width = value.width !== void 0 ? value.width : DEFAULT_COLUMN_WIDTH;
            this.outlineLevel = value.outlineLevel;
            if (value.style) {
              this.style = value.style;
            } else {
              this.style = {};
            }
            this.header = value.header;
            this._hidden = !!value.hidden;
          } else {
            delete this._header;
            delete this._key;
            delete this.width;
            this.style = {};
            this.outlineLevel = 0;
          }
        } }, { key: "headers", get: function get() {
          return this._header && this._header instanceof Array ? this._header : [this._header];
        } }, { key: "header", get: function get() {
          return this._header;
        }, set: function set(value) {
          var _this = this;
          if (value !== void 0) {
            this._header = value;
            this.headers.forEach(function(text, index2) {
              _this._worksheet.getCell(index2 + 1, _this.number).value = text;
            });
          } else {
            this._header = void 0;
          }
        } }, { key: "key", get: function get() {
          return this._key;
        }, set: function set(value) {
          var column = this._key && this._worksheet.getColumnKey(this._key);
          if (column === this) {
            this._worksheet.deleteColumnKey(this._key);
          }
          this._key = value;
          if (value) {
            this._worksheet.setColumnKey(this._key, this);
          }
        } }, { key: "hidden", get: function get() {
          return !!this._hidden;
        }, set: function set(value) {
          this._hidden = value;
        } }, { key: "outlineLevel", get: function get() {
          return this._outlineLevel || 0;
        }, set: function set(value) {
          this._outlineLevel = value;
        } }, { key: "collapsed", get: function get() {
          return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelCol);
        } }, { key: "isDefault", get: function get() {
          if (this.isCustomWidth) {
            return false;
          }
          if (this.hidden) {
            return false;
          }
          if (this.outlineLevel) {
            return false;
          }
          var s = this.style;
          if (s && (s.font || s.numFmt || s.alignment || s.border || s.fill || s.protection)) {
            return false;
          }
          return true;
        } }, { key: "headerCount", get: function get() {
          return this.headers.length;
        } }, { key: "values", get: function get() {
          var v = [];
          this.eachCell(function(cell, rowNumber) {
            if (cell && cell.type !== Enums.ValueType.Null) {
              v[rowNumber] = cell.value;
            }
          });
          return v;
        }, set: function set(v) {
          var _this2 = this;
          if (!v) {
            return;
          }
          var colNumber = this.number;
          var offset = 0;
          if (v.hasOwnProperty("0")) {
            offset = 1;
          }
          v.forEach(function(value, index2) {
            _this2._worksheet.getCell(index2 + offset, colNumber).value = value;
          });
        } }, { key: "numFmt", get: function get() {
          return this.style.numFmt;
        }, set: function set(value) {
          this._applyStyle("numFmt", value);
        } }, { key: "font", get: function get() {
          return this.style.font;
        }, set: function set(value) {
          this._applyStyle("font", value);
        } }, { key: "alignment", get: function get() {
          return this.style.alignment;
        }, set: function set(value) {
          this._applyStyle("alignment", value);
        } }, { key: "protection", get: function get() {
          return this.style.protection;
        }, set: function set(value) {
          this._applyStyle("protection", value);
        } }, { key: "border", get: function get() {
          return this.style.border;
        }, set: function set(value) {
          this._applyStyle("border", value);
        } }, {
          key: "fill",
          get: function get() {
            return this.style.fill;
          },
          set: function set(value) {
            this._applyStyle("fill", value);
          }
          // =============================================================================
          // static functions
        }], [{ key: "toModel", value: function toModel(columns) {
          var cols = [];
          var col = null;
          if (columns) {
            columns.forEach(function(column, index2) {
              if (column.isDefault) {
                if (col) {
                  col = null;
                }
              } else if (!col || !column.equivalentTo(col)) {
                col = { min: index2 + 1, max: index2 + 1, width: column.width !== void 0 ? column.width : DEFAULT_COLUMN_WIDTH, style: column.style, isCustomWidth: column.isCustomWidth, hidden: column.hidden, outlineLevel: column.outlineLevel, collapsed: column.collapsed };
                cols.push(col);
              } else {
                col.max = index2 + 1;
              }
            });
          }
          return cols.length ? cols : void 0;
        } }, { key: "fromModel", value: function fromModel(worksheet, cols) {
          cols = cols || [];
          var columns = [];
          var count = 1;
          var index2 = 0;
          while (index2 < cols.length) {
            var col = cols[index2++];
            while (count < col.min) {
              columns.push(new Column2(worksheet, count++));
            }
            while (count <= col.max) {
              columns.push(new Column2(worksheet, count++, col));
            }
          }
          return columns.length ? columns : null;
        } }]);
        return Column2;
      }();
      module2.exports = Column;
    }, { "../utils/col-cache": 19, "../utils/under-dash": 25, "./enums": 7 }], 5: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var DataValidations = /* @__PURE__ */ function() {
        function DataValidations2(model) {
          _classCallCheck2(this, DataValidations2);
          this.model = model || {};
        }
        _createClass2(DataValidations2, [{ key: "add", value: function add(address, validation) {
          return this.model[address] = validation;
        } }, { key: "find", value: function find(address) {
          return this.model[address];
        } }, { key: "remove", value: function remove(address) {
          this.model[address] = void 0;
        } }]);
        return DataValidations2;
      }();
      module2.exports = DataValidations;
    }, {}], 6: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var _ = require2("../utils/under-dash");
      var colCache = require2("../utils/col-cache");
      var CellMatrix = require2("../utils/cell-matrix");
      var Range = require2("./range");
      var rangeRegexp = /[$](\w+)[$](\d+)(:[$](\w+)[$](\d+))?/;
      var DefinedNames = /* @__PURE__ */ function() {
        function DefinedNames2() {
          _classCallCheck2(this, DefinedNames2);
          this.matrixMap = {};
        }
        _createClass2(DefinedNames2, [{
          key: "getMatrix",
          value: function getMatrix(name) {
            var matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix());
            return matrix;
          }
          // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2
        }, { key: "add", value: function add(locStr, name) {
          var location = colCache.decodeEx(locStr);
          this.addEx(location, name);
        } }, { key: "addEx", value: function addEx(location, name) {
          var matrix = this.getMatrix(name);
          if (location.top) {
            for (var col = location.left; col <= location.right; col++) {
              for (var row = location.top; row <= location.bottom; row++) {
                var address = { sheetName: location.sheetName, address: colCache.n2l(col) + row, row, col };
                matrix.addCellEx(address);
              }
            }
          } else {
            matrix.addCellEx(location);
          }
        } }, { key: "remove", value: function remove(locStr, name) {
          var location = colCache.decodeEx(locStr);
          this.removeEx(location, name);
        } }, { key: "removeEx", value: function removeEx(location, name) {
          var matrix = this.getMatrix(name);
          matrix.removeCellEx(location);
        } }, { key: "removeAllNames", value: function removeAllNames(location) {
          _.each(this.matrixMap, function(matrix) {
            matrix.removeCellEx(location);
          });
        } }, {
          key: "forEach",
          value: function forEach(callback) {
            _.each(this.matrixMap, function(matrix, name) {
              matrix.forEach(function(cell) {
                callback(name, cell);
              });
            });
          }
          // get all the names of a cell
        }, { key: "getNames", value: function getNames(addressStr) {
          return this.getNamesEx(colCache.decodeEx(addressStr));
        } }, { key: "getNamesEx", value: function getNamesEx(address) {
          return _.map(this.matrixMap, function(matrix, name) {
            return matrix.findCellEx(address) && name;
          }).filter(Boolean);
        } }, { key: "_explore", value: function _explore(matrix, cell) {
          cell.mark = false;
          var sheetName = cell.sheetName;
          var range = new Range(cell.row, cell.col, cell.row, cell.col, sheetName);
          var x;
          var y;
          function vGrow(yy, edge) {
            var c = matrix.findCellAt(sheetName, yy, cell.col);
            if (!c || !c.mark) {
              return false;
            }
            range[edge] = yy;
            c.mark = false;
            return true;
          }
          for (y = cell.row - 1; vGrow(y, "top"); y--) {
          }
          for (y = cell.row + 1; vGrow(y, "bottom"); y++) {
          }
          function hGrow(xx, edge) {
            var cells = [];
            for (y = range.top; y <= range.bottom; y++) {
              var c = matrix.findCellAt(sheetName, y, xx);
              if (c && c.mark) {
                cells.push(c);
              } else {
                return false;
              }
            }
            range[edge] = xx;
            for (var i = 0; i < cells.length; i++) {
              cells[i].mark = false;
            }
            return true;
          }
          for (x = cell.col - 1; hGrow(x, "left"); x--) {
          }
          for (x = cell.col + 1; hGrow(x, "right"); x++) {
          }
          return range;
        } }, { key: "getRanges", value: function getRanges(name, matrix) {
          var _this = this;
          matrix = matrix || this.matrixMap[name];
          if (!matrix) {
            return { name, ranges: [] };
          }
          matrix.forEach(function(cell) {
            cell.mark = true;
          });
          var ranges = matrix.map(function(cell) {
            return cell.mark && _this._explore(matrix, cell);
          }).filter(Boolean).map(function(range) {
            return range.$shortRange;
          });
          return { name, ranges };
        } }, { key: "normaliseMatrix", value: function normaliseMatrix(matrix, sheetName) {
          matrix.forEachInSheet(sheetName, function(cell, row, col) {
            if (cell) {
              if (cell.row !== row || cell.col !== col) {
                cell.row = row;
                cell.col = col;
                cell.address = colCache.n2l(col) + row;
              }
            }
          });
        } }, { key: "spliceRows", value: function spliceRows(sheetName, start, numDelete, numInsert) {
          var _this2 = this;
          _.each(this.matrixMap, function(matrix) {
            matrix.spliceRows(sheetName, start, numDelete, numInsert);
            _this2.normaliseMatrix(matrix, sheetName);
          });
        } }, { key: "spliceColumns", value: function spliceColumns(sheetName, start, numDelete, numInsert) {
          var _this3 = this;
          _.each(this.matrixMap, function(matrix) {
            matrix.spliceColumns(sheetName, start, numDelete, numInsert);
            _this3.normaliseMatrix(matrix, sheetName);
          });
        } }, { key: "model", get: function get() {
          var _this4 = this;
          return _.map(this.matrixMap, function(matrix, name) {
            return _this4.getRanges(name, matrix);
          }).filter(function(definedName) {
            return definedName.ranges.length;
          });
        }, set: function set(value) {
          var matrixMap = this.matrixMap = {};
          value.forEach(function(definedName) {
            var matrix = matrixMap[definedName.name] = new CellMatrix();
            definedName.ranges.forEach(function(rangeStr) {
              if (rangeRegexp.test(rangeStr.split("!").pop() || "")) {
                matrix.addCell(rangeStr);
              }
            });
          });
        } }]);
        return DefinedNames2;
      }();
      module2.exports = DefinedNames;
    }, { "../utils/cell-matrix": 18, "../utils/col-cache": 19, "../utils/under-dash": 25, "./range": 10 }], 7: [function(require2, module2, exports2) {
      module2.exports = { ValueType: { Null: 0, Merge: 1, Number: 2, String: 3, Date: 4, Hyperlink: 5, Formula: 6, SharedString: 7, RichText: 8, Boolean: 9, Error: 10 }, FormulaType: { None: 0, Master: 1, Shared: 2 }, RelationshipType: { None: 0, OfficeDocument: 1, Worksheet: 2, CalcChain: 3, SharedStrings: 4, Styles: 5, Theme: 6, Hyperlink: 7 }, DocumentType: { Xlsx: 1 }, ReadingOrder: { LeftToRight: 1, RightToLeft: 2 }, ErrorValue: { NotApplicable: "#N/A", Ref: "#REF!", Name: "#NAME?", DivZero: "#DIV/0!", Null: "#NULL!", Value: "#VALUE!", Num: "#NUM!" } };
    }, {}], 8: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var colCache = require2("../utils/col-cache");
      var Anchor = require2("./anchor");
      var Image2 = /* @__PURE__ */ function() {
        function Image3(worksheet, model) {
          _classCallCheck2(this, Image3);
          this.worksheet = worksheet;
          this.model = model;
        }
        _createClass2(Image3, [{ key: "model", get: function get() {
          switch (this.type) {
            case "background":
              return { type: this.type, imageId: this.imageId };
            case "image":
              return { type: this.type, imageId: this.imageId, hyperlinks: this.range.hyperlinks, range: { tl: this.range.tl.model, br: this.range.br && this.range.br.model, ext: this.range.ext, editAs: this.range.editAs } };
            default:
              throw new Error("Invalid Image Type");
          }
        }, set: function set(_ref) {
          var type = _ref.type, imageId = _ref.imageId, range = _ref.range, hyperlinks = _ref.hyperlinks;
          this.type = type;
          this.imageId = imageId;
          if (type === "image") {
            if (typeof range === "string") {
              var decoded = colCache.decode(range);
              this.range = { tl: new Anchor(this.worksheet, { col: decoded.left, row: decoded.top }, -1), br: new Anchor(this.worksheet, { col: decoded.right, row: decoded.bottom }, 0), editAs: "oneCell" };
            } else {
              this.range = { tl: new Anchor(this.worksheet, range.tl, 0), br: range.br && new Anchor(this.worksheet, range.br, 0), ext: range.ext, editAs: range.editAs, hyperlinks: hyperlinks || range.hyperlinks };
            }
          }
        } }]);
        return Image3;
      }();
      module2.exports = Image2;
    }, { "../utils/col-cache": 19, "./anchor": 2 }], 9: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var _ = require2("../utils/under-dash");
      var Note = /* @__PURE__ */ function() {
        function Note2(note) {
          _classCallCheck2(this, Note2);
          this.note = note;
        }
        _createClass2(Note2, [{ key: "model", get: function get() {
          var value = null;
          switch (_typeof2(this.note)) {
            case "string":
              value = { type: "note", note: { texts: [{ text: this.note }] } };
              break;
            default:
              value = { type: "note", note: this.note };
              break;
          }
          return _.deepMerge({}, Note2.DEFAULT_CONFIGS, value);
        }, set: function set(value) {
          var note = value.note;
          var texts = note.texts;
          if (texts.length === 1 && Object.keys(texts[0]).length === 1) {
            this.note = texts[0].text;
          } else {
            this.note = note;
          }
        } }], [{ key: "fromModel", value: function fromModel(model) {
          var note = new Note2();
          note.model = model;
          return note;
        } }]);
        return Note2;
      }();
      Note.DEFAULT_CONFIGS = { note: { margins: { insetmode: "auto", inset: [0.13, 0.13, 0.25, 0.25] }, protection: { locked: "True", lockText: "True" }, editAs: "absolute" } };
      module2.exports = Note;
    }, { "../utils/under-dash": 25 }], 10: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var colCache = require2("../utils/col-cache");
      var Range = /* @__PURE__ */ function() {
        function Range2() {
          _classCallCheck2(this, Range2);
          this.decode(arguments);
        }
        _createClass2(Range2, [{ key: "setTLBR", value: function setTLBR(t2, l, b, r, s) {
          if (arguments.length < 4) {
            var tl = colCache.decodeAddress(t2);
            var br = colCache.decodeAddress(l);
            this.model = { top: Math.min(tl.row, br.row), left: Math.min(tl.col, br.col), bottom: Math.max(tl.row, br.row), right: Math.max(tl.col, br.col), sheetName: b };
            this.setTLBR(tl.row, tl.col, br.row, br.col, s);
          } else {
            this.model = { top: Math.min(t2, b), left: Math.min(l, r), bottom: Math.max(t2, b), right: Math.max(l, r), sheetName: s };
          }
        } }, { key: "decode", value: function decode(argv) {
          switch (argv.length) {
            case 5:
              this.setTLBR(argv[0], argv[1], argv[2], argv[3], argv[4]);
              break;
            case 4:
              this.setTLBR(argv[0], argv[1], argv[2], argv[3]);
              break;
            case 3:
              this.setTLBR(argv[0], argv[1], argv[2]);
              break;
            case 2:
              this.setTLBR(argv[0], argv[1]);
              break;
            case 1: {
              var value = argv[0];
              if (value instanceof Range2) {
                this.model = { top: value.model.top, left: value.model.left, bottom: value.model.bottom, right: value.model.right, sheetName: value.sheetName };
              } else if (value instanceof Array) {
                this.decode(value);
              } else if (value.top && value.left && value.bottom && value.right) {
                this.model = { top: value.top, left: value.left, bottom: value.bottom, right: value.right, sheetName: value.sheetName };
              } else {
                var tlbr = colCache.decodeEx(value);
                if (tlbr.top) {
                  this.model = { top: tlbr.top, left: tlbr.left, bottom: tlbr.bottom, right: tlbr.right, sheetName: tlbr.sheetName };
                } else {
                  this.model = { top: tlbr.row, left: tlbr.col, bottom: tlbr.row, right: tlbr.col, sheetName: tlbr.sheetName };
                }
              }
              break;
            }
            case 0:
              this.model = { top: 0, left: 0, bottom: 0, right: 0 };
              break;
            default:
              throw new Error("Invalid number of arguments to _getDimensions() - ".concat(argv.length));
          }
        } }, { key: "expand", value: function expand(top, left, bottom, right) {
          if (!this.model.top || top < this.top)
            this.top = top;
          if (!this.model.left || left < this.left)
            this.left = left;
          if (!this.model.bottom || bottom > this.bottom)
            this.bottom = bottom;
          if (!this.model.right || right > this.right)
            this.right = right;
        } }, { key: "expandRow", value: function expandRow(row) {
          if (row) {
            var dimensions = row.dimensions, number = row.number;
            if (dimensions) {
              this.expand(number, dimensions.min, number, dimensions.max);
            }
          }
        } }, { key: "expandToAddress", value: function expandToAddress(addressStr) {
          var address = colCache.decodeEx(addressStr);
          this.expand(address.row, address.col, address.row, address.col);
        } }, { key: "toString", value: function toString2() {
          return this.range;
        } }, { key: "intersects", value: function intersects(other) {
          if (other.sheetName && this.sheetName && other.sheetName !== this.sheetName)
            return false;
          if (other.bottom < this.top)
            return false;
          if (other.top > this.bottom)
            return false;
          if (other.right < this.left)
            return false;
          if (other.left > this.right)
            return false;
          return true;
        } }, { key: "contains", value: function contains(addressStr) {
          var address = colCache.decodeEx(addressStr);
          return this.containsEx(address);
        } }, { key: "containsEx", value: function containsEx(address) {
          if (address.sheetName && this.sheetName && address.sheetName !== this.sheetName)
            return false;
          return address.row >= this.top && address.row <= this.bottom && address.col >= this.left && address.col <= this.right;
        } }, { key: "forEachAddress", value: function forEachAddress(cb) {
          for (var col = this.left; col <= this.right; col++) {
            for (var row = this.top; row <= this.bottom; row++) {
              cb(colCache.encodeAddress(row, col), row, col);
            }
          }
        } }, { key: "top", get: function get() {
          return this.model.top || 1;
        }, set: function set(value) {
          this.model.top = value;
        } }, { key: "left", get: function get() {
          return this.model.left || 1;
        }, set: function set(value) {
          this.model.left = value;
        } }, { key: "bottom", get: function get() {
          return this.model.bottom || 1;
        }, set: function set(value) {
          this.model.bottom = value;
        } }, { key: "right", get: function get() {
          return this.model.right || 1;
        }, set: function set(value) {
          this.model.right = value;
        } }, { key: "sheetName", get: function get() {
          return this.model.sheetName;
        }, set: function set(value) {
          this.model.sheetName = value;
        } }, { key: "_serialisedSheetName", get: function get() {
          var sheetName = this.model.sheetName;
          if (sheetName) {
            if (/^[a-zA-Z0-9]*$/.test(sheetName)) {
              return "".concat(sheetName, "!");
            }
            return "'".concat(sheetName, "'!");
          }
          return "";
        } }, { key: "tl", get: function get() {
          return colCache.n2l(this.left) + this.top;
        } }, { key: "$t$l", get: function get() {
          return "$".concat(colCache.n2l(this.left), "$").concat(this.top);
        } }, { key: "br", get: function get() {
          return colCache.n2l(this.right) + this.bottom;
        } }, { key: "$b$r", get: function get() {
          return "$".concat(colCache.n2l(this.right), "$").concat(this.bottom);
        } }, { key: "range", get: function get() {
          return "".concat(this._serialisedSheetName + this.tl, ":").concat(this.br);
        } }, { key: "$range", get: function get() {
          return "".concat(this._serialisedSheetName + this.$t$l, ":").concat(this.$b$r);
        } }, { key: "shortRange", get: function get() {
          return this.count > 1 ? this.range : this._serialisedSheetName + this.tl;
        } }, { key: "$shortRange", get: function get() {
          return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l;
        } }, { key: "count", get: function get() {
          return (1 + this.bottom - this.top) * (1 + this.right - this.left);
        } }]);
        return Range2;
      }();
      module2.exports = Range;
    }, { "../utils/col-cache": 19 }], 11: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var _ = require2("../utils/under-dash");
      var Enums = require2("./enums");
      var colCache = require2("../utils/col-cache");
      var Cell = require2("./cell");
      var Row = /* @__PURE__ */ function() {
        function Row2(worksheet, number) {
          _classCallCheck2(this, Row2);
          this._worksheet = worksheet;
          this._number = number;
          this._cells = [];
          this.style = {};
          this.outlineLevel = 0;
        }
        _createClass2(Row2, [{
          key: "commit",
          // Inform Streaming Writer that this row (and all rows before it) are complete
          // and ready to write. Has no effect on Worksheet document
          value: function commit() {
            this._worksheet._commitRow(this);
          }
          // helps GC by breaking cyclic references
        }, { key: "destroy", value: function destroy() {
          delete this._worksheet;
          delete this._cells;
          delete this.style;
        } }, {
          key: "findCell",
          value: function findCell(colNumber) {
            return this._cells[colNumber - 1];
          }
          // given {address, row, col}, find or create new cell
        }, {
          key: "getCellEx",
          value: function getCellEx(address) {
            var cell = this._cells[address.col - 1];
            if (!cell) {
              var column = this._worksheet.getColumn(address.col);
              cell = new Cell(this, column, address.address);
              this._cells[address.col - 1] = cell;
            }
            return cell;
          }
          // get cell by key, letter or column number
        }, {
          key: "getCell",
          value: function getCell(col) {
            if (typeof col === "string") {
              var column = this._worksheet.getColumnKey(col);
              if (column) {
                col = column.number;
              } else {
                col = colCache.l2n(col);
              }
            }
            return this._cells[col - 1] || this.getCellEx({ address: colCache.encodeAddress(this._number, col), row: this._number, col });
          }
          // remove cell(s) and shift all higher cells down by count
        }, {
          key: "splice",
          value: function splice(start, count) {
            var nKeep = start + count;
            for (var _len = arguments.length, inserts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
              inserts[_key - 2] = arguments[_key];
            }
            var nExpand = inserts.length - count;
            var nEnd = this._cells.length;
            var i;
            var cSrc;
            var cDst;
            if (nExpand < 0) {
              for (i = start + inserts.length; i <= nEnd; i++) {
                cDst = this._cells[i - 1];
                cSrc = this._cells[i - nExpand - 1];
                if (cSrc) {
                  cDst = this.getCell(i);
                  cDst.value = cSrc.value;
                  cDst.style = cSrc.style;
                  cDst._comment = cSrc._comment;
                } else if (cDst) {
                  cDst.value = null;
                  cDst.style = {};
                  cDst._comment = void 0;
                }
              }
            } else if (nExpand > 0) {
              for (i = nEnd; i >= nKeep; i--) {
                cSrc = this._cells[i - 1];
                if (cSrc) {
                  cDst = this.getCell(i + nExpand);
                  cDst.value = cSrc.value;
                  cDst.style = cSrc.style;
                  cDst._comment = cSrc._comment;
                } else {
                  this._cells[i + nExpand - 1] = void 0;
                }
              }
            }
            for (i = 0; i < inserts.length; i++) {
              cDst = this.getCell(start + i);
              cDst.value = inserts[i];
              cDst.style = {};
              cDst._comment = void 0;
            }
          }
          // Iterate over all non-null cells in this row
        }, {
          key: "eachCell",
          value: function eachCell(options, iteratee) {
            if (!iteratee) {
              iteratee = options;
              options = null;
            }
            if (options && options.includeEmpty) {
              var n = this._cells.length;
              for (var i = 1; i <= n; i++) {
                iteratee(this.getCell(i), i);
              }
            } else {
              this._cells.forEach(function(cell, index2) {
                if (cell && cell.type !== Enums.ValueType.Null) {
                  iteratee(cell, index2 + 1);
                }
              });
            }
          }
          // ===========================================================================
          // Page Breaks
        }, {
          key: "addPageBreak",
          value: function addPageBreak(lft, rght) {
            var ws = this._worksheet;
            var left = Math.max(0, lft - 1) || 0;
            var right = Math.max(0, rght - 1) || 16838;
            var pb = { id: this._number, max: right, man: 1 };
            if (left)
              pb.min = left;
            ws.rowBreaks.push(pb);
          }
          // return a sparse array of cell values
        }, {
          key: "_applyStyle",
          // =========================================================================
          // styles
          value: function _applyStyle(name, value) {
            this.style[name] = value;
            this._cells.forEach(function(cell) {
              if (cell) {
                cell[name] = value;
              }
            });
            return value;
          }
        }, { key: "number", get: function get() {
          return this._number;
        } }, { key: "worksheet", get: function get() {
          return this._worksheet;
        } }, {
          key: "values",
          get: function get() {
            var values = [];
            this._cells.forEach(function(cell) {
              if (cell && cell.type !== Enums.ValueType.Null) {
                values[cell.col] = cell.value;
              }
            });
            return values;
          },
          set: function set(value) {
            var _this = this;
            this._cells = [];
            if (!value)
              ;
            else if (value instanceof Array) {
              var offset = 0;
              if (value.hasOwnProperty("0")) {
                offset = 1;
              }
              value.forEach(function(item, index2) {
                if (item !== void 0) {
                  _this.getCellEx({ address: colCache.encodeAddress(_this._number, index2 + offset), row: _this._number, col: index2 + offset }).value = item;
                }
              });
            } else {
              this._worksheet.eachColumnKey(function(column, key) {
                if (value[key] !== void 0) {
                  _this.getCellEx({ address: colCache.encodeAddress(_this._number, column.number), row: _this._number, col: column.number }).value = value[key];
                }
              });
            }
          }
          // returns true if the row includes at least one cell with a value
        }, { key: "hasValues", get: function get() {
          return _.some(this._cells, function(cell) {
            return cell && cell.type !== Enums.ValueType.Null;
          });
        } }, { key: "cellCount", get: function get() {
          return this._cells.length;
        } }, {
          key: "actualCellCount",
          get: function get() {
            var count = 0;
            this.eachCell(function() {
              count++;
            });
            return count;
          }
          // get the min and max column number for the non-null cells in this row or null
        }, { key: "dimensions", get: function get() {
          var min = 0;
          var max = 0;
          this._cells.forEach(function(cell) {
            if (cell && cell.type !== Enums.ValueType.Null) {
              if (!min || min > cell.col) {
                min = cell.col;
              }
              if (max < cell.col) {
                max = cell.col;
              }
            }
          });
          return min > 0 ? { min, max } : null;
        } }, { key: "numFmt", get: function get() {
          return this.style.numFmt;
        }, set: function set(value) {
          this._applyStyle("numFmt", value);
        } }, { key: "font", get: function get() {
          return this.style.font;
        }, set: function set(value) {
          this._applyStyle("font", value);
        } }, { key: "alignment", get: function get() {
          return this.style.alignment;
        }, set: function set(value) {
          this._applyStyle("alignment", value);
        } }, { key: "protection", get: function get() {
          return this.style.protection;
        }, set: function set(value) {
          this._applyStyle("protection", value);
        } }, { key: "border", get: function get() {
          return this.style.border;
        }, set: function set(value) {
          this._applyStyle("border", value);
        } }, { key: "fill", get: function get() {
          return this.style.fill;
        }, set: function set(value) {
          this._applyStyle("fill", value);
        } }, { key: "hidden", get: function get() {
          return !!this._hidden;
        }, set: function set(value) {
          this._hidden = value;
        } }, { key: "outlineLevel", get: function get() {
          return this._outlineLevel || 0;
        }, set: function set(value) {
          this._outlineLevel = value;
        } }, {
          key: "collapsed",
          get: function get() {
            return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow);
          }
          // =========================================================================
        }, { key: "model", get: function get() {
          var cells = [];
          var min = 0;
          var max = 0;
          this._cells.forEach(function(cell) {
            if (cell) {
              var cellModel = cell.model;
              if (cellModel) {
                if (!min || min > cell.col) {
                  min = cell.col;
                }
                if (max < cell.col) {
                  max = cell.col;
                }
                cells.push(cellModel);
              }
            }
          });
          return this.height || cells.length ? { cells, number: this.number, min, max, height: this.height, style: this.style, hidden: this.hidden, outlineLevel: this.outlineLevel, collapsed: this.collapsed } : null;
        }, set: function set(value) {
          var _this2 = this;
          if (value.number !== this._number) {
            throw new Error("Invalid row number in model");
          }
          this._cells = [];
          var previousAddress;
          value.cells.forEach(function(cellModel) {
            switch (cellModel.type) {
              case Cell.Types.Merge:
                break;
              default: {
                var address;
                if (cellModel.address) {
                  address = colCache.decodeAddress(cellModel.address);
                } else if (previousAddress) {
                  var _previousAddress = previousAddress, row = _previousAddress.row;
                  var col = previousAddress.col + 1;
                  address = { row, col, address: colCache.encodeAddress(row, col), $col$row: "$".concat(colCache.n2l(col), "$").concat(row) };
                }
                previousAddress = address;
                var cell = _this2.getCellEx(address);
                cell.model = cellModel;
                break;
              }
            }
          });
          if (value.height) {
            this.height = value.height;
          } else {
            delete this.height;
          }
          this.hidden = value.hidden;
          this.outlineLevel = value.outlineLevel || 0;
          this.style = value.style && JSON.parse(JSON.stringify(value.style)) || {};
        } }]);
        return Row2;
      }();
      module2.exports = Row;
    }, { "../utils/col-cache": 19, "../utils/under-dash": 25, "./cell": 3, "./enums": 7 }], 12: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var colCache = require2("../utils/col-cache");
      var Column = /* @__PURE__ */ function() {
        function Column2(table, column, index2) {
          _classCallCheck2(this, Column2);
          this.table = table;
          this.column = column;
          this.index = index2;
        }
        _createClass2(Column2, [{
          key: "_set",
          value: function _set(name, value) {
            this.table.cacheState();
            this.column[name] = value;
          }
          /* eslint-disable lines-between-class-members */
        }, { key: "name", get: function get() {
          return this.column.name;
        }, set: function set(value) {
          this._set("name", value);
        } }, { key: "filterButton", get: function get() {
          return this.column.filterButton;
        }, set: function set(value) {
          this.column.filterButton = value;
        } }, { key: "style", get: function get() {
          return this.column.style;
        }, set: function set(value) {
          this.column.style = value;
        } }, { key: "totalsRowLabel", get: function get() {
          return this.column.totalsRowLabel;
        }, set: function set(value) {
          this._set("totalsRowLabel", value);
        } }, { key: "totalsRowFunction", get: function get() {
          return this.column.totalsRowFunction;
        }, set: function set(value) {
          this._set("totalsRowFunction", value);
        } }, { key: "totalsRowResult", get: function get() {
          return this.column.totalsRowResult;
        }, set: function set(value) {
          this._set("totalsRowResult", value);
        } }, {
          key: "totalsRowFormula",
          get: function get() {
            return this.column.totalsRowFormula;
          },
          set: function set(value) {
            this._set("totalsRowFormula", value);
          }
          /* eslint-enable lines-between-class-members */
        }]);
        return Column2;
      }();
      var Table2 = /* @__PURE__ */ function() {
        function Table3(worksheet, table) {
          _classCallCheck2(this, Table3);
          this.worksheet = worksheet;
          if (table) {
            this.table = table;
            this.validate();
            this.store();
          }
        }
        _createClass2(Table3, [{ key: "getFormula", value: function getFormula(column) {
          switch (column.totalsRowFunction) {
            case "none":
              return null;
            case "average":
              return "SUBTOTAL(101,".concat(this.table.name, "[").concat(column.name, "])");
            case "countNums":
              return "SUBTOTAL(102,".concat(this.table.name, "[").concat(column.name, "])");
            case "count":
              return "SUBTOTAL(103,".concat(this.table.name, "[").concat(column.name, "])");
            case "max":
              return "SUBTOTAL(104,".concat(this.table.name, "[").concat(column.name, "])");
            case "min":
              return "SUBTOTAL(105,".concat(this.table.name, "[").concat(column.name, "])");
            case "stdDev":
              return "SUBTOTAL(106,".concat(this.table.name, "[").concat(column.name, "])");
            case "var":
              return "SUBTOTAL(107,".concat(this.table.name, "[").concat(column.name, "])");
            case "sum":
              return "SUBTOTAL(109,".concat(this.table.name, "[").concat(column.name, "])");
            case "custom":
              return column.totalsRowFormula;
            default:
              throw new Error("Invalid Totals Row Function: ".concat(column.totalsRowFunction));
          }
        } }, { key: "validate", value: function validate() {
          var _this = this;
          var table = this.table;
          var assign = function assign2(o, name, dflt) {
            if (o[name] === void 0) {
              o[name] = dflt;
            }
          };
          assign(table, "headerRow", true);
          assign(table, "totalsRow", false);
          assign(table, "style", {});
          assign(table.style, "theme", "TableStyleMedium2");
          assign(table.style, "showFirstColumn", false);
          assign(table.style, "showLastColumn", false);
          assign(table.style, "showRowStripes", false);
          assign(table.style, "showColumnStripes", false);
          var assert = function assert2(test, message) {
            if (!test) {
              throw new Error(message);
            }
          };
          assert(table.ref, "Table must have ref");
          assert(table.columns, "Table must have column definitions");
          assert(table.rows, "Table must have row definitions");
          table.tl = colCache.decodeAddress(table.ref);
          var _table$tl = table.tl, row = _table$tl.row, col = _table$tl.col;
          assert(row > 0, "Table must be on valid row");
          assert(col > 0, "Table must be on valid col");
          var width2 = this.width, filterHeight = this.filterHeight, tableHeight = this.tableHeight;
          table.autoFilterRef = colCache.encode(row, col, row + filterHeight - 1, col + width2 - 1);
          table.tableRef = colCache.encode(row, col, row + tableHeight - 1, col + width2 - 1);
          table.columns.forEach(function(column, i) {
            assert(column.name, "Column ".concat(i, " must have a name"));
            if (i === 0) {
              assign(column, "totalsRowLabel", "Total");
            } else {
              assign(column, "totalsRowFunction", "none");
              column.totalsRowFormula = _this.getFormula(column);
            }
          });
        } }, { key: "store", value: function store() {
          var _this2 = this;
          var assignStyle = function assignStyle2(cell, style) {
            if (style) {
              Object.keys(style).forEach(function(key) {
                cell[key] = style[key];
              });
            }
          };
          var worksheet = this.worksheet, table = this.table;
          var _table$tl2 = table.tl, row = _table$tl2.row, col = _table$tl2.col;
          var count = 0;
          if (table.headerRow) {
            var r = worksheet.getRow(row + count++);
            table.columns.forEach(function(column, j) {
              var style = column.style, name = column.name;
              var cell = r.getCell(col + j);
              cell.value = name;
              assignStyle(cell, style);
            });
          }
          table.rows.forEach(function(data) {
            var r2 = worksheet.getRow(row + count++);
            data.forEach(function(value, j) {
              var cell = r2.getCell(col + j);
              cell.value = value;
              assignStyle(cell, table.columns[j].style);
            });
          });
          if (table.totalsRow) {
            var _r = worksheet.getRow(row + count++);
            table.columns.forEach(function(column, j) {
              var cell = _r.getCell(col + j);
              if (j === 0) {
                cell.value = column.totalsRowLabel;
              } else {
                var formula = _this2.getFormula(column);
                if (formula) {
                  cell.value = { formula: column.totalsRowFormula, result: column.totalsRowResult };
                } else {
                  cell.value = null;
                }
              }
              assignStyle(cell, column.style);
            });
          }
        } }, { key: "load", value: function load(worksheet) {
          var _this3 = this;
          var table = this.table;
          var _table$tl3 = table.tl, row = _table$tl3.row, col = _table$tl3.col;
          var count = 0;
          if (table.headerRow) {
            var r = worksheet.getRow(row + count++);
            table.columns.forEach(function(column, j) {
              var cell = r.getCell(col + j);
              cell.value = column.name;
            });
          }
          table.rows.forEach(function(data) {
            var r2 = worksheet.getRow(row + count++);
            data.forEach(function(value, j) {
              var cell = r2.getCell(col + j);
              cell.value = value;
            });
          });
          if (table.totalsRow) {
            var _r2 = worksheet.getRow(row + count++);
            table.columns.forEach(function(column, j) {
              var cell = _r2.getCell(col + j);
              if (j === 0) {
                cell.value = column.totalsRowLabel;
              } else {
                var formula = _this3.getFormula(column);
                if (formula) {
                  cell.value = { formula: column.totalsRowFormula, result: column.totalsRowResult };
                }
              }
            });
          }
        } }, {
          key: "cacheState",
          // ================================================================
          // TODO: Mutating methods
          value: function cacheState() {
            if (!this._cache) {
              this._cache = { ref: this.ref, width: this.width, tableHeight: this.tableHeight };
            }
          }
        }, { key: "commit", value: function commit() {
          if (!this._cache) {
            return;
          }
          this.validate();
          var ref2 = colCache.decodeAddress(this._cache.ref);
          if (this.ref !== this._cache.ref) {
            for (var i = 0; i < this._cache.tableHeight; i++) {
              var row = this.worksheet.getRow(ref2.row + i);
              for (var j = 0; j < this._cache.width; j++) {
                var cell = row.getCell(ref2.col + j);
                cell.value = null;
              }
            }
          } else {
            for (var _i = this.tableHeight; _i < this._cache.tableHeight; _i++) {
              var _row = this.worksheet.getRow(ref2.row + _i);
              for (var _j = 0; _j < this._cache.width; _j++) {
                var _cell2 = _row.getCell(ref2.col + _j);
                _cell2.value = null;
              }
            }
            for (var _i2 = 0; _i2 < this.tableHeight; _i2++) {
              var _row2 = this.worksheet.getRow(ref2.row + _i2);
              for (var _j2 = this.width; _j2 < this._cache.width; _j2++) {
                var _cell22 = _row2.getCell(ref2.col + _j2);
                _cell22.value = null;
              }
            }
          }
          this.store();
        } }, { key: "addRow", value: function addRow(values, rowNumber) {
          this.cacheState();
          if (rowNumber === void 0) {
            this.table.rows.push(values);
          } else {
            this.table.rows.splice(rowNumber, 0, values);
          }
        } }, { key: "removeRows", value: function removeRows(rowIndex) {
          var count = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          this.cacheState();
          this.table.rows.splice(rowIndex, count);
        } }, { key: "getColumn", value: function getColumn(colIndex) {
          var column = this.table.columns[colIndex];
          return new Column(this, column, colIndex);
        } }, { key: "addColumn", value: function addColumn(column, values, colIndex) {
          this.cacheState();
          if (colIndex === void 0) {
            this.table.columns.push(column);
            this.table.rows.forEach(function(row, i) {
              row.push(values[i]);
            });
          } else {
            this.table.columns.splice(colIndex, 0, column);
            this.table.rows.forEach(function(row, i) {
              row.splice(colIndex, 0, values[i]);
            });
          }
        } }, { key: "removeColumns", value: function removeColumns(colIndex) {
          var count = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          this.cacheState();
          this.table.columns.splice(colIndex, count);
          this.table.rows.forEach(function(row) {
            row.splice(colIndex, count);
          });
        } }, {
          key: "_assign",
          value: function _assign(target, prop, value) {
            this.cacheState();
            target[prop] = value;
          }
          /* eslint-disable lines-between-class-members */
        }, { key: "width", get: function get() {
          return this.table.columns.length;
        } }, { key: "height", get: function get() {
          return this.table.rows.length;
        } }, { key: "filterHeight", get: function get() {
          return this.height + (this.table.headerRow ? 1 : 0);
        } }, { key: "tableHeight", get: function get() {
          return this.filterHeight + (this.table.totalsRow ? 1 : 0);
        } }, { key: "model", get: function get() {
          return this.table;
        }, set: function set(value) {
          this.table = value;
        } }, { key: "ref", get: function get() {
          return this.table.ref;
        }, set: function set(value) {
          this._assign(this.table, "ref", value);
        } }, { key: "name", get: function get() {
          return this.table.name;
        }, set: function set(value) {
          this.table.name = value;
        } }, { key: "displayName", get: function get() {
          return this.table.displyName || this.table.name;
        } }, { key: "displayNamename", set: function set(value) {
          this.table.displayName = value;
        } }, { key: "headerRow", get: function get() {
          return this.table.headerRow;
        }, set: function set(value) {
          this._assign(this.table, "headerRow", value);
        } }, { key: "totalsRow", get: function get() {
          return this.table.totalsRow;
        }, set: function set(value) {
          this._assign(this.table, "totalsRow", value);
        } }, { key: "theme", get: function get() {
          return this.table.style.name;
        }, set: function set(value) {
          this.table.style.name = value;
        } }, { key: "showFirstColumn", get: function get() {
          return this.table.style.showFirstColumn;
        }, set: function set(value) {
          this.table.style.showFirstColumn = value;
        } }, { key: "showLastColumn", get: function get() {
          return this.table.style.showLastColumn;
        }, set: function set(value) {
          this.table.style.showLastColumn = value;
        } }, { key: "showRowStripes", get: function get() {
          return this.table.style.showRowStripes;
        }, set: function set(value) {
          this.table.style.showRowStripes = value;
        } }, {
          key: "showColumnStripes",
          get: function get() {
            return this.table.style.showColumnStripes;
          },
          set: function set(value) {
            this.table.style.showColumnStripes = value;
          }
          /* eslint-enable lines-between-class-members */
        }]);
        return Table3;
      }();
      module2.exports = Table2;
    }, { "../utils/col-cache": 19 }], 13: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var Worksheet = require2("./worksheet");
      var DefinedNames = require2("./defined-names");
      var XLSX = require2("../xlsx/xlsx");
      var CSV = require2("../csv/csv");
      var Workbook = /* @__PURE__ */ function() {
        function Workbook2() {
          _classCallCheck2(this, Workbook2);
          this.category = "";
          this.company = "";
          this.created = /* @__PURE__ */ new Date();
          this.description = "";
          this.keywords = "";
          this.manager = "";
          this.modified = this.created;
          this.properties = {};
          this.calcProperties = {};
          this._worksheets = [];
          this.subject = "";
          this.title = "";
          this.views = [];
          this.media = [];
          this._definedNames = new DefinedNames();
        }
        _createClass2(Workbook2, [{ key: "addWorksheet", value: function addWorksheet(name, options) {
          var id = this.nextId;
          if (name && name.length > 31) {
            console.warn("Worksheet name ".concat(name, " exceeds 31 chars. This will be truncated"));
          }
          if (/[*?:/\\[\]]/.test(name)) {
            throw new Error("Worksheet name ".concat(name, " cannot include any of the following characters: * ? : \\ / [ ]"));
          }
          if (/(^')|('$)/.test(name)) {
            throw new Error("The first or last character of worksheet name cannot be a single quotation mark: ".concat(name));
          }
          name = (name || "sheet".concat(id)).substring(0, 31);
          if (this._worksheets.find(function(ws) {
            return ws && ws.name.toLowerCase() === name.toLowerCase();
          })) {
            throw new Error("Worksheet name already exists: ".concat(name));
          }
          if (options) {
            if (typeof options === "string") {
              console.trace('tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: "rbg value" } }');
              options = { properties: { tabColor: { argb: options } } };
            } else if (options.argb || options.theme || options.indexed) {
              console.trace("tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }");
              options = { properties: { tabColor: options } };
            }
          }
          var lastOrderNo = this._worksheets.reduce(function(acc, ws) {
            return (ws && ws.orderNo) > acc ? ws.orderNo : acc;
          }, 0);
          var worksheetOptions = Object.assign({}, options, { id, name, orderNo: lastOrderNo + 1, workbook: this });
          var worksheet = new Worksheet(worksheetOptions);
          this._worksheets[id] = worksheet;
          return worksheet;
        } }, { key: "removeWorksheetEx", value: function removeWorksheetEx(worksheet) {
          delete this._worksheets[worksheet.id];
        } }, { key: "removeWorksheet", value: function removeWorksheet(id) {
          var worksheet = this.getWorksheet(id);
          if (worksheet) {
            worksheet.destroy();
          }
        } }, { key: "getWorksheet", value: function getWorksheet(id) {
          if (id === void 0) {
            return this._worksheets.find(Boolean);
          }
          if (typeof id === "number") {
            return this._worksheets[id];
          }
          if (typeof id === "string") {
            return this._worksheets.find(function(worksheet) {
              return worksheet && worksheet.name === id;
            });
          }
          return void 0;
        } }, { key: "eachSheet", value: function eachSheet(iteratee) {
          this.worksheets.forEach(function(sheet) {
            iteratee(sheet, sheet.id);
          });
        } }, { key: "clearThemes", value: function clearThemes() {
          this._themes = void 0;
        } }, { key: "addImage", value: function addImage(image) {
          var id = this.media.length;
          this.media.push(Object.assign({}, image, { type: "image" }));
          return id;
        } }, { key: "getImage", value: function getImage2(id) {
          return this.media[id];
        } }, { key: "xlsx", get: function get() {
          if (!this._xlsx)
            this._xlsx = new XLSX(this);
          return this._xlsx;
        } }, { key: "csv", get: function get() {
          if (!this._csv)
            this._csv = new CSV(this);
          return this._csv;
        } }, { key: "nextId", get: function get() {
          for (var i = 1; i < this._worksheets.length; i++) {
            if (!this._worksheets[i]) {
              return i;
            }
          }
          return this._worksheets.length || 1;
        } }, { key: "worksheets", get: function get() {
          return this._worksheets.slice(1).sort(function(a, b) {
            return a.orderNo - b.orderNo;
          }).filter(Boolean);
        } }, { key: "definedNames", get: function get() {
          return this._definedNames;
        } }, { key: "model", get: function get() {
          return { creator: this.creator || "Unknown", lastModifiedBy: this.lastModifiedBy || "Unknown", lastPrinted: this.lastPrinted, created: this.created, modified: this.modified, properties: this.properties, worksheets: this.worksheets.map(function(worksheet) {
            return worksheet.model;
          }), sheets: this.worksheets.map(function(ws) {
            return ws.model;
          }).filter(Boolean), definedNames: this._definedNames.model, views: this.views, company: this.company, manager: this.manager, title: this.title, subject: this.subject, keywords: this.keywords, category: this.category, description: this.description, language: this.language, revision: this.revision, contentStatus: this.contentStatus, themes: this._themes, media: this.media, calcProperties: this.calcProperties };
        }, set: function set(value) {
          var _this = this;
          this.creator = value.creator;
          this.lastModifiedBy = value.lastModifiedBy;
          this.lastPrinted = value.lastPrinted;
          this.created = value.created;
          this.modified = value.modified;
          this.company = value.company;
          this.manager = value.manager;
          this.title = value.title;
          this.subject = value.subject;
          this.keywords = value.keywords;
          this.category = value.category;
          this.description = value.description;
          this.language = value.language;
          this.revision = value.revision;
          this.contentStatus = value.contentStatus;
          this.properties = value.properties;
          this.calcProperties = value.calcProperties;
          this._worksheets = [];
          value.worksheets.forEach(function(worksheetModel) {
            var id = worksheetModel.id, name = worksheetModel.name, state = worksheetModel.state;
            var orderNo = value.sheets && value.sheets.findIndex(function(ws) {
              return ws.id === id;
            });
            var worksheet = _this._worksheets[id] = new Worksheet({ id, name, orderNo, state, workbook: _this });
            worksheet.model = worksheetModel;
          });
          this._definedNames.model = value.definedNames;
          this.views = value.views;
          this._themes = value.themes;
          this.media = value.media || [];
        } }]);
        return Workbook2;
      }();
      module2.exports = Workbook;
    }, { "../csv/csv": 1, "../xlsx/xlsx": 141, "./defined-names": 6, "./worksheet": 14 }], 14: [function(require2, module2, exports2) {
      function ownKeys2(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys2(Object(source), true).forEach(function(key) {
              _defineProperty2(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys2(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _toConsumableArray2(arr) {
        return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
      }
      function _nonIterableSpread2() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray2(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray2(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray2(o, minLen);
      }
      function _iterableToArray2(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
          return Array.from(iter);
      }
      function _arrayWithoutHoles2(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray2(arr);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var _ = require2("../utils/under-dash");
      var colCache = require2("../utils/col-cache");
      var Range = require2("./range");
      var Row = require2("./row");
      var Column = require2("./column");
      var Enums = require2("./enums");
      var Image2 = require2("./image");
      var Table2 = require2("./table");
      var DataValidations = require2("./data-validations");
      var Encryptor = require2("../utils/encryptor");
      var Worksheet = /* @__PURE__ */ function() {
        function Worksheet2(options) {
          _classCallCheck2(this, Worksheet2);
          options = options || {};
          this.id = options.id;
          this.orderNo = options.orderNo;
          this.name = options.name || "Sheet".concat(this.id);
          this.state = options.state || "visible";
          this._rows = [];
          this._columns = null;
          this._keys = {};
          this._merges = {};
          this.rowBreaks = [];
          this._workbook = options.workbook;
          this.properties = Object.assign({}, { defaultRowHeight: 15, dyDescent: 55, outlineLevelCol: 0, outlineLevelRow: 0 }, options.properties);
          this.pageSetup = Object.assign({}, { margins: { left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 }, orientation: "portrait", horizontalDpi: 4294967295, verticalDpi: 4294967295, fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale), pageOrder: "downThenOver", blackAndWhite: false, draft: false, cellComments: "None", errors: "displayed", scale: 100, fitToWidth: 1, fitToHeight: 1, paperSize: void 0, showRowColHeaders: false, showGridLines: false, firstPageNumber: void 0, horizontalCentered: false, verticalCentered: false, rowBreaks: null, colBreaks: null }, options.pageSetup);
          this.headerFooter = Object.assign({}, { differentFirst: false, differentOddEven: false, oddHeader: null, oddFooter: null, evenHeader: null, evenFooter: null, firstHeader: null, firstFooter: null }, options.headerFooter);
          this.dataValidations = new DataValidations();
          this.views = options.views || [];
          this.autoFilter = options.autoFilter || null;
          this._media = [];
          this.sheetProtection = null;
          this.tables = {};
          this.conditionalFormattings = [];
        }
        _createClass2(Worksheet2, [{
          key: "destroy",
          // when you're done with this worksheet, call this to remove from workbook
          value: function destroy() {
            this._workbook.removeWorksheetEx(this);
          }
          // Get the bounding range of the cells in this worksheet
        }, { key: "getColumnKey", value: function getColumnKey(key) {
          return this._keys[key];
        } }, { key: "setColumnKey", value: function setColumnKey(key, value) {
          this._keys[key] = value;
        } }, { key: "deleteColumnKey", value: function deleteColumnKey(key) {
          delete this._keys[key];
        } }, {
          key: "eachColumnKey",
          value: function eachColumnKey(f) {
            _.each(this._keys, f);
          }
          // get a single column by col number. If it doesn't exist, create it and any gaps before it
        }, { key: "getColumn", value: function getColumn(c) {
          if (typeof c === "string") {
            var col = this._keys[c];
            if (col)
              return col;
            c = colCache.l2n(c);
          }
          if (!this._columns) {
            this._columns = [];
          }
          if (c > this._columns.length) {
            var n = this._columns.length + 1;
            while (n <= c) {
              this._columns.push(new Column(this, n++));
            }
          }
          return this._columns[c - 1];
        } }, { key: "spliceColumns", value: function spliceColumns(start, count) {
          var _this = this;
          var rows = this._rows;
          var nRows = rows.length;
          for (var _len = arguments.length, inserts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            inserts[_key - 2] = arguments[_key];
          }
          if (inserts.length > 0) {
            var _loop = function _loop2(i2) {
              var rowArguments = [start, count];
              inserts.forEach(function(insert) {
                rowArguments.push(insert[i2] || null);
              });
              var row = _this.getRow(i2 + 1);
              row.splice.apply(row, rowArguments);
            };
            for (var i = 0; i < nRows; i++) {
              _loop(i);
            }
          } else {
            this._rows.forEach(function(r) {
              if (r) {
                r.splice(start, count);
              }
            });
          }
          var nExpand = inserts.length - count;
          var nKeep = start + count;
          var nEnd = this._columns.length;
          if (nExpand < 0) {
            for (var _i = start + inserts.length; _i <= nEnd; _i++) {
              this.getColumn(_i).defn = this.getColumn(_i - nExpand).defn;
            }
          } else if (nExpand > 0) {
            for (var _i2 = nEnd; _i2 >= nKeep; _i2--) {
              this.getColumn(_i2 + nExpand).defn = this.getColumn(_i2).defn;
            }
          }
          for (var _i3 = start; _i3 < start + inserts.length; _i3++) {
            this.getColumn(_i3).defn = null;
          }
          this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);
        } }, {
          key: "_commitRow",
          // =========================================================================
          // Rows
          value: function _commitRow() {
          }
        }, {
          key: "findRow",
          // find a row (if exists) by row number
          value: function findRow(r) {
            return this._rows[r - 1];
          }
          // find multiple rows (if exists) by row number
        }, { key: "findRows", value: function findRows(start, length) {
          return this._rows.slice(start - 1, start - 1 + length);
        } }, {
          key: "getRow",
          // get a row by row number.
          value: function getRow(r) {
            var row = this._rows[r - 1];
            if (!row) {
              row = this._rows[r - 1] = new Row(this, r);
            }
            return row;
          }
          // get multiple rows by row number.
        }, { key: "getRows", value: function getRows(start, length) {
          if (length < 1)
            return void 0;
          var rows = [];
          for (var i = start; i < start + length; i++) {
            rows.push(this.getRow(i));
          }
          return rows;
        } }, { key: "addRow", value: function addRow(value) {
          var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "n";
          var rowNo = this._nextRow;
          var row = this.getRow(rowNo);
          row.values = value;
          this._setStyleOption(rowNo, style[0] === "i" ? style : "n");
          return row;
        } }, { key: "addRows", value: function addRows(value) {
          var _this2 = this;
          var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "n";
          var rows = [];
          value.forEach(function(row) {
            rows.push(_this2.addRow(row, style));
          });
          return rows;
        } }, { key: "insertRow", value: function insertRow(pos, value) {
          var style = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "n";
          this.spliceRows(pos, 0, value);
          this._setStyleOption(pos, style);
          return this.getRow(pos);
        } }, {
          key: "insertRows",
          value: function insertRows(pos, values) {
            var style = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "n";
            this.spliceRows.apply(this, [pos, 0].concat(_toConsumableArray2(values)));
            if (style !== "n") {
              for (var i = 0; i < values.length; i++) {
                if (style[0] === "o" && this.findRow(values.length + pos + i) !== void 0) {
                  this._copyStyle(values.length + pos + i, pos + i, style[1] === "+");
                } else if (style[0] === "i" && this.findRow(pos - 1) !== void 0) {
                  this._copyStyle(pos - 1, pos + i, style[1] === "+");
                }
              }
            }
            return this.getRows(pos, values.length);
          }
          // set row at position to same style as of either pervious row (option 'i') or next row (option 'o')
        }, { key: "_setStyleOption", value: function _setStyleOption(pos) {
          var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "n";
          if (style[0] === "o" && this.findRow(pos + 1) !== void 0) {
            this._copyStyle(pos + 1, pos, style[1] === "+");
          } else if (style[0] === "i" && this.findRow(pos - 1) !== void 0) {
            this._copyStyle(pos - 1, pos, style[1] === "+");
          }
        } }, { key: "_copyStyle", value: function _copyStyle(src, dest) {
          var styleEmpty = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var rSrc = this.getRow(src);
          var rDst = this.getRow(dest);
          rDst.style = Object.freeze(_objectSpread2({}, rSrc.style));
          rSrc.eachCell({ includeEmpty: styleEmpty }, function(cell, colNumber) {
            rDst.getCell(colNumber).style = Object.freeze(_objectSpread2({}, cell.style));
          });
          rDst.height = rSrc.height;
        } }, { key: "duplicateRow", value: function duplicateRow(rowNum, count) {
          var _this3 = this;
          var insert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var rSrc = this._rows[rowNum - 1];
          var inserts = new Array(count).fill(rSrc.values);
          this.spliceRows.apply(this, [rowNum + 1, insert ? 0 : count].concat(_toConsumableArray2(inserts)));
          var _loop2 = function _loop22(i2) {
            var rDst = _this3._rows[rowNum + i2];
            rDst.style = rSrc.style;
            rDst.height = rSrc.height;
            rSrc.eachCell({ includeEmpty: true }, function(cell, colNumber) {
              rDst.getCell(colNumber).style = cell.style;
            });
          };
          for (var i = 0; i < count; i++) {
            _loop2(i);
          }
        } }, {
          key: "spliceRows",
          value: function spliceRows(start, count) {
            var _this4 = this;
            var nKeep = start + count;
            for (var _len2 = arguments.length, inserts = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
              inserts[_key2 - 2] = arguments[_key2];
            }
            var nInserts = inserts.length;
            var nExpand = nInserts - count;
            var nEnd = this._rows.length;
            var i;
            var rSrc;
            if (nExpand < 0) {
              for (i = nKeep; i <= nEnd; i++) {
                rSrc = this._rows[i - 1];
                if (rSrc) {
                  (function() {
                    var rDst2 = _this4.getRow(i + nExpand);
                    rDst2.values = rSrc.values;
                    rDst2.style = rSrc.style;
                    rDst2.height = rSrc.height;
                    rSrc.eachCell({ includeEmpty: true }, function(cell, colNumber) {
                      rDst2.getCell(colNumber).style = cell.style;
                    });
                    _this4._rows[i - 1] = void 0;
                  })();
                } else {
                  this._rows[i + nExpand - 1] = void 0;
                }
              }
            } else if (nExpand > 0) {
              for (i = nEnd; i >= nKeep; i--) {
                rSrc = this._rows[i - 1];
                if (rSrc) {
                  (function() {
                    var rDst2 = _this4.getRow(i + nExpand);
                    rDst2.values = rSrc.values;
                    rDst2.style = rSrc.style;
                    rDst2.height = rSrc.height;
                    rSrc.eachCell({ includeEmpty: true }, function(cell, colNumber) {
                      rDst2.getCell(colNumber).style = cell.style;
                      if (cell._value.constructor.name === "MergeValue") {
                        var cellToBeMerged = _this4.getRow(cell._row._number + nInserts).getCell(colNumber);
                        var prevMaster = cell._value._master;
                        var newMaster = _this4.getRow(prevMaster._row._number + nInserts).getCell(prevMaster._column._number);
                        cellToBeMerged.merge(newMaster);
                      }
                    });
                  })();
                } else {
                  this._rows[i + nExpand - 1] = void 0;
                }
              }
            }
            for (i = 0; i < nInserts; i++) {
              var rDst = this.getRow(start + i);
              rDst.style = {};
              rDst.values = inserts[i];
            }
            this.workbook.definedNames.spliceRows(this.name, start, count, nInserts);
          }
          // iterate over every row in the worksheet, including maybe empty rows
        }, {
          key: "eachRow",
          value: function eachRow(options, iteratee) {
            if (!iteratee) {
              iteratee = options;
              options = void 0;
            }
            if (options && options.includeEmpty) {
              var n = this._rows.length;
              for (var i = 1; i <= n; i++) {
                iteratee(this.getRow(i), i);
              }
            } else {
              this._rows.forEach(function(row) {
                if (row && row.hasValues) {
                  iteratee(row, row.number);
                }
              });
            }
          }
          // return all rows as sparse array
        }, {
          key: "getSheetValues",
          value: function getSheetValues() {
            var rows = [];
            this._rows.forEach(function(row) {
              if (row) {
                rows[row.number] = row.values;
              }
            });
            return rows;
          }
          // =========================================================================
          // Cells
          // returns the cell at [r,c] or address given by r. If not found, return undefined
        }, {
          key: "findCell",
          value: function findCell(r, c) {
            var address = colCache.getAddress(r, c);
            var row = this._rows[address.row - 1];
            return row ? row.findCell(address.col) : void 0;
          }
          // return the cell at [r,c] or address given by r. If not found, create a new one.
        }, {
          key: "getCell",
          value: function getCell(r, c) {
            var address = colCache.getAddress(r, c);
            var row = this.getRow(address.row);
            return row.getCellEx(address);
          }
          // =========================================================================
          // Merge
          // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell
        }, { key: "mergeCells", value: function mergeCells() {
          for (var _len3 = arguments.length, cells = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            cells[_key3] = arguments[_key3];
          }
          var dimensions = new Range(cells);
          this._mergeCellsInternal(dimensions);
        } }, { key: "mergeCellsWithoutStyle", value: function mergeCellsWithoutStyle() {
          for (var _len4 = arguments.length, cells = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            cells[_key4] = arguments[_key4];
          }
          var dimensions = new Range(cells);
          this._mergeCellsInternal(dimensions, true);
        } }, { key: "_mergeCellsInternal", value: function _mergeCellsInternal(dimensions, ignoreStyle) {
          _.each(this._merges, function(merge2) {
            if (merge2.intersects(dimensions)) {
              throw new Error("Cannot merge already merged cells");
            }
          });
          var master = this.getCell(dimensions.top, dimensions.left);
          for (var i = dimensions.top; i <= dimensions.bottom; i++) {
            for (var j = dimensions.left; j <= dimensions.right; j++) {
              if (i > dimensions.top || j > dimensions.left) {
                this.getCell(i, j).merge(master, ignoreStyle);
              }
            }
          }
          this._merges[master.address] = dimensions;
        } }, { key: "_unMergeMaster", value: function _unMergeMaster(master) {
          var merge2 = this._merges[master.address];
          if (merge2) {
            for (var i = merge2.top; i <= merge2.bottom; i++) {
              for (var j = merge2.left; j <= merge2.right; j++) {
                this.getCell(i, j).unmerge();
              }
            }
            delete this._merges[master.address];
          }
        } }, {
          key: "unMergeCells",
          // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,
          // un-merge the group. Note this function can affect multiple merges and merge-blocks are
          // atomic - either they're all merged or all un-merged.
          value: function unMergeCells() {
            for (var _len5 = arguments.length, cells = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              cells[_key5] = arguments[_key5];
            }
            var dimensions = new Range(cells);
            for (var i = dimensions.top; i <= dimensions.bottom; i++) {
              for (var j = dimensions.left; j <= dimensions.right; j++) {
                var cell = this.findCell(i, j);
                if (cell) {
                  if (cell.type === Enums.ValueType.Merge) {
                    this._unMergeMaster(cell.master);
                  } else if (this._merges[cell.address]) {
                    this._unMergeMaster(cell);
                  }
                }
              }
            }
          }
          // ===========================================================================
          // Shared/Array Formula
        }, {
          key: "fillFormula",
          value: function fillFormula(range, formula, results) {
            var shareType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "shared";
            var decoded = colCache.decode(range);
            var top = decoded.top, left = decoded.left, bottom = decoded.bottom, right = decoded.right;
            var width2 = right - left + 1;
            var masterAddress = colCache.encodeAddress(top, left);
            var isShared = shareType === "shared";
            var getResult;
            if (typeof results === "function") {
              getResult = results;
            } else if (Array.isArray(results)) {
              if (Array.isArray(results[0])) {
                getResult = function getResult2(row, col) {
                  return results[row - top][col - left];
                };
              } else {
                getResult = function getResult2(row, col) {
                  return results[(row - top) * width2 + (col - left)];
                };
              }
            } else {
              getResult = function getResult2() {
                return void 0;
              };
            }
            var first = true;
            for (var r = top; r <= bottom; r++) {
              for (var c = left; c <= right; c++) {
                if (first) {
                  this.getCell(r, c).value = { shareType, formula, ref: range, result: getResult(r, c) };
                  first = false;
                } else {
                  this.getCell(r, c).value = isShared ? { sharedFormula: masterAddress, result: getResult(r, c) } : getResult(r, c);
                }
              }
            }
          }
          // =========================================================================
          // Images
        }, { key: "addImage", value: function addImage(imageId, range) {
          var model = { type: "image", imageId, range };
          this._media.push(new Image2(this, model));
        } }, { key: "getImages", value: function getImages() {
          return this._media.filter(function(m) {
            return m.type === "image";
          });
        } }, { key: "addBackgroundImage", value: function addBackgroundImage(imageId) {
          var model = { type: "background", imageId };
          this._media.push(new Image2(this, model));
        } }, {
          key: "getBackgroundImageId",
          value: function getBackgroundImageId() {
            var image = this._media.find(function(m) {
              return m.type === "background";
            });
            return image && image.imageId;
          }
          // =========================================================================
          // Worksheet Protection
        }, { key: "protect", value: function protect(password, options) {
          var _this5 = this;
          return new Promise(function(resolve) {
            _this5.sheetProtection = { sheet: true };
            if (options && "spinCount" in options) {
              options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 1e5;
            }
            if (password) {
              _this5.sheetProtection.algorithmName = "SHA-512";
              _this5.sheetProtection.saltValue = Encryptor.randomBytes(16).toString("base64");
              _this5.sheetProtection.spinCount = options && "spinCount" in options ? options.spinCount : 1e5;
              _this5.sheetProtection.hashValue = Encryptor.convertPasswordToHash(password, "SHA512", _this5.sheetProtection.saltValue, _this5.sheetProtection.spinCount);
            }
            if (options) {
              _this5.sheetProtection = Object.assign(_this5.sheetProtection, options);
              if (!password && "spinCount" in options) {
                delete _this5.sheetProtection.spinCount;
              }
            }
            resolve();
          });
        } }, {
          key: "unprotect",
          value: function unprotect() {
            this.sheetProtection = null;
          }
          // =========================================================================
          // Tables
        }, { key: "addTable", value: function addTable(model) {
          var table = new Table2(this, model);
          this.tables[model.name] = table;
          return table;
        } }, { key: "getTable", value: function getTable(name) {
          return this.tables[name];
        } }, { key: "removeTable", value: function removeTable(name) {
          delete this.tables[name];
        } }, {
          key: "getTables",
          value: function getTables() {
            return Object.values(this.tables);
          }
          // ===========================================================================
          // Conditional Formatting
        }, { key: "addConditionalFormatting", value: function addConditionalFormatting(cf) {
          this.conditionalFormattings.push(cf);
        } }, {
          key: "removeConditionalFormatting",
          value: function removeConditionalFormatting(filter) {
            if (typeof filter === "number") {
              this.conditionalFormattings.splice(filter, 1);
            } else if (filter instanceof Function) {
              this.conditionalFormattings = this.conditionalFormattings.filter(filter);
            } else {
              this.conditionalFormattings = [];
            }
          }
          // ===========================================================================
          // Deprecated
        }, { key: "_parseRows", value: function _parseRows(model) {
          var _this6 = this;
          this._rows = [];
          model.rows.forEach(function(rowModel) {
            var row = new Row(_this6, rowModel.number);
            _this6._rows[row.number - 1] = row;
            row.model = rowModel;
          });
        } }, { key: "_parseMergeCells", value: function _parseMergeCells(model) {
          var _this7 = this;
          _.each(model.mergeCells, function(merge2) {
            _this7.mergeCellsWithoutStyle(merge2);
          });
        } }, { key: "workbook", get: function get() {
          return this._workbook;
        } }, {
          key: "dimensions",
          get: function get() {
            var dimensions = new Range();
            this._rows.forEach(function(row) {
              if (row) {
                var rowDims = row.dimensions;
                if (rowDims) {
                  dimensions.expand(row.number, rowDims.min, row.number, rowDims.max);
                }
              }
            });
            return dimensions;
          }
          // =========================================================================
          // Columns
          // get the current columns array.
        }, {
          key: "columns",
          get: function get() {
            return this._columns;
          },
          set: function set(value) {
            var _this8 = this;
            this._headerRowCount = value.reduce(function(pv, cv) {
              var headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;
              return Math.max(pv, headerCount);
            }, 0);
            var count = 1;
            var columns = this._columns = [];
            value.forEach(function(defn) {
              var column = new Column(_this8, count++, false);
              columns.push(column);
              column.defn = defn;
            });
          }
        }, { key: "lastColumn", get: function get() {
          return this.getColumn(this.columnCount);
        } }, { key: "columnCount", get: function get() {
          var maxCount = 0;
          this.eachRow(function(row) {
            maxCount = Math.max(maxCount, row.cellCount);
          });
          return maxCount;
        } }, { key: "actualColumnCount", get: function get() {
          var counts = [];
          var count = 0;
          this.eachRow(function(row) {
            row.eachCell(function(_ref) {
              var col = _ref.col;
              if (!counts[col]) {
                counts[col] = true;
                count++;
              }
            });
          });
          return count;
        } }, { key: "_lastRowNumber", get: function get() {
          var rows = this._rows;
          var n = rows.length;
          while (n > 0 && rows[n - 1] === void 0) {
            n--;
          }
          return n;
        } }, { key: "_nextRow", get: function get() {
          return this._lastRowNumber + 1;
        } }, { key: "lastRow", get: function get() {
          if (this._rows.length) {
            return this._rows[this._rows.length - 1];
          }
          return void 0;
        } }, { key: "rowCount", get: function get() {
          return this._lastRowNumber;
        } }, { key: "actualRowCount", get: function get() {
          var count = 0;
          this.eachRow(function() {
            count++;
          });
          return count;
        } }, { key: "hasMerges", get: function get() {
          return _.some(this._merges, Boolean);
        } }, {
          key: "tabColor",
          get: function get() {
            console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
            return this.properties.tabColor;
          },
          set: function set(value) {
            console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
            this.properties.tabColor = value;
          }
          // ===========================================================================
          // Model
        }, { key: "model", get: function get() {
          var model = { id: this.id, name: this.name, dataValidations: this.dataValidations.model, properties: this.properties, state: this.state, pageSetup: this.pageSetup, headerFooter: this.headerFooter, rowBreaks: this.rowBreaks, views: this.views, autoFilter: this.autoFilter, media: this._media.map(function(medium) {
            return medium.model;
          }), sheetProtection: this.sheetProtection, tables: Object.values(this.tables).map(function(table) {
            return table.model;
          }), conditionalFormattings: this.conditionalFormattings };
          model.cols = Column.toModel(this.columns);
          var rows = model.rows = [];
          var dimensions = model.dimensions = new Range();
          this._rows.forEach(function(row) {
            var rowModel = row && row.model;
            if (rowModel) {
              dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);
              rows.push(rowModel);
            }
          });
          model.merges = [];
          _.each(this._merges, function(merge2) {
            model.merges.push(merge2.range);
          });
          return model;
        }, set: function set(value) {
          var _this9 = this;
          this.name = value.name;
          this._columns = Column.fromModel(this, value.cols);
          this._parseRows(value);
          this._parseMergeCells(value);
          this.dataValidations = new DataValidations(value.dataValidations);
          this.properties = value.properties;
          this.pageSetup = value.pageSetup;
          this.headerFooter = value.headerFooter;
          this.views = value.views;
          this.autoFilter = value.autoFilter;
          this._media = value.media.map(function(medium) {
            return new Image2(_this9, medium);
          });
          this.sheetProtection = value.sheetProtection;
          this.tables = value.tables.reduce(function(tables, table) {
            var t2 = new Table2();
            t2.model = table;
            tables[table.name] = t2;
            return tables;
          }, {});
          this.conditionalFormattings = value.conditionalFormattings;
        } }]);
        return Worksheet2;
      }();
      module2.exports = Worksheet;
    }, { "../utils/col-cache": 19, "../utils/encryptor": 20, "../utils/under-dash": 25, "./column": 4, "./data-validations": 5, "./enums": 7, "./image": 8, "./range": 10, "./row": 11, "./table": 12 }], 15: [function(require2, module2, exports2) {
      require2("core-js/modules/es.promise");
      require2("core-js/modules/es.object.assign");
      require2("core-js/modules/es.object.keys");
      require2("core-js/modules/es.object.values");
      require2("core-js/modules/es.symbol");
      require2("core-js/modules/es.symbol.async-iterator");
      require2("core-js/modules/es.array.iterator");
      require2("core-js/modules/es.array.includes");
      require2("core-js/modules/es.array.find-index");
      require2("core-js/modules/es.array.find");
      require2("core-js/modules/es.string.from-code-point");
      require2("core-js/modules/es.string.includes");
      require2("core-js/modules/es.number.is-nan");
      require2("regenerator-runtime/runtime");
      var ExcelJS = { Workbook: require2("./doc/workbook") };
      var Enums = require2("./doc/enums");
      Object.keys(Enums).forEach(function(key) {
        ExcelJS[key] = Enums[key];
      });
      module2.exports = ExcelJS;
    }, { "./doc/enums": 7, "./doc/workbook": 13, "core-js/modules/es.array.find": 316, "core-js/modules/es.array.find-index": 315, "core-js/modules/es.array.includes": 317, "core-js/modules/es.array.iterator": 318, "core-js/modules/es.number.is-nan": 319, "core-js/modules/es.object.assign": 320, "core-js/modules/es.object.keys": 321, "core-js/modules/es.object.values": 322, "core-js/modules/es.promise": 323, "core-js/modules/es.string.from-code-point": 324, "core-js/modules/es.string.includes": 325, "core-js/modules/es.symbol": 327, "core-js/modules/es.symbol.async-iterator": 326, "regenerator-runtime/runtime": 492 }], 16: [function(require2, module2, exports2) {
      var textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
      function bufferToString(chunk) {
        if (typeof chunk === "string") {
          return chunk;
        }
        if (textDecoder) {
          return textDecoder.decode(chunk);
        }
        return chunk.toString();
      }
      exports2.bufferToString = bufferToString;
    }, {}], 17: [function(require2, module2, exports2) {
      var textEncoder = typeof TextEncoder === "undefined" ? null : new TextEncoder("utf-8");
      var _require = require2("buffer"), Buffer = _require.Buffer;
      function stringToBuffer(str) {
        if (typeof str !== "string") {
          return str;
        }
        if (textEncoder) {
          return Buffer.from(textEncoder.encode(str).buffer);
        }
        return Buffer.from(str);
      }
      exports2.stringToBuffer = stringToBuffer;
    }, { "buffer": 216 }], 18: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var _ = require2("./under-dash");
      var colCache = require2("./col-cache");
      var CellMatrix = /* @__PURE__ */ function() {
        function CellMatrix2(template) {
          _classCallCheck2(this, CellMatrix2);
          this.template = template;
          this.sheets = {};
        }
        _createClass2(CellMatrix2, [{ key: "addCell", value: function addCell(addressStr) {
          this.addCellEx(colCache.decodeEx(addressStr));
        } }, { key: "getCell", value: function getCell(addressStr) {
          return this.findCellEx(colCache.decodeEx(addressStr), true);
        } }, { key: "findCell", value: function findCell(addressStr) {
          return this.findCellEx(colCache.decodeEx(addressStr), false);
        } }, { key: "findCellAt", value: function findCellAt(sheetName, rowNumber, colNumber) {
          var sheet = this.sheets[sheetName];
          var row = sheet && sheet[rowNumber];
          return row && row[colNumber];
        } }, { key: "addCellEx", value: function addCellEx(address) {
          if (address.top) {
            for (var row = address.top; row <= address.bottom; row++) {
              for (var col = address.left; col <= address.right; col++) {
                this.getCellAt(address.sheetName, row, col);
              }
            }
          } else {
            this.findCellEx(address, true);
          }
        } }, { key: "getCellEx", value: function getCellEx(address) {
          return this.findCellEx(address, true);
        } }, { key: "findCellEx", value: function findCellEx(address, create) {
          var sheet = this.findSheet(address, create);
          var row = this.findSheetRow(sheet, address, create);
          return this.findRowCell(row, address, create);
        } }, { key: "getCellAt", value: function getCellAt(sheetName, rowNumber, colNumber) {
          var sheet = this.sheets[sheetName] || (this.sheets[sheetName] = []);
          var row = sheet[rowNumber] || (sheet[rowNumber] = []);
          var cell = row[colNumber] || (row[colNumber] = { sheetName, address: colCache.n2l(colNumber) + rowNumber, row: rowNumber, col: colNumber });
          return cell;
        } }, { key: "removeCellEx", value: function removeCellEx(address) {
          var sheet = this.findSheet(address);
          if (!sheet) {
            return;
          }
          var row = this.findSheetRow(sheet, address);
          if (!row) {
            return;
          }
          delete row[address.col];
        } }, { key: "forEachInSheet", value: function forEachInSheet(sheetName, callback) {
          var sheet = this.sheets[sheetName];
          if (sheet) {
            sheet.forEach(function(row, rowNumber) {
              if (row) {
                row.forEach(function(cell, colNumber) {
                  if (cell) {
                    callback(cell, rowNumber, colNumber);
                  }
                });
              }
            });
          }
        } }, { key: "forEach", value: function forEach(callback) {
          var _this = this;
          _.each(this.sheets, function(sheet, sheetName) {
            _this.forEachInSheet(sheetName, callback);
          });
        } }, { key: "map", value: function map(callback) {
          var results = [];
          this.forEach(function(cell) {
            results.push(callback(cell));
          });
          return results;
        } }, { key: "findSheet", value: function findSheet(address, create) {
          var name = address.sheetName;
          if (this.sheets[name]) {
            return this.sheets[name];
          }
          if (create) {
            return this.sheets[name] = [];
          }
          return void 0;
        } }, { key: "findSheetRow", value: function findSheetRow(sheet, address, create) {
          var row = address.row;
          if (sheet && sheet[row]) {
            return sheet[row];
          }
          if (create) {
            return sheet[row] = [];
          }
          return void 0;
        } }, { key: "findRowCell", value: function findRowCell(row, address, create) {
          var col = address.col;
          if (row && row[col]) {
            return row[col];
          }
          if (create) {
            return row[col] = this.template ? Object.assign(address, JSON.parse(JSON.stringify(this.template))) : address;
          }
          return void 0;
        } }, { key: "spliceRows", value: function spliceRows(sheetName, start, numDelete, numInsert) {
          var sheet = this.sheets[sheetName];
          if (sheet) {
            var inserts = [];
            for (var i = 0; i < numInsert; i++) {
              inserts.push([]);
            }
            sheet.splice.apply(sheet, [start, numDelete].concat(inserts));
          }
        } }, { key: "spliceColumns", value: function spliceColumns(sheetName, start, numDelete, numInsert) {
          var sheet = this.sheets[sheetName];
          if (sheet) {
            var inserts = [];
            for (var i = 0; i < numInsert; i++) {
              inserts.push(null);
            }
            _.each(sheet, function(row) {
              row.splice.apply(row, [start, numDelete].concat(inserts));
            });
          }
        } }]);
        return CellMatrix2;
      }();
      module2.exports = CellMatrix;
    }, { "./col-cache": 19, "./under-dash": 25 }], 19: [function(require2, module2, exports2) {
      function _slicedToArray2(arr, i) {
        return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
      }
      function _nonIterableRest2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray2(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray2(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray2(o, minLen);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _iterableToArrayLimit2(arr, i) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles2(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function ownKeys2(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys2(Object(source), true).forEach(function(key) {
              _defineProperty2(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys2(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var addressRegex = /^[A-Z]+\d+$/;
      var colCache = {
        _dictionary: ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"],
        _l2nFill: 0,
        _l2n: {},
        _n2l: [],
        _level: function _level(n) {
          if (n <= 26) {
            return 1;
          }
          if (n <= 26 * 26) {
            return 2;
          }
          return 3;
        },
        _fill: function _fill(level) {
          var c;
          var v;
          var l1;
          var l2;
          var l3;
          var n = 1;
          if (level >= 4) {
            throw new Error("Out of bounds. Excel supports columns from 1 to 16384");
          }
          if (this._l2nFill < 1 && level >= 1) {
            while (n <= 26) {
              c = this._dictionary[n - 1];
              this._n2l[n] = c;
              this._l2n[c] = n;
              n++;
            }
            this._l2nFill = 1;
          }
          if (this._l2nFill < 2 && level >= 2) {
            n = 27;
            while (n <= 26 + 26 * 26) {
              v = n - (26 + 1);
              l1 = v % 26;
              l2 = Math.floor(v / 26);
              c = this._dictionary[l2] + this._dictionary[l1];
              this._n2l[n] = c;
              this._l2n[c] = n;
              n++;
            }
            this._l2nFill = 2;
          }
          if (this._l2nFill < 3 && level >= 3) {
            n = 26 + 26 * 26 + 1;
            while (n <= 16384) {
              v = n - (26 * 26 + 26 + 1);
              l1 = v % 26;
              l2 = Math.floor(v / 26) % 26;
              l3 = Math.floor(v / (26 * 26));
              c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];
              this._n2l[n] = c;
              this._l2n[c] = n;
              n++;
            }
            this._l2nFill = 3;
          }
        },
        l2n: function l2n(l) {
          if (!this._l2n[l]) {
            this._fill(l.length);
          }
          if (!this._l2n[l]) {
            throw new Error("Out of bounds. Invalid column letter: ".concat(l));
          }
          return this._l2n[l];
        },
        n2l: function n2l(n) {
          if (n < 1 || n > 16384) {
            throw new Error("".concat(n, " is out of bounds. Excel supports columns from 1 to 16384"));
          }
          if (!this._n2l[n]) {
            this._fill(this._level(n));
          }
          return this._n2l[n];
        },
        // =========================================================================
        // Address processing
        _hash: {},
        // check if value looks like an address
        validateAddress: function validateAddress(value) {
          if (!addressRegex.test(value)) {
            throw new Error("Invalid Address: ".concat(value));
          }
          return true;
        },
        // convert address string into structure
        decodeAddress: function decodeAddress(value) {
          var addr = value.length < 5 && this._hash[value];
          if (addr) {
            return addr;
          }
          var hasCol = false;
          var col = "";
          var colNumber = 0;
          var hasRow = false;
          var row = "";
          var rowNumber = 0;
          for (var i = 0, char; i < value.length; i++) {
            char = value.charCodeAt(i);
            if (!hasRow && char >= 65 && char <= 90) {
              hasCol = true;
              col += value[i];
              colNumber = colNumber * 26 + char - 64;
            } else if (char >= 48 && char <= 57) {
              hasRow = true;
              row += value[i];
              rowNumber = rowNumber * 10 + char - 48;
            } else if (hasRow && hasCol && char !== 36) {
              break;
            }
          }
          if (!hasCol) {
            colNumber = void 0;
          } else if (colNumber > 16384) {
            throw new Error("Out of bounds. Invalid column letter: ".concat(col));
          }
          if (!hasRow) {
            rowNumber = void 0;
          }
          value = col + row;
          var address = { address: value, col: colNumber, row: rowNumber, $col$row: "$".concat(col, "$").concat(row) };
          if (colNumber <= 100 && rowNumber <= 100) {
            this._hash[value] = address;
            this._hash[address.$col$row] = address;
          }
          return address;
        },
        // convert r,c into structure (if only 1 arg, assume r is address string)
        getAddress: function getAddress(r, c) {
          if (c) {
            var address = this.n2l(c) + r;
            return this.decodeAddress(address);
          }
          return this.decodeAddress(r);
        },
        // convert [address], [tl:br] into address structures
        decode: function decode(value) {
          var parts = value.split(":");
          if (parts.length === 2) {
            var tl = this.decodeAddress(parts[0]);
            var br = this.decodeAddress(parts[1]);
            var result = { top: Math.min(tl.row, br.row), left: Math.min(tl.col, br.col), bottom: Math.max(tl.row, br.row), right: Math.max(tl.col, br.col) };
            result.tl = this.n2l(result.left) + result.top;
            result.br = this.n2l(result.right) + result.bottom;
            result.dimensions = "".concat(result.tl, ":").concat(result.br);
            return result;
          }
          return this.decodeAddress(value);
        },
        // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures
        decodeEx: function decodeEx(value) {
          var groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);
          var sheetName = groups[1] || groups[2];
          var reference = groups[3];
          var parts = reference.split(":");
          if (parts.length > 1) {
            var tl = this.decodeAddress(parts[0]);
            var br = this.decodeAddress(parts[1]);
            var top = Math.min(tl.row, br.row);
            var left = Math.min(tl.col, br.col);
            var bottom = Math.max(tl.row, br.row);
            var right = Math.max(tl.col, br.col);
            tl = this.n2l(left) + top;
            br = this.n2l(right) + bottom;
            return { top, left, bottom, right, sheetName, tl: { address: tl, col: left, row: top, $col$row: "$".concat(this.n2l(left), "$").concat(top), sheetName }, br: { address: br, col: right, row: bottom, $col$row: "$".concat(this.n2l(right), "$").concat(bottom), sheetName }, dimensions: "".concat(tl, ":").concat(br) };
          }
          if (reference.startsWith("#")) {
            return sheetName ? { sheetName, error: reference } : { error: reference };
          }
          var address = this.decodeAddress(reference);
          return sheetName ? _objectSpread2({ sheetName }, address) : address;
        },
        // convert row,col into address string
        encodeAddress: function encodeAddress(row, col) {
          return colCache.n2l(col) + row;
        },
        // convert row,col into string address or t,l,b,r into range
        encode: function encode() {
          switch (arguments.length) {
            case 2:
              return colCache.encodeAddress(arguments[0], arguments[1]);
            case 4:
              return "".concat(colCache.encodeAddress(arguments[0], arguments[1]), ":").concat(colCache.encodeAddress(arguments[2], arguments[3]));
            default:
              throw new Error("Can only encode with 2 or 4 arguments");
          }
        },
        // return true if address is contained within range
        inRange: function inRange(range, address) {
          var _range = _slicedToArray2(range, 5), left = _range[0], top = _range[1], right = _range[3], bottom = _range[4];
          var _address = _slicedToArray2(address, 2), col = _address[0], row = _address[1];
          return col >= left && col <= right && row >= top && row <= bottom;
        }
      };
      module2.exports = colCache;
    }, {}], 20: [function(require2, module2, exports2) {
      (function(Buffer) {
        var crypto2 = require2("crypto");
        var Encryptor = {
          /**
          * Calculate a hash of the concatenated buffers with the given algorithm.
          * @param {string} algorithm - The hash algorithm.
          * @returns {Buffer} The hash
          */
          hash: function hash(algorithm) {
            var hash2 = crypto2.createHash(algorithm);
            for (var _len = arguments.length, buffers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              buffers[_key - 1] = arguments[_key];
            }
            hash2.update(Buffer.concat(buffers));
            return hash2.digest();
          },
          /**
          * Convert a password into an encryption key
          * @param {string} password - The password
          * @param {string} hashAlgorithm - The hash algoritm
          * @param {string} saltValue - The salt value
          * @param {number} spinCount - The spin count
          * @param {number} keyBits - The length of the key in bits
          * @param {Buffer} blockKey - The block key
          * @returns {Buffer} The encryption key
          */
          convertPasswordToHash: function convertPasswordToHash(password, hashAlgorithm, saltValue, spinCount) {
            hashAlgorithm = hashAlgorithm.toLowerCase();
            var hashes = crypto2.getHashes();
            if (hashes.indexOf(hashAlgorithm) < 0) {
              throw new Error("Hash algorithm '".concat(hashAlgorithm, "' not supported!"));
            }
            var passwordBuffer = Buffer.from(password, "utf16le");
            var key = this.hash(hashAlgorithm, Buffer.from(saltValue, "base64"), passwordBuffer);
            for (var i = 0; i < spinCount; i++) {
              var iterator = Buffer.alloc(4);
              iterator.writeUInt32LE(i, 0);
              key = this.hash(hashAlgorithm, key, iterator);
            }
            return key.toString("base64");
          },
          /**
          * Generates cryptographically strong pseudo-random data.
          * @param size The size argument is a number indicating the number of bytes to generate.
          */
          randomBytes: function randomBytes(size) {
            return crypto2.randomBytes(size);
          }
        };
        module2.exports = Encryptor;
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 216, "crypto": 335 }], 21: [function(require2, module2, exports2) {
      function _awaitAsyncGenerator(value) {
        return new _AwaitValue(value);
      }
      function _wrapAsyncGenerator(fn) {
        return function() {
          return new _AsyncGenerator(fn.apply(this, arguments));
        };
      }
      function _AsyncGenerator(gen) {
        var front, back;
        function send(key, arg) {
          return new Promise(function(resolve, reject) {
            var request = { key, arg, resolve, reject, next: null };
            if (back) {
              back = back.next = request;
            } else {
              front = back = request;
              resume(key, arg);
            }
          });
        }
        function resume(key, arg) {
          try {
            var result = gen[key](arg);
            var value = result.value;
            var wrappedAwait = value instanceof _AwaitValue;
            Promise.resolve(wrappedAwait ? value.wrapped : value).then(function(arg2) {
              if (wrappedAwait) {
                resume(key === "return" ? "return" : "next", arg2);
                return;
              }
              settle(result.done ? "return" : "normal", arg2);
            }, function(err) {
              resume("throw", err);
            });
          } catch (err) {
            settle("throw", err);
          }
        }
        function settle(type, value) {
          switch (type) {
            case "return":
              front.resolve({ value, done: true });
              break;
            case "throw":
              front.reject(value);
              break;
            default:
              front.resolve({ value, done: false });
              break;
          }
          front = front.next;
          if (front) {
            resume(front.key, front.arg);
          } else {
            back = null;
          }
        }
        this._invoke = send;
        if (typeof gen.return !== "function") {
          this.return = void 0;
        }
      }
      if (typeof Symbol === "function" && Symbol.asyncIterator) {
        _AsyncGenerator.prototype[Symbol.asyncIterator] = function() {
          return this;
        };
      }
      _AsyncGenerator.prototype.next = function(arg) {
        return this._invoke("next", arg);
      };
      _AsyncGenerator.prototype.throw = function(arg) {
        return this._invoke("throw", arg);
      };
      _AsyncGenerator.prototype.return = function(arg) {
        return this._invoke("return", arg);
      };
      function _AwaitValue(value) {
        this.wrapped = value;
      }
      function _asyncIterator(iterable) {
        var method;
        if (typeof Symbol !== "undefined") {
          if (Symbol.asyncIterator) {
            method = iterable[Symbol.asyncIterator];
            if (method != null)
              return method.call(iterable);
          }
          if (Symbol.iterator) {
            method = iterable[Symbol.iterator];
            if (method != null)
              return method.call(iterable);
          }
        }
        throw new TypeError("Object is not async iterable");
      }
      var _require = require2("saxes"), SaxesParser = _require.SaxesParser;
      var _require2 = require2("readable-stream"), PassThrough = _require2.PassThrough;
      var _require3 = require2("./browser-buffer-decode"), bufferToString = _require3.bufferToString;
      module2.exports = /* @__PURE__ */ function() {
        var _ref = _wrapAsyncGenerator(/* @__PURE__ */ regenerator.mark(function _callee(iterable) {
          var saxesParser, error, events, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (iterable.pipe && !iterable[Symbol.asyncIterator]) {
                    iterable = iterable.pipe(new PassThrough());
                  }
                  saxesParser = new SaxesParser();
                  saxesParser.on("error", function(err) {
                    error = err;
                  });
                  events = [];
                  saxesParser.on("opentag", function(value) {
                    return events.push({ eventType: "opentag", value });
                  });
                  saxesParser.on("text", function(value) {
                    return events.push({ eventType: "text", value });
                  });
                  saxesParser.on("closetag", function(value) {
                    return events.push({ eventType: "closetag", value });
                  });
                  _iteratorNormalCompletion = true;
                  _didIteratorError = false;
                  _context.prev = 9;
                  _iterator = _asyncIterator(iterable);
                case 11:
                  _context.next = 13;
                  return _awaitAsyncGenerator(_iterator.next());
                case 13:
                  _step = _context.sent;
                  _iteratorNormalCompletion = _step.done;
                  _context.next = 17;
                  return _awaitAsyncGenerator(_step.value);
                case 17:
                  _value = _context.sent;
                  if (_iteratorNormalCompletion) {
                    _context.next = 29;
                    break;
                  }
                  chunk = _value;
                  saxesParser.write(bufferToString(chunk));
                  if (!error) {
                    _context.next = 23;
                    break;
                  }
                  throw error;
                case 23:
                  _context.next = 25;
                  return events;
                case 25:
                  events = [];
                case 26:
                  _iteratorNormalCompletion = true;
                  _context.next = 11;
                  break;
                case 29:
                  _context.next = 35;
                  break;
                case 31:
                  _context.prev = 31;
                  _context.t0 = _context["catch"](9);
                  _didIteratorError = true;
                  _iteratorError = _context.t0;
                case 35:
                  _context.prev = 35;
                  _context.prev = 36;
                  if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                    _context.next = 40;
                    break;
                  }
                  _context.next = 40;
                  return _awaitAsyncGenerator(_iterator.return());
                case 40:
                  _context.prev = 40;
                  if (!_didIteratorError) {
                    _context.next = 43;
                    break;
                  }
                  throw _iteratorError;
                case 43:
                  return _context.finish(40);
                case 44:
                  return _context.finish(35);
                case 45:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[9, 31, 35, 45], [36, , 40, 44]]);
        }));
        return function(_x) {
          return _ref.apply(this, arguments);
        };
      }();
    }, { "./browser-buffer-decode": 16, "readable-stream": 491, "saxes": 496 }], 22: [function(require2, module2, exports2) {
      var colCache = require2("./col-cache");
      var replacementCandidateRx = /(([a-z_\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi;
      var CRrx = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i;
      function slideFormula(formula, fromCell, toCell) {
        var offset = colCache.decode(fromCell);
        var to = colCache.decode(toCell);
        return formula.replace(replacementCandidateRx, function(refMatch, sheet, sheetMaybe, addrPart, trailingParen) {
          if (trailingParen) {
            return refMatch;
          }
          var match = CRrx.exec(addrPart);
          if (match) {
            var colDollar = match[1];
            var colStr = match[2].toUpperCase();
            var rowDollar = match[3];
            var rowStr = match[4];
            if (colStr.length > 3 || colStr.length === 3 && colStr > "XFD") {
              return refMatch;
            }
            var col = colCache.l2n(colStr);
            var row = parseInt(rowStr, 10);
            if (!colDollar) {
              col += to.col - offset.col;
            }
            if (!rowDollar) {
              row += to.row - offset.row;
            }
            var res = (sheet || "") + (colDollar || "") + colCache.n2l(col) + (rowDollar || "") + row;
            return res;
          }
          return refMatch;
        });
      }
      module2.exports = { slideFormula };
    }, { "./col-cache": 19 }], 23: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }
          if (info.done) {
            resolve(value);
          } else {
            Promise.resolve(value).then(_next, _throw);
          }
        }
        function _asyncToGenerator2(fn) {
          return function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve, reject) {
              var gen = fn.apply(self2, args);
              function _next(value) {
                asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
              }
              function _throw(err) {
                asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
              }
              _next(void 0);
            });
          };
        }
        function _classCallCheck2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties2(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        var Stream = require2("readable-stream");
        var utils = require2("./utils");
        var StringBuf = require2("./string-buf");
        var StringChunk = /* @__PURE__ */ function() {
          function StringChunk2(data, encoding) {
            _classCallCheck2(this, StringChunk2);
            this._data = data;
            this._encoding = encoding;
          }
          _createClass2(StringChunk2, [{
            key: "copy",
            // copy to target buffer
            value: function copy2(target, targetOffset, offset, length) {
              return this.toBuffer().copy(target, targetOffset, offset, length);
            }
          }, { key: "toBuffer", value: function toBuffer() {
            if (!this._buffer) {
              this._buffer = Buffer.from(this._data, this._encoding);
            }
            return this._buffer;
          } }, { key: "length", get: function get() {
            return this.toBuffer().length;
          } }]);
          return StringChunk2;
        }();
        var StringBufChunk = /* @__PURE__ */ function() {
          function StringBufChunk2(data) {
            _classCallCheck2(this, StringBufChunk2);
            this._data = data;
          }
          _createClass2(StringBufChunk2, [{
            key: "copy",
            // copy to target buffer
            value: function copy2(target, targetOffset, offset, length) {
              return this._data._buf.copy(target, targetOffset, offset, length);
            }
          }, { key: "toBuffer", value: function toBuffer() {
            return this._data.toBuffer();
          } }, { key: "length", get: function get() {
            return this._data.length;
          } }]);
          return StringBufChunk2;
        }();
        var BufferChunk = /* @__PURE__ */ function() {
          function BufferChunk2(data) {
            _classCallCheck2(this, BufferChunk2);
            this._data = data;
          }
          _createClass2(BufferChunk2, [{
            key: "copy",
            // copy to target buffer
            value: function copy2(target, targetOffset, offset, length) {
              this._data.copy(target, targetOffset, offset, length);
            }
          }, { key: "toBuffer", value: function toBuffer() {
            return this._data;
          } }, { key: "length", get: function get() {
            return this._data.length;
          } }]);
          return BufferChunk2;
        }();
        var ReadWriteBuf = /* @__PURE__ */ function() {
          function ReadWriteBuf2(size) {
            _classCallCheck2(this, ReadWriteBuf2);
            this.size = size;
            this.buffer = Buffer.alloc(size);
            this.iRead = 0;
            this.iWrite = 0;
          }
          _createClass2(ReadWriteBuf2, [{ key: "toBuffer", value: function toBuffer() {
            if (this.iRead === 0 && this.iWrite === this.size) {
              return this.buffer;
            }
            var buf = Buffer.alloc(this.iWrite - this.iRead);
            this.buffer.copy(buf, 0, this.iRead, this.iWrite);
            return buf;
          } }, { key: "read", value: function read(size) {
            var buf;
            if (size === 0) {
              return null;
            }
            if (size === void 0 || size >= this.length) {
              buf = this.toBuffer();
              this.iRead = this.iWrite;
              return buf;
            }
            buf = Buffer.alloc(size);
            this.buffer.copy(buf, 0, this.iRead, size);
            this.iRead += size;
            return buf;
          } }, { key: "write", value: function write(chunk, offset, length) {
            var size = Math.min(length, this.size - this.iWrite);
            chunk.copy(this.buffer, this.iWrite, offset, offset + size);
            this.iWrite += size;
            return size;
          } }, { key: "length", get: function get() {
            return this.iWrite - this.iRead;
          } }, { key: "eod", get: function get() {
            return this.iRead === this.iWrite;
          } }, { key: "full", get: function get() {
            return this.iWrite === this.size;
          } }]);
          return ReadWriteBuf2;
        }();
        var StreamBuf = function StreamBuf2(options) {
          options = options || {};
          this.bufSize = options.bufSize || 1024 * 1024;
          this.buffers = [];
          this.batch = options.batch || false;
          this.corked = false;
          this.inPos = 0;
          this.outPos = 0;
          this.pipes = [];
          this.paused = false;
          this.encoding = null;
        };
        utils.inherits(StreamBuf, Stream.Duplex, {
          toBuffer: function toBuffer() {
            switch (this.buffers.length) {
              case 0:
                return null;
              case 1:
                return this.buffers[0].toBuffer();
              default:
                return Buffer.concat(this.buffers.map(function(rwBuf) {
                  return rwBuf.toBuffer();
                }));
            }
          },
          // writable
          // event drain - if write returns false (which it won't), indicates when safe to write again.
          // finish - end() has been called
          // pipe(src) - pipe() has been called on readable
          // unpipe(src) - unpipe() has been called on readable
          // error - duh
          _getWritableBuffer: function _getWritableBuffer() {
            if (this.buffers.length) {
              var last = this.buffers[this.buffers.length - 1];
              if (!last.full) {
                return last;
              }
            }
            var buf = new ReadWriteBuf(this.bufSize);
            this.buffers.push(buf);
            return buf;
          },
          _pipe: function _pipe(chunk) {
            var _this = this;
            return _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee() {
              var write;
              return regenerator.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      write = function write2(pipe) {
                        return new Promise(function(resolve) {
                          pipe.write(chunk.toBuffer(), function() {
                            resolve();
                          });
                        });
                      };
                      _context.next = 3;
                      return Promise.all(_this.pipes.map(write));
                    case 3:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }))();
          },
          _writeToBuffers: function _writeToBuffers(chunk) {
            var inPos = 0;
            var inLen = chunk.length;
            while (inPos < inLen) {
              var buffer = this._getWritableBuffer();
              inPos += buffer.write(chunk, inPos, inLen - inPos);
            }
          },
          write: function write(data, encoding, callback) {
            var _this2 = this;
            return _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee2() {
              var chunk;
              return regenerator.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      if (encoding instanceof Function) {
                        callback = encoding;
                        encoding = "utf8";
                      }
                      callback = callback || utils.nop;
                      if (!(data instanceof StringBuf)) {
                        _context2.next = 6;
                        break;
                      }
                      chunk = new StringBufChunk(data);
                      _context2.next = 15;
                      break;
                    case 6:
                      if (!(data instanceof Buffer)) {
                        _context2.next = 10;
                        break;
                      }
                      chunk = new BufferChunk(data);
                      _context2.next = 15;
                      break;
                    case 10:
                      if (!(typeof data === "string" || data instanceof String || data instanceof ArrayBuffer)) {
                        _context2.next = 14;
                        break;
                      }
                      chunk = new StringChunk(data, encoding);
                      _context2.next = 15;
                      break;
                    case 14:
                      throw new Error("Chunk must be one of type String, Buffer or StringBuf.");
                    case 15:
                      if (!_this2.pipes.length) {
                        _context2.next = 31;
                        break;
                      }
                      if (!_this2.batch) {
                        _context2.next = 21;
                        break;
                      }
                      _this2._writeToBuffers(chunk);
                      while (!_this2.corked && _this2.buffers.length > 1) {
                        _this2._pipe(_this2.buffers.shift());
                      }
                      _context2.next = 29;
                      break;
                    case 21:
                      if (_this2.corked) {
                        _context2.next = 27;
                        break;
                      }
                      _context2.next = 24;
                      return _this2._pipe(chunk);
                    case 24:
                      callback();
                      _context2.next = 29;
                      break;
                    case 27:
                      _this2._writeToBuffers(chunk);
                      process.nextTick(callback);
                    case 29:
                      _context2.next = 34;
                      break;
                    case 31:
                      if (!_this2.paused) {
                        _this2.emit("data", chunk.toBuffer());
                      }
                      _this2._writeToBuffers(chunk);
                      _this2.emit("readable");
                    case 34:
                      return _context2.abrupt("return", true);
                    case 35:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }))();
          },
          cork: function cork() {
            this.corked = true;
          },
          _flush: function _flush() {
            if (this.pipes.length) {
              while (this.buffers.length) {
                this._pipe(this.buffers.shift());
              }
            }
          },
          uncork: function uncork() {
            this.corked = false;
            this._flush();
          },
          end: function end(chunk, encoding, callback) {
            var _this3 = this;
            var writeComplete = function writeComplete2(error) {
              if (error) {
                callback(error);
              } else {
                _this3._flush();
                _this3.pipes.forEach(function(pipe) {
                  pipe.end();
                });
                _this3.emit("finish");
              }
            };
            if (chunk) {
              this.write(chunk, encoding, writeComplete);
            } else {
              writeComplete();
            }
          },
          // readable
          // event readable - some data is now available
          // event data - switch to flowing mode - feeds chunks to handler
          // event end - no more data
          // event close - optional, indicates upstream close
          // event error - duh
          read: function read(size) {
            var buffers;
            if (size) {
              buffers = [];
              while (size && this.buffers.length && !this.buffers[0].eod) {
                var first = this.buffers[0];
                var buffer = first.read(size);
                size -= buffer.length;
                buffers.push(buffer);
                if (first.eod && first.full) {
                  this.buffers.shift();
                }
              }
              return Buffer.concat(buffers);
            }
            buffers = this.buffers.map(function(buf) {
              return buf.toBuffer();
            }).filter(Boolean);
            this.buffers = [];
            return Buffer.concat(buffers);
          },
          setEncoding: function setEncoding(encoding) {
            this.encoding = encoding;
          },
          pause: function pause() {
            this.paused = true;
          },
          resume: function resume() {
            this.paused = false;
          },
          isPaused: function isPaused() {
            return !!this.paused;
          },
          pipe: function pipe(destination) {
            this.pipes.push(destination);
            if (!this.paused && this.buffers.length) {
              this.end();
            }
          },
          unpipe: function unpipe(destination) {
            this.pipes = this.pipes.filter(function(pipe) {
              return pipe !== destination;
            });
          },
          unshift: function unshift() {
            throw new Error("Not Implemented");
          },
          wrap: function wrap() {
            throw new Error("Not Implemented");
          }
        });
        module2.exports = StreamBuf;
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "./string-buf": 24, "./utils": 26, "_process": 467, "buffer": 216, "readable-stream": 491 }], 24: [function(require2, module2, exports2) {
      (function(Buffer) {
        function _classCallCheck2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties2(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        var StringBuf = /* @__PURE__ */ function() {
          function StringBuf2(options) {
            _classCallCheck2(this, StringBuf2);
            this._buf = Buffer.alloc(options && options.size || 16384);
            this._encoding = options && options.encoding || "utf8";
            this._inPos = 0;
            this._buffer = void 0;
          }
          _createClass2(StringBuf2, [{ key: "toBuffer", value: function toBuffer() {
            if (!this._buffer) {
              this._buffer = Buffer.alloc(this.length);
              this._buf.copy(this._buffer, 0, 0, this.length);
            }
            return this._buffer;
          } }, { key: "reset", value: function reset(position) {
            position = position || 0;
            this._buffer = void 0;
            this._inPos = position;
          } }, { key: "_grow", value: function _grow(min) {
            var size = this._buf.length * 2;
            while (size < min) {
              size *= 2;
            }
            var buf = Buffer.alloc(size);
            this._buf.copy(buf, 0);
            this._buf = buf;
          } }, { key: "addText", value: function addText(text) {
            this._buffer = void 0;
            var inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
            while (inPos >= this._buf.length - 4) {
              this._grow(this._inPos + text.length);
              inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
            }
            this._inPos = inPos;
          } }, { key: "addStringBuf", value: function addStringBuf(inBuf) {
            if (inBuf.length) {
              this._buffer = void 0;
              if (this.length + inBuf.length > this.capacity) {
                this._grow(this.length + inBuf.length);
              }
              inBuf._buf.copy(this._buf, this._inPos, 0, inBuf.length);
              this._inPos += inBuf.length;
            }
          } }, { key: "length", get: function get() {
            return this._inPos;
          } }, { key: "capacity", get: function get() {
            return this._buf.length;
          } }, { key: "buffer", get: function get() {
            return this._buf;
          } }]);
          return StringBuf2;
        }();
        module2.exports = StringBuf;
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 216 }], 25: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var toString2 = Object.prototype.toString;
      var escapeHtmlRegex = /["&<>]/;
      var _ = { each: function each(obj, cb) {
        if (obj) {
          if (Array.isArray(obj)) {
            obj.forEach(cb);
          } else {
            Object.keys(obj).forEach(function(key) {
              cb(obj[key], key);
            });
          }
        }
      }, some: function some(obj, cb) {
        if (obj) {
          if (Array.isArray(obj)) {
            return obj.some(cb);
          }
          return Object.keys(obj).some(function(key) {
            return cb(obj[key], key);
          });
        }
        return false;
      }, every: function every(obj, cb) {
        if (obj) {
          if (Array.isArray(obj)) {
            return obj.every(cb);
          }
          return Object.keys(obj).every(function(key) {
            return cb(obj[key], key);
          });
        }
        return true;
      }, map: function map(obj, cb) {
        if (obj) {
          if (Array.isArray(obj)) {
            return obj.map(cb);
          }
          return Object.keys(obj).map(function(key) {
            return cb(obj[key], key);
          });
        }
        return [];
      }, keyBy: function keyBy(a, p) {
        return a.reduce(function(o, v) {
          o[v[p]] = v;
          return o;
        }, {});
      }, isEqual: function isEqual(a, b) {
        var aType = _typeof2(a);
        var bType = _typeof2(b);
        var aArray = Array.isArray(a);
        var bArray = Array.isArray(b);
        if (aType !== bType) {
          return false;
        }
        switch (_typeof2(a)) {
          case "object":
            if (aArray || bArray) {
              if (aArray && bArray) {
                return a.length === b.length && a.every(function(aValue, index2) {
                  var bValue = b[index2];
                  return _.isEqual(aValue, bValue);
                });
              }
              return false;
            }
            return _.every(a, function(aValue, key) {
              var bValue = b[key];
              return _.isEqual(aValue, bValue);
            });
          default:
            return a === b;
        }
      }, escapeHtml: function escapeHtml(html) {
        var regexResult = escapeHtmlRegex.exec(html);
        if (!regexResult)
          return html;
        var result = "";
        var escape = "";
        var lastIndex = 0;
        var i = regexResult.index;
        for (; i < html.length; i++) {
          switch (html.charAt(i)) {
            case '"':
              escape = "&quot;";
              break;
            case "&":
              escape = "&amp;";
              break;
            case "'":
              escape = "&apos;";
              break;
            case "<":
              escape = "&lt;";
              break;
            case ">":
              escape = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== i)
            result += html.substring(lastIndex, i);
          lastIndex = i + 1;
          result += escape;
        }
        if (lastIndex !== i)
          return result + html.substring(lastIndex, i);
        return result;
      }, strcmp: function strcmp(a, b) {
        if (a < b)
          return -1;
        if (a > b)
          return 1;
        return 0;
      }, isUndefined: function isUndefined(val) {
        return toString2.call(val) === "[object Undefined]";
      }, isObject: function isObject(val) {
        return toString2.call(val) === "[object Object]";
      }, deepMerge: function deepMerge() {
        var target = arguments[0] || {};
        var length = arguments.length;
        var src, clone2, copyIsArray;
        function assignValue(val, key) {
          src = target[key];
          copyIsArray = Array.isArray(val);
          if (_.isObject(val) || copyIsArray) {
            if (copyIsArray) {
              copyIsArray = false;
              clone2 = src && Array.isArray(src) ? src : [];
            } else {
              clone2 = src && _.isObject(src) ? src : {};
            }
            target[key] = _.deepMerge(clone2, val);
          } else if (!_.isUndefined(val)) {
            target[key] = val;
          }
        }
        for (var i = 0; i < length; i++) {
          _.each(arguments[i], assignValue);
        }
        return target;
      } };
      module2.exports = _;
    }, {}], 26: [function(require2, module2, exports2) {
      (function(global2, setImmediate) {
        var fs = require2("fs");
        var inherits = function inherits2(cls, superCtor, statics, prototype) {
          cls.super_ = superCtor;
          if (!prototype) {
            prototype = statics;
            statics = null;
          }
          if (statics) {
            Object.keys(statics).forEach(function(i) {
              Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));
            });
          }
          var properties = { constructor: { value: cls, enumerable: false, writable: false, configurable: true } };
          if (prototype) {
            Object.keys(prototype).forEach(function(i) {
              properties[i] = Object.getOwnPropertyDescriptor(prototype, i);
            });
          }
          cls.prototype = Object.create(superCtor.prototype, properties);
        };
        var xmlDecodeRegex = /[<>&'"\x7F\x00-\x08\x0B-\x0C\x0E-\x1F]/;
        var utils = { nop: function nop() {
        }, promiseImmediate: function promiseImmediate(value) {
          return new Promise(function(resolve) {
            if (global2.setImmediate) {
              setImmediate(function() {
                resolve(value);
              });
            } else {
              setTimeout(function() {
                resolve(value);
              }, 1);
            }
          });
        }, inherits, dateToExcel: function dateToExcel(d, date1904) {
          return 25569 + d.getTime() / (24 * 3600 * 1e3) - (date1904 ? 1462 : 0);
        }, excelToDate: function excelToDate(v, date1904) {
          var millisecondSinceEpoch = Math.round((v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1e3);
          return new Date(millisecondSinceEpoch);
        }, parsePath: function parsePath(filepath) {
          var last = filepath.lastIndexOf("/");
          return { path: filepath.substring(0, last), name: filepath.substring(last + 1) };
        }, getRelsPath: function getRelsPath(filepath) {
          var path = utils.parsePath(filepath);
          return "".concat(path.path, "/_rels/").concat(path.name, ".rels");
        }, xmlEncode: function xmlEncode(text) {
          var regexResult = xmlDecodeRegex.exec(text);
          if (!regexResult)
            return text;
          var result = "";
          var escape = "";
          var lastIndex = 0;
          var i = regexResult.index;
          for (; i < text.length; i++) {
            var charCode = text.charCodeAt(i);
            switch (charCode) {
              case 34:
                escape = "&quot;";
                break;
              case 38:
                escape = "&amp;";
                break;
              case 39:
                escape = "&apos;";
                break;
              case 60:
                escape = "&lt;";
                break;
              case 62:
                escape = "&gt;";
                break;
              case 127:
                escape = "";
                break;
              default: {
                if (charCode <= 31 && (charCode <= 8 || charCode >= 11 && charCode !== 13)) {
                  escape = "";
                  break;
                }
                continue;
              }
            }
            if (lastIndex !== i)
              result += text.substring(lastIndex, i);
            lastIndex = i + 1;
            if (escape)
              result += escape;
          }
          if (lastIndex !== i)
            return result + text.substring(lastIndex, i);
          return result;
        }, xmlDecode: function xmlDecode(text) {
          return text.replace(/&([a-z]*);/g, function(c) {
            switch (c) {
              case "&lt;":
                return "<";
              case "&gt;":
                return ">";
              case "&amp;":
                return "&";
              case "&apos;":
                return "'";
              case "&quot;":
                return '"';
              default:
                return c;
            }
          });
        }, validInt: function validInt(value) {
          var i = parseInt(value, 10);
          return !Number.isNaN(i) ? i : 0;
        }, isDateFmt: function isDateFmt(fmt) {
          if (!fmt) {
            return false;
          }
          fmt = fmt.replace(/\[[^\]]*]/g, "");
          fmt = fmt.replace(/"[^"]*"/g, "");
          var result = fmt.match(/[ymdhMsb]+/) !== null;
          return result;
        }, fs: { exists: function exists(path) {
          return new Promise(function(resolve) {
            fs.access(path, fs.constants.F_OK, function(err) {
              resolve(!err);
            });
          });
        } }, toIsoDateString: function toIsoDateString(dt) {
          return dt.toIsoString().subsstr(0, 10);
        } };
        module2.exports = utils;
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("timers").setImmediate);
    }, { "fs": 215, "timers": 521 }], 27: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var _ = require2("./under-dash");
      var utils = require2("./utils");
      var OPEN_ANGLE = "<";
      var CLOSE_ANGLE = ">";
      var OPEN_ANGLE_SLASH = "</";
      var CLOSE_SLASH_ANGLE = "/>";
      var EQUALS_QUOTE = '="';
      var QUOTE = '"';
      var SPACE = " ";
      function pushAttribute(xml, name, value) {
        xml.push(SPACE);
        xml.push(name);
        xml.push(EQUALS_QUOTE);
        xml.push(utils.xmlEncode(value.toString()));
        xml.push(QUOTE);
      }
      function pushAttributes(xml, attributes) {
        if (attributes) {
          _.each(attributes, function(value, name) {
            if (value !== void 0) {
              pushAttribute(xml, name, value);
            }
          });
        }
      }
      var XmlStream = /* @__PURE__ */ function() {
        function XmlStream2() {
          _classCallCheck2(this, XmlStream2);
          this._xml = [];
          this._stack = [];
          this._rollbacks = [];
        }
        _createClass2(XmlStream2, [{ key: "openXml", value: function openXml(docAttributes) {
          var xml = this._xml;
          xml.push("<?xml");
          pushAttributes(xml, docAttributes);
          xml.push("?>\n");
        } }, { key: "openNode", value: function openNode(name, attributes) {
          var parent = this.tos;
          var xml = this._xml;
          if (parent && this.open) {
            xml.push(CLOSE_ANGLE);
          }
          this._stack.push(name);
          xml.push(OPEN_ANGLE);
          xml.push(name);
          pushAttributes(xml, attributes);
          this.leaf = true;
          this.open = true;
        } }, { key: "addAttribute", value: function addAttribute(name, value) {
          if (!this.open) {
            throw new Error("Cannot write attributes to node if it is not open");
          }
          if (value !== void 0) {
            pushAttribute(this._xml, name, value);
          }
        } }, { key: "addAttributes", value: function addAttributes(attrs) {
          if (!this.open) {
            throw new Error("Cannot write attributes to node if it is not open");
          }
          pushAttributes(this._xml, attrs);
        } }, { key: "writeText", value: function writeText(text) {
          var xml = this._xml;
          if (this.open) {
            xml.push(CLOSE_ANGLE);
            this.open = false;
          }
          this.leaf = false;
          xml.push(utils.xmlEncode(text.toString()));
        } }, { key: "writeXml", value: function writeXml(xml) {
          if (this.open) {
            this._xml.push(CLOSE_ANGLE);
            this.open = false;
          }
          this.leaf = false;
          this._xml.push(xml);
        } }, { key: "closeNode", value: function closeNode() {
          var node = this._stack.pop();
          var xml = this._xml;
          if (this.leaf) {
            xml.push(CLOSE_SLASH_ANGLE);
          } else {
            xml.push(OPEN_ANGLE_SLASH);
            xml.push(node);
            xml.push(CLOSE_ANGLE);
          }
          this.open = false;
          this.leaf = false;
        } }, { key: "leafNode", value: function leafNode(name, attributes, text) {
          this.openNode(name, attributes);
          if (text !== void 0) {
            this.writeText(text);
          }
          this.closeNode();
        } }, { key: "closeAll", value: function closeAll() {
          while (this._stack.length) {
            this.closeNode();
          }
        } }, { key: "addRollback", value: function addRollback() {
          this._rollbacks.push({ xml: this._xml.length, stack: this._stack.length, leaf: this.leaf, open: this.open });
          return this.cursor;
        } }, { key: "commit", value: function commit() {
          this._rollbacks.pop();
        } }, { key: "rollback", value: function rollback() {
          var r = this._rollbacks.pop();
          if (this._xml.length > r.xml) {
            this._xml.splice(r.xml, this._xml.length - r.xml);
          }
          if (this._stack.length > r.stack) {
            this._stack.splice(r.stack, this._stack.length - r.stack);
          }
          this.leaf = r.leaf;
          this.open = r.open;
        } }, { key: "tos", get: function get() {
          return this._stack.length ? this._stack[this._stack.length - 1] : void 0;
        } }, { key: "cursor", get: function get() {
          return this._xml.length;
        } }, { key: "xml", get: function get() {
          this.closeAll();
          return this._xml.join("");
        } }]);
        return XmlStream2;
      }();
      XmlStream.StdDocAttributes = { version: "1.0", encoding: "UTF-8", standalone: "yes" };
      module2.exports = XmlStream;
    }, { "./under-dash": 25, "./utils": 26 }], 28: [function(require2, module2, exports2) {
      (function(process) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }
          if (info.done) {
            resolve(value);
          } else {
            Promise.resolve(value).then(_next, _throw);
          }
        }
        function _asyncToGenerator2(fn) {
          return function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve, reject) {
              var gen = fn.apply(self2, args);
              function _next(value) {
                asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
              }
              function _throw(err) {
                asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
              }
              _next(void 0);
            });
          };
        }
        function _classCallCheck2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties2(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inherits2(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
          if (superClass)
            _setPrototypeOf2(subClass, superClass);
        }
        function _setPrototypeOf2(o, p) {
          _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf2(o, p);
        }
        function _createSuper2(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct2();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf2(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf2(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn2(this, result);
          };
        }
        function _possibleConstructorReturn2(self2, call) {
          if (call && (_typeof2(call) === "object" || typeof call === "function")) {
            return call;
          }
          return _assertThisInitialized2(self2);
        }
        function _assertThisInitialized2(self2) {
          if (self2 === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        function _isNativeReflectConstruct2() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            }));
            return true;
          } catch (e) {
            return false;
          }
        }
        function _getPrototypeOf2(o) {
          _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return _getPrototypeOf2(o);
        }
        var events = require2("events");
        var JSZip = require2("jszip");
        var StreamBuf = require2("./stream-buf");
        var _require = require2("./browser-buffer-encode"), stringToBuffer = _require.stringToBuffer;
        var ZipWriter = /* @__PURE__ */ function(_events$EventEmitter) {
          _inherits2(ZipWriter2, _events$EventEmitter);
          var _super = _createSuper2(ZipWriter2);
          function ZipWriter2(options) {
            var _this;
            _classCallCheck2(this, ZipWriter2);
            _this = _super.call(this);
            _this.options = Object.assign({ type: "nodebuffer", compression: "DEFLATE" }, options);
            _this.zip = new JSZip();
            _this.stream = new StreamBuf();
            return _this;
          }
          _createClass2(ZipWriter2, [{ key: "append", value: function append(data, options) {
            if (options.hasOwnProperty("base64") && options.base64) {
              this.zip.file(options.name, data, { base64: true });
            } else {
              if (process.browser && typeof data === "string") {
                data = stringToBuffer(data);
              }
              this.zip.file(options.name, data);
            }
          } }, {
            key: "finalize",
            value: function() {
              var _finalize = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee() {
                var content;
                return regenerator.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.next = 2;
                        return this.zip.generateAsync(this.options);
                      case 2:
                        content = _context.sent;
                        this.stream.end(content);
                        this.emit("finish");
                      case 5:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, this);
              }));
              function finalize() {
                return _finalize.apply(this, arguments);
              }
              return finalize;
            }()
            // ==========================================================================
            // Stream.Readable interface
          }, { key: "read", value: function read(size) {
            return this.stream.read(size);
          } }, { key: "setEncoding", value: function setEncoding(encoding) {
            return this.stream.setEncoding(encoding);
          } }, { key: "pause", value: function pause() {
            return this.stream.pause();
          } }, { key: "resume", value: function resume() {
            return this.stream.resume();
          } }, { key: "isPaused", value: function isPaused() {
            return this.stream.isPaused();
          } }, { key: "pipe", value: function pipe(destination, options) {
            return this.stream.pipe(destination, options);
          } }, { key: "unpipe", value: function unpipe(destination) {
            return this.stream.unpipe(destination);
          } }, { key: "unshift", value: function unshift(chunk) {
            return this.stream.unshift(chunk);
          } }, { key: "wrap", value: function wrap(stream) {
            return this.stream.wrap(stream);
          } }]);
          return ZipWriter2;
        }(events.EventEmitter);
        module2.exports = { ZipWriter };
      }).call(this, require2("_process"));
    }, { "./browser-buffer-encode": 17, "./stream-buf": 23, "_process": 467, "events": 367, "jszip": 399 }], 29: [function(require2, module2, exports2) {
      module2.exports = { 0: { f: "General" }, 1: { f: "0" }, 2: { f: "0.00" }, 3: { f: "#,##0" }, 4: { f: "#,##0.00" }, 9: { f: "0%" }, 10: { f: "0.00%" }, 11: { f: "0.00E+00" }, 12: { f: "# ?/?" }, 13: { f: "# ??/??" }, 14: { f: "mm-dd-yy" }, 15: { f: "d-mmm-yy" }, 16: { f: "d-mmm" }, 17: { f: "mmm-yy" }, 18: { f: "h:mm AM/PM" }, 19: { f: "h:mm:ss AM/PM" }, 20: { f: "h:mm" }, 21: { f: "h:mm:ss" }, 22: { f: 'm/d/yy "h":mm' }, 27: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy""m""', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"" mm"" dd""' }, 28: { "zh-tw": '[$-404]e""m""d""', "zh-cn": 'm""d""', "ja-jp": '[$-411]ggge""m""d""', "ko-kr": "mm-dd" }, 29: { "zh-tw": '[$-404]e""m""d""', "zh-cn": 'm""d""', "ja-jp": '[$-411]ggge""m""d""', "ko-kr": "mm-dd" }, 30: { "zh-tw": "m/d/yy ", "zh-cn": "m-d-yy", "ja-jp": "m/d/yy", "ko-kr": "mm-dd-yy" }, 31: { "zh-tw": 'yyyy""m""d""', "zh-cn": 'yyyy""m""d""', "ja-jp": 'yyyy""m""d""', "ko-kr": 'yyyy"" mm"" dd""' }, 32: { "zh-tw": 'hh""mm""', "zh-cn": 'h""mm""', "ja-jp": 'h""mm""', "ko-kr": 'h"" mm""' }, 33: { "zh-tw": 'hh""mm""ss""', "zh-cn": 'h""mm""ss""', "ja-jp": 'h""mm""ss""', "ko-kr": 'h"" mm"" ss""' }, 34: { "zh-tw": '/ hh""mm""', "zh-cn": '/ h""mm""', "ja-jp": 'yyyy""m""', "ko-kr": "yyyy-mm-dd" }, 35: { "zh-tw": '/ hh""mm""ss""', "zh-cn": '/ h""mm""ss""', "ja-jp": 'm""d""', "ko-kr": "yyyy-mm-dd" }, 36: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy""m""', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"" mm"" dd""' }, 37: { f: "#,##0 ;(#,##0)" }, 38: { f: "#,##0 ;[Red](#,##0)" }, 39: { f: "#,##0.00 ;(#,##0.00)" }, 40: { f: "#,##0.00 ;[Red](#,##0.00)" }, 45: { f: "mm:ss" }, 46: { f: "[h]:mm:ss" }, 47: { f: "mmss.0" }, 48: { f: "##0.0E+0" }, 49: { f: "@" }, 50: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy""m""', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"" mm"" dd""' }, 51: { "zh-tw": '[$-404]e""m""d""', "zh-cn": 'm""d""', "ja-jp": '[$-411]ggge""m""d""', "ko-kr": "mm-dd" }, 52: { "zh-tw": '/ hh""mm""', "zh-cn": 'yyyy""m""', "ja-jp": 'yyyy""m""', "ko-kr": "yyyy-mm-dd" }, 53: { "zh-tw": '/ hh""mm""ss""', "zh-cn": 'm""d""', "ja-jp": 'm""d""', "ko-kr": "yyyy-mm-dd" }, 54: { "zh-tw": '[$-404]e""m""d""', "zh-cn": 'm""d""', "ja-jp": '[$-411]ggge""m""d""', "ko-kr": "mm-dd" }, 55: { "zh-tw": '/ hh""mm""', "zh-cn": '/ h""mm""', "ja-jp": 'yyyy""m""', "ko-kr": "yyyy-mm-dd" }, 56: { "zh-tw": '/ hh""mm""ss""', "zh-cn": '/ h""mm""ss""', "ja-jp": 'm""d""', "ko-kr": "yyyy-mm-dd" }, 57: { "zh-tw": "[$-404]e/m/d", "zh-cn": 'yyyy""m""', "ja-jp": "[$-411]ge.m.d", "ko-kr": 'yyyy"" mm"" dd""' }, 58: { "zh-tw": '[$-404]e""m""d""', "zh-cn": 'm""d""', "ja-jp": '[$-411]ggge""m""d""', "ko-kr": "mm-dd" }, 59: { "th-th": "t0" }, 60: { "th-th": "t0.00" }, 61: { "th-th": "t#,##0" }, 62: { "th-th": "t#,##0.00" }, 67: { "th-th": "t0%" }, 68: { "th-th": "t0.00%" }, 69: { "th-th": "t# ?/?" }, 70: { "th-th": "t# ??/??" }, 81: { "th-th": "d/m/bb" } };
    }, {}], 30: [function(require2, module2, exports2) {
      module2.exports = { OfficeDocument: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument", Worksheet: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet", CalcChain: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain", SharedStrings: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings", Styles: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles", Theme: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme", Hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink", Image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", CoreProperties: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties", ExtenderProperties: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties", Comments: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments", VmlDrawing: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing", Table: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table" };
    }, {}], 31: [function(require2, module2, exports2) {
      function _createForOfIteratorHelper2(o, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it)
              o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length)
                return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = o[Symbol.iterator]();
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _unsupportedIterableToArray2(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray2(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray2(o, minLen);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }
        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }
      function _asyncToGenerator2(fn) {
        return function() {
          var self2 = this, args = arguments;
          return new Promise(function(resolve, reject) {
            var gen = fn.apply(self2, args);
            function _next(value) {
              asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
              asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(void 0);
          });
        };
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _asyncIterator(iterable) {
        var method;
        if (typeof Symbol !== "undefined") {
          if (Symbol.asyncIterator) {
            method = iterable[Symbol.asyncIterator];
            if (method != null)
              return method.call(iterable);
          }
          if (Symbol.iterator) {
            method = iterable[Symbol.iterator];
            if (method != null)
              return method.call(iterable);
          }
        }
        throw new TypeError("Object is not async iterable");
      }
      var parseSax = require2("../../utils/parse-sax");
      var XmlStream = require2("../../utils/xml-stream");
      var BaseXform = /* @__PURE__ */ function() {
        function BaseXform2() {
          _classCallCheck2(this, BaseXform2);
        }
        _createClass2(BaseXform2, [{
          key: "prepare",
          // constructor(/* model, name */) {}
          // ============================================================
          // Virtual Interface
          value: function prepare() {
          }
        }, { key: "render", value: function render15() {
        } }, { key: "parseOpen", value: function parseOpen(node) {
        } }, { key: "parseText", value: function parseText(text) {
        } }, { key: "parseClose", value: function parseClose(name) {
        } }, {
          key: "reconcile",
          value: function reconcile(model, options) {
          }
          // ============================================================
        }, { key: "reset", value: function reset() {
          this.model = null;
          if (this.map) {
            Object.values(this.map).forEach(function(xform) {
              if (xform instanceof BaseXform2) {
                xform.reset();
              } else if (xform.xform) {
                xform.xform.reset();
              }
            });
          }
        } }, { key: "mergeModel", value: function mergeModel(obj) {
          this.model = Object.assign(this.model || {}, obj);
        } }, { key: "parse", value: function() {
          var _parse = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee(saxParser) {
            var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, events, _iterator2, _step2, _step2$value, eventType, value;
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _iteratorNormalCompletion = true;
                    _didIteratorError = false;
                    _context.prev = 2;
                    _iterator = _asyncIterator(saxParser);
                  case 4:
                    _context.next = 6;
                    return _iterator.next();
                  case 6:
                    _step = _context.sent;
                    _iteratorNormalCompletion = _step.done;
                    _context.next = 10;
                    return _step.value;
                  case 10:
                    _value = _context.sent;
                    if (_iteratorNormalCompletion) {
                      _context.next = 42;
                      break;
                    }
                    events = _value;
                    _iterator2 = _createForOfIteratorHelper2(events);
                    _context.prev = 14;
                    _iterator2.s();
                  case 16:
                    if ((_step2 = _iterator2.n()).done) {
                      _context.next = 31;
                      break;
                    }
                    _step2$value = _step2.value, eventType = _step2$value.eventType, value = _step2$value.value;
                    if (!(eventType === "opentag")) {
                      _context.next = 22;
                      break;
                    }
                    this.parseOpen(value);
                    _context.next = 29;
                    break;
                  case 22:
                    if (!(eventType === "text")) {
                      _context.next = 26;
                      break;
                    }
                    this.parseText(value);
                    _context.next = 29;
                    break;
                  case 26:
                    if (!(eventType === "closetag")) {
                      _context.next = 29;
                      break;
                    }
                    if (this.parseClose(value.name)) {
                      _context.next = 29;
                      break;
                    }
                    return _context.abrupt("return", this.model);
                  case 29:
                    _context.next = 16;
                    break;
                  case 31:
                    _context.next = 36;
                    break;
                  case 33:
                    _context.prev = 33;
                    _context.t0 = _context["catch"](14);
                    _iterator2.e(_context.t0);
                  case 36:
                    _context.prev = 36;
                    _iterator2.f();
                    return _context.finish(36);
                  case 39:
                    _iteratorNormalCompletion = true;
                    _context.next = 4;
                    break;
                  case 42:
                    _context.next = 48;
                    break;
                  case 44:
                    _context.prev = 44;
                    _context.t1 = _context["catch"](2);
                    _didIteratorError = true;
                    _iteratorError = _context.t1;
                  case 48:
                    _context.prev = 48;
                    _context.prev = 49;
                    if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                      _context.next = 53;
                      break;
                    }
                    _context.next = 53;
                    return _iterator.return();
                  case 53:
                    _context.prev = 53;
                    if (!_didIteratorError) {
                      _context.next = 56;
                      break;
                    }
                    throw _iteratorError;
                  case 56:
                    return _context.finish(53);
                  case 57:
                    return _context.finish(48);
                  case 58:
                    return _context.abrupt("return", this.model);
                  case 59:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[2, 44, 48, 58], [14, 33, 36, 39], [49, , 53, 57]]);
          }));
          function parse(_x) {
            return _parse.apply(this, arguments);
          }
          return parse;
        }() }, { key: "parseStream", value: function() {
          var _parseStream = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee2(stream) {
            return regenerator.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", this.parse(parseSax(stream)));
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function parseStream(_x2) {
            return _parseStream.apply(this, arguments);
          }
          return parseStream;
        }() }, {
          key: "toXml",
          value: function toXml(model) {
            var xmlStream = new XmlStream();
            this.render(xmlStream, model);
            return xmlStream.xml;
          }
          // ============================================================
          // Useful Utilities
        }, { key: "xml", get: function get() {
          return this.toXml(this.model);
        } }], [{ key: "toAttribute", value: function toAttribute(value, dflt) {
          var always = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (value === void 0) {
            if (always) {
              return dflt;
            }
          } else if (always || value !== dflt) {
            return value.toString();
          }
          return void 0;
        } }, { key: "toStringAttribute", value: function toStringAttribute(value, dflt) {
          var always = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          return BaseXform2.toAttribute(value, dflt, always);
        } }, { key: "toStringValue", value: function toStringValue(attr, dflt) {
          return attr === void 0 ? dflt : attr;
        } }, { key: "toBoolAttribute", value: function toBoolAttribute(value, dflt) {
          var always = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (value === void 0) {
            if (always) {
              return dflt;
            }
          } else if (always || value !== dflt) {
            return value ? "1" : "0";
          }
          return void 0;
        } }, { key: "toBoolValue", value: function toBoolValue(attr, dflt) {
          return attr === void 0 ? dflt : attr === "1";
        } }, { key: "toIntAttribute", value: function toIntAttribute(value, dflt) {
          var always = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          return BaseXform2.toAttribute(value, dflt, always);
        } }, { key: "toIntValue", value: function toIntValue(attr, dflt) {
          return attr === void 0 ? dflt : parseInt(attr, 10);
        } }, { key: "toFloatAttribute", value: function toFloatAttribute(value, dflt) {
          var always = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          return BaseXform2.toAttribute(value, dflt, always);
        } }, { key: "toFloatValue", value: function toFloatValue(attr, dflt) {
          return attr === void 0 ? dflt : parseFloat(attr);
        } }]);
        return BaseXform2;
      }();
      module2.exports = BaseXform;
    }, { "../../utils/parse-sax": 21, "../../utils/xml-stream": 27 }], 32: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var colCache = require2("../../../utils/col-cache");
      var DefinedNamesXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(DefinedNamesXform2, _BaseXform);
        var _super = _createSuper2(DefinedNamesXform2);
        function DefinedNamesXform2() {
          _classCallCheck2(this, DefinedNamesXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(DefinedNamesXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode("definedName", { name: model.name, localSheetId: model.localSheetId });
          xmlStream.writeText(model.ranges.join(","));
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "definedName":
              this._parsedName = node.attributes.name;
              this._parsedLocalSheetId = node.attributes.localSheetId;
              this._parsedText = [];
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          this._parsedText.push(text);
        } }, { key: "parseClose", value: function parseClose() {
          this.model = { name: this._parsedName, ranges: extractRanges(this._parsedText.join("")) };
          if (this._parsedLocalSheetId !== void 0) {
            this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10);
          }
          return false;
        } }]);
        return DefinedNamesXform2;
      }(BaseXform);
      function isValidRange(range) {
        try {
          colCache.decodeEx(range);
          return true;
        } catch (err) {
          return false;
        }
      }
      function extractRanges(parsedText) {
        var ranges = [];
        var quotesOpened = false;
        var last = "";
        parsedText.split(",").forEach(function(item) {
          if (!item) {
            return;
          }
          var quotes = (item.match(/'/g) || []).length;
          if (!quotes) {
            if (quotesOpened) {
              last += "".concat(item, ",");
            } else if (isValidRange(item)) {
              ranges.push(item);
            }
            return;
          }
          var quotesEven = quotes % 2 === 0;
          if (!quotesOpened && quotesEven && isValidRange(item)) {
            ranges.push(item);
          } else if (quotesOpened && !quotesEven) {
            quotesOpened = false;
            if (isValidRange(last + item)) {
              ranges.push(last + item);
            }
            last = "";
          } else {
            quotesOpened = true;
            last += "".concat(item, ",");
          }
        });
        return ranges;
      }
      module2.exports = DefinedNamesXform;
    }, { "../../../utils/col-cache": 19, "../base-xform": 31 }], 33: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var utils = require2("../../../utils/utils");
      var BaseXform = require2("../base-xform");
      var WorksheetXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(WorksheetXform2, _BaseXform);
        var _super = _createSuper2(WorksheetXform2);
        function WorksheetXform2() {
          _classCallCheck2(this, WorksheetXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(WorksheetXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode("sheet", { sheetId: model.id, name: model.name, state: model.state, "r:id": model.rId });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "sheet") {
            this.model = { name: utils.xmlDecode(node.attributes.name), id: parseInt(node.attributes.sheetId, 10), state: node.attributes.state, rId: node.attributes["r:id"] };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return WorksheetXform2;
      }(BaseXform);
      module2.exports = WorksheetXform;
    }, { "../../../utils/utils": 26, "../base-xform": 31 }], 34: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var WorkbookCalcPropertiesXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(WorkbookCalcPropertiesXform2, _BaseXform);
        var _super = _createSuper2(WorkbookCalcPropertiesXform2);
        function WorkbookCalcPropertiesXform2() {
          _classCallCheck2(this, WorkbookCalcPropertiesXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(WorkbookCalcPropertiesXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode("calcPr", { calcId: 171027, fullCalcOnLoad: model.fullCalcOnLoad ? 1 : void 0 });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "calcPr") {
            this.model = {};
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return WorkbookCalcPropertiesXform2;
      }(BaseXform);
      module2.exports = WorkbookCalcPropertiesXform;
    }, { "../base-xform": 31 }], 35: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var WorksheetPropertiesXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(WorksheetPropertiesXform2, _BaseXform);
        var _super = _createSuper2(WorksheetPropertiesXform2);
        function WorksheetPropertiesXform2() {
          _classCallCheck2(this, WorksheetPropertiesXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(WorksheetPropertiesXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode("workbookPr", { date1904: model.date1904 ? 1 : void 0, defaultThemeVersion: 164011, filterPrivacy: 1 });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "workbookPr") {
            this.model = { date1904: node.attributes.date1904 === "1" };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return WorksheetPropertiesXform2;
      }(BaseXform);
      module2.exports = WorksheetPropertiesXform;
    }, { "../base-xform": 31 }], 36: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var WorkbookViewXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(WorkbookViewXform2, _BaseXform);
        var _super = _createSuper2(WorkbookViewXform2);
        function WorkbookViewXform2() {
          _classCallCheck2(this, WorkbookViewXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(WorkbookViewXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var attributes = { xWindow: model.x || 0, yWindow: model.y || 0, windowWidth: model.width || 12e3, windowHeight: model.height || 24e3, firstSheet: model.firstSheet, activeTab: model.activeTab };
          if (model.visibility && model.visibility !== "visible") {
            attributes.visibility = model.visibility;
          }
          xmlStream.leafNode("workbookView", attributes);
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "workbookView") {
            var model = this.model = {};
            var addS = function addS2(name, value, dflt) {
              var s = value !== void 0 ? model[name] = value : dflt;
              if (s !== void 0) {
                model[name] = s;
              }
            };
            var addN = function addN2(name, value, dflt) {
              var n = value !== void 0 ? model[name] = parseInt(value, 10) : dflt;
              if (n !== void 0) {
                model[name] = n;
              }
            };
            addN("x", node.attributes.xWindow, 0);
            addN("y", node.attributes.yWindow, 0);
            addN("width", node.attributes.windowWidth, 25e3);
            addN("height", node.attributes.windowHeight, 1e4);
            addS("visibility", node.attributes.visibility, "visible");
            addN("activeTab", node.attributes.activeTab, void 0);
            addN("firstSheet", node.attributes.firstSheet, void 0);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return WorkbookViewXform2;
      }(BaseXform);
      module2.exports = WorkbookViewXform;
    }, { "../base-xform": 31 }], 37: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var _ = require2("../../../utils/under-dash");
      var colCache = require2("../../../utils/col-cache");
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var StaticXform = require2("../static-xform");
      var ListXform = require2("../list-xform");
      var DefinedNameXform = require2("./defined-name-xform");
      var SheetXform = require2("./sheet-xform");
      var WorkbookViewXform = require2("./workbook-view-xform");
      var WorkbookPropertiesXform = require2("./workbook-properties-xform");
      var WorkbookCalcPropertiesXform = require2("./workbook-calc-properties-xform");
      var WorkbookXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(WorkbookXform2, _BaseXform);
        var _super = _createSuper2(WorkbookXform2);
        function WorkbookXform2() {
          var _this;
          _classCallCheck2(this, WorkbookXform2);
          _this = _super.call(this);
          _this.map = { fileVersion: WorkbookXform2.STATIC_XFORMS.fileVersion, workbookPr: new WorkbookPropertiesXform(), bookViews: new ListXform({ tag: "bookViews", count: false, childXform: new WorkbookViewXform() }), sheets: new ListXform({ tag: "sheets", count: false, childXform: new SheetXform() }), definedNames: new ListXform({ tag: "definedNames", count: false, childXform: new DefinedNameXform() }), calcPr: new WorkbookCalcPropertiesXform() };
          return _this;
        }
        _createClass2(WorkbookXform2, [{ key: "prepare", value: function prepare(model) {
          model.sheets = model.worksheets;
          var printAreas = [];
          var index2 = 0;
          model.sheets.forEach(function(sheet) {
            if (sheet.pageSetup && sheet.pageSetup.printArea) {
              sheet.pageSetup.printArea.split("&&").forEach(function(printArea) {
                var printAreaComponents = printArea.split(":");
                var definedName2 = { name: "_xlnm.Print_Area", ranges: ["'".concat(sheet.name, "'!$").concat(printAreaComponents[0], ":$").concat(printAreaComponents[1])], localSheetId: index2 };
                printAreas.push(definedName2);
              });
            }
            if (sheet.pageSetup && (sheet.pageSetup.printTitlesRow || sheet.pageSetup.printTitlesColumn)) {
              var ranges = [];
              if (sheet.pageSetup.printTitlesColumn) {
                var titlesColumns = sheet.pageSetup.printTitlesColumn.split(":");
                ranges.push("'".concat(sheet.name, "'!$").concat(titlesColumns[0], ":$").concat(titlesColumns[1]));
              }
              if (sheet.pageSetup.printTitlesRow) {
                var titlesRows = sheet.pageSetup.printTitlesRow.split(":");
                ranges.push("'".concat(sheet.name, "'!$").concat(titlesRows[0], ":$").concat(titlesRows[1]));
              }
              var definedName = { name: "_xlnm.Print_Titles", ranges, localSheetId: index2 };
              printAreas.push(definedName);
            }
            index2++;
          });
          if (printAreas.length) {
            model.definedNames = model.definedNames.concat(printAreas);
          }
          (model.media || []).forEach(function(medium, i) {
            medium.name = medium.type + (i + 1);
          });
        } }, { key: "render", value: function render15(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("workbook", WorkbookXform2.WORKBOOK_ATTRIBUTES);
          this.map.fileVersion.render(xmlStream);
          this.map.workbookPr.render(xmlStream, model.properties);
          this.map.bookViews.render(xmlStream, model.views);
          this.map.sheets.render(xmlStream, model.sheets);
          this.map.definedNames.render(xmlStream, model.definedNames);
          this.map.calcPr.render(xmlStream, model.calcProperties);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "workbook":
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              return true;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "workbook":
              this.model = { sheets: this.map.sheets.model, properties: this.map.workbookPr.model || {}, views: this.map.bookViews.model, calcProperties: {} };
              if (this.map.definedNames.model) {
                this.model.definedNames = this.map.definedNames.model;
              }
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model) {
          var rels = (model.workbookRels || []).reduce(function(map, rel) {
            map[rel.Id] = rel;
            return map;
          }, {});
          var worksheets = [];
          var worksheet;
          var index2 = 0;
          (model.sheets || []).forEach(function(sheet) {
            var rel = rels[sheet.rId];
            if (!rel) {
              return;
            }
            worksheet = model.worksheetHash["xl/".concat(rel.Target.replace(/^(\s|\/xl\/)+/, ""))];
            if (worksheet) {
              worksheet.name = sheet.name;
              worksheet.id = sheet.id;
              worksheet.state = sheet.state;
              worksheets[index2++] = worksheet;
            }
          });
          var definedNames = [];
          _.each(model.definedNames, function(definedName) {
            if (definedName.name === "_xlnm.Print_Area") {
              worksheet = worksheets[definedName.localSheetId];
              if (worksheet) {
                if (!worksheet.pageSetup) {
                  worksheet.pageSetup = {};
                }
                var range = colCache.decodeEx(definedName.ranges[0]);
                worksheet.pageSetup.printArea = worksheet.pageSetup.printArea ? "".concat(worksheet.pageSetup.printArea, "&&").concat(range.dimensions) : range.dimensions;
              }
            } else if (definedName.name === "_xlnm.Print_Titles") {
              worksheet = worksheets[definedName.localSheetId];
              if (worksheet) {
                if (!worksheet.pageSetup) {
                  worksheet.pageSetup = {};
                }
                var rangeString = definedName.ranges.join(",");
                var dollarRegex = /\$/g;
                var rowRangeRegex = /\$\d+:\$\d+/;
                var rowRangeMatches = rangeString.match(rowRangeRegex);
                if (rowRangeMatches && rowRangeMatches.length) {
                  var _range = rowRangeMatches[0];
                  worksheet.pageSetup.printTitlesRow = _range.replace(dollarRegex, "");
                }
                var columnRangeRegex = /\$[A-Z]+:\$[A-Z]+/;
                var columnRangeMatches = rangeString.match(columnRangeRegex);
                if (columnRangeMatches && columnRangeMatches.length) {
                  var _range2 = columnRangeMatches[0];
                  worksheet.pageSetup.printTitlesColumn = _range2.replace(dollarRegex, "");
                }
              }
            } else {
              definedNames.push(definedName);
            }
          });
          model.definedNames = definedNames;
          model.media.forEach(function(media, i) {
            media.index = i;
          });
        } }]);
        return WorkbookXform2;
      }(BaseXform);
      WorkbookXform.WORKBOOK_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x15", "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" };
      WorkbookXform.STATIC_XFORMS = { fileVersion: new StaticXform({ tag: "fileVersion", $: { appName: "xl", lastEdited: 5, lowestEdited: 5, rupBuild: 9303 } }) };
      module2.exports = WorkbookXform;
    }, { "../../../utils/col-cache": 19, "../../../utils/under-dash": 25, "../../../utils/xml-stream": 27, "../base-xform": 31, "../list-xform": 70, "../static-xform": 119, "./defined-name-xform": 32, "./sheet-xform": 33, "./workbook-calc-properties-xform": 34, "./workbook-properties-xform": 35, "./workbook-view-xform": 36 }], 38: [function(require2, module2, exports2) {
      function ownKeys2(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys2(Object(source), true).forEach(function(key) {
              _defineProperty2(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys2(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var RichTextXform = require2("../strings/rich-text-xform");
      var utils = require2("../../../utils/utils");
      var BaseXform = require2("../base-xform");
      var CommentXform = module2.exports = function(model) {
        this.model = model;
      };
      utils.inherits(CommentXform, BaseXform, { get tag() {
        return "r";
      }, get richTextXform() {
        if (!this._richTextXform) {
          this._richTextXform = new RichTextXform();
        }
        return this._richTextXform;
      }, render: function render15(xmlStream, model) {
        var _this = this;
        model = model || this.model;
        xmlStream.openNode("comment", { ref: model.ref, authorId: 0 });
        xmlStream.openNode("text");
        if (model && model.note && model.note.texts) {
          model.note.texts.forEach(function(text) {
            _this.richTextXform.render(xmlStream, text);
          });
        }
        xmlStream.closeNode();
        xmlStream.closeNode();
      }, parseOpen: function parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "comment":
            this.model = _objectSpread2({ type: "note", note: { texts: [] } }, node.attributes);
            return true;
          case "r":
            this.parser = this.richTextXform;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      }, parseText: function parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }, parseClose: function parseClose(name) {
        switch (name) {
          case "comment":
            return false;
          case "r":
            this.model.note.texts.push(this.parser.model);
            this.parser = void 0;
            return true;
          default:
            if (this.parser) {
              this.parser.parseClose(name);
            }
            return true;
        }
      } });
    }, { "../../../utils/utils": 26, "../base-xform": 31, "../strings/rich-text-xform": 121 }], 39: [function(require2, module2, exports2) {
      var XmlStream = require2("../../../utils/xml-stream");
      var utils = require2("../../../utils/utils");
      var BaseXform = require2("../base-xform");
      var CommentXform = require2("./comment-xform");
      var CommentsXform = module2.exports = function() {
        this.map = { comment: new CommentXform() };
      };
      utils.inherits(CommentsXform, BaseXform, { COMMENTS_ATTRIBUTES: { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main" } }, { render: function render15(xmlStream, model) {
        var _this = this;
        model = model || this.model;
        xmlStream.openXml(XmlStream.StdDocAttributes);
        xmlStream.openNode("comments", CommentsXform.COMMENTS_ATTRIBUTES);
        xmlStream.openNode("authors");
        xmlStream.leafNode("author", null, "Author");
        xmlStream.closeNode();
        xmlStream.openNode("commentList");
        model.comments.forEach(function(comment) {
          _this.map.comment.render(xmlStream, comment);
        });
        xmlStream.closeNode();
        xmlStream.closeNode();
      }, parseOpen: function parseOpen(node) {
        if (this.parser) {
          this.parser.parseOpen(node);
          return true;
        }
        switch (node.name) {
          case "commentList":
            this.model = { comments: [] };
            return true;
          case "comment":
            this.parser = this.map.comment;
            this.parser.parseOpen(node);
            return true;
          default:
            return false;
        }
      }, parseText: function parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      }, parseClose: function parseClose(name) {
        switch (name) {
          case "commentList":
            return false;
          case "comment":
            this.model.comments.push(this.parser.model);
            this.parser = void 0;
            return true;
          default:
            if (this.parser) {
              this.parser.parseClose(name);
            }
            return true;
        }
      } });
    }, { "../../../utils/utils": 26, "../../../utils/xml-stream": 27, "../base-xform": 31, "./comment-xform": 38 }], 40: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var VmlPositionXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(VmlPositionXform2, _BaseXform);
        var _super = _createSuper2(VmlPositionXform2);
        function VmlPositionXform2(model) {
          var _this;
          _classCallCheck2(this, VmlPositionXform2);
          _this = _super.call(this);
          _this._model = model;
          return _this;
        }
        _createClass2(VmlPositionXform2, [{ key: "render", value: function render15(xmlStream, model, type) {
          if (model === type[2]) {
            xmlStream.leafNode(this.tag);
          } else if (this.tag === "x:SizeWithCells" && model === type[1]) {
            xmlStream.leafNode(this.tag);
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = {};
              this.model[this.tag] = true;
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return this._model && this._model.tag;
        } }]);
        return VmlPositionXform2;
      }(BaseXform);
      module2.exports = VmlPositionXform;
    }, { "../../base-xform": 31 }], 41: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var VmlProtectionXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(VmlProtectionXform2, _BaseXform);
        var _super = _createSuper2(VmlProtectionXform2);
        function VmlProtectionXform2(model) {
          var _this;
          _classCallCheck2(this, VmlProtectionXform2);
          _this = _super.call(this);
          _this._model = model;
          return _this;
        }
        _createClass2(VmlProtectionXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode(this.tag, null, model);
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.text = "";
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          this.text = text;
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return this._model && this._model.tag;
        } }]);
        return VmlProtectionXform2;
      }(BaseXform);
      module2.exports = VmlProtectionXform;
    }, { "../../base-xform": 31 }], 42: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var VmlAnchorXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(VmlAnchorXform2, _BaseXform);
        var _super = _createSuper2(VmlAnchorXform2);
        function VmlAnchorXform2() {
          _classCallCheck2(this, VmlAnchorXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(VmlAnchorXform2, [{ key: "getAnchorRect", value: function getAnchorRect(anchor) {
          var l = Math.floor(anchor.left);
          var lf = Math.floor((anchor.left - l) * 68);
          var t2 = Math.floor(anchor.top);
          var tf2 = Math.floor((anchor.top - t2) * 18);
          var r = Math.floor(anchor.right);
          var rf = Math.floor((anchor.right - r) * 68);
          var b = Math.floor(anchor.bottom);
          var bf = Math.floor((anchor.bottom - b) * 18);
          return [l, lf, t2, tf2, r, rf, b, bf];
        } }, { key: "getDefaultRect", value: function getDefaultRect(ref2) {
          var l = ref2.col;
          var lf = 6;
          var t2 = Math.max(ref2.row - 2, 0);
          var tf2 = 14;
          var r = l + 2;
          var rf = 2;
          var b = t2 + 4;
          var bf = 16;
          return [l, lf, t2, tf2, r, rf, b, bf];
        } }, { key: "render", value: function render15(xmlStream, model) {
          var rect = model.anchor ? this.getAnchorRect(model.anchor) : this.getDefaultRect(model.refAddress);
          xmlStream.leafNode("x:Anchor", null, rect.join(", "));
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.text = "";
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          this.text = text;
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "x:Anchor";
        } }]);
        return VmlAnchorXform2;
      }(BaseXform);
      module2.exports = VmlAnchorXform;
    }, { "../base-xform": 31 }], 43: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var VmlAnchorXform = require2("./vml-anchor-xform");
      var VmlProtectionXform = require2("./style/vml-protection-xform");
      var VmlPositionXform = require2("./style/vml-position-xform");
      var POSITION_TYPE = ["twoCells", "oneCells", "absolute"];
      var VmlClientDataXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(VmlClientDataXform2, _BaseXform);
        var _super = _createSuper2(VmlClientDataXform2);
        function VmlClientDataXform2() {
          var _this;
          _classCallCheck2(this, VmlClientDataXform2);
          _this = _super.call(this);
          _this.map = { "x:Anchor": new VmlAnchorXform(), "x:Locked": new VmlProtectionXform({ tag: "x:Locked" }), "x:LockText": new VmlProtectionXform({ tag: "x:LockText" }), "x:SizeWithCells": new VmlPositionXform({ tag: "x:SizeWithCells" }), "x:MoveWithCells": new VmlPositionXform({ tag: "x:MoveWithCells" }) };
          return _this;
        }
        _createClass2(VmlClientDataXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var _model$note = model.note, protection = _model$note.protection, editAs = _model$note.editAs;
          xmlStream.openNode(this.tag, { ObjectType: "Note" });
          this.map["x:MoveWithCells"].render(xmlStream, editAs, POSITION_TYPE);
          this.map["x:SizeWithCells"].render(xmlStream, editAs, POSITION_TYPE);
          this.map["x:Anchor"].render(xmlStream, model);
          this.map["x:Locked"].render(xmlStream, protection.locked);
          xmlStream.leafNode("x:AutoFill", null, "False");
          this.map["x:LockText"].render(xmlStream, protection.lockText);
          xmlStream.leafNode("x:Row", null, model.refAddress.row - 1);
          xmlStream.leafNode("x:Column", null, model.refAddress.col - 1);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.reset();
              this.model = { anchor: [], protection: {}, editAs: "" };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.normalizeModel();
              return false;
            default:
              return true;
          }
        } }, { key: "normalizeModel", value: function normalizeModel() {
          var position = Object.assign({}, this.map["x:MoveWithCells"].model, this.map["x:SizeWithCells"].model);
          var len = Object.keys(position).length;
          this.model.editAs = POSITION_TYPE[len];
          this.model.anchor = this.map["x:Anchor"].text;
          this.model.protection.locked = this.map["x:Locked"].text;
          this.model.protection.lockText = this.map["x:LockText"].text;
        } }, { key: "tag", get: function get() {
          return "x:ClientData";
        } }]);
        return VmlClientDataXform2;
      }(BaseXform);
      module2.exports = VmlClientDataXform;
    }, { "../base-xform": 31, "./style/vml-position-xform": 40, "./style/vml-protection-xform": 41, "./vml-anchor-xform": 42 }], 44: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var VmlShapeXform = require2("./vml-shape-xform");
      var VmlNotesXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(VmlNotesXform2, _BaseXform);
        var _super = _createSuper2(VmlNotesXform2);
        function VmlNotesXform2() {
          var _this;
          _classCallCheck2(this, VmlNotesXform2);
          _this = _super.call(this);
          _this.map = { "v:shape": new VmlShapeXform() };
          return _this;
        }
        _createClass2(VmlNotesXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode(this.tag, VmlNotesXform2.DRAWING_ATTRIBUTES);
          xmlStream.openNode("o:shapelayout", { "v:ext": "edit" });
          xmlStream.leafNode("o:idmap", { "v:ext": "edit", data: 1 });
          xmlStream.closeNode();
          xmlStream.openNode("v:shapetype", { id: "_x0000_t202", coordsize: "21600,21600", "o:spt": 202, path: "m,l,21600r21600,l21600,xe" });
          xmlStream.leafNode("v:stroke", { joinstyle: "miter" });
          xmlStream.leafNode("v:path", { gradientshapeok: "t", "o:connecttype": "rect" });
          xmlStream.closeNode();
          model.comments.forEach(function(item, index2) {
            _this2.map["v:shape"].render(xmlStream, item, index2);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              this.model = { comments: [] };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.comments.push(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          var _this3 = this;
          model.anchors.forEach(function(anchor) {
            if (anchor.br) {
              _this3.map["xdr:twoCellAnchor"].reconcile(anchor, options);
            } else {
              _this3.map["xdr:oneCellAnchor"].reconcile(anchor, options);
            }
          });
        } }, { key: "tag", get: function get() {
          return "xml";
        } }]);
        return VmlNotesXform2;
      }(BaseXform);
      VmlNotesXform.DRAWING_ATTRIBUTES = { "xmlns:v": "urn:schemas-microsoft-com:vml", "xmlns:o": "urn:schemas-microsoft-com:office:office", "xmlns:x": "urn:schemas-microsoft-com:office:excel" };
      module2.exports = VmlNotesXform;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "./vml-shape-xform": 45 }], 45: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var VmlTextboxXform = require2("./vml-textbox-xform");
      var VmlClientDataXform = require2("./vml-client-data-xform");
      var VmlShapeXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(VmlShapeXform2, _BaseXform);
        var _super = _createSuper2(VmlShapeXform2);
        function VmlShapeXform2() {
          var _this;
          _classCallCheck2(this, VmlShapeXform2);
          _this = _super.call(this);
          _this.map = { "v:textbox": new VmlTextboxXform(), "x:ClientData": new VmlClientDataXform() };
          return _this;
        }
        _createClass2(VmlShapeXform2, [{ key: "render", value: function render15(xmlStream, model, index2) {
          xmlStream.openNode("v:shape", VmlShapeXform2.V_SHAPE_ATTRIBUTES(model, index2));
          xmlStream.leafNode("v:fill", { color2: "infoBackground [80]" });
          xmlStream.leafNode("v:shadow", { color: "none [81]", obscured: "t" });
          xmlStream.leafNode("v:path", { "o:connecttype": "none" });
          this.map["v:textbox"].render(xmlStream, model);
          this.map["x:ClientData"].render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              this.model = { margins: { insetmode: node.attributes["o:insetmode"] }, anchor: "", editAs: "", protection: {} };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model.margins.inset = this.map["v:textbox"].model && this.map["v:textbox"].model.inset;
              this.model.protection = this.map["x:ClientData"].model && this.map["x:ClientData"].model.protection;
              this.model.anchor = this.map["x:ClientData"].model && this.map["x:ClientData"].model.anchor;
              this.model.editAs = this.map["x:ClientData"].model && this.map["x:ClientData"].model.editAs;
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "v:shape";
        } }]);
        return VmlShapeXform2;
      }(BaseXform);
      VmlShapeXform.V_SHAPE_ATTRIBUTES = function(model, index2) {
        return { id: "_x0000_s".concat(1025 + index2), type: "#_x0000_t202", style: "position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden", fillcolor: "infoBackground [80]", strokecolor: "none [81]", "o:insetmode": model.note.margins && model.note.margins.insetmode };
      };
      module2.exports = VmlShapeXform;
    }, { "../base-xform": 31, "./vml-client-data-xform": 43, "./vml-textbox-xform": 46 }], 46: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var VmlTextboxXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(VmlTextboxXform2, _BaseXform);
        var _super = _createSuper2(VmlTextboxXform2);
        function VmlTextboxXform2() {
          _classCallCheck2(this, VmlTextboxXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(VmlTextboxXform2, [{ key: "conversionUnit", value: function conversionUnit(value, multiple, unit) {
          return "".concat(parseFloat(value) * multiple.toFixed(2)).concat(unit);
        } }, { key: "reverseConversionUnit", value: function reverseConversionUnit(inset) {
          var _this = this;
          return (inset || "").split(",").map(function(margin) {
            return Number(parseFloat(_this.conversionUnit(parseFloat(margin), 0.1, "")).toFixed(2));
          });
        } }, { key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          var attributes = { style: "mso-direction-alt:auto" };
          if (model && model.note) {
            var _ref = model.note && model.note.margins, inset = _ref.inset;
            if (Array.isArray(inset)) {
              inset = inset.map(function(margin) {
                return _this2.conversionUnit(margin, 10, "mm");
              }).join(",");
            }
            if (inset) {
              attributes.inset = inset;
            }
          }
          xmlStream.openNode("v:textbox", attributes);
          xmlStream.leafNode("div", { style: "text-align:left" });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { inset: this.reverseConversionUnit(node.attributes.inset) };
              return true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "v:textbox";
        } }]);
        return VmlTextboxXform2;
      }(BaseXform);
      module2.exports = VmlTextboxXform;
    }, { "../base-xform": 31 }], 47: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("./base-xform");
      var CompositeXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(CompositeXform2, _BaseXform);
        var _super = _createSuper2(CompositeXform2);
        function CompositeXform2() {
          _classCallCheck2(this, CompositeXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(CompositeXform2, [{ key: "createNewModel", value: function createNewModel(node) {
          return {};
        } }, { key: "parseOpen", value: function parseOpen(node) {
          this.parser = this.parser || this.map[node.name];
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (node.name === this.tag) {
            this.model = this.createNewModel(node);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model[name] = parser.model;
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.onParserClose(name, this.parser);
              this.parser = void 0;
            }
            return true;
          }
          return name !== this.tag;
        } }]);
        return CompositeXform2;
      }(BaseXform);
      module2.exports = CompositeXform;
    }, { "./base-xform": 31 }], 48: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var AppHeadingPairsXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(AppHeadingPairsXform2, _BaseXform);
        var _super = _createSuper2(AppHeadingPairsXform2);
        function AppHeadingPairsXform2() {
          _classCallCheck2(this, AppHeadingPairsXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(AppHeadingPairsXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode("HeadingPairs");
          xmlStream.openNode("vt:vector", { size: 2, baseType: "variant" });
          xmlStream.openNode("vt:variant");
          xmlStream.leafNode("vt:lpstr", void 0, "Worksheets");
          xmlStream.closeNode();
          xmlStream.openNode("vt:variant");
          xmlStream.leafNode("vt:i4", void 0, model.length);
          xmlStream.closeNode();
          xmlStream.closeNode();
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          return node.name === "HeadingPairs";
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== "HeadingPairs";
        } }]);
        return AppHeadingPairsXform2;
      }(BaseXform);
      module2.exports = AppHeadingPairsXform;
    }, { "../base-xform": 31 }], 49: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var AppTitlesOfPartsXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(AppTitlesOfPartsXform2, _BaseXform);
        var _super = _createSuper2(AppTitlesOfPartsXform2);
        function AppTitlesOfPartsXform2() {
          _classCallCheck2(this, AppTitlesOfPartsXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(AppTitlesOfPartsXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode("TitlesOfParts");
          xmlStream.openNode("vt:vector", { size: model.length, baseType: "lpstr" });
          model.forEach(function(sheet) {
            xmlStream.leafNode("vt:lpstr", void 0, sheet.name);
          });
          xmlStream.closeNode();
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          return node.name === "TitlesOfParts";
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== "TitlesOfParts";
        } }]);
        return AppTitlesOfPartsXform2;
      }(BaseXform);
      module2.exports = AppTitlesOfPartsXform;
    }, { "../base-xform": 31 }], 50: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var StringXform = require2("../simple/string-xform");
      var AppHeadingPairsXform = require2("./app-heading-pairs-xform");
      var AppTitleOfPartsXform = require2("./app-titles-of-parts-xform");
      var AppXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(AppXform2, _BaseXform);
        var _super = _createSuper2(AppXform2);
        function AppXform2() {
          var _this;
          _classCallCheck2(this, AppXform2);
          _this = _super.call(this);
          _this.map = { Company: new StringXform({ tag: "Company" }), Manager: new StringXform({ tag: "Manager" }), HeadingPairs: new AppHeadingPairsXform(), TitleOfParts: new AppTitleOfPartsXform() };
          return _this;
        }
        _createClass2(AppXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("Properties", AppXform2.PROPERTY_ATTRIBUTES);
          xmlStream.leafNode("Application", void 0, "Microsoft Excel");
          xmlStream.leafNode("DocSecurity", void 0, "0");
          xmlStream.leafNode("ScaleCrop", void 0, "false");
          this.map.HeadingPairs.render(xmlStream, model.worksheets);
          this.map.TitleOfParts.render(xmlStream, model.worksheets);
          this.map.Company.render(xmlStream, model.company || "");
          this.map.Manager.render(xmlStream, model.manager);
          xmlStream.leafNode("LinksUpToDate", void 0, "false");
          xmlStream.leafNode("SharedDoc", void 0, "false");
          xmlStream.leafNode("HyperlinksChanged", void 0, "false");
          xmlStream.leafNode("AppVersion", void 0, "16.0300");
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "Properties":
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "Properties":
              this.model = { worksheets: this.map.TitleOfParts.model, company: this.map.Company.model, manager: this.map.Manager.model };
              return false;
            default:
              return true;
          }
        } }]);
        return AppXform2;
      }(BaseXform);
      AppXform.DateFormat = function(dt) {
        return dt.toISOString().replace(/[.]\d{3,6}/, "");
      };
      AppXform.DateAttrs = { "xsi:type": "dcterms:W3CDTF" };
      AppXform.PROPERTY_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties", "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes" };
      module2.exports = AppXform;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "../simple/string-xform": 118, "./app-heading-pairs-xform": 48, "./app-titles-of-parts-xform": 49 }], 51: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var ContentTypesXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(ContentTypesXform2, _BaseXform);
        var _super = _createSuper2(ContentTypesXform2);
        function ContentTypesXform2() {
          _classCallCheck2(this, ContentTypesXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(ContentTypesXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("Types", ContentTypesXform2.PROPERTY_ATTRIBUTES);
          var mediaHash = {};
          (model.media || []).forEach(function(medium) {
            if (medium.type === "image") {
              var imageType = medium.extension;
              if (!mediaHash[imageType]) {
                mediaHash[imageType] = true;
                xmlStream.leafNode("Default", { Extension: imageType, ContentType: "image/".concat(imageType) });
              }
            }
          });
          xmlStream.leafNode("Default", { Extension: "rels", ContentType: "application/vnd.openxmlformats-package.relationships+xml" });
          xmlStream.leafNode("Default", { Extension: "xml", ContentType: "application/xml" });
          xmlStream.leafNode("Override", { PartName: "/xl/workbook.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" });
          model.worksheets.forEach(function(worksheet) {
            var name = "/xl/worksheets/sheet".concat(worksheet.id, ".xml");
            xmlStream.leafNode("Override", { PartName: name, ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" });
          });
          xmlStream.leafNode("Override", { PartName: "/xl/theme/theme1.xml", ContentType: "application/vnd.openxmlformats-officedocument.theme+xml" });
          xmlStream.leafNode("Override", { PartName: "/xl/styles.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml" });
          var hasSharedStrings = model.sharedStrings && model.sharedStrings.count;
          if (hasSharedStrings) {
            xmlStream.leafNode("Override", { PartName: "/xl/sharedStrings.xml", ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml" });
          }
          if (model.tables) {
            model.tables.forEach(function(table) {
              xmlStream.leafNode("Override", { PartName: "/xl/tables/".concat(table.target), ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml" });
            });
          }
          if (model.drawings) {
            model.drawings.forEach(function(drawing) {
              xmlStream.leafNode("Override", { PartName: "/xl/drawings/".concat(drawing.name, ".xml"), ContentType: "application/vnd.openxmlformats-officedocument.drawing+xml" });
            });
          }
          if (model.commentRefs) {
            xmlStream.leafNode("Default", { Extension: "vml", ContentType: "application/vnd.openxmlformats-officedocument.vmlDrawing" });
            model.commentRefs.forEach(function(_ref) {
              var commentName = _ref.commentName;
              xmlStream.leafNode("Override", { PartName: "/xl/".concat(commentName, ".xml"), ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml" });
            });
          }
          xmlStream.leafNode("Override", { PartName: "/docProps/core.xml", ContentType: "application/vnd.openxmlformats-package.core-properties+xml" });
          xmlStream.leafNode("Override", { PartName: "/docProps/app.xml", ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml" });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen() {
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return ContentTypesXform2;
      }(BaseXform);
      ContentTypesXform.PROPERTY_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/package/2006/content-types" };
      module2.exports = ContentTypesXform;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31 }], 52: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var DateXform = require2("../simple/date-xform");
      var StringXform = require2("../simple/string-xform");
      var IntegerXform = require2("../simple/integer-xform");
      var CoreXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(CoreXform2, _BaseXform);
        var _super = _createSuper2(CoreXform2);
        function CoreXform2() {
          var _this;
          _classCallCheck2(this, CoreXform2);
          _this = _super.call(this);
          _this.map = { "dc:creator": new StringXform({ tag: "dc:creator" }), "dc:title": new StringXform({ tag: "dc:title" }), "dc:subject": new StringXform({ tag: "dc:subject" }), "dc:description": new StringXform({ tag: "dc:description" }), "dc:identifier": new StringXform({ tag: "dc:identifier" }), "dc:language": new StringXform({ tag: "dc:language" }), "cp:keywords": new StringXform({ tag: "cp:keywords" }), "cp:category": new StringXform({ tag: "cp:category" }), "cp:lastModifiedBy": new StringXform({ tag: "cp:lastModifiedBy" }), "cp:lastPrinted": new DateXform({ tag: "cp:lastPrinted", format: CoreXform2.DateFormat }), "cp:revision": new IntegerXform({ tag: "cp:revision" }), "cp:version": new StringXform({ tag: "cp:version" }), "cp:contentStatus": new StringXform({ tag: "cp:contentStatus" }), "cp:contentType": new StringXform({ tag: "cp:contentType" }), "dcterms:created": new DateXform({ tag: "dcterms:created", attrs: CoreXform2.DateAttrs, format: CoreXform2.DateFormat }), "dcterms:modified": new DateXform({ tag: "dcterms:modified", attrs: CoreXform2.DateAttrs, format: CoreXform2.DateFormat }) };
          return _this;
        }
        _createClass2(CoreXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("cp:coreProperties", CoreXform2.CORE_PROPERTY_ATTRIBUTES);
          this.map["dc:creator"].render(xmlStream, model.creator);
          this.map["dc:title"].render(xmlStream, model.title);
          this.map["dc:subject"].render(xmlStream, model.subject);
          this.map["dc:description"].render(xmlStream, model.description);
          this.map["dc:identifier"].render(xmlStream, model.identifier);
          this.map["dc:language"].render(xmlStream, model.language);
          this.map["cp:keywords"].render(xmlStream, model.keywords);
          this.map["cp:category"].render(xmlStream, model.category);
          this.map["cp:lastModifiedBy"].render(xmlStream, model.lastModifiedBy);
          this.map["cp:lastPrinted"].render(xmlStream, model.lastPrinted);
          this.map["cp:revision"].render(xmlStream, model.revision);
          this.map["cp:version"].render(xmlStream, model.version);
          this.map["cp:contentStatus"].render(xmlStream, model.contentStatus);
          this.map["cp:contentType"].render(xmlStream, model.contentType);
          this.map["dcterms:created"].render(xmlStream, model.created);
          this.map["dcterms:modified"].render(xmlStream, model.modified);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "cp:coreProperties":
            case "coreProperties":
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(node)));
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "cp:coreProperties":
            case "coreProperties":
              this.model = { creator: this.map["dc:creator"].model, title: this.map["dc:title"].model, subject: this.map["dc:subject"].model, description: this.map["dc:description"].model, identifier: this.map["dc:identifier"].model, language: this.map["dc:language"].model, keywords: this.map["cp:keywords"].model, category: this.map["cp:category"].model, lastModifiedBy: this.map["cp:lastModifiedBy"].model, lastPrinted: this.map["cp:lastPrinted"].model, revision: this.map["cp:revision"].model, contentStatus: this.map["cp:contentStatus"].model, contentType: this.map["cp:contentType"].model, created: this.map["dcterms:created"].model, modified: this.map["dcterms:modified"].model };
              return false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(name));
          }
        } }]);
        return CoreXform2;
      }(BaseXform);
      CoreXform.DateFormat = function(dt) {
        return dt.toISOString().replace(/[.]\d{3}/, "");
      };
      CoreXform.DateAttrs = { "xsi:type": "dcterms:W3CDTF" };
      CoreXform.CORE_PROPERTY_ATTRIBUTES = { "xmlns:cp": "http://schemas.openxmlformats.org/package/2006/metadata/core-properties", "xmlns:dc": "http://purl.org/dc/elements/1.1/", "xmlns:dcterms": "http://purl.org/dc/terms/", "xmlns:dcmitype": "http://purl.org/dc/dcmitype/", "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance" };
      module2.exports = CoreXform;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "../simple/date-xform": 116, "../simple/integer-xform": 117, "../simple/string-xform": 118 }], 53: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var RelationshipXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(RelationshipXform2, _BaseXform);
        var _super = _createSuper2(RelationshipXform2);
        function RelationshipXform2() {
          _classCallCheck2(this, RelationshipXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(RelationshipXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode("Relationship", model);
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "Relationship":
              this.model = node.attributes;
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return RelationshipXform2;
      }(BaseXform);
      module2.exports = RelationshipXform;
    }, { "../base-xform": 31 }], 54: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var RelationshipXform = require2("./relationship-xform");
      var RelationshipsXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(RelationshipsXform2, _BaseXform);
        var _super = _createSuper2(RelationshipsXform2);
        function RelationshipsXform2() {
          var _this;
          _classCallCheck2(this, RelationshipsXform2);
          _this = _super.call(this);
          _this.map = { Relationship: new RelationshipXform() };
          return _this;
        }
        _createClass2(RelationshipsXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          model = model || this._values;
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("Relationships", RelationshipsXform2.RELATIONSHIPS_ATTRIBUTES);
          model.forEach(function(relationship) {
            _this2.map.Relationship.render(xmlStream, relationship);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "Relationships":
              this.model = [];
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(node)));
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.push(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "Relationships":
              return false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(name));
          }
        } }]);
        return RelationshipsXform2;
      }(BaseXform);
      RelationshipsXform.RELATIONSHIPS_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/package/2006/relationships" };
      module2.exports = RelationshipsXform;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "./relationship-xform": 53 }], 55: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var BaseCellAnchorXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(BaseCellAnchorXform2, _BaseXform);
        var _super = _createSuper2(BaseCellAnchorXform2);
        function BaseCellAnchorXform2() {
          _classCallCheck2(this, BaseCellAnchorXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(BaseCellAnchorXform2, [{ key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              this.model = { range: { editAs: node.attributes.editAs || "oneCell" } };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "reconcilePicture", value: function reconcilePicture(model, options) {
          if (model && model.rId) {
            var rel = options.rels[model.rId];
            var match = rel.Target.match(/.*\/media\/(.+[.][a-zA-Z]{3,4})/);
            if (match) {
              var name = match[1];
              var mediaId = options.mediaIndex[name];
              return options.media[mediaId];
            }
          }
          return void 0;
        } }]);
        return BaseCellAnchorXform2;
      }(BaseXform);
      module2.exports = BaseCellAnchorXform;
    }, { "../base-xform": 31 }], 56: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var BlipXform = require2("./blip-xform");
      var BlipFillXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(BlipFillXform2, _BaseXform);
        var _super = _createSuper2(BlipFillXform2);
        function BlipFillXform2() {
          var _this;
          _classCallCheck2(this, BlipFillXform2);
          _this = _super.call(this);
          _this.map = { "a:blip": new BlipXform() };
          return _this;
        }
        _createClass2(BlipFillXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag);
          this.map["a:blip"].render(xmlStream, model);
          xmlStream.openNode("a:stretch");
          xmlStream.leafNode("a:fillRect");
          xmlStream.closeNode();
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model = this.map["a:blip"].model;
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "xdr:blipFill";
        } }]);
        return BlipFillXform2;
      }(BaseXform);
      module2.exports = BlipFillXform;
    }, { "../base-xform": 31, "./blip-xform": 57 }], 57: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var BlipXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(BlipXform2, _BaseXform);
        var _super = _createSuper2(BlipXform2);
        function BlipXform2() {
          _classCallCheck2(this, BlipXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(BlipXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode(this.tag, { "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "r:embed": model.rId, cstate: "print" });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { rId: node.attributes["r:embed"] };
              return true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "a:blip";
        } }]);
        return BlipXform2;
      }(BaseXform);
      module2.exports = BlipXform;
    }, { "../base-xform": 31 }], 58: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var CNvPicPrXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(CNvPicPrXform2, _BaseXform);
        var _super = _createSuper2(CNvPicPrXform2);
        function CNvPicPrXform2() {
          _classCallCheck2(this, CNvPicPrXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(CNvPicPrXform2, [{ key: "render", value: function render15(xmlStream) {
          xmlStream.openNode(this.tag);
          xmlStream.leafNode("a:picLocks", { noChangeAspect: "1" });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              return true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "xdr:cNvPicPr";
        } }]);
        return CNvPicPrXform2;
      }(BaseXform);
      module2.exports = CNvPicPrXform;
    }, { "../base-xform": 31 }], 59: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var HlickClickXform = require2("./hlink-click-xform");
      var ExtLstXform = require2("./ext-lst-xform");
      var CNvPrXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(CNvPrXform2, _BaseXform);
        var _super = _createSuper2(CNvPrXform2);
        function CNvPrXform2() {
          var _this;
          _classCallCheck2(this, CNvPrXform2);
          _this = _super.call(this);
          _this.map = { "a:hlinkClick": new HlickClickXform(), "a:extLst": new ExtLstXform() };
          return _this;
        }
        _createClass2(CNvPrXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag, { id: model.index, name: "Picture ".concat(model.index) });
          this.map["a:hlinkClick"].render(xmlStream, model);
          this.map["a:extLst"].render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model = this.map["a:hlinkClick"].model;
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "xdr:cNvPr";
        } }]);
        return CNvPrXform2;
      }(BaseXform);
      module2.exports = CNvPrXform;
    }, { "../base-xform": 31, "./ext-lst-xform": 62, "./hlink-click-xform": 64 }], 60: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var IntegerXform = require2("../simple/integer-xform");
      var CellPositionXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(CellPositionXform2, _BaseXform);
        var _super = _createSuper2(CellPositionXform2);
        function CellPositionXform2(options) {
          var _this;
          _classCallCheck2(this, CellPositionXform2);
          _this = _super.call(this);
          _this.tag = options.tag;
          _this.map = { "xdr:col": new IntegerXform({ tag: "xdr:col", zero: true }), "xdr:colOff": new IntegerXform({ tag: "xdr:colOff", zero: true }), "xdr:row": new IntegerXform({ tag: "xdr:row", zero: true }), "xdr:rowOff": new IntegerXform({ tag: "xdr:rowOff", zero: true }) };
          return _this;
        }
        _createClass2(CellPositionXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag);
          this.map["xdr:col"].render(xmlStream, model.nativeCol);
          this.map["xdr:colOff"].render(xmlStream, model.nativeColOff);
          this.map["xdr:row"].render(xmlStream, model.nativeRow);
          this.map["xdr:rowOff"].render(xmlStream, model.nativeRowOff);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model = { nativeCol: this.map["xdr:col"].model, nativeColOff: this.map["xdr:colOff"].model, nativeRow: this.map["xdr:row"].model, nativeRowOff: this.map["xdr:rowOff"].model };
              return false;
            default:
              return true;
          }
        } }]);
        return CellPositionXform2;
      }(BaseXform);
      module2.exports = CellPositionXform;
    }, { "../base-xform": 31, "../simple/integer-xform": 117 }], 61: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var colCache = require2("../../../utils/col-cache");
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var TwoCellAnchorXform = require2("./two-cell-anchor-xform");
      var OneCellAnchorXform = require2("./one-cell-anchor-xform");
      function getAnchorType(model) {
        var range = typeof model.range === "string" ? colCache.decode(model.range) : model.range;
        return range.br ? "xdr:twoCellAnchor" : "xdr:oneCellAnchor";
      }
      var DrawingXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(DrawingXform2, _BaseXform);
        var _super = _createSuper2(DrawingXform2);
        function DrawingXform2() {
          var _this;
          _classCallCheck2(this, DrawingXform2);
          _this = _super.call(this);
          _this.map = { "xdr:twoCellAnchor": new TwoCellAnchorXform(), "xdr:oneCellAnchor": new OneCellAnchorXform() };
          return _this;
        }
        _createClass2(DrawingXform2, [{ key: "prepare", value: function prepare(model) {
          var _this2 = this;
          model.anchors.forEach(function(item, index2) {
            item.anchorType = getAnchorType(item);
            var anchor = _this2.map[item.anchorType];
            anchor.prepare(item, { index: index2 });
          });
        } }, { key: "render", value: function render15(xmlStream, model) {
          var _this3 = this;
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode(this.tag, DrawingXform2.DRAWING_ATTRIBUTES);
          model.anchors.forEach(function(item) {
            var anchor = _this3.map[item.anchorType];
            anchor.render(xmlStream, item);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              this.model = { anchors: [] };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.anchors.push(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          var _this4 = this;
          model.anchors.forEach(function(anchor) {
            if (anchor.br) {
              _this4.map["xdr:twoCellAnchor"].reconcile(anchor, options);
            } else {
              _this4.map["xdr:oneCellAnchor"].reconcile(anchor, options);
            }
          });
        } }, { key: "tag", get: function get() {
          return "xdr:wsDr";
        } }]);
        return DrawingXform2;
      }(BaseXform);
      DrawingXform.DRAWING_ATTRIBUTES = { "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing", "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main" };
      module2.exports = DrawingXform;
    }, { "../../../utils/col-cache": 19, "../../../utils/xml-stream": 27, "../base-xform": 31, "./one-cell-anchor-xform": 66, "./two-cell-anchor-xform": 69 }], 62: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var ExtLstXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(ExtLstXform2, _BaseXform);
        var _super = _createSuper2(ExtLstXform2);
        function ExtLstXform2() {
          _classCallCheck2(this, ExtLstXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(ExtLstXform2, [{ key: "render", value: function render15(xmlStream) {
          xmlStream.openNode(this.tag);
          xmlStream.openNode("a:ext", { uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}" });
          xmlStream.leafNode("a16:creationId", { "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main", id: "{00000000-0008-0000-0000-000002000000}" });
          xmlStream.closeNode();
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              return true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "a:extLst";
        } }]);
        return ExtLstXform2;
      }(BaseXform);
      module2.exports = ExtLstXform;
    }, { "../base-xform": 31 }], 63: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var EMU_PER_PIXEL_AT_96_DPI = 9525;
      var ExtXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(ExtXform2, _BaseXform);
        var _super = _createSuper2(ExtXform2);
        function ExtXform2(options) {
          var _this;
          _classCallCheck2(this, ExtXform2);
          _this = _super.call(this);
          _this.tag = options.tag;
          _this.map = {};
          return _this;
        }
        _createClass2(ExtXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag);
          var width2 = Math.floor(model.width * EMU_PER_PIXEL_AT_96_DPI);
          var height2 = Math.floor(model.height * EMU_PER_PIXEL_AT_96_DPI);
          xmlStream.addAttribute("cx", width2);
          xmlStream.addAttribute("cy", height2);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            this.model = { width: parseInt(node.attributes.cx || "0", 10) / EMU_PER_PIXEL_AT_96_DPI, height: parseInt(node.attributes.cy || "0", 10) / EMU_PER_PIXEL_AT_96_DPI };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return ExtXform2;
      }(BaseXform);
      module2.exports = ExtXform;
    }, { "../base-xform": 31 }], 64: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var HLinkClickXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(HLinkClickXform2, _BaseXform);
        var _super = _createSuper2(HLinkClickXform2);
        function HLinkClickXform2() {
          _classCallCheck2(this, HLinkClickXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(HLinkClickXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (!(model.hyperlinks && model.hyperlinks.rId)) {
            return;
          }
          xmlStream.leafNode(this.tag, { "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "r:id": model.hyperlinks.rId, tooltip: model.hyperlinks.tooltip });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { hyperlinks: { rId: node.attributes["r:id"], tooltip: node.attributes.tooltip } };
              return true;
            default:
              return true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "a:hlinkClick";
        } }]);
        return HLinkClickXform2;
      }(BaseXform);
      module2.exports = HLinkClickXform;
    }, { "../base-xform": 31 }], 65: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var CNvPrXform = require2("./c-nv-pr-xform");
      var CNvPicPrXform = require2("./c-nv-pic-pr-xform");
      var NvPicPrXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(NvPicPrXform2, _BaseXform);
        var _super = _createSuper2(NvPicPrXform2);
        function NvPicPrXform2() {
          var _this;
          _classCallCheck2(this, NvPicPrXform2);
          _this = _super.call(this);
          _this.map = { "xdr:cNvPr": new CNvPrXform(), "xdr:cNvPicPr": new CNvPicPrXform() };
          return _this;
        }
        _createClass2(NvPicPrXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag);
          this.map["xdr:cNvPr"].render(xmlStream, model);
          this.map["xdr:cNvPicPr"].render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model = this.map["xdr:cNvPr"].model;
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "xdr:nvPicPr";
        } }]);
        return NvPicPrXform2;
      }(BaseXform);
      module2.exports = NvPicPrXform;
    }, { "../base-xform": 31, "./c-nv-pic-pr-xform": 58, "./c-nv-pr-xform": 59 }], 66: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseCellAnchorXform = require2("./base-cell-anchor-xform");
      var StaticXform = require2("../static-xform");
      var CellPositionXform = require2("./cell-position-xform");
      var ExtXform = require2("./ext-xform");
      var PicXform = require2("./pic-xform");
      var OneCellAnchorXform = /* @__PURE__ */ function(_BaseCellAnchorXform) {
        _inherits2(OneCellAnchorXform2, _BaseCellAnchorXform);
        var _super = _createSuper2(OneCellAnchorXform2);
        function OneCellAnchorXform2() {
          var _this;
          _classCallCheck2(this, OneCellAnchorXform2);
          _this = _super.call(this);
          _this.map = { "xdr:from": new CellPositionXform({ tag: "xdr:from" }), "xdr:ext": new ExtXform({ tag: "xdr:ext" }), "xdr:pic": new PicXform(), "xdr:clientData": new StaticXform({ tag: "xdr:clientData" }) };
          return _this;
        }
        _createClass2(OneCellAnchorXform2, [{ key: "prepare", value: function prepare(model, options) {
          this.map["xdr:pic"].prepare(model.picture, options);
        } }, { key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag, { editAs: model.range.editAs || "oneCell" });
          this.map["xdr:from"].render(xmlStream, model.range.tl);
          this.map["xdr:ext"].render(xmlStream, model.range.ext);
          this.map["xdr:pic"].render(xmlStream, model.picture);
          this.map["xdr:clientData"].render(xmlStream, {});
          xmlStream.closeNode();
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model.range.tl = this.map["xdr:from"].model;
              this.model.range.ext = this.map["xdr:ext"].model;
              this.model.picture = this.map["xdr:pic"].model;
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          model.medium = this.reconcilePicture(model.picture, options);
        } }, { key: "tag", get: function get() {
          return "xdr:oneCellAnchor";
        } }]);
        return OneCellAnchorXform2;
      }(BaseCellAnchorXform);
      module2.exports = OneCellAnchorXform;
    }, { "../static-xform": 119, "./base-cell-anchor-xform": 55, "./cell-position-xform": 60, "./ext-xform": 63, "./pic-xform": 67 }], 67: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var StaticXform = require2("../static-xform");
      var BlipFillXform = require2("./blip-fill-xform");
      var NvPicPrXform = require2("./nv-pic-pr-xform");
      var spPrJSON = require2("./sp-pr");
      var PicXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(PicXform2, _BaseXform);
        var _super = _createSuper2(PicXform2);
        function PicXform2() {
          var _this;
          _classCallCheck2(this, PicXform2);
          _this = _super.call(this);
          _this.map = { "xdr:nvPicPr": new NvPicPrXform(), "xdr:blipFill": new BlipFillXform(), "xdr:spPr": new StaticXform(spPrJSON) };
          return _this;
        }
        _createClass2(PicXform2, [{ key: "prepare", value: function prepare(model, options) {
          model.index = options.index + 1;
        } }, { key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag);
          this.map["xdr:nvPicPr"].render(xmlStream, model);
          this.map["xdr:blipFill"].render(xmlStream, model);
          this.map["xdr:spPr"].render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.mergeModel(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "xdr:pic";
        } }]);
        return PicXform2;
      }(BaseXform);
      module2.exports = PicXform;
    }, { "../base-xform": 31, "../static-xform": 119, "./blip-fill-xform": 56, "./nv-pic-pr-xform": 65, "./sp-pr": 68 }], 68: [function(require2, module2, exports2) {
      module2.exports = { tag: "xdr:spPr", c: [{ tag: "a:xfrm", c: [{ tag: "a:off", $: { x: "0", y: "0" } }, { tag: "a:ext", $: { cx: "0", cy: "0" } }] }, { tag: "a:prstGeom", $: { prst: "rect" }, c: [{ tag: "a:avLst" }] }] };
    }, {}], 69: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseCellAnchorXform = require2("./base-cell-anchor-xform");
      var StaticXform = require2("../static-xform");
      var CellPositionXform = require2("./cell-position-xform");
      var PicXform = require2("./pic-xform");
      var TwoCellAnchorXform = /* @__PURE__ */ function(_BaseCellAnchorXform) {
        _inherits2(TwoCellAnchorXform2, _BaseCellAnchorXform);
        var _super = _createSuper2(TwoCellAnchorXform2);
        function TwoCellAnchorXform2() {
          var _this;
          _classCallCheck2(this, TwoCellAnchorXform2);
          _this = _super.call(this);
          _this.map = { "xdr:from": new CellPositionXform({ tag: "xdr:from" }), "xdr:to": new CellPositionXform({ tag: "xdr:to" }), "xdr:pic": new PicXform(), "xdr:clientData": new StaticXform({ tag: "xdr:clientData" }) };
          return _this;
        }
        _createClass2(TwoCellAnchorXform2, [{ key: "prepare", value: function prepare(model, options) {
          this.map["xdr:pic"].prepare(model.picture, options);
        } }, { key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag, { editAs: model.range.editAs || "oneCell" });
          this.map["xdr:from"].render(xmlStream, model.range.tl);
          this.map["xdr:to"].render(xmlStream, model.range.br);
          this.map["xdr:pic"].render(xmlStream, model.picture);
          this.map["xdr:clientData"].render(xmlStream, {});
          xmlStream.closeNode();
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model.range.tl = this.map["xdr:from"].model;
              this.model.range.br = this.map["xdr:to"].model;
              this.model.picture = this.map["xdr:pic"].model;
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          model.medium = this.reconcilePicture(model.picture, options);
        } }, { key: "tag", get: function get() {
          return "xdr:twoCellAnchor";
        } }]);
        return TwoCellAnchorXform2;
      }(BaseCellAnchorXform);
      module2.exports = TwoCellAnchorXform;
    }, { "../static-xform": 119, "./base-cell-anchor-xform": 55, "./cell-position-xform": 60, "./pic-xform": 67 }], 70: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("./base-xform");
      var ListXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(ListXform2, _BaseXform);
        var _super = _createSuper2(ListXform2);
        function ListXform2(options) {
          var _this;
          _classCallCheck2(this, ListXform2);
          _this = _super.call(this);
          _this.tag = options.tag;
          _this.always = !!options.always;
          _this.count = options.count;
          _this.empty = options.empty;
          _this.$count = options.$count || "count";
          _this.$ = options.$;
          _this.childXform = options.childXform;
          _this.maxItems = options.maxItems;
          return _this;
        }
        _createClass2(ListXform2, [{ key: "prepare", value: function prepare(model, options) {
          var childXform = this.childXform;
          if (model) {
            model.forEach(function(childModel, index2) {
              options.index = index2;
              childXform.prepare(childModel, options);
            });
          }
        } }, { key: "render", value: function render15(xmlStream, model) {
          if (this.always || model && model.length) {
            xmlStream.openNode(this.tag, this.$);
            if (this.count) {
              xmlStream.addAttribute(this.$count, model && model.length || 0);
            }
            var childXform = this.childXform;
            (model || []).forEach(function(childModel, index2) {
              childXform.render(xmlStream, childModel, index2);
            });
            xmlStream.closeNode();
          } else if (this.empty) {
            xmlStream.leafNode(this.tag);
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.model = [];
              return true;
            default:
              if (this.childXform.parseOpen(node)) {
                this.parser = this.childXform;
                return true;
              }
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.push(this.parser.model);
              this.parser = void 0;
              if (this.maxItems && this.model.length > this.maxItems) {
                throw new Error("Max ".concat(this.childXform.tag, " count (").concat(this.maxItems, ") exceeded"));
              }
            }
            return true;
          }
          return false;
        } }, { key: "reconcile", value: function reconcile(model, options) {
          if (model) {
            var childXform = this.childXform;
            model.forEach(function(childModel) {
              childXform.reconcile(childModel, options);
            });
          }
        } }]);
        return ListXform2;
      }(BaseXform);
      module2.exports = ListXform;
    }, { "./base-xform": 31 }], 71: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var colCache = require2("../../../utils/col-cache");
      var BaseXform = require2("../base-xform");
      var AutoFilterXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(AutoFilterXform2, _BaseXform);
        var _super = _createSuper2(AutoFilterXform2);
        function AutoFilterXform2() {
          _classCallCheck2(this, AutoFilterXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(AutoFilterXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            if (typeof model === "string") {
              xmlStream.leafNode("autoFilter", { ref: model });
            } else {
              var getAddress = function getAddress2(addr) {
                if (typeof addr === "string") {
                  return addr;
                }
                return colCache.getAddress(addr.row, addr.column).address;
              };
              var firstAddress = getAddress(model.from);
              var secondAddress = getAddress(model.to);
              if (firstAddress && secondAddress) {
                xmlStream.leafNode("autoFilter", { ref: "".concat(firstAddress, ":").concat(secondAddress) });
              }
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "autoFilter") {
            this.model = node.attributes.ref;
          }
        } }, { key: "tag", get: function get() {
          return "autoFilter";
        } }]);
        return AutoFilterXform2;
      }(BaseXform);
      module2.exports = AutoFilterXform;
    }, { "../../../utils/col-cache": 19, "../base-xform": 31 }], 72: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function ownKeys2(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys2(Object(source), true).forEach(function(key) {
              _defineProperty2(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys2(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var utils = require2("../../../utils/utils");
      var BaseXform = require2("../base-xform");
      var Range = require2("../../../doc/range");
      var Enums = require2("../../../doc/enums");
      var RichTextXform = require2("../strings/rich-text-xform");
      function getValueType(v) {
        if (v === null || v === void 0) {
          return Enums.ValueType.Null;
        }
        if (v instanceof String || typeof v === "string") {
          return Enums.ValueType.String;
        }
        if (typeof v === "number") {
          return Enums.ValueType.Number;
        }
        if (typeof v === "boolean") {
          return Enums.ValueType.Boolean;
        }
        if (v instanceof Date) {
          return Enums.ValueType.Date;
        }
        if (v.text && v.hyperlink) {
          return Enums.ValueType.Hyperlink;
        }
        if (v.formula) {
          return Enums.ValueType.Formula;
        }
        if (v.error) {
          return Enums.ValueType.Error;
        }
        throw new Error("I could not understand type of value");
      }
      function getEffectiveCellType(cell) {
        switch (cell.type) {
          case Enums.ValueType.Formula:
            return getValueType(cell.result);
          default:
            return cell.type;
        }
      }
      var CellXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(CellXform2, _BaseXform);
        var _super = _createSuper2(CellXform2);
        function CellXform2() {
          var _this;
          _classCallCheck2(this, CellXform2);
          _this = _super.call(this);
          _this.richTextXForm = new RichTextXform();
          return _this;
        }
        _createClass2(CellXform2, [{ key: "prepare", value: function prepare(model, options) {
          var styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));
          if (styleId) {
            model.styleId = styleId;
          }
          if (model.comment) {
            options.comments.push(_objectSpread2(_objectSpread2({}, model.comment), {}, { ref: model.address }));
          }
          switch (model.type) {
            case Enums.ValueType.String:
            case Enums.ValueType.RichText:
              if (options.sharedStrings) {
                model.ssId = options.sharedStrings.add(model.value);
              }
              break;
            case Enums.ValueType.Date:
              if (options.date1904) {
                model.date1904 = true;
              }
              break;
            case Enums.ValueType.Hyperlink:
              if (options.sharedStrings && model.text !== void 0 && model.text !== null) {
                model.ssId = options.sharedStrings.add(model.text);
              }
              options.hyperlinks.push({ address: model.address, target: model.hyperlink, tooltip: model.tooltip });
              break;
            case Enums.ValueType.Merge:
              options.merges.add(model);
              break;
            case Enums.ValueType.Formula:
              if (options.date1904) {
                model.date1904 = true;
              }
              if (model.shareType === "shared") {
                model.si = options.siFormulae++;
              }
              if (model.formula) {
                options.formulae[model.address] = model;
              } else if (model.sharedFormula) {
                var master = options.formulae[model.sharedFormula];
                if (!master) {
                  throw new Error("Shared Formula master must exist above and or left of clone for cell ".concat(model.address));
                }
                if (master.si === void 0) {
                  master.shareType = "shared";
                  master.si = options.siFormulae++;
                  master.range = new Range(master.address, model.address);
                } else if (master.range) {
                  master.range.expandToAddress(model.address);
                }
                model.si = master.si;
              }
              break;
          }
        } }, { key: "renderFormula", value: function renderFormula(xmlStream, model) {
          var attrs = null;
          switch (model.shareType) {
            case "shared":
              attrs = { t: "shared", ref: model.ref || model.range.range, si: model.si };
              break;
            case "array":
              attrs = { t: "array", ref: model.ref };
              break;
            default:
              if (model.si !== void 0) {
                attrs = { t: "shared", si: model.si };
              }
              break;
          }
          switch (getValueType(model.result)) {
            case Enums.ValueType.Null:
              xmlStream.leafNode("f", attrs, model.formula);
              break;
            case Enums.ValueType.String:
              xmlStream.addAttribute("t", "str");
              xmlStream.leafNode("f", attrs, model.formula);
              xmlStream.leafNode("v", null, model.result);
              break;
            case Enums.ValueType.Number:
              xmlStream.leafNode("f", attrs, model.formula);
              xmlStream.leafNode("v", null, model.result);
              break;
            case Enums.ValueType.Boolean:
              xmlStream.addAttribute("t", "b");
              xmlStream.leafNode("f", attrs, model.formula);
              xmlStream.leafNode("v", null, model.result ? 1 : 0);
              break;
            case Enums.ValueType.Error:
              xmlStream.addAttribute("t", "e");
              xmlStream.leafNode("f", attrs, model.formula);
              xmlStream.leafNode("v", null, model.result.error);
              break;
            case Enums.ValueType.Date:
              xmlStream.leafNode("f", attrs, model.formula);
              xmlStream.leafNode("v", null, utils.dateToExcel(model.result, model.date1904));
              break;
            default:
              throw new Error("I could not understand type of value");
          }
        } }, { key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          if (model.type === Enums.ValueType.Null && !model.styleId) {
            return;
          }
          xmlStream.openNode("c");
          xmlStream.addAttribute("r", model.address);
          if (model.styleId) {
            xmlStream.addAttribute("s", model.styleId);
          }
          switch (model.type) {
            case Enums.ValueType.Null:
              break;
            case Enums.ValueType.Number:
              xmlStream.leafNode("v", null, model.value);
              break;
            case Enums.ValueType.Boolean:
              xmlStream.addAttribute("t", "b");
              xmlStream.leafNode("v", null, model.value ? "1" : "0");
              break;
            case Enums.ValueType.Error:
              xmlStream.addAttribute("t", "e");
              xmlStream.leafNode("v", null, model.value.error);
              break;
            case Enums.ValueType.String:
            case Enums.ValueType.RichText:
              if (model.ssId !== void 0) {
                xmlStream.addAttribute("t", "s");
                xmlStream.leafNode("v", null, model.ssId);
              } else if (model.value && model.value.richText) {
                xmlStream.addAttribute("t", "inlineStr");
                xmlStream.openNode("is");
                model.value.richText.forEach(function(text) {
                  _this2.richTextXForm.render(xmlStream, text);
                });
                xmlStream.closeNode("is");
              } else {
                xmlStream.addAttribute("t", "str");
                xmlStream.leafNode("v", null, model.value);
              }
              break;
            case Enums.ValueType.Date:
              xmlStream.leafNode("v", null, utils.dateToExcel(model.value, model.date1904));
              break;
            case Enums.ValueType.Hyperlink:
              if (model.ssId !== void 0) {
                xmlStream.addAttribute("t", "s");
                xmlStream.leafNode("v", null, model.ssId);
              } else {
                xmlStream.addAttribute("t", "str");
                xmlStream.leafNode("v", null, model.text);
              }
              break;
            case Enums.ValueType.Formula:
              this.renderFormula(xmlStream, model);
              break;
            case Enums.ValueType.Merge:
              break;
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "c":
              this.model = { address: node.attributes.r };
              this.t = node.attributes.t;
              if (node.attributes.s) {
                this.model.styleId = parseInt(node.attributes.s, 10);
              }
              return true;
            case "f":
              this.currentNode = "f";
              this.model.si = node.attributes.si;
              this.model.shareType = node.attributes.t;
              this.model.ref = node.attributes.ref;
              return true;
            case "v":
              this.currentNode = "v";
              return true;
            case "t":
              this.currentNode = "t";
              return true;
            case "r":
              this.parser = this.richTextXForm;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
            return;
          }
          switch (this.currentNode) {
            case "f":
              this.model.formula = this.model.formula ? this.model.formula + text : text;
              break;
            case "v":
            case "t":
              if (this.model.value && this.model.value.richText) {
                this.model.value.richText.text = this.model.value.richText.text ? this.model.value.richText.text + text : text;
              } else {
                this.model.value = this.model.value ? this.model.value + text : text;
              }
              break;
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case "c": {
              var model = this.model;
              if (model.formula || model.shareType) {
                model.type = Enums.ValueType.Formula;
                if (model.value) {
                  if (this.t === "str") {
                    model.result = utils.xmlDecode(model.value);
                  } else if (this.t === "b") {
                    model.result = parseInt(model.value, 10) !== 0;
                  } else if (this.t === "e") {
                    model.result = { error: model.value };
                  } else {
                    model.result = parseFloat(model.value);
                  }
                  model.value = void 0;
                }
              } else if (model.value !== void 0) {
                switch (this.t) {
                  case "s":
                    model.type = Enums.ValueType.String;
                    model.value = parseInt(model.value, 10);
                    break;
                  case "str":
                    model.type = Enums.ValueType.String;
                    model.value = utils.xmlDecode(model.value);
                    break;
                  case "inlineStr":
                    model.type = Enums.ValueType.String;
                    break;
                  case "b":
                    model.type = Enums.ValueType.Boolean;
                    model.value = parseInt(model.value, 10) !== 0;
                    break;
                  case "e":
                    model.type = Enums.ValueType.Error;
                    model.value = { error: model.value };
                    break;
                  default:
                    model.type = Enums.ValueType.Number;
                    model.value = parseFloat(model.value);
                    break;
                }
              } else if (model.styleId) {
                model.type = Enums.ValueType.Null;
              } else {
                model.type = Enums.ValueType.Merge;
              }
              return false;
            }
            case "f":
            case "v":
            case "is":
              this.currentNode = void 0;
              return true;
            case "t":
              if (this.parser) {
                this.parser.parseClose(name);
                return true;
              }
              this.currentNode = void 0;
              return true;
            case "r":
              this.model.value = this.model.value || {};
              this.model.value.richText = this.model.value.richText || [];
              this.model.value.richText.push(this.parser.model);
              this.parser = void 0;
              this.currentNode = void 0;
              return true;
            default:
              if (this.parser) {
                this.parser.parseClose(name);
                return true;
              }
              return false;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          var style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);
          if (style) {
            model.style = style;
          }
          if (model.styleId !== void 0) {
            model.styleId = void 0;
          }
          switch (model.type) {
            case Enums.ValueType.String:
              if (typeof model.value === "number") {
                if (options.sharedStrings) {
                  model.value = options.sharedStrings.getString(model.value);
                }
              }
              if (model.value.richText) {
                model.type = Enums.ValueType.RichText;
              }
              break;
            case Enums.ValueType.Number:
              if (style && utils.isDateFmt(style.numFmt)) {
                model.type = Enums.ValueType.Date;
                model.value = utils.excelToDate(model.value, options.date1904);
              }
              break;
            case Enums.ValueType.Formula:
              if (model.result !== void 0 && style && utils.isDateFmt(style.numFmt)) {
                model.result = utils.excelToDate(model.result, options.date1904);
              }
              if (model.shareType === "shared") {
                if (model.ref) {
                  options.formulae[model.si] = model.address;
                } else {
                  model.sharedFormula = options.formulae[model.si];
                  delete model.shareType;
                }
                delete model.si;
              }
              break;
          }
          var hyperlink = options.hyperlinkMap[model.address];
          if (hyperlink) {
            if (model.type === Enums.ValueType.Formula) {
              model.text = model.result;
              model.result = void 0;
            } else {
              model.text = model.value;
              model.value = void 0;
            }
            model.type = Enums.ValueType.Hyperlink;
            model.hyperlink = hyperlink;
          }
          var comment = options.commentsMap && options.commentsMap[model.address];
          if (comment) {
            model.comment = comment;
          }
        } }, { key: "tag", get: function get() {
          return "c";
        } }]);
        return CellXform2;
      }(BaseXform);
      module2.exports = CellXform;
    }, { "../../../doc/enums": 7, "../../../doc/range": 10, "../../../utils/utils": 26, "../base-xform": 31, "../strings/rich-text-xform": 121 }], 73: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var CfIconExtXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(CfIconExtXform2, _BaseXform);
        var _super = _createSuper2(CfIconExtXform2);
        function CfIconExtXform2() {
          _classCallCheck2(this, CfIconExtXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(CfIconExtXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode(this.tag, { iconSet: model.iconSet, iconId: model.iconId });
        } }, { key: "parseOpen", value: function parseOpen(_ref) {
          var attributes = _ref.attributes;
          this.model = { iconSet: attributes.iconSet, iconId: BaseXform.toIntValue(attributes.iconId) };
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }, { key: "tag", get: function get() {
          return "x14:cfIcon";
        } }]);
        return CfIconExtXform2;
      }(BaseXform);
      module2.exports = CfIconExtXform;
    }, { "../../base-xform": 31 }], 74: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var _require = require2("uuid"), uuidv4 = _require.v4;
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var DatabarExtXform = require2("./databar-ext-xform");
      var IconSetExtXform = require2("./icon-set-ext-xform");
      var extIcons = { "3Triangles": true, "3Stars": true, "5Boxes": true };
      var CfRuleExtXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(CfRuleExtXform2, _CompositeXform);
        var _super = _createSuper2(CfRuleExtXform2);
        function CfRuleExtXform2() {
          var _this;
          _classCallCheck2(this, CfRuleExtXform2);
          _this = _super.call(this);
          _this.map = { "x14:dataBar": _this.databarXform = new DatabarExtXform(), "x14:iconSet": _this.iconSetXform = new IconSetExtXform() };
          return _this;
        }
        _createClass2(CfRuleExtXform2, [{ key: "prepare", value: function prepare(model) {
          if (CfRuleExtXform2.isExt(model)) {
            model.x14Id = "{".concat(uuidv4(), "}").toUpperCase();
          }
        } }, { key: "render", value: function render15(xmlStream, model) {
          if (!CfRuleExtXform2.isExt(model)) {
            return;
          }
          switch (model.type) {
            case "dataBar":
              this.renderDataBar(xmlStream, model);
              break;
            case "iconSet":
              this.renderIconSet(xmlStream, model);
              break;
          }
        } }, { key: "renderDataBar", value: function renderDataBar(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "dataBar", id: model.x14Id });
          this.databarXform.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "renderIconSet", value: function renderIconSet(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "iconSet", priority: model.priority, id: model.x14Id || "{".concat(uuidv4(), "}") });
          this.iconSetXform.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return { type: attributes.type, x14Id: attributes.id, priority: BaseXform.toIntValue(attributes.priority) };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          Object.assign(this.model, parser.model);
        } }, { key: "tag", get: function get() {
          return "x14:cfRule";
        } }], [{ key: "isExt", value: function isExt(rule) {
          if (rule.type === "dataBar") {
            return DatabarExtXform.isExt(rule);
          }
          if (rule.type === "iconSet") {
            if (rule.custom || extIcons[rule.iconSet]) {
              return true;
            }
          }
          return false;
        } }]);
        return CfRuleExtXform2;
      }(CompositeXform);
      module2.exports = CfRuleExtXform;
    }, { "../../base-xform": 31, "../../composite-xform": 47, "./databar-ext-xform": 78, "./icon-set-ext-xform": 80, "uuid": 526 }], 75: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var CompositeXform = require2("../../composite-xform");
      var FExtXform = require2("./f-ext-xform");
      var CfvoExtXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(CfvoExtXform2, _CompositeXform);
        var _super = _createSuper2(CfvoExtXform2);
        function CfvoExtXform2() {
          var _this;
          _classCallCheck2(this, CfvoExtXform2);
          _this = _super.call(this);
          _this.map = { "xm:f": _this.fExtXform = new FExtXform() };
          return _this;
        }
        _createClass2(CfvoExtXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: model.type });
          if (model.value !== void 0) {
            this.fExtXform.render(xmlStream, model.value);
          }
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(node) {
          return { type: node.attributes.type };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          switch (name) {
            case "xm:f":
              this.model.value = parser.model ? parseFloat(parser.model) : 0;
              break;
          }
        } }, { key: "tag", get: function get() {
          return "x14:cfvo";
        } }]);
        return CfvoExtXform2;
      }(CompositeXform);
      module2.exports = CfvoExtXform;
    }, { "../../composite-xform": 47, "./f-ext-xform": 79 }], 76: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var CompositeXform = require2("../../composite-xform");
      var SqRefExtXform = require2("./sqref-ext-xform");
      var CfRuleExtXform = require2("./cf-rule-ext-xform");
      var ConditionalFormattingExtXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(ConditionalFormattingExtXform2, _CompositeXform);
        var _super = _createSuper2(ConditionalFormattingExtXform2);
        function ConditionalFormattingExtXform2() {
          var _this;
          _classCallCheck2(this, ConditionalFormattingExtXform2);
          _this = _super.call(this);
          _this.map = { "xm:sqref": _this.sqRef = new SqRefExtXform(), "x14:cfRule": _this.cfRule = new CfRuleExtXform() };
          return _this;
        }
        _createClass2(ConditionalFormattingExtXform2, [{ key: "prepare", value: function prepare(model, options) {
          var _this2 = this;
          model.rules.forEach(function(rule) {
            _this2.cfRule.prepare(rule, options);
          });
        } }, { key: "render", value: function render15(xmlStream, model) {
          var _this3 = this;
          if (!model.rules.some(CfRuleExtXform.isExt)) {
            return;
          }
          xmlStream.openNode(this.tag, { "xmlns:xm": "http://schemas.microsoft.com/office/excel/2006/main" });
          model.rules.filter(CfRuleExtXform.isExt).forEach(function(rule) {
            return _this3.cfRule.render(xmlStream, rule);
          });
          this.sqRef.render(xmlStream, model.ref);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return { rules: [] };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          switch (name) {
            case "xm:sqref":
              this.model.ref = parser.model;
              break;
            case "x14:cfRule":
              this.model.rules.push(parser.model);
              break;
          }
        } }, { key: "tag", get: function get() {
          return "x14:conditionalFormatting";
        } }]);
        return ConditionalFormattingExtXform2;
      }(CompositeXform);
      module2.exports = ConditionalFormattingExtXform;
    }, { "../../composite-xform": 47, "./cf-rule-ext-xform": 74, "./sqref-ext-xform": 81 }], 77: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var CompositeXform = require2("../../composite-xform");
      var CfRuleExtXform = require2("./cf-rule-ext-xform");
      var ConditionalFormattingExtXform = require2("./conditional-formatting-ext-xform");
      var ConditionalFormattingsExtXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(ConditionalFormattingsExtXform2, _CompositeXform);
        var _super = _createSuper2(ConditionalFormattingsExtXform2);
        function ConditionalFormattingsExtXform2() {
          var _this;
          _classCallCheck2(this, ConditionalFormattingsExtXform2);
          _this = _super.call(this);
          _this.map = { "x14:conditionalFormatting": _this.cfXform = new ConditionalFormattingExtXform() };
          return _this;
        }
        _createClass2(ConditionalFormattingsExtXform2, [{ key: "hasContent", value: function hasContent(model) {
          if (model.hasExtContent === void 0) {
            model.hasExtContent = model.some(function(cf) {
              return cf.rules.some(CfRuleExtXform.isExt);
            });
          }
          return model.hasExtContent;
        } }, { key: "prepare", value: function prepare(model, options) {
          var _this2 = this;
          model.forEach(function(cf) {
            _this2.cfXform.prepare(cf, options);
          });
        } }, { key: "render", value: function render15(xmlStream, model) {
          var _this3 = this;
          if (this.hasContent(model)) {
            xmlStream.openNode(this.tag);
            model.forEach(function(cf) {
              return _this3.cfXform.render(xmlStream, cf);
            });
            xmlStream.closeNode();
          }
        } }, { key: "createNewModel", value: function createNewModel() {
          return [];
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model.push(parser.model);
        } }, { key: "tag", get: function get() {
          return "x14:conditionalFormattings";
        } }]);
        return ConditionalFormattingsExtXform2;
      }(CompositeXform);
      module2.exports = ConditionalFormattingsExtXform;
    }, { "../../composite-xform": 47, "./cf-rule-ext-xform": 74, "./conditional-formatting-ext-xform": 76 }], 78: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _slicedToArray2(arr, i) {
        return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
      }
      function _nonIterableRest2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray2(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray2(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray2(o, minLen);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _iterableToArrayLimit2(arr, i) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles2(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var ColorXform = require2("../../style/color-xform");
      var CfvoExtXform = require2("./cfvo-ext-xform");
      var DatabarExtXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(DatabarExtXform2, _CompositeXform);
        var _super = _createSuper2(DatabarExtXform2);
        function DatabarExtXform2() {
          var _this;
          _classCallCheck2(this, DatabarExtXform2);
          _this = _super.call(this);
          _this.map = { "x14:cfvo": _this.cfvoXform = new CfvoExtXform(), "x14:borderColor": _this.borderColorXform = new ColorXform("x14:borderColor"), "x14:negativeBorderColor": _this.negativeBorderColorXform = new ColorXform("x14:negativeBorderColor"), "x14:negativeFillColor": _this.negativeFillColorXform = new ColorXform("x14:negativeFillColor"), "x14:axisColor": _this.axisColorXform = new ColorXform("x14:axisColor") };
          return _this;
        }
        _createClass2(DatabarExtXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          xmlStream.openNode(this.tag, { minLength: BaseXform.toIntAttribute(model.minLength, 0, true), maxLength: BaseXform.toIntAttribute(model.maxLength, 100, true), border: BaseXform.toBoolAttribute(model.border, false), gradient: BaseXform.toBoolAttribute(model.gradient, true), negativeBarColorSameAsPositive: BaseXform.toBoolAttribute(model.negativeBarColorSameAsPositive, true), negativeBarBorderColorSameAsPositive: BaseXform.toBoolAttribute(model.negativeBarBorderColorSameAsPositive, true), axisPosition: BaseXform.toAttribute(model.axisPosition, "auto"), direction: BaseXform.toAttribute(model.direction, "leftToRight") });
          model.cfvo.forEach(function(cfvo) {
            _this2.cfvoXform.render(xmlStream, cfvo);
          });
          this.borderColorXform.render(xmlStream, model.borderColor);
          this.negativeBorderColorXform.render(xmlStream, model.negativeBorderColor);
          this.negativeFillColorXform.render(xmlStream, model.negativeFillColor);
          this.axisColorXform.render(xmlStream, model.axisColor);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return { cfvo: [], minLength: BaseXform.toIntValue(attributes.minLength, 0), maxLength: BaseXform.toIntValue(attributes.maxLength, 100), border: BaseXform.toBoolValue(attributes.border, false), gradient: BaseXform.toBoolValue(attributes.gradient, true), negativeBarColorSameAsPositive: BaseXform.toBoolValue(attributes.negativeBarColorSameAsPositive, true), negativeBarBorderColorSameAsPositive: BaseXform.toBoolValue(attributes.negativeBarBorderColorSameAsPositive, true), axisPosition: BaseXform.toStringValue(attributes.axisPosition, "auto"), direction: BaseXform.toStringValue(attributes.direction, "leftToRight") };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          var _name$split = name.split(":"), _name$split2 = _slicedToArray2(_name$split, 2), prop = _name$split2[1];
          switch (prop) {
            case "cfvo":
              this.model.cfvo.push(parser.model);
              break;
            default:
              this.model[prop] = parser.model;
              break;
          }
        } }, { key: "tag", get: function get() {
          return "x14:dataBar";
        } }], [{ key: "isExt", value: function isExt(rule) {
          return !rule.gradient;
        } }]);
        return DatabarExtXform2;
      }(CompositeXform);
      module2.exports = DatabarExtXform;
    }, { "../../base-xform": 31, "../../composite-xform": 47, "../../style/color-xform": 127, "./cfvo-ext-xform": 75 }], 79: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var FExtXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(FExtXform2, _BaseXform);
        var _super = _createSuper2(FExtXform2);
        function FExtXform2() {
          _classCallCheck2(this, FExtXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(FExtXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode(this.tag, null, model);
        } }, { key: "parseOpen", value: function parseOpen() {
          this.model = "";
        } }, { key: "parseText", value: function parseText(text) {
          this.model += text;
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }, { key: "tag", get: function get() {
          return "xm:f";
        } }]);
        return FExtXform2;
      }(BaseXform);
      module2.exports = FExtXform;
    }, { "../../base-xform": 31 }], 80: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _slicedToArray2(arr, i) {
        return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
      }
      function _nonIterableRest2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray2(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray2(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray2(o, minLen);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _iterableToArrayLimit2(arr, i) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      function _arrayWithHoles2(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var CfvoExtXform = require2("./cfvo-ext-xform");
      var CfIconExtXform = require2("./cf-icon-ext-xform");
      var IconSetExtXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(IconSetExtXform2, _CompositeXform);
        var _super = _createSuper2(IconSetExtXform2);
        function IconSetExtXform2() {
          var _this;
          _classCallCheck2(this, IconSetExtXform2);
          _this = _super.call(this);
          _this.map = { "x14:cfvo": _this.cfvoXform = new CfvoExtXform(), "x14:cfIcon": _this.cfIconXform = new CfIconExtXform() };
          return _this;
        }
        _createClass2(IconSetExtXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          xmlStream.openNode(this.tag, { iconSet: BaseXform.toStringAttribute(model.iconSet), reverse: BaseXform.toBoolAttribute(model.reverse, false), showValue: BaseXform.toBoolAttribute(model.showValue, true), custom: BaseXform.toBoolAttribute(model.icons, false) });
          model.cfvo.forEach(function(cfvo) {
            _this2.cfvoXform.render(xmlStream, cfvo);
          });
          if (model.icons) {
            model.icons.forEach(function(icon, i) {
              icon.iconId = i;
              _this2.cfIconXform.render(xmlStream, icon);
            });
          }
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return { cfvo: [], iconSet: BaseXform.toStringValue(attributes.iconSet, "3TrafficLights"), reverse: BaseXform.toBoolValue(attributes.reverse, false), showValue: BaseXform.toBoolValue(attributes.showValue, true) };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          var _name$split = name.split(":"), _name$split2 = _slicedToArray2(_name$split, 2), prop = _name$split2[1];
          switch (prop) {
            case "cfvo":
              this.model.cfvo.push(parser.model);
              break;
            case "cfIcon":
              if (!this.model.icons) {
                this.model.icons = [];
              }
              this.model.icons.push(parser.model);
              break;
            default:
              this.model[prop] = parser.model;
              break;
          }
        } }, { key: "tag", get: function get() {
          return "x14:iconSet";
        } }]);
        return IconSetExtXform2;
      }(CompositeXform);
      module2.exports = IconSetExtXform;
    }, { "../../base-xform": 31, "../../composite-xform": 47, "./cf-icon-ext-xform": 73, "./cfvo-ext-xform": 75 }], 81: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var SqrefExtXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(SqrefExtXform2, _BaseXform);
        var _super = _createSuper2(SqrefExtXform2);
        function SqrefExtXform2() {
          _classCallCheck2(this, SqrefExtXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(SqrefExtXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode(this.tag, null, model);
        } }, { key: "parseOpen", value: function parseOpen() {
          this.model = "";
        } }, { key: "parseText", value: function parseText(text) {
          this.model += text;
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }, { key: "tag", get: function get() {
          return "xm:sqref";
        } }]);
        return SqrefExtXform2;
      }(BaseXform);
      module2.exports = SqrefExtXform;
    }, { "../../base-xform": 31 }], 82: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function ownKeys2(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys2(Object(source), true).forEach(function(key) {
              _defineProperty2(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys2(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var Range = require2("../../../../doc/range");
      var DatabarXform = require2("./databar-xform");
      var ExtLstRefXform = require2("./ext-lst-ref-xform");
      var FormulaXform = require2("./formula-xform");
      var ColorScaleXform = require2("./color-scale-xform");
      var IconSetXform = require2("./icon-set-xform");
      var extIcons = { "3Triangles": true, "3Stars": true, "5Boxes": true };
      var getTextFormula = function getTextFormula2(model) {
        if (model.formulae && model.formulae[0]) {
          return model.formulae[0];
        }
        var range = new Range(model.ref);
        var tl = range.tl;
        switch (model.operator) {
          case "containsText":
            return 'NOT(ISERROR(SEARCH("'.concat(model.text, '",').concat(tl, ")))");
          case "containsBlanks":
            return "LEN(TRIM(".concat(tl, "))=0");
          case "notContainsBlanks":
            return "LEN(TRIM(".concat(tl, "))>0");
          case "containsErrors":
            return "ISERROR(".concat(tl, ")");
          case "notContainsErrors":
            return "NOT(ISERROR(".concat(tl, "))");
          default:
            return void 0;
        }
      };
      var getTimePeriodFormula = function getTimePeriodFormula2(model) {
        if (model.formulae && model.formulae[0]) {
          return model.formulae[0];
        }
        var range = new Range(model.ref);
        var tl = range.tl;
        switch (model.timePeriod) {
          case "thisWeek":
            return "AND(TODAY()-ROUNDDOWN(".concat(tl, ",0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(").concat(tl, ",0)-TODAY()<=7-WEEKDAY(TODAY()))");
          case "lastWeek":
            return "AND(TODAY()-ROUNDDOWN(".concat(tl, ",0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(").concat(tl, ",0)<(WEEKDAY(TODAY())+7))");
          case "nextWeek":
            return "AND(ROUNDDOWN(".concat(tl, ",0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(").concat(tl, ",0)-TODAY()<(15-WEEKDAY(TODAY())))");
          case "yesterday":
            return "FLOOR(".concat(tl, ",1)=TODAY()-1");
          case "today":
            return "FLOOR(".concat(tl, ",1)=TODAY()");
          case "tomorrow":
            return "FLOOR(".concat(tl, ",1)=TODAY()+1");
          case "last7Days":
            return "AND(TODAY()-FLOOR(".concat(tl, ",1)<=6,FLOOR(").concat(tl, ",1)<=TODAY())");
          case "lastMonth":
            return "AND(MONTH(".concat(tl, ")=MONTH(EDATE(TODAY(),0-1)),YEAR(").concat(tl, ")=YEAR(EDATE(TODAY(),0-1)))");
          case "thisMonth":
            return "AND(MONTH(".concat(tl, ")=MONTH(TODAY()),YEAR(").concat(tl, ")=YEAR(TODAY()))");
          case "nextMonth":
            return "AND(MONTH(".concat(tl, ")=MONTH(EDATE(TODAY(),0+1)),YEAR(").concat(tl, ")=YEAR(EDATE(TODAY(),0+1)))");
          default:
            return void 0;
        }
      };
      var opType = function opType2(attributes) {
        var type = attributes.type, operator = attributes.operator;
        switch (type) {
          case "containsText":
          case "containsBlanks":
          case "notContainsBlanks":
          case "containsErrors":
          case "notContainsErrors":
            return { type: "containsText", operator: type };
          default:
            return { type, operator };
        }
      };
      var CfRuleXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(CfRuleXform2, _CompositeXform);
        var _super = _createSuper2(CfRuleXform2);
        function CfRuleXform2() {
          var _this;
          _classCallCheck2(this, CfRuleXform2);
          _this = _super.call(this);
          _this.map = { dataBar: _this.databarXform = new DatabarXform(), extLst: _this.extLstRefXform = new ExtLstRefXform(), formula: _this.formulaXform = new FormulaXform(), colorScale: _this.colorScaleXform = new ColorScaleXform(), iconSet: _this.iconSetXform = new IconSetXform() };
          return _this;
        }
        _createClass2(CfRuleXform2, [{ key: "render", value: function render15(xmlStream, model) {
          switch (model.type) {
            case "expression":
              this.renderExpression(xmlStream, model);
              break;
            case "cellIs":
              this.renderCellIs(xmlStream, model);
              break;
            case "top10":
              this.renderTop10(xmlStream, model);
              break;
            case "aboveAverage":
              this.renderAboveAverage(xmlStream, model);
              break;
            case "dataBar":
              this.renderDataBar(xmlStream, model);
              break;
            case "colorScale":
              this.renderColorScale(xmlStream, model);
              break;
            case "iconSet":
              this.renderIconSet(xmlStream, model);
              break;
            case "containsText":
              this.renderText(xmlStream, model);
              break;
            case "timePeriod":
              this.renderTimePeriod(xmlStream, model);
              break;
          }
        } }, { key: "renderExpression", value: function renderExpression(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "expression", dxfId: model.dxfId, priority: model.priority });
          this.formulaXform.render(xmlStream, model.formulae[0]);
          xmlStream.closeNode();
        } }, { key: "renderCellIs", value: function renderCellIs(xmlStream, model) {
          var _this2 = this;
          xmlStream.openNode(this.tag, { type: "cellIs", dxfId: model.dxfId, priority: model.priority, operator: model.operator });
          model.formulae.forEach(function(formula) {
            _this2.formulaXform.render(xmlStream, formula);
          });
          xmlStream.closeNode();
        } }, { key: "renderTop10", value: function renderTop10(xmlStream, model) {
          xmlStream.leafNode(this.tag, { type: "top10", dxfId: model.dxfId, priority: model.priority, percent: BaseXform.toBoolAttribute(model.percent, false), bottom: BaseXform.toBoolAttribute(model.bottom, false), rank: BaseXform.toIntValue(model.rank, 10, true) });
        } }, { key: "renderAboveAverage", value: function renderAboveAverage(xmlStream, model) {
          xmlStream.leafNode(this.tag, { type: "aboveAverage", dxfId: model.dxfId, priority: model.priority, aboveAverage: BaseXform.toBoolAttribute(model.aboveAverage, true) });
        } }, { key: "renderDataBar", value: function renderDataBar(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "dataBar", priority: model.priority });
          this.databarXform.render(xmlStream, model);
          this.extLstRefXform.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "renderColorScale", value: function renderColorScale(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "colorScale", priority: model.priority });
          this.colorScaleXform.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "renderIconSet", value: function renderIconSet(xmlStream, model) {
          if (!CfRuleXform2.isPrimitive(model)) {
            return;
          }
          xmlStream.openNode(this.tag, { type: "iconSet", priority: model.priority });
          this.iconSetXform.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "renderText", value: function renderText(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: model.operator, dxfId: model.dxfId, priority: model.priority, operator: BaseXform.toStringAttribute(model.operator, "containsText") });
          var formula = getTextFormula(model);
          if (formula) {
            this.formulaXform.render(xmlStream, formula);
          }
          xmlStream.closeNode();
        } }, { key: "renderTimePeriod", value: function renderTimePeriod(xmlStream, model) {
          xmlStream.openNode(this.tag, { type: "timePeriod", dxfId: model.dxfId, priority: model.priority, timePeriod: model.timePeriod });
          var formula = getTimePeriodFormula(model);
          if (formula) {
            this.formulaXform.render(xmlStream, formula);
          }
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return _objectSpread2(_objectSpread2({}, opType(attributes)), {}, { dxfId: BaseXform.toIntValue(attributes.dxfId), priority: BaseXform.toIntValue(attributes.priority), timePeriod: attributes.timePeriod, percent: BaseXform.toBoolValue(attributes.percent), bottom: BaseXform.toBoolValue(attributes.bottom), rank: BaseXform.toIntValue(attributes.rank), aboveAverage: BaseXform.toBoolValue(attributes.aboveAverage) });
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          switch (name) {
            case "dataBar":
            case "extLst":
            case "colorScale":
            case "iconSet":
              Object.assign(this.model, parser.model);
              break;
            case "formula":
              this.model.formulae = this.model.formulae || [];
              this.model.formulae.push(parser.model);
              break;
          }
        } }, { key: "tag", get: function get() {
          return "cfRule";
        } }], [{ key: "isPrimitive", value: function isPrimitive(rule) {
          if (rule.type === "iconSet") {
            if (rule.custom || extIcons[rule.iconSet]) {
              return false;
            }
          }
          return true;
        } }]);
        return CfRuleXform2;
      }(CompositeXform);
      module2.exports = CfRuleXform;
    }, { "../../../../doc/range": 10, "../../base-xform": 31, "../../composite-xform": 47, "./color-scale-xform": 84, "./databar-xform": 87, "./ext-lst-ref-xform": 88, "./formula-xform": 89, "./icon-set-xform": 90 }], 83: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var CfvoXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(CfvoXform2, _BaseXform);
        var _super = _createSuper2(CfvoXform2);
        function CfvoXform2() {
          _classCallCheck2(this, CfvoXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(CfvoXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode(this.tag, { type: model.type, val: model.value });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          this.model = { type: node.attributes.type, value: BaseXform.toFloatValue(node.attributes.val) };
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }, { key: "tag", get: function get() {
          return "cfvo";
        } }]);
        return CfvoXform2;
      }(BaseXform);
      module2.exports = CfvoXform;
    }, { "../../base-xform": 31 }], 84: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var CompositeXform = require2("../../composite-xform");
      var ColorXform = require2("../../style/color-xform");
      var CfvoXform = require2("./cfvo-xform");
      var ColorScaleXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(ColorScaleXform2, _CompositeXform);
        var _super = _createSuper2(ColorScaleXform2);
        function ColorScaleXform2() {
          var _this;
          _classCallCheck2(this, ColorScaleXform2);
          _this = _super.call(this);
          _this.map = { cfvo: _this.cfvoXform = new CfvoXform(), color: _this.colorXform = new ColorXform() };
          return _this;
        }
        _createClass2(ColorScaleXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          xmlStream.openNode(this.tag);
          model.cfvo.forEach(function(cfvo) {
            _this2.cfvoXform.render(xmlStream, cfvo);
          });
          model.color.forEach(function(color) {
            _this2.colorXform.render(xmlStream, color);
          });
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(node) {
          return { cfvo: [], color: [] };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model[name].push(parser.model);
        } }, { key: "tag", get: function get() {
          return "colorScale";
        } }]);
        return ColorScaleXform2;
      }(CompositeXform);
      module2.exports = ColorScaleXform;
    }, { "../../composite-xform": 47, "../../style/color-xform": 127, "./cfvo-xform": 83 }], 85: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var CompositeXform = require2("../../composite-xform");
      var CfRuleXform = require2("./cf-rule-xform");
      var ConditionalFormattingXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(ConditionalFormattingXform2, _CompositeXform);
        var _super = _createSuper2(ConditionalFormattingXform2);
        function ConditionalFormattingXform2() {
          var _this;
          _classCallCheck2(this, ConditionalFormattingXform2);
          _this = _super.call(this);
          _this.map = { cfRule: new CfRuleXform() };
          return _this;
        }
        _createClass2(ConditionalFormattingXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          if (!model.rules.some(CfRuleXform.isPrimitive)) {
            return;
          }
          xmlStream.openNode(this.tag, { sqref: model.ref });
          model.rules.forEach(function(rule) {
            if (CfRuleXform.isPrimitive(rule)) {
              rule.ref = model.ref;
              _this2.map.cfRule.render(xmlStream, rule);
            }
          });
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return { ref: attributes.sqref, rules: [] };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model.rules.push(parser.model);
        } }, { key: "tag", get: function get() {
          return "conditionalFormatting";
        } }]);
        return ConditionalFormattingXform2;
      }(CompositeXform);
      module2.exports = ConditionalFormattingXform;
    }, { "../../composite-xform": 47, "./cf-rule-xform": 82 }], 86: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _toConsumableArray2(arr) {
        return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
      }
      function _nonIterableSpread2() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray2(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray2(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray2(o, minLen);
      }
      function _iterableToArray2(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
          return Array.from(iter);
      }
      function _arrayWithoutHoles2(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray2(arr);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var ConditionalFormattingXform = require2("./conditional-formatting-xform");
      var ConditionalFormattingsXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(ConditionalFormattingsXform2, _BaseXform);
        var _super = _createSuper2(ConditionalFormattingsXform2);
        function ConditionalFormattingsXform2() {
          var _this;
          _classCallCheck2(this, ConditionalFormattingsXform2);
          _this = _super.call(this);
          _this.cfXform = new ConditionalFormattingXform();
          return _this;
        }
        _createClass2(ConditionalFormattingsXform2, [{ key: "reset", value: function reset() {
          this.model = [];
        } }, { key: "prepare", value: function prepare(model, options) {
          var nextPriority = model.reduce(function(p, cf) {
            return Math.max.apply(Math, [p].concat(_toConsumableArray2(cf.rules.map(function(rule) {
              return rule.priority || 0;
            }))));
          }, 1);
          model.forEach(function(cf) {
            cf.rules.forEach(function(rule) {
              if (!rule.priority) {
                rule.priority = nextPriority++;
              }
              if (rule.style) {
                rule.dxfId = options.styles.addDxfStyle(rule.style);
              }
            });
          });
        } }, { key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          model.forEach(function(cf) {
            _this2.cfXform.render(xmlStream, cf);
          });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "conditionalFormatting":
              this.parser = this.cfXform;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.push(this.parser.model);
              this.parser = void 0;
              return false;
            }
            return true;
          }
          return false;
        } }, { key: "reconcile", value: function reconcile(model, options) {
          model.forEach(function(cf) {
            cf.rules.forEach(function(rule) {
              if (rule.dxfId !== void 0) {
                rule.style = options.styles.getDxfStyle(rule.dxfId);
                delete rule.dxfId;
              }
            });
          });
        } }, { key: "tag", get: function get() {
          return "conditionalFormatting";
        } }]);
        return ConditionalFormattingsXform2;
      }(BaseXform);
      module2.exports = ConditionalFormattingsXform;
    }, { "../../base-xform": 31, "./conditional-formatting-xform": 85 }], 87: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var CompositeXform = require2("../../composite-xform");
      var ColorXform = require2("../../style/color-xform");
      var CfvoXform = require2("./cfvo-xform");
      var DatabarXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(DatabarXform2, _CompositeXform);
        var _super = _createSuper2(DatabarXform2);
        function DatabarXform2() {
          var _this;
          _classCallCheck2(this, DatabarXform2);
          _this = _super.call(this);
          _this.map = { cfvo: _this.cfvoXform = new CfvoXform(), color: _this.colorXform = new ColorXform() };
          return _this;
        }
        _createClass2(DatabarXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          xmlStream.openNode(this.tag);
          model.cfvo.forEach(function(cfvo) {
            _this2.cfvoXform.render(xmlStream, cfvo);
          });
          this.colorXform.render(xmlStream, model.color);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return { cfvo: [] };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          switch (name) {
            case "cfvo":
              this.model.cfvo.push(parser.model);
              break;
            case "color":
              this.model.color = parser.model;
              break;
          }
        } }, { key: "tag", get: function get() {
          return "dataBar";
        } }]);
        return DatabarXform2;
      }(CompositeXform);
      module2.exports = DatabarXform;
    }, { "../../composite-xform": 47, "../../style/color-xform": 127, "./cfvo-xform": 83 }], 88: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var X14IdXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(X14IdXform2, _BaseXform);
        var _super = _createSuper2(X14IdXform2);
        function X14IdXform2() {
          _classCallCheck2(this, X14IdXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(X14IdXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode(this.tag, null, model);
        } }, { key: "parseOpen", value: function parseOpen() {
          this.model = "";
        } }, { key: "parseText", value: function parseText(text) {
          this.model += text;
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }, { key: "tag", get: function get() {
          return "x14:id";
        } }]);
        return X14IdXform2;
      }(BaseXform);
      var ExtXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(ExtXform2, _CompositeXform);
        var _super2 = _createSuper2(ExtXform2);
        function ExtXform2() {
          var _this;
          _classCallCheck2(this, ExtXform2);
          _this = _super2.call(this);
          _this.map = { "x14:id": _this.idXform = new X14IdXform() };
          return _this;
        }
        _createClass2(ExtXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag, { uri: "{B025F937-C7B1-47D3-B67F-A62EFF666E3E}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" });
          this.idXform.render(xmlStream, model.x14Id);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return {};
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model.x14Id = parser.model;
        } }, { key: "tag", get: function get() {
          return "ext";
        } }]);
        return ExtXform2;
      }(CompositeXform);
      var ExtLstRefXform = /* @__PURE__ */ function(_CompositeXform2) {
        _inherits2(ExtLstRefXform2, _CompositeXform2);
        var _super3 = _createSuper2(ExtLstRefXform2);
        function ExtLstRefXform2() {
          var _this2;
          _classCallCheck2(this, ExtLstRefXform2);
          _this2 = _super3.call(this);
          _this2.map = { ext: new ExtXform() };
          return _this2;
        }
        _createClass2(ExtLstRefXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag);
          this.map.ext.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return {};
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          Object.assign(this.model, parser.model);
        } }, { key: "tag", get: function get() {
          return "extLst";
        } }]);
        return ExtLstRefXform2;
      }(CompositeXform);
      module2.exports = ExtLstRefXform;
    }, { "../../base-xform": 31, "../../composite-xform": 47 }], 89: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var FormulaXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(FormulaXform2, _BaseXform);
        var _super = _createSuper2(FormulaXform2);
        function FormulaXform2() {
          _classCallCheck2(this, FormulaXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(FormulaXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode(this.tag, null, model);
        } }, { key: "parseOpen", value: function parseOpen() {
          this.model = "";
        } }, { key: "parseText", value: function parseText(text) {
          this.model += text;
        } }, { key: "parseClose", value: function parseClose(name) {
          return name !== this.tag;
        } }, { key: "tag", get: function get() {
          return "formula";
        } }]);
        return FormulaXform2;
      }(BaseXform);
      module2.exports = FormulaXform;
    }, { "../../base-xform": 31 }], 90: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../../base-xform");
      var CompositeXform = require2("../../composite-xform");
      var CfvoXform = require2("./cfvo-xform");
      var IconSetXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(IconSetXform2, _CompositeXform);
        var _super = _createSuper2(IconSetXform2);
        function IconSetXform2() {
          var _this;
          _classCallCheck2(this, IconSetXform2);
          _this = _super.call(this);
          _this.map = { cfvo: _this.cfvoXform = new CfvoXform() };
          return _this;
        }
        _createClass2(IconSetXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          xmlStream.openNode(this.tag, { iconSet: BaseXform.toStringAttribute(model.iconSet, "3TrafficLights"), reverse: BaseXform.toBoolAttribute(model.reverse, false), showValue: BaseXform.toBoolAttribute(model.showValue, true) });
          model.cfvo.forEach(function(cfvo) {
            _this2.cfvoXform.render(xmlStream, cfvo);
          });
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel(_ref) {
          var attributes = _ref.attributes;
          return { iconSet: BaseXform.toStringValue(attributes.iconSet, "3TrafficLights"), reverse: BaseXform.toBoolValue(attributes.reverse), showValue: BaseXform.toBoolValue(attributes.showValue), cfvo: [] };
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model[name].push(parser.model);
        } }, { key: "tag", get: function get() {
          return "iconSet";
        } }]);
        return IconSetXform2;
      }(CompositeXform);
      module2.exports = IconSetXform;
    }, { "../../base-xform": 31, "../../composite-xform": 47, "./cfvo-xform": 83 }], 91: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var ColXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(ColXform2, _BaseXform);
        var _super = _createSuper2(ColXform2);
        function ColXform2() {
          _classCallCheck2(this, ColXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(ColXform2, [{ key: "prepare", value: function prepare(model, options) {
          var styleId = options.styles.addStyleModel(model.style || {});
          if (styleId) {
            model.styleId = styleId;
          }
        } }, { key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode("col");
          xmlStream.addAttribute("min", model.min);
          xmlStream.addAttribute("max", model.max);
          if (model.width) {
            xmlStream.addAttribute("width", model.width);
          }
          if (model.styleId) {
            xmlStream.addAttribute("style", model.styleId);
          }
          if (model.hidden) {
            xmlStream.addAttribute("hidden", "1");
          }
          if (model.bestFit) {
            xmlStream.addAttribute("bestFit", "1");
          }
          if (model.outlineLevel) {
            xmlStream.addAttribute("outlineLevel", model.outlineLevel);
          }
          if (model.collapsed) {
            xmlStream.addAttribute("collapsed", "1");
          }
          xmlStream.addAttribute("customWidth", "1");
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "col") {
            var model = this.model = { min: parseInt(node.attributes.min || "0", 10), max: parseInt(node.attributes.max || "0", 10), width: node.attributes.width === void 0 ? void 0 : parseFloat(node.attributes.width || "0") };
            if (node.attributes.style) {
              model.styleId = parseInt(node.attributes.style, 10);
            }
            if (node.attributes.hidden === true || node.attributes.hidden === "true" || node.attributes.hidden === 1 || node.attributes.hidden === "1") {
              model.hidden = true;
            }
            if (node.attributes.bestFit) {
              model.bestFit = true;
            }
            if (node.attributes.outlineLevel) {
              model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);
            }
            if (node.attributes.collapsed) {
              model.collapsed = true;
            }
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "reconcile", value: function reconcile(model, options) {
          if (model.styleId) {
            model.style = options.styles.getStyleModel(model.styleId);
          }
        } }, { key: "tag", get: function get() {
          return "col";
        } }]);
        return ColXform2;
      }(BaseXform);
      module2.exports = ColXform;
    }, { "../base-xform": 31 }], 92: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      function ownKeys2(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys2(Object(source), true).forEach(function(key) {
              _defineProperty2(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys2(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      var _ = require2("../../../utils/under-dash");
      var utils = require2("../../../utils/utils");
      var colCache = require2("../../../utils/col-cache");
      var BaseXform = require2("../base-xform");
      var Range = require2("../../../doc/range");
      function assign(definedName, attributes, name, defaultValue) {
        var value = attributes[name];
        if (value !== void 0) {
          definedName[name] = value;
        } else if (defaultValue !== void 0) {
          definedName[name] = defaultValue;
        }
      }
      function parseBool(value) {
        switch (value) {
          case "1":
          case "true":
            return true;
          default:
            return false;
        }
      }
      function assignBool(definedName, attributes, name, defaultValue) {
        var value = attributes[name];
        if (value !== void 0) {
          definedName[name] = parseBool(value);
        } else if (defaultValue !== void 0) {
          definedName[name] = defaultValue;
        }
      }
      function optimiseDataValidations(model) {
        var dvList = _.map(model, function(dataValidation, address) {
          return { address, dataValidation, marked: false };
        }).sort(function(a, b) {
          return _.strcmp(a.address, b.address);
        });
        var dvMap = _.keyBy(dvList, "address");
        var matchCol = function matchCol2(addr, height2, col) {
          for (var i = 0; i < height2; i++) {
            var otherAddress = colCache.encodeAddress(addr.row + i, col);
            if (!model[otherAddress] || !_.isEqual(model[addr.address], model[otherAddress])) {
              return false;
            }
          }
          return true;
        };
        return dvList.map(function(dv) {
          if (!dv.marked) {
            var addr = colCache.decodeEx(dv.address);
            if (addr.dimensions) {
              dvMap[addr.dimensions].marked = true;
              return _objectSpread2(_objectSpread2({}, dv.dataValidation), {}, { sqref: dv.address });
            }
            var height2 = 1;
            var otherAddress = colCache.encodeAddress(addr.row + height2, addr.col);
            while (model[otherAddress] && _.isEqual(dv.dataValidation, model[otherAddress])) {
              height2++;
              otherAddress = colCache.encodeAddress(addr.row + height2, addr.col);
            }
            var width2 = 1;
            while (matchCol(addr, height2, addr.col + width2)) {
              width2++;
            }
            for (var i = 0; i < height2; i++) {
              for (var j = 0; j < width2; j++) {
                otherAddress = colCache.encodeAddress(addr.row + i, addr.col + j);
                dvMap[otherAddress].marked = true;
              }
            }
            if (height2 > 1 || width2 > 1) {
              var bottom = addr.row + (height2 - 1);
              var right = addr.col + (width2 - 1);
              return _objectSpread2(_objectSpread2({}, dv.dataValidation), {}, { sqref: "".concat(dv.address, ":").concat(colCache.encodeAddress(bottom, right)) });
            }
            return _objectSpread2(_objectSpread2({}, dv.dataValidation), {}, { sqref: dv.address });
          }
          return null;
        }).filter(Boolean);
      }
      var DataValidationsXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(DataValidationsXform2, _BaseXform);
        var _super = _createSuper2(DataValidationsXform2);
        function DataValidationsXform2() {
          _classCallCheck2(this, DataValidationsXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(DataValidationsXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var optimizedModel = optimiseDataValidations(model);
          if (optimizedModel.length) {
            xmlStream.openNode("dataValidations", { count: optimizedModel.length });
            optimizedModel.forEach(function(value) {
              xmlStream.openNode("dataValidation");
              if (value.type !== "any") {
                xmlStream.addAttribute("type", value.type);
                if (value.operator && value.type !== "list" && value.operator !== "between") {
                  xmlStream.addAttribute("operator", value.operator);
                }
                if (value.allowBlank) {
                  xmlStream.addAttribute("allowBlank", "1");
                }
              }
              if (value.showInputMessage) {
                xmlStream.addAttribute("showInputMessage", "1");
              }
              if (value.promptTitle) {
                xmlStream.addAttribute("promptTitle", value.promptTitle);
              }
              if (value.prompt) {
                xmlStream.addAttribute("prompt", value.prompt);
              }
              if (value.showErrorMessage) {
                xmlStream.addAttribute("showErrorMessage", "1");
              }
              if (value.errorStyle) {
                xmlStream.addAttribute("errorStyle", value.errorStyle);
              }
              if (value.errorTitle) {
                xmlStream.addAttribute("errorTitle", value.errorTitle);
              }
              if (value.error) {
                xmlStream.addAttribute("error", value.error);
              }
              xmlStream.addAttribute("sqref", value.sqref);
              (value.formulae || []).forEach(function(formula, index2) {
                xmlStream.openNode("formula".concat(index2 + 1));
                if (value.type === "date") {
                  xmlStream.writeText(utils.dateToExcel(new Date(formula)));
                } else {
                  xmlStream.writeText(formula);
                }
                xmlStream.closeNode();
              });
              xmlStream.closeNode();
            });
            xmlStream.closeNode();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "dataValidations":
              this.model = {};
              return true;
            case "dataValidation": {
              this._address = node.attributes.sqref;
              var dataValidation = { type: node.attributes.type || "any", formulae: [] };
              if (node.attributes.type) {
                assignBool(dataValidation, node.attributes, "allowBlank");
              }
              assignBool(dataValidation, node.attributes, "showInputMessage");
              assignBool(dataValidation, node.attributes, "showErrorMessage");
              switch (dataValidation.type) {
                case "any":
                case "list":
                case "custom":
                  break;
                default:
                  assign(dataValidation, node.attributes, "operator", "between");
                  break;
              }
              assign(dataValidation, node.attributes, "promptTitle");
              assign(dataValidation, node.attributes, "prompt");
              assign(dataValidation, node.attributes, "errorStyle");
              assign(dataValidation, node.attributes, "errorTitle");
              assign(dataValidation, node.attributes, "error");
              this._dataValidation = dataValidation;
              return true;
            }
            case "formula1":
            case "formula2":
              this._formula = [];
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this._formula) {
            this._formula.push(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          var _this = this;
          switch (name) {
            case "dataValidations":
              return false;
            case "dataValidation": {
              if (!this._dataValidation.formulae || !this._dataValidation.formulae.length) {
                delete this._dataValidation.formulae;
                delete this._dataValidation.operator;
              }
              var list = this._address.split(/\s+/g) || [];
              list.forEach(function(addr) {
                if (addr.includes(":")) {
                  var range = new Range(addr);
                  range.forEachAddress(function(address) {
                    _this.model[address] = _this._dataValidation;
                  });
                } else {
                  _this.model[addr] = _this._dataValidation;
                }
              });
              return true;
            }
            case "formula1":
            case "formula2": {
              var formula = this._formula.join("");
              switch (this._dataValidation.type) {
                case "whole":
                case "textLength":
                  formula = parseInt(formula, 10);
                  break;
                case "decimal":
                  formula = parseFloat(formula);
                  break;
                case "date":
                  formula = utils.excelToDate(parseFloat(formula));
                  break;
              }
              this._dataValidation.formulae.push(formula);
              this._formula = void 0;
              return true;
            }
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "dataValidations";
        } }]);
        return DataValidationsXform2;
      }(BaseXform);
      module2.exports = DataValidationsXform;
    }, { "../../../doc/range": 10, "../../../utils/col-cache": 19, "../../../utils/under-dash": 25, "../../../utils/utils": 26, "../base-xform": 31 }], 93: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var DimensionXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(DimensionXform2, _BaseXform);
        var _super = _createSuper2(DimensionXform2);
        function DimensionXform2() {
          _classCallCheck2(this, DimensionXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(DimensionXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            xmlStream.leafNode("dimension", { ref: model });
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "dimension") {
            this.model = node.attributes.ref;
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "dimension";
        } }]);
        return DimensionXform2;
      }(BaseXform);
      module2.exports = DimensionXform;
    }, { "../base-xform": 31 }], 94: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var DrawingXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(DrawingXform2, _BaseXform);
        var _super = _createSuper2(DrawingXform2);
        function DrawingXform2() {
          _classCallCheck2(this, DrawingXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(DrawingXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            xmlStream.leafNode(this.tag, { "r:id": model.rId });
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { rId: node.attributes["r:id"] };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "drawing";
        } }]);
        return DrawingXform2;
      }(BaseXform);
      module2.exports = DrawingXform;
    }, { "../base-xform": 31 }], 95: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var CompositeXform = require2("../composite-xform");
      var ConditionalFormattingsExt = require2("./cf-ext/conditional-formattings-ext-xform");
      var ExtXform = /* @__PURE__ */ function(_CompositeXform) {
        _inherits2(ExtXform2, _CompositeXform);
        var _super = _createSuper2(ExtXform2);
        function ExtXform2() {
          var _this;
          _classCallCheck2(this, ExtXform2);
          _this = _super.call(this);
          _this.map = { "x14:conditionalFormattings": _this.conditionalFormattings = new ConditionalFormattingsExt() };
          return _this;
        }
        _createClass2(ExtXform2, [{ key: "hasContent", value: function hasContent(model) {
          return this.conditionalFormattings.hasContent(model.conditionalFormattings);
        } }, { key: "prepare", value: function prepare(model, options) {
          this.conditionalFormattings.prepare(model.conditionalFormattings, options);
        } }, { key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode("ext", { uri: "{78C0D931-6437-407d-A8EE-F0AAD7539E65}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" });
          this.conditionalFormattings.render(xmlStream, model.conditionalFormattings);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return {};
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          this.model[name] = parser.model;
        } }, { key: "tag", get: function get() {
          return "ext";
        } }]);
        return ExtXform2;
      }(CompositeXform);
      var ExtLstXform = /* @__PURE__ */ function(_CompositeXform2) {
        _inherits2(ExtLstXform2, _CompositeXform2);
        var _super2 = _createSuper2(ExtLstXform2);
        function ExtLstXform2() {
          var _this2;
          _classCallCheck2(this, ExtLstXform2);
          _this2 = _super2.call(this);
          _this2.map = { ext: _this2.ext = new ExtXform() };
          return _this2;
        }
        _createClass2(ExtLstXform2, [{ key: "prepare", value: function prepare(model, options) {
          this.ext.prepare(model, options);
        } }, { key: "hasContent", value: function hasContent(model) {
          return this.ext.hasContent(model);
        } }, { key: "render", value: function render15(xmlStream, model) {
          if (!this.hasContent(model)) {
            return;
          }
          xmlStream.openNode("extLst");
          this.ext.render(xmlStream, model);
          xmlStream.closeNode();
        } }, { key: "createNewModel", value: function createNewModel() {
          return {};
        } }, { key: "onParserClose", value: function onParserClose(name, parser) {
          Object.assign(this.model, parser.model);
        } }, { key: "tag", get: function get() {
          return "extLst";
        } }]);
        return ExtLstXform2;
      }(CompositeXform);
      module2.exports = ExtLstXform;
    }, { "../composite-xform": 47, "./cf-ext/conditional-formattings-ext-xform": 77 }], 96: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var HeaderFooterXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(HeaderFooterXform2, _BaseXform);
        var _super = _createSuper2(HeaderFooterXform2);
        function HeaderFooterXform2() {
          _classCallCheck2(this, HeaderFooterXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(HeaderFooterXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            xmlStream.addRollback();
            var createTag = false;
            xmlStream.openNode("headerFooter");
            if (model.differentFirst) {
              xmlStream.addAttribute("differentFirst", "1");
              createTag = true;
            }
            if (model.differentOddEven) {
              xmlStream.addAttribute("differentOddEven", "1");
              createTag = true;
            }
            if (model.oddHeader && typeof model.oddHeader === "string") {
              xmlStream.leafNode("oddHeader", null, model.oddHeader);
              createTag = true;
            }
            if (model.oddFooter && typeof model.oddFooter === "string") {
              xmlStream.leafNode("oddFooter", null, model.oddFooter);
              createTag = true;
            }
            if (model.evenHeader && typeof model.evenHeader === "string") {
              xmlStream.leafNode("evenHeader", null, model.evenHeader);
              createTag = true;
            }
            if (model.evenFooter && typeof model.evenFooter === "string") {
              xmlStream.leafNode("evenFooter", null, model.evenFooter);
              createTag = true;
            }
            if (model.firstHeader && typeof model.firstHeader === "string") {
              xmlStream.leafNode("firstHeader", null, model.firstHeader);
              createTag = true;
            }
            if (model.firstFooter && typeof model.firstFooter === "string") {
              xmlStream.leafNode("firstFooter", null, model.firstFooter);
              createTag = true;
            }
            if (createTag) {
              xmlStream.closeNode();
              xmlStream.commit();
            } else {
              xmlStream.rollback();
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "headerFooter":
              this.model = {};
              if (node.attributes.differentFirst) {
                this.model.differentFirst = parseInt(node.attributes.differentFirst, 0) === 1;
              }
              if (node.attributes.differentOddEven) {
                this.model.differentOddEven = parseInt(node.attributes.differentOddEven, 0) === 1;
              }
              return true;
            case "oddHeader":
              this.currentNode = "oddHeader";
              return true;
            case "oddFooter":
              this.currentNode = "oddFooter";
              return true;
            case "evenHeader":
              this.currentNode = "evenHeader";
              return true;
            case "evenFooter":
              this.currentNode = "evenFooter";
              return true;
            case "firstHeader":
              this.currentNode = "firstHeader";
              return true;
            case "firstFooter":
              this.currentNode = "firstFooter";
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          switch (this.currentNode) {
            case "oddHeader":
              this.model.oddHeader = text;
              break;
            case "oddFooter":
              this.model.oddFooter = text;
              break;
            case "evenHeader":
              this.model.evenHeader = text;
              break;
            case "evenFooter":
              this.model.evenFooter = text;
              break;
            case "firstHeader":
              this.model.firstHeader = text;
              break;
            case "firstFooter":
              this.model.firstFooter = text;
              break;
          }
        } }, { key: "parseClose", value: function parseClose() {
          switch (this.currentNode) {
            case "oddHeader":
            case "oddFooter":
            case "evenHeader":
            case "evenFooter":
            case "firstHeader":
            case "firstFooter":
              this.currentNode = void 0;
              return true;
            default:
              return false;
          }
        } }, { key: "tag", get: function get() {
          return "headerFooter";
        } }]);
        return HeaderFooterXform2;
      }(BaseXform);
      module2.exports = HeaderFooterXform;
    }, { "../base-xform": 31 }], 97: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var HyperlinkXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(HyperlinkXform2, _BaseXform);
        var _super = _createSuper2(HyperlinkXform2);
        function HyperlinkXform2() {
          _classCallCheck2(this, HyperlinkXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(HyperlinkXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode("hyperlink", { ref: model.address, "r:id": model.rId, tooltip: model.tooltip });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "hyperlink") {
            this.model = { address: node.attributes.ref, rId: node.attributes["r:id"], tooltip: node.attributes.tooltip };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "hyperlink";
        } }]);
        return HyperlinkXform2;
      }(BaseXform);
      module2.exports = HyperlinkXform;
    }, { "../base-xform": 31 }], 98: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var MergeCellXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(MergeCellXform2, _BaseXform);
        var _super = _createSuper2(MergeCellXform2);
        function MergeCellXform2() {
          _classCallCheck2(this, MergeCellXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(MergeCellXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode("mergeCell", { ref: model });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "mergeCell") {
            this.model = node.attributes.ref;
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "mergeCell";
        } }]);
        return MergeCellXform2;
      }(BaseXform);
      module2.exports = MergeCellXform;
    }, { "../base-xform": 31 }], 99: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var _ = require2("../../../utils/under-dash");
      var Range = require2("../../../doc/range");
      var colCache = require2("../../../utils/col-cache");
      var Enums = require2("../../../doc/enums");
      var Merges2 = /* @__PURE__ */ function() {
        function Merges3() {
          _classCallCheck2(this, Merges3);
          this.merges = {};
        }
        _createClass2(Merges3, [{ key: "add", value: function add(merge2) {
          if (this.merges[merge2.master]) {
            this.merges[merge2.master].expandToAddress(merge2.address);
          } else {
            var range = "".concat(merge2.master, ":").concat(merge2.address);
            this.merges[merge2.master] = new Range(range);
          }
        } }, { key: "reconcile", value: function reconcile(mergeCells, rows) {
          _.each(mergeCells, function(merge2) {
            var dimensions = colCache.decode(merge2);
            for (var i = dimensions.top; i <= dimensions.bottom; i++) {
              var row = rows[i - 1];
              for (var j = dimensions.left; j <= dimensions.right; j++) {
                var cell = row.cells[j - 1];
                if (!cell) {
                  row.cells[j] = { type: Enums.ValueType.Null, address: colCache.encodeAddress(i, j) };
                } else if (cell.type === Enums.ValueType.Merge) {
                  cell.master = dimensions.tl;
                }
              }
            }
          });
        } }, { key: "getMasterAddress", value: function getMasterAddress(address) {
          var range = this.hash[address];
          return range && range.tl;
        } }, { key: "mergeCells", get: function get() {
          return _.map(this.merges, function(merge2) {
            return merge2.range;
          });
        } }]);
        return Merges3;
      }();
      module2.exports = Merges2;
    }, { "../../../doc/enums": 7, "../../../doc/range": 10, "../../../utils/col-cache": 19, "../../../utils/under-dash": 25 }], 100: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var isDefined = function isDefined2(attr) {
        return typeof attr !== "undefined";
      };
      var OutlinePropertiesXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(OutlinePropertiesXform2, _BaseXform);
        var _super = _createSuper2(OutlinePropertiesXform2);
        function OutlinePropertiesXform2() {
          _classCallCheck2(this, OutlinePropertiesXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(OutlinePropertiesXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model && (isDefined(model.summaryBelow) || isDefined(model.summaryRight))) {
            xmlStream.leafNode(this.tag, { summaryBelow: isDefined(model.summaryBelow) ? Number(model.summaryBelow) : void 0, summaryRight: isDefined(model.summaryRight) ? Number(model.summaryRight) : void 0 });
            return true;
          }
          return false;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            this.model = { summaryBelow: isDefined(node.attributes.summaryBelow) ? Boolean(Number(node.attributes.summaryBelow)) : void 0, summaryRight: isDefined(node.attributes.summaryRight) ? Boolean(Number(node.attributes.summaryRight)) : void 0 };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "outlinePr";
        } }]);
        return OutlinePropertiesXform2;
      }(BaseXform);
      module2.exports = OutlinePropertiesXform;
    }, { "../base-xform": 31 }], 101: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var PageBreaksXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(PageBreaksXform2, _BaseXform);
        var _super = _createSuper2(PageBreaksXform2);
        function PageBreaksXform2() {
          _classCallCheck2(this, PageBreaksXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(PageBreaksXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode("brk", model);
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "brk") {
            this.model = node.attributes.ref;
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "brk";
        } }]);
        return PageBreaksXform2;
      }(BaseXform);
      module2.exports = PageBreaksXform;
    }, { "../base-xform": 31 }], 102: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      var PageMarginsXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(PageMarginsXform2, _BaseXform);
        var _super = _createSuper2(PageMarginsXform2);
        function PageMarginsXform2() {
          _classCallCheck2(this, PageMarginsXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(PageMarginsXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            var attributes = { left: model.left, right: model.right, top: model.top, bottom: model.bottom, header: model.header, footer: model.footer };
            if (_.some(attributes, function(value) {
              return value !== void 0;
            })) {
              xmlStream.leafNode(this.tag, attributes);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { left: parseFloat(node.attributes.left || 0.7), right: parseFloat(node.attributes.right || 0.7), top: parseFloat(node.attributes.top || 0.75), bottom: parseFloat(node.attributes.bottom || 0.75), header: parseFloat(node.attributes.header || 0.3), footer: parseFloat(node.attributes.footer || 0.3) };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "pageMargins";
        } }]);
        return PageMarginsXform2;
      }(BaseXform);
      module2.exports = PageMarginsXform;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31 }], 103: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var PageSetupPropertiesXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(PageSetupPropertiesXform2, _BaseXform);
        var _super = _createSuper2(PageSetupPropertiesXform2);
        function PageSetupPropertiesXform2() {
          _classCallCheck2(this, PageSetupPropertiesXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(PageSetupPropertiesXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model && model.fitToPage) {
            xmlStream.leafNode(this.tag, { fitToPage: model.fitToPage ? "1" : void 0 });
            return true;
          }
          return false;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            this.model = { fitToPage: node.attributes.fitToPage === "1" };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "pageSetUpPr";
        } }]);
        return PageSetupPropertiesXform2;
      }(BaseXform);
      module2.exports = PageSetupPropertiesXform;
    }, { "../base-xform": 31 }], 104: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      function booleanToXml(model) {
        return model ? "1" : void 0;
      }
      function pageOrderToXml(model) {
        switch (model) {
          case "overThenDown":
            return model;
          default:
            return void 0;
        }
      }
      function cellCommentsToXml(model) {
        switch (model) {
          case "atEnd":
          case "asDisplyed":
            return model;
          default:
            return void 0;
        }
      }
      function errorsToXml(model) {
        switch (model) {
          case "dash":
          case "blank":
          case "NA":
            return model;
          default:
            return void 0;
        }
      }
      function pageSizeToModel(value) {
        return value !== void 0 ? parseInt(value, 10) : void 0;
      }
      var PageSetupXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(PageSetupXform2, _BaseXform);
        var _super = _createSuper2(PageSetupXform2);
        function PageSetupXform2() {
          _classCallCheck2(this, PageSetupXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(PageSetupXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            var attributes = { paperSize: model.paperSize, orientation: model.orientation, horizontalDpi: model.horizontalDpi, verticalDpi: model.verticalDpi, pageOrder: pageOrderToXml(model.pageOrder), blackAndWhite: booleanToXml(model.blackAndWhite), draft: booleanToXml(model.draft), cellComments: cellCommentsToXml(model.cellComments), errors: errorsToXml(model.errors), scale: model.scale, fitToWidth: model.fitToWidth, fitToHeight: model.fitToHeight, firstPageNumber: model.firstPageNumber, useFirstPageNumber: booleanToXml(model.firstPageNumber), usePrinterDefaults: booleanToXml(model.usePrinterDefaults), copies: model.copies };
            if (_.some(attributes, function(value) {
              return value !== void 0;
            })) {
              xmlStream.leafNode(this.tag, attributes);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { paperSize: pageSizeToModel(node.attributes.paperSize), orientation: node.attributes.orientation || "portrait", horizontalDpi: parseInt(node.attributes.horizontalDpi || "4294967295", 10), verticalDpi: parseInt(node.attributes.verticalDpi || "4294967295", 10), pageOrder: node.attributes.pageOrder || "downThenOver", blackAndWhite: node.attributes.blackAndWhite === "1", draft: node.attributes.draft === "1", cellComments: node.attributes.cellComments || "None", errors: node.attributes.errors || "displayed", scale: parseInt(node.attributes.scale || "100", 10), fitToWidth: parseInt(node.attributes.fitToWidth || "1", 10), fitToHeight: parseInt(node.attributes.fitToHeight || "1", 10), firstPageNumber: parseInt(node.attributes.firstPageNumber || "1", 10), useFirstPageNumber: node.attributes.useFirstPageNumber === "1", usePrinterDefaults: node.attributes.usePrinterDefaults === "1", copies: parseInt(node.attributes.copies || "1", 10) };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "pageSetup";
        } }]);
        return PageSetupXform2;
      }(BaseXform);
      module2.exports = PageSetupXform;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31 }], 105: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var PictureXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(PictureXform2, _BaseXform);
        var _super = _createSuper2(PictureXform2);
        function PictureXform2() {
          _classCallCheck2(this, PictureXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(PictureXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            xmlStream.leafNode(this.tag, { "r:id": model.rId });
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { rId: node.attributes["r:id"] };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "picture";
        } }]);
        return PictureXform2;
      }(BaseXform);
      module2.exports = PictureXform;
    }, { "../base-xform": 31 }], 106: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      function booleanToXml(model) {
        return model ? "1" : void 0;
      }
      var PrintOptionsXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(PrintOptionsXform2, _BaseXform);
        var _super = _createSuper2(PrintOptionsXform2);
        function PrintOptionsXform2() {
          _classCallCheck2(this, PrintOptionsXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(PrintOptionsXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            var attributes = { headings: booleanToXml(model.showRowColHeaders), gridLines: booleanToXml(model.showGridLines), horizontalCentered: booleanToXml(model.horizontalCentered), verticalCentered: booleanToXml(model.verticalCentered) };
            if (_.some(attributes, function(value) {
              return value !== void 0;
            })) {
              xmlStream.leafNode(this.tag, attributes);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { showRowColHeaders: node.attributes.headings === "1", showGridLines: node.attributes.gridLines === "1", horizontalCentered: node.attributes.horizontalCentered === "1", verticalCentered: node.attributes.verticalCentered === "1" };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "printOptions";
        } }]);
        return PrintOptionsXform2;
      }(BaseXform);
      module2.exports = PrintOptionsXform;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31 }], 107: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var PageBreaksXform = require2("./page-breaks-xform");
      var ListXform = require2("../list-xform");
      var RowBreaksXform = /* @__PURE__ */ function(_ListXform) {
        _inherits2(RowBreaksXform2, _ListXform);
        var _super = _createSuper2(RowBreaksXform2);
        function RowBreaksXform2() {
          _classCallCheck2(this, RowBreaksXform2);
          var options = { tag: "rowBreaks", count: true, childXform: new PageBreaksXform() };
          return _super.call(this, options);
        }
        _createClass2(RowBreaksXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model && model.length) {
            xmlStream.openNode(this.tag, this.$);
            if (this.count) {
              xmlStream.addAttribute(this.$count, model.length);
              xmlStream.addAttribute("manualBreakCount", model.length);
            }
            var childXform = this.childXform;
            model.forEach(function(childModel) {
              childXform.render(xmlStream, childModel);
            });
            xmlStream.closeNode();
          } else if (this.empty) {
            xmlStream.leafNode(this.tag);
          }
        } }]);
        return RowBreaksXform2;
      }(ListXform);
      module2.exports = RowBreaksXform;
    }, { "../list-xform": 70, "./page-breaks-xform": 101 }], 108: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var CellXform = require2("./cell-xform");
      var RowXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(RowXform2, _BaseXform);
        var _super = _createSuper2(RowXform2);
        function RowXform2(options) {
          var _this;
          _classCallCheck2(this, RowXform2);
          _this = _super.call(this);
          _this.maxItems = options && options.maxItems;
          _this.map = { c: new CellXform() };
          return _this;
        }
        _createClass2(RowXform2, [{ key: "prepare", value: function prepare(model, options) {
          var styleId = options.styles.addStyleModel(model.style);
          if (styleId) {
            model.styleId = styleId;
          }
          var cellXform = this.map.c;
          model.cells.forEach(function(cellModel) {
            cellXform.prepare(cellModel, options);
          });
        } }, { key: "render", value: function render15(xmlStream, model, options) {
          xmlStream.openNode("row");
          xmlStream.addAttribute("r", model.number);
          if (model.height) {
            xmlStream.addAttribute("ht", model.height);
            xmlStream.addAttribute("customHeight", "1");
          }
          if (model.hidden) {
            xmlStream.addAttribute("hidden", "1");
          }
          if (model.min > 0 && model.max > 0 && model.min <= model.max) {
            xmlStream.addAttribute("spans", "".concat(model.min, ":").concat(model.max));
          }
          if (model.styleId) {
            xmlStream.addAttribute("s", model.styleId);
            xmlStream.addAttribute("customFormat", "1");
          }
          xmlStream.addAttribute("x14ac:dyDescent", "0.25");
          if (model.outlineLevel) {
            xmlStream.addAttribute("outlineLevel", model.outlineLevel);
          }
          if (model.collapsed) {
            xmlStream.addAttribute("collapsed", "1");
          }
          var cellXform = this.map.c;
          model.cells.forEach(function(cellModel) {
            cellXform.render(xmlStream, cellModel, options);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (node.name === "row") {
            this.numRowsSeen += 1;
            var spans = node.attributes.spans ? node.attributes.spans.split(":").map(function(span) {
              return parseInt(span, 10);
            }) : [void 0, void 0];
            var model = this.model = { number: parseInt(node.attributes.r, 10), min: spans[0], max: spans[1], cells: [] };
            if (node.attributes.s) {
              model.styleId = parseInt(node.attributes.s, 10);
            }
            if (node.attributes.hidden === true || node.attributes.hidden === "true" || node.attributes.hidden === 1 || node.attributes.hidden === "1") {
              model.hidden = true;
            }
            if (node.attributes.bestFit) {
              model.bestFit = true;
            }
            if (node.attributes.ht) {
              model.height = parseFloat(node.attributes.ht);
            }
            if (node.attributes.outlineLevel) {
              model.outlineLevel = parseInt(node.attributes.outlineLevel, 10);
            }
            if (node.attributes.collapsed) {
              model.collapsed = true;
            }
            return true;
          }
          this.parser = this.map[node.name];
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.cells.push(this.parser.model);
              if (this.maxItems && this.model.cells.length > this.maxItems) {
                throw new Error("Max column count (".concat(this.maxItems, ") exceeded"));
              }
              this.parser = void 0;
            }
            return true;
          }
          return false;
        } }, { key: "reconcile", value: function reconcile(model, options) {
          model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};
          if (model.styleId !== void 0) {
            model.styleId = void 0;
          }
          var cellXform = this.map.c;
          model.cells.forEach(function(cellModel) {
            cellXform.reconcile(cellModel, options);
          });
        } }, { key: "tag", get: function get() {
          return "row";
        } }]);
        return RowXform2;
      }(BaseXform);
      module2.exports = RowXform;
    }, { "../base-xform": 31, "./cell-xform": 72 }], 109: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      var SheetFormatPropertiesXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(SheetFormatPropertiesXform2, _BaseXform);
        var _super = _createSuper2(SheetFormatPropertiesXform2);
        function SheetFormatPropertiesXform2() {
          _classCallCheck2(this, SheetFormatPropertiesXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(SheetFormatPropertiesXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            var attributes = { defaultRowHeight: model.defaultRowHeight, outlineLevelRow: model.outlineLevelRow, outlineLevelCol: model.outlineLevelCol, "x14ac:dyDescent": model.dyDescent };
            if (model.defaultColWidth) {
              attributes.defaultColWidth = model.defaultColWidth;
            }
            if (!model.defaultRowHeight || model.defaultRowHeight !== 15) {
              attributes.customHeight = "1";
            }
            if (_.some(attributes, function(value) {
              return value !== void 0;
            })) {
              xmlStream.leafNode("sheetFormatPr", attributes);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "sheetFormatPr") {
            this.model = { defaultRowHeight: parseFloat(node.attributes.defaultRowHeight || "0"), dyDescent: parseFloat(node.attributes["x14ac:dyDescent"] || "0"), outlineLevelRow: parseInt(node.attributes.outlineLevelRow || "0", 10), outlineLevelCol: parseInt(node.attributes.outlineLevelCol || "0", 10) };
            if (node.attributes.defaultColWidth) {
              this.model.defaultColWidth = parseFloat(node.attributes.defaultColWidth);
            }
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "sheetFormatPr";
        } }]);
        return SheetFormatPropertiesXform2;
      }(BaseXform);
      module2.exports = SheetFormatPropertiesXform;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31 }], 110: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var ColorXform = require2("../style/color-xform");
      var PageSetupPropertiesXform = require2("./page-setup-properties-xform");
      var OutlinePropertiesXform = require2("./outline-properties-xform");
      var SheetPropertiesXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(SheetPropertiesXform2, _BaseXform);
        var _super = _createSuper2(SheetPropertiesXform2);
        function SheetPropertiesXform2() {
          var _this;
          _classCallCheck2(this, SheetPropertiesXform2);
          _this = _super.call(this);
          _this.map = { tabColor: new ColorXform("tabColor"), pageSetUpPr: new PageSetupPropertiesXform(), outlinePr: new OutlinePropertiesXform() };
          return _this;
        }
        _createClass2(SheetPropertiesXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            xmlStream.addRollback();
            xmlStream.openNode("sheetPr");
            var inner = false;
            inner = this.map.tabColor.render(xmlStream, model.tabColor) || inner;
            inner = this.map.pageSetUpPr.render(xmlStream, model.pageSetup) || inner;
            inner = this.map.outlinePr.render(xmlStream, model.outlineProperties) || inner;
            if (inner) {
              xmlStream.closeNode();
              xmlStream.commit();
            } else {
              xmlStream.rollback();
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (node.name === this.tag) {
            this.reset();
            return true;
          }
          if (this.map[node.name]) {
            this.parser = this.map[node.name];
            this.parser.parseOpen(node);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
            return true;
          }
          return false;
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          if (this.map.tabColor.model || this.map.pageSetUpPr.model || this.map.outlinePr.model) {
            this.model = {};
            if (this.map.tabColor.model) {
              this.model.tabColor = this.map.tabColor.model;
            }
            if (this.map.pageSetUpPr.model) {
              this.model.pageSetup = this.map.pageSetUpPr.model;
            }
            if (this.map.outlinePr.model) {
              this.model.outlineProperties = this.map.outlinePr.model;
            }
          } else {
            this.model = null;
          }
          return false;
        } }, { key: "tag", get: function get() {
          return "sheetPr";
        } }]);
        return SheetPropertiesXform2;
      }(BaseXform);
      module2.exports = SheetPropertiesXform;
    }, { "../base-xform": 31, "../style/color-xform": 127, "./outline-properties-xform": 100, "./page-setup-properties-xform": 103 }], 111: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      function booleanToXml(model, value) {
        return model ? value : void 0;
      }
      function xmlToBoolean(value, equals2) {
        return value === equals2 ? true : void 0;
      }
      var SheetProtectionXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(SheetProtectionXform2, _BaseXform);
        var _super = _createSuper2(SheetProtectionXform2);
        function SheetProtectionXform2() {
          _classCallCheck2(this, SheetProtectionXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(SheetProtectionXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            var attributes = { sheet: booleanToXml(model.sheet, "1"), selectLockedCells: model.selectLockedCells === false ? "1" : void 0, selectUnlockedCells: model.selectUnlockedCells === false ? "1" : void 0, formatCells: booleanToXml(model.formatCells, "0"), formatColumns: booleanToXml(model.formatColumns, "0"), formatRows: booleanToXml(model.formatRows, "0"), insertColumns: booleanToXml(model.insertColumns, "0"), insertRows: booleanToXml(model.insertRows, "0"), insertHyperlinks: booleanToXml(model.insertHyperlinks, "0"), deleteColumns: booleanToXml(model.deleteColumns, "0"), deleteRows: booleanToXml(model.deleteRows, "0"), sort: booleanToXml(model.sort, "0"), autoFilter: booleanToXml(model.autoFilter, "0"), pivotTables: booleanToXml(model.pivotTables, "0") };
            if (model.sheet) {
              attributes.algorithmName = model.algorithmName;
              attributes.hashValue = model.hashValue;
              attributes.saltValue = model.saltValue;
              attributes.spinCount = model.spinCount;
              attributes.objects = booleanToXml(model.objects === false, "1");
              attributes.scenarios = booleanToXml(model.scenarios === false, "1");
            }
            if (_.some(attributes, function(value) {
              return value !== void 0;
            })) {
              xmlStream.leafNode(this.tag, attributes);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { sheet: xmlToBoolean(node.attributes.sheet, "1"), objects: node.attributes.objects === "1" ? false : void 0, scenarios: node.attributes.scenarios === "1" ? false : void 0, selectLockedCells: node.attributes.selectLockedCells === "1" ? false : void 0, selectUnlockedCells: node.attributes.selectUnlockedCells === "1" ? false : void 0, formatCells: xmlToBoolean(node.attributes.formatCells, "0"), formatColumns: xmlToBoolean(node.attributes.formatColumns, "0"), formatRows: xmlToBoolean(node.attributes.formatRows, "0"), insertColumns: xmlToBoolean(node.attributes.insertColumns, "0"), insertRows: xmlToBoolean(node.attributes.insertRows, "0"), insertHyperlinks: xmlToBoolean(node.attributes.insertHyperlinks, "0"), deleteColumns: xmlToBoolean(node.attributes.deleteColumns, "0"), deleteRows: xmlToBoolean(node.attributes.deleteRows, "0"), sort: xmlToBoolean(node.attributes.sort, "0"), autoFilter: xmlToBoolean(node.attributes.autoFilter, "0"), pivotTables: xmlToBoolean(node.attributes.pivotTables, "0") };
              if (node.attributes.algorithmName) {
                this.model.algorithmName = node.attributes.algorithmName;
                this.model.hashValue = node.attributes.hashValue;
                this.model.saltValue = node.attributes.saltValue;
                this.model.spinCount = parseInt(node.attributes.spinCount, 10);
              }
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "sheetProtection";
        } }]);
        return SheetProtectionXform2;
      }(BaseXform);
      module2.exports = SheetProtectionXform;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31 }], 112: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var colCache = require2("../../../utils/col-cache");
      var BaseXform = require2("../base-xform");
      var VIEW_STATES = { frozen: "frozen", frozenSplit: "frozen", split: "split" };
      var SheetViewXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(SheetViewXform2, _BaseXform);
        var _super = _createSuper2(SheetViewXform2);
        function SheetViewXform2() {
          _classCallCheck2(this, SheetViewXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(SheetViewXform2, [{ key: "prepare", value: function prepare(model) {
          switch (model.state) {
            case "frozen":
            case "split":
              break;
            default:
              model.state = "normal";
              break;
          }
        } }, { key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode("sheetView", { workbookViewId: model.workbookViewId || 0 });
          var add = function add2(name, value, included) {
            if (included) {
              xmlStream.addAttribute(name, value);
            }
          };
          add("rightToLeft", "1", model.rightToLeft === true);
          add("tabSelected", "1", model.tabSelected);
          add("showRuler", "0", model.showRuler === false);
          add("showRowColHeaders", "0", model.showRowColHeaders === false);
          add("showGridLines", "0", model.showGridLines === false);
          add("zoomScale", model.zoomScale, model.zoomScale);
          add("zoomScaleNormal", model.zoomScaleNormal, model.zoomScaleNormal);
          add("view", model.style, model.style);
          var topLeftCell;
          var xSplit;
          var ySplit;
          var activePane;
          switch (model.state) {
            case "frozen":
              xSplit = model.xSplit || 0;
              ySplit = model.ySplit || 0;
              topLeftCell = model.topLeftCell || colCache.getAddress(ySplit + 1, xSplit + 1).address;
              activePane = model.xSplit && model.ySplit && "bottomRight" || model.xSplit && "topRight" || "bottomLeft";
              xmlStream.leafNode("pane", { xSplit: model.xSplit || void 0, ySplit: model.ySplit || void 0, topLeftCell, activePane, state: "frozen" });
              xmlStream.leafNode("selection", { pane: activePane, activeCell: model.activeCell, sqref: model.activeCell });
              break;
            case "split":
              if (model.activePane === "topLeft") {
                model.activePane = void 0;
              }
              xmlStream.leafNode("pane", { xSplit: model.xSplit || void 0, ySplit: model.ySplit || void 0, topLeftCell: model.topLeftCell, activePane: model.activePane });
              xmlStream.leafNode("selection", { pane: model.activePane, activeCell: model.activeCell, sqref: model.activeCell });
              break;
            case "normal":
              if (model.activeCell) {
                xmlStream.leafNode("selection", { activeCell: model.activeCell, sqref: model.activeCell });
              }
              break;
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "sheetView":
              this.sheetView = { workbookViewId: parseInt(node.attributes.workbookViewId, 10), rightToLeft: node.attributes.rightToLeft === "1", tabSelected: node.attributes.tabSelected === "1", showRuler: !(node.attributes.showRuler === "0"), showRowColHeaders: !(node.attributes.showRowColHeaders === "0"), showGridLines: !(node.attributes.showGridLines === "0"), zoomScale: parseInt(node.attributes.zoomScale || "100", 10), zoomScaleNormal: parseInt(node.attributes.zoomScaleNormal || "100", 10), style: node.attributes.view };
              this.pane = void 0;
              this.selections = {};
              return true;
            case "pane":
              this.pane = { xSplit: parseInt(node.attributes.xSplit || "0", 10), ySplit: parseInt(node.attributes.ySplit || "0", 10), topLeftCell: node.attributes.topLeftCell, activePane: node.attributes.activePane || "topLeft", state: node.attributes.state };
              return true;
            case "selection": {
              var name = node.attributes.pane || "topLeft";
              this.selections[name] = { pane: name, activeCell: node.attributes.activeCell };
              return true;
            }
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          var model;
          var selection;
          switch (name) {
            case "sheetView":
              if (this.sheetView && this.pane) {
                model = this.model = {
                  workbookViewId: this.sheetView.workbookViewId,
                  rightToLeft: this.sheetView.rightToLeft,
                  state: VIEW_STATES[this.pane.state] || "split",
                  // split is default
                  xSplit: this.pane.xSplit,
                  ySplit: this.pane.ySplit,
                  topLeftCell: this.pane.topLeftCell,
                  showRuler: this.sheetView.showRuler,
                  showRowColHeaders: this.sheetView.showRowColHeaders,
                  showGridLines: this.sheetView.showGridLines,
                  zoomScale: this.sheetView.zoomScale,
                  zoomScaleNormal: this.sheetView.zoomScaleNormal
                };
                if (this.model.state === "split") {
                  model.activePane = this.pane.activePane;
                }
                selection = this.selections[this.pane.activePane];
                if (selection && selection.activeCell) {
                  model.activeCell = selection.activeCell;
                }
                if (this.sheetView.style) {
                  model.style = this.sheetView.style;
                }
              } else {
                model = this.model = { workbookViewId: this.sheetView.workbookViewId, rightToLeft: this.sheetView.rightToLeft, state: "normal", showRuler: this.sheetView.showRuler, showRowColHeaders: this.sheetView.showRowColHeaders, showGridLines: this.sheetView.showGridLines, zoomScale: this.sheetView.zoomScale, zoomScaleNormal: this.sheetView.zoomScaleNormal };
                selection = this.selections.topLeft;
                if (selection && selection.activeCell) {
                  model.activeCell = selection.activeCell;
                }
                if (this.sheetView.style) {
                  model.style = this.sheetView.style;
                }
              }
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile() {
        } }, { key: "tag", get: function get() {
          return "sheetView";
        } }]);
        return SheetViewXform2;
      }(BaseXform);
      module2.exports = SheetViewXform;
    }, { "../../../utils/col-cache": 19, "../base-xform": 31 }], 113: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var TablePartXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(TablePartXform2, _BaseXform);
        var _super = _createSuper2(TablePartXform2);
        function TablePartXform2() {
          _classCallCheck2(this, TablePartXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(TablePartXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            xmlStream.leafNode(this.tag, { "r:id": model.rId });
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case this.tag:
              this.model = { rId: node.attributes["r:id"] };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "tablePart";
        } }]);
        return TablePartXform2;
      }(BaseXform);
      module2.exports = TablePartXform;
    }, { "../base-xform": 31 }], 114: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var _ = require2("../../../utils/under-dash");
      var colCache = require2("../../../utils/col-cache");
      var XmlStream = require2("../../../utils/xml-stream");
      var RelType = require2("../../rel-type");
      var Merges2 = require2("./merges");
      var BaseXform = require2("../base-xform");
      var ListXform = require2("../list-xform");
      var RowXform = require2("./row-xform");
      var ColXform = require2("./col-xform");
      var DimensionXform = require2("./dimension-xform");
      var HyperlinkXform = require2("./hyperlink-xform");
      var MergeCellXform = require2("./merge-cell-xform");
      var DataValidationsXform = require2("./data-validations-xform");
      var SheetPropertiesXform = require2("./sheet-properties-xform");
      var SheetFormatPropertiesXform = require2("./sheet-format-properties-xform");
      var SheetViewXform = require2("./sheet-view-xform");
      var SheetProtectionXform = require2("./sheet-protection-xform");
      var PageMarginsXform = require2("./page-margins-xform");
      var PageSetupXform = require2("./page-setup-xform");
      var PrintOptionsXform = require2("./print-options-xform");
      var AutoFilterXform = require2("./auto-filter-xform");
      var PictureXform = require2("./picture-xform");
      var DrawingXform = require2("./drawing-xform");
      var TablePartXform = require2("./table-part-xform");
      var RowBreaksXform = require2("./row-breaks-xform");
      var HeaderFooterXform = require2("./header-footer-xform");
      var ConditionalFormattingsXform = require2("./cf/conditional-formattings-xform");
      var ExtListXform = require2("./ext-lst-xform");
      var mergeRule = function mergeRule2(rule, extRule) {
        Object.keys(extRule).forEach(function(key) {
          var value = rule[key];
          var extValue = extRule[key];
          if (value === void 0 && extValue !== void 0) {
            rule[key] = extValue;
          }
        });
      };
      var mergeConditionalFormattings = function mergeConditionalFormattings2(model, extModel) {
        if (!extModel || !extModel.length) {
          return model;
        }
        if (!model || !model.length) {
          return extModel;
        }
        var cfMap = {};
        var ruleMap = {};
        model.forEach(function(cf) {
          cfMap[cf.ref] = cf;
          cf.rules.forEach(function(rule) {
            var x14Id = rule.x14Id;
            if (x14Id) {
              ruleMap[x14Id] = rule;
            }
          });
        });
        extModel.forEach(function(extCf) {
          extCf.rules.forEach(function(extRule) {
            var rule = ruleMap[extRule.x14Id];
            if (rule) {
              mergeRule(rule, extRule);
            } else if (cfMap[extCf.ref]) {
              cfMap[extCf.ref].rules.push(extRule);
            } else {
              model.push({ ref: extCf.ref, rules: [extRule] });
            }
          });
        });
        return model;
      };
      var WorkSheetXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(WorkSheetXform2, _BaseXform);
        var _super = _createSuper2(WorkSheetXform2);
        function WorkSheetXform2(options) {
          var _this;
          _classCallCheck2(this, WorkSheetXform2);
          _this = _super.call(this);
          var _ref = options || {}, maxRows = _ref.maxRows, maxCols = _ref.maxCols;
          _this.map = { sheetPr: new SheetPropertiesXform(), dimension: new DimensionXform(), sheetViews: new ListXform({ tag: "sheetViews", count: false, childXform: new SheetViewXform() }), sheetFormatPr: new SheetFormatPropertiesXform(), cols: new ListXform({ tag: "cols", count: false, childXform: new ColXform() }), sheetData: new ListXform({ tag: "sheetData", count: false, empty: true, childXform: new RowXform({ maxItems: maxCols }), maxItems: maxRows }), autoFilter: new AutoFilterXform(), mergeCells: new ListXform({ tag: "mergeCells", count: true, childXform: new MergeCellXform() }), rowBreaks: new RowBreaksXform(), hyperlinks: new ListXform({ tag: "hyperlinks", count: false, childXform: new HyperlinkXform() }), pageMargins: new PageMarginsXform(), dataValidations: new DataValidationsXform(), pageSetup: new PageSetupXform(), headerFooter: new HeaderFooterXform(), printOptions: new PrintOptionsXform(), picture: new PictureXform(), drawing: new DrawingXform(), sheetProtection: new SheetProtectionXform(), tableParts: new ListXform({ tag: "tableParts", count: true, childXform: new TablePartXform() }), conditionalFormatting: new ConditionalFormattingsXform(), extLst: new ExtListXform() };
          return _this;
        }
        _createClass2(WorkSheetXform2, [{ key: "prepare", value: function prepare(model, options) {
          var _this2 = this;
          options.merges = new Merges2();
          model.hyperlinks = options.hyperlinks = [];
          model.comments = options.comments = [];
          options.formulae = {};
          options.siFormulae = 0;
          this.map.cols.prepare(model.cols, options);
          this.map.sheetData.prepare(model.rows, options);
          this.map.conditionalFormatting.prepare(model.conditionalFormattings, options);
          model.mergeCells = options.merges.mergeCells;
          var rels = model.rels = [];
          function nextRid(r) {
            return "rId".concat(r.length + 1);
          }
          model.hyperlinks.forEach(function(hyperlink) {
            var rId = nextRid(rels);
            hyperlink.rId = rId;
            rels.push({ Id: rId, Type: RelType.Hyperlink, Target: hyperlink.target, TargetMode: "External" });
          });
          if (model.comments.length > 0) {
            var comment = { Id: nextRid(rels), Type: RelType.Comments, Target: "../comments".concat(model.id, ".xml") };
            rels.push(comment);
            var vmlDrawing = { Id: nextRid(rels), Type: RelType.VmlDrawing, Target: "../drawings/vmlDrawing".concat(model.id, ".vml") };
            rels.push(vmlDrawing);
            model.comments.forEach(function(item) {
              item.refAddress = colCache.decodeAddress(item.ref);
            });
            options.commentRefs.push({ commentName: "comments".concat(model.id), vmlDrawing: "vmlDrawing".concat(model.id) });
          }
          var drawingRelsHash = [];
          var bookImage;
          model.media.forEach(function(medium) {
            if (medium.type === "background") {
              var rId = nextRid(rels);
              bookImage = options.media[medium.imageId];
              rels.push({ Id: rId, Type: RelType.Image, Target: "../media/".concat(bookImage.name, ".").concat(bookImage.extension) });
              model.background = { rId };
              model.image = options.media[medium.imageId];
            } else if (medium.type === "image") {
              var drawing = model.drawing;
              bookImage = options.media[medium.imageId];
              if (!drawing) {
                drawing = model.drawing = { rId: nextRid(rels), name: "drawing".concat(++options.drawingsCount), anchors: [], rels: [] };
                options.drawings.push(drawing);
                rels.push({ Id: drawing.rId, Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing", Target: "../drawings/".concat(drawing.name, ".xml") });
              }
              var rIdImage = _this2.preImageId === medium.imageId ? drawingRelsHash[medium.imageId] : drawingRelsHash[drawing.rels.length];
              if (!rIdImage) {
                rIdImage = nextRid(drawing.rels);
                drawingRelsHash[drawing.rels.length] = rIdImage;
                drawing.rels.push({ Id: rIdImage, Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image", Target: "../media/".concat(bookImage.name, ".").concat(bookImage.extension) });
              }
              var anchor = { picture: { rId: rIdImage }, range: medium.range };
              if (medium.hyperlinks && medium.hyperlinks.hyperlink) {
                var rIdHyperLink = nextRid(drawing.rels);
                drawingRelsHash[drawing.rels.length] = rIdHyperLink;
                anchor.picture.hyperlinks = { tooltip: medium.hyperlinks.tooltip, rId: rIdHyperLink };
                drawing.rels.push({ Id: rIdHyperLink, Type: RelType.Hyperlink, Target: medium.hyperlinks.hyperlink, TargetMode: "External" });
              }
              _this2.preImageId = medium.imageId;
              drawing.anchors.push(anchor);
            }
          });
          model.tables.forEach(function(table) {
            var rId = nextRid(rels);
            table.rId = rId;
            rels.push({ Id: rId, Type: RelType.Table, Target: "../tables/".concat(table.target) });
            table.columns.forEach(function(column) {
              var style = column.style;
              if (style) {
                column.dxfId = options.styles.addDxfStyle(style);
              }
            });
          });
          this.map.extLst.prepare(model, options);
        } }, { key: "render", value: function render15(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("worksheet", WorkSheetXform2.WORKSHEET_ATTRIBUTES);
          var sheetFormatPropertiesModel = model.properties ? { defaultRowHeight: model.properties.defaultRowHeight, dyDescent: model.properties.dyDescent, outlineLevelCol: model.properties.outlineLevelCol, outlineLevelRow: model.properties.outlineLevelRow } : void 0;
          if (model.properties && model.properties.defaultColWidth) {
            sheetFormatPropertiesModel.defaultColWidth = model.properties.defaultColWidth;
          }
          var sheetPropertiesModel = { outlineProperties: model.properties && model.properties.outlineProperties, tabColor: model.properties && model.properties.tabColor, pageSetup: model.pageSetup && model.pageSetup.fitToPage ? { fitToPage: model.pageSetup.fitToPage } : void 0 };
          var pageMarginsModel = model.pageSetup && model.pageSetup.margins;
          var printOptionsModel = { showRowColHeaders: model.pageSetup && model.pageSetup.showRowColHeaders, showGridLines: model.pageSetup && model.pageSetup.showGridLines, horizontalCentered: model.pageSetup && model.pageSetup.horizontalCentered, verticalCentered: model.pageSetup && model.pageSetup.verticalCentered };
          var sheetProtectionModel = model.sheetProtection;
          this.map.sheetPr.render(xmlStream, sheetPropertiesModel);
          this.map.dimension.render(xmlStream, model.dimensions);
          this.map.sheetViews.render(xmlStream, model.views);
          this.map.sheetFormatPr.render(xmlStream, sheetFormatPropertiesModel);
          this.map.cols.render(xmlStream, model.cols);
          this.map.sheetData.render(xmlStream, model.rows);
          this.map.sheetProtection.render(xmlStream, sheetProtectionModel);
          this.map.autoFilter.render(xmlStream, model.autoFilter);
          this.map.mergeCells.render(xmlStream, model.mergeCells);
          this.map.conditionalFormatting.render(xmlStream, model.conditionalFormattings);
          this.map.dataValidations.render(xmlStream, model.dataValidations);
          this.map.hyperlinks.render(xmlStream, model.hyperlinks);
          this.map.printOptions.render(xmlStream, printOptionsModel);
          this.map.pageMargins.render(xmlStream, pageMarginsModel);
          this.map.pageSetup.render(xmlStream, model.pageSetup);
          this.map.headerFooter.render(xmlStream, model.headerFooter);
          this.map.rowBreaks.render(xmlStream, model.rowBreaks);
          this.map.drawing.render(xmlStream, model.drawing);
          this.map.picture.render(xmlStream, model.background);
          this.map.tableParts.render(xmlStream, model.tables);
          this.map.extLst.render(xmlStream, model);
          if (model.rels) {
            model.rels.forEach(function(rel) {
              if (rel.Type === RelType.VmlDrawing) {
                xmlStream.leafNode("legacyDrawing", { "r:id": rel.Id });
              }
            });
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (node.name === "worksheet") {
            _.each(this.map, function(xform) {
              xform.reset();
            });
            return true;
          }
          this.parser = this.map[node.name];
          if (this.parser) {
            this.parser.parseOpen(node);
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "worksheet": {
              var properties = this.map.sheetFormatPr.model || {};
              if (this.map.sheetPr.model && this.map.sheetPr.model.tabColor) {
                properties.tabColor = this.map.sheetPr.model.tabColor;
              }
              if (this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties) {
                properties.outlineProperties = this.map.sheetPr.model.outlineProperties;
              }
              var sheetProperties = { fitToPage: this.map.sheetPr.model && this.map.sheetPr.model.pageSetup && this.map.sheetPr.model.pageSetup.fitToPage || false, margins: this.map.pageMargins.model };
              var pageSetup = Object.assign(sheetProperties, this.map.pageSetup.model, this.map.printOptions.model);
              var conditionalFormattings = mergeConditionalFormattings(this.map.conditionalFormatting.model, this.map.extLst.model && this.map.extLst.model["x14:conditionalFormattings"]);
              this.model = { dimensions: this.map.dimension.model, cols: this.map.cols.model, rows: this.map.sheetData.model, mergeCells: this.map.mergeCells.model, hyperlinks: this.map.hyperlinks.model, dataValidations: this.map.dataValidations.model, properties, views: this.map.sheetViews.model, pageSetup, headerFooter: this.map.headerFooter.model, background: this.map.picture.model, drawing: this.map.drawing.model, tables: this.map.tableParts.model, conditionalFormattings };
              if (this.map.autoFilter.model) {
                this.model.autoFilter = this.map.autoFilter.model;
              }
              if (this.map.sheetProtection.model) {
                this.model.sheetProtection = this.map.sheetProtection.model;
              }
              return false;
            }
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          var rels = (model.relationships || []).reduce(function(h3, rel) {
            h3[rel.Id] = rel;
            if (rel.Type === RelType.Comments) {
              model.comments = options.comments[rel.Target].comments;
            }
            if (rel.Type === RelType.VmlDrawing && model.comments && model.comments.length) {
              var vmlComment = options.vmlDrawings[rel.Target].comments;
              model.comments.forEach(function(comment, index2) {
                comment.note = Object.assign({}, comment.note, vmlComment[index2]);
              });
            }
            return h3;
          }, {});
          options.commentsMap = (model.comments || []).reduce(function(h3, comment) {
            if (comment.ref) {
              h3[comment.ref] = comment;
            }
            return h3;
          }, {});
          options.hyperlinkMap = (model.hyperlinks || []).reduce(function(h3, hyperlink) {
            if (hyperlink.rId) {
              h3[hyperlink.address] = rels[hyperlink.rId].Target;
            }
            return h3;
          }, {});
          options.formulae = {};
          model.rows = model.rows && model.rows.filter(Boolean) || [];
          model.rows.forEach(function(row) {
            row.cells = row.cells && row.cells.filter(Boolean) || [];
          });
          this.map.cols.reconcile(model.cols, options);
          this.map.sheetData.reconcile(model.rows, options);
          this.map.conditionalFormatting.reconcile(model.conditionalFormattings, options);
          model.media = [];
          if (model.drawing) {
            var drawingRel = rels[model.drawing.rId];
            var match = drawingRel.Target.match(/\/drawings\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);
            if (match) {
              var drawingName = match[1];
              var drawing = options.drawings[drawingName];
              drawing.anchors.forEach(function(anchor) {
                if (anchor.medium) {
                  var image = { type: "image", imageId: anchor.medium.index, range: anchor.range, hyperlinks: anchor.picture.hyperlinks };
                  model.media.push(image);
                }
              });
            }
          }
          var backgroundRel = model.background && rels[model.background.rId];
          if (backgroundRel) {
            var target = backgroundRel.Target.split("/media/")[1];
            var imageId = options.mediaIndex && options.mediaIndex[target];
            if (imageId !== void 0) {
              model.media.push({ type: "background", imageId });
            }
          }
          model.tables = (model.tables || []).map(function(tablePart) {
            var rel = rels[tablePart.rId];
            return options.tables[rel.Target];
          });
          delete model.relationships;
          delete model.hyperlinks;
          delete model.comments;
        } }]);
        return WorkSheetXform2;
      }(BaseXform);
      WorkSheetXform.WORKSHEET_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x14ac", "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" };
      module2.exports = WorkSheetXform;
    }, { "../../../utils/col-cache": 19, "../../../utils/under-dash": 25, "../../../utils/xml-stream": 27, "../../rel-type": 30, "../base-xform": 31, "../list-xform": 70, "./auto-filter-xform": 71, "./cf/conditional-formattings-xform": 86, "./col-xform": 91, "./data-validations-xform": 92, "./dimension-xform": 93, "./drawing-xform": 94, "./ext-lst-xform": 95, "./header-footer-xform": 96, "./hyperlink-xform": 97, "./merge-cell-xform": 98, "./merges": 99, "./page-margins-xform": 102, "./page-setup-xform": 104, "./picture-xform": 105, "./print-options-xform": 106, "./row-breaks-xform": 107, "./row-xform": 108, "./sheet-format-properties-xform": 109, "./sheet-properties-xform": 110, "./sheet-protection-xform": 111, "./sheet-view-xform": 112, "./table-part-xform": 113 }], 115: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var BooleanXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(BooleanXform2, _BaseXform);
        var _super = _createSuper2(BooleanXform2);
        function BooleanXform2(options) {
          var _this;
          _classCallCheck2(this, BooleanXform2);
          _this = _super.call(this);
          _this.tag = options.tag;
          _this.attr = options.attr;
          return _this;
        }
        _createClass2(BooleanXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            xmlStream.openNode(this.tag);
            xmlStream.closeNode();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            this.model = true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }]);
        return BooleanXform2;
      }(BaseXform);
      module2.exports = BooleanXform;
    }, { "../base-xform": 31 }], 116: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var DateXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(DateXform2, _BaseXform);
        var _super = _createSuper2(DateXform2);
        function DateXform2(options) {
          var _this;
          _classCallCheck2(this, DateXform2);
          _this = _super.call(this);
          _this.tag = options.tag;
          _this.attr = options.attr;
          _this.attrs = options.attrs;
          _this._format = options.format || function(dt) {
            try {
              if (Number.isNaN(dt.getTime()))
                return "";
              return dt.toISOString();
            } catch (e) {
              return "";
            }
          };
          _this._parse = options.parse || function(str) {
            return new Date(str);
          };
          return _this;
        }
        _createClass2(DateXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            xmlStream.openNode(this.tag);
            if (this.attrs) {
              xmlStream.addAttributes(this.attrs);
            }
            if (this.attr) {
              xmlStream.addAttribute(this.attr, this._format(model));
            } else {
              xmlStream.writeText(this._format(model));
            }
            xmlStream.closeNode();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            if (this.attr) {
              this.model = this._parse(node.attributes[this.attr]);
            } else {
              this.text = [];
            }
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (!this.attr) {
            this.text.push(text);
          }
        } }, { key: "parseClose", value: function parseClose() {
          if (!this.attr) {
            this.model = this._parse(this.text.join(""));
          }
          return false;
        } }]);
        return DateXform2;
      }(BaseXform);
      module2.exports = DateXform;
    }, { "../base-xform": 31 }], 117: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var IntegerXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(IntegerXform2, _BaseXform);
        var _super = _createSuper2(IntegerXform2);
        function IntegerXform2(options) {
          var _this;
          _classCallCheck2(this, IntegerXform2);
          _this = _super.call(this);
          _this.tag = options.tag;
          _this.attr = options.attr;
          _this.attrs = options.attrs;
          _this.zero = options.zero;
          return _this;
        }
        _createClass2(IntegerXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model || this.zero) {
            xmlStream.openNode(this.tag);
            if (this.attrs) {
              xmlStream.addAttributes(this.attrs);
            }
            if (this.attr) {
              xmlStream.addAttribute(this.attr, model);
            } else {
              xmlStream.writeText(model);
            }
            xmlStream.closeNode();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            if (this.attr) {
              this.model = parseInt(node.attributes[this.attr], 10);
            } else {
              this.text = [];
            }
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (!this.attr) {
            this.text.push(text);
          }
        } }, { key: "parseClose", value: function parseClose() {
          if (!this.attr) {
            this.model = parseInt(this.text.join("") || 0, 10);
          }
          return false;
        } }]);
        return IntegerXform2;
      }(BaseXform);
      module2.exports = IntegerXform;
    }, { "../base-xform": 31 }], 118: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var StringXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(StringXform2, _BaseXform);
        var _super = _createSuper2(StringXform2);
        function StringXform2(options) {
          var _this;
          _classCallCheck2(this, StringXform2);
          _this = _super.call(this);
          _this.tag = options.tag;
          _this.attr = options.attr;
          _this.attrs = options.attrs;
          return _this;
        }
        _createClass2(StringXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model !== void 0) {
            xmlStream.openNode(this.tag);
            if (this.attrs) {
              xmlStream.addAttributes(this.attrs);
            }
            if (this.attr) {
              xmlStream.addAttribute(this.attr, model);
            } else {
              xmlStream.writeText(model);
            }
            xmlStream.closeNode();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            if (this.attr) {
              this.model = node.attributes[this.attr];
            } else {
              this.text = [];
            }
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (!this.attr) {
            this.text.push(text);
          }
        } }, { key: "parseClose", value: function parseClose() {
          if (!this.attr) {
            this.model = this.text.join("");
          }
          return false;
        } }]);
        return StringXform2;
      }(BaseXform);
      module2.exports = StringXform;
    }, { "../base-xform": 31 }], 119: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("./base-xform");
      var XmlStream = require2("../../utils/xml-stream");
      function build(xmlStream, model) {
        xmlStream.openNode(model.tag, model.$);
        if (model.c) {
          model.c.forEach(function(child) {
            build(xmlStream, child);
          });
        }
        if (model.t) {
          xmlStream.writeText(model.t);
        }
        xmlStream.closeNode();
      }
      var StaticXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(StaticXform2, _BaseXform);
        var _super = _createSuper2(StaticXform2);
        function StaticXform2(model) {
          var _this;
          _classCallCheck2(this, StaticXform2);
          _this = _super.call(this);
          _this._model = model;
          return _this;
        }
        _createClass2(StaticXform2, [{ key: "render", value: function render15(xmlStream) {
          if (!this._xml) {
            var stream = new XmlStream();
            build(stream, this._model);
            this._xml = stream.xml;
          }
          xmlStream.writeXml(this._xml);
        } }, { key: "parseOpen", value: function parseOpen() {
          return true;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case this._model.tag:
              return false;
            default:
              return true;
          }
        } }]);
        return StaticXform2;
      }(BaseXform);
      module2.exports = StaticXform;
    }, { "../../utils/xml-stream": 27, "./base-xform": 31 }], 120: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var TextXform = require2("./text-xform");
      var RichTextXform = require2("./rich-text-xform");
      var BaseXform = require2("../base-xform");
      var PhoneticTextXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(PhoneticTextXform2, _BaseXform);
        var _super = _createSuper2(PhoneticTextXform2);
        function PhoneticTextXform2() {
          var _this;
          _classCallCheck2(this, PhoneticTextXform2);
          _this = _super.call(this);
          _this.map = { r: new RichTextXform(), t: new TextXform() };
          return _this;
        }
        _createClass2(PhoneticTextXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode(this.tag, { sb: model.sb || 0, eb: model.eb || 0 });
          if (model && model.hasOwnProperty("richText") && model.richText) {
            var r = this.map.r;
            model.richText.forEach(function(text) {
              r.render(xmlStream, text);
            });
          } else if (model) {
            this.map.t.render(xmlStream, model.text);
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          var name = node.name;
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (name === this.tag) {
            this.model = { sb: parseInt(node.attributes.sb, 10), eb: parseInt(node.attributes.eb, 10) };
            return true;
          }
          this.parser = this.map[name];
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              switch (name) {
                case "r": {
                  var rt = this.model.richText;
                  if (!rt) {
                    rt = this.model.richText = [];
                  }
                  rt.push(this.parser.model);
                  break;
                }
                case "t":
                  this.model.text = this.parser.model;
                  break;
              }
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "rPh";
        } }]);
        return PhoneticTextXform2;
      }(BaseXform);
      module2.exports = PhoneticTextXform;
    }, { "../base-xform": 31, "./rich-text-xform": 121, "./text-xform": 124 }], 121: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var TextXform = require2("./text-xform");
      var FontXform = require2("../style/font-xform");
      var BaseXform = require2("../base-xform");
      var RichTextXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(RichTextXform2, _BaseXform);
        var _super = _createSuper2(RichTextXform2);
        function RichTextXform2(model) {
          var _this;
          _classCallCheck2(this, RichTextXform2);
          _this = _super.call(this);
          _this.model = model;
          return _this;
        }
        _createClass2(RichTextXform2, [{ key: "render", value: function render15(xmlStream, model) {
          model = model || this.model;
          xmlStream.openNode("r");
          if (model.font) {
            this.fontXform.render(xmlStream, model.font);
          }
          this.textXform.render(xmlStream, model.text);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "r":
              this.model = {};
              return true;
            case "t":
              this.parser = this.textXform;
              this.parser.parseOpen(node);
              return true;
            case "rPr":
              this.parser = this.fontXform;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          switch (name) {
            case "r":
              return false;
            case "t":
              this.model.text = this.parser.model;
              this.parser = void 0;
              return true;
            case "rPr":
              this.model.font = this.parser.model;
              this.parser = void 0;
              return true;
            default:
              if (this.parser) {
                this.parser.parseClose(name);
              }
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "r";
        } }, { key: "textXform", get: function get() {
          return this._textXform || (this._textXform = new TextXform());
        } }, { key: "fontXform", get: function get() {
          return this._fontXform || (this._fontXform = new FontXform(RichTextXform2.FONT_OPTIONS));
        } }]);
        return RichTextXform2;
      }(BaseXform);
      RichTextXform.FONT_OPTIONS = { tagName: "rPr", fontNameTag: "rFont" };
      module2.exports = RichTextXform;
    }, { "../base-xform": 31, "../style/font-xform": 130, "./text-xform": 124 }], 122: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var TextXform = require2("./text-xform");
      var RichTextXform = require2("./rich-text-xform");
      var PhoneticTextXform = require2("./phonetic-text-xform");
      var BaseXform = require2("../base-xform");
      var SharedStringXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(SharedStringXform2, _BaseXform);
        var _super = _createSuper2(SharedStringXform2);
        function SharedStringXform2(model) {
          var _this;
          _classCallCheck2(this, SharedStringXform2);
          _this = _super.call(this);
          _this.model = model;
          _this.map = { r: new RichTextXform(), t: new TextXform(), rPh: new PhoneticTextXform() };
          return _this;
        }
        _createClass2(SharedStringXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var _this2 = this;
          xmlStream.openNode(this.tag);
          if (model && model.hasOwnProperty("richText") && model.richText) {
            if (model.richText.length) {
              model.richText.forEach(function(text) {
                _this2.map.r.render(xmlStream, text);
              });
            } else {
              this.map.t.render(xmlStream, "");
            }
          } else if (model !== void 0 && model !== null) {
            this.map.t.render(xmlStream, model);
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          var name = node.name;
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (name === this.tag) {
            this.model = {};
            return true;
          }
          this.parser = this.map[name];
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              switch (name) {
                case "r": {
                  var rt = this.model.richText;
                  if (!rt) {
                    rt = this.model.richText = [];
                  }
                  rt.push(this.parser.model);
                  break;
                }
                case "t":
                  this.model = this.parser.model;
                  break;
              }
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return "si";
        } }]);
        return SharedStringXform2;
      }(BaseXform);
      module2.exports = SharedStringXform;
    }, { "../base-xform": 31, "./phonetic-text-xform": 120, "./rich-text-xform": 121, "./text-xform": 124 }], 123: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var SharedStringXform = require2("./shared-string-xform");
      var SharedStringsXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(SharedStringsXform2, _BaseXform);
        var _super = _createSuper2(SharedStringsXform2);
        function SharedStringsXform2(model) {
          var _this;
          _classCallCheck2(this, SharedStringsXform2);
          _this = _super.call(this);
          _this.model = model || { values: [], count: 0 };
          _this.hash = /* @__PURE__ */ Object.create(null);
          _this.rich = /* @__PURE__ */ Object.create(null);
          return _this;
        }
        _createClass2(SharedStringsXform2, [{ key: "getString", value: function getString(index2) {
          return this.model.values[index2];
        } }, { key: "add", value: function add(value) {
          return value.richText ? this.addRichText(value) : this.addText(value);
        } }, { key: "addText", value: function addText(value) {
          var index2 = this.hash[value];
          if (index2 === void 0) {
            index2 = this.hash[value] = this.model.values.length;
            this.model.values.push(value);
          }
          this.model.count++;
          return index2;
        } }, {
          key: "addRichText",
          value: function addRichText(value) {
            var xml = this.sharedStringXform.toXml(value);
            var index2 = this.rich[xml];
            if (index2 === void 0) {
              index2 = this.rich[xml] = this.model.values.length;
              this.model.values.push(value);
            }
            this.model.count++;
            return index2;
          }
          // <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
          // <sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="<%=totalRefs%>" uniqueCount="<%=count%>">
          //   <si><t><%=text%></t></si>
          //   <si><r><rPr></rPr><t></t></r></si>
          // </sst>
        }, { key: "render", value: function render15(xmlStream, model) {
          model = model || this._values;
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("sst", { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", count: model.count, uniqueCount: model.values.length });
          var sx = this.sharedStringXform;
          model.values.forEach(function(sharedString) {
            sx.render(xmlStream, sharedString);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "sst":
              return true;
            case "si":
              this.parser = this.sharedStringXform;
              this.parser.parseOpen(node);
              return true;
            default:
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(node)));
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.values.push(this.parser.model);
              this.model.count++;
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case "sst":
              return false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(name));
          }
        } }, { key: "sharedStringXform", get: function get() {
          return this._sharedStringXform || (this._sharedStringXform = new SharedStringXform());
        } }, { key: "values", get: function get() {
          return this.model.values;
        } }, { key: "uniqueCount", get: function get() {
          return this.model.values.length;
        } }, { key: "count", get: function get() {
          return this.model.count;
        } }]);
        return SharedStringsXform2;
      }(BaseXform);
      module2.exports = SharedStringsXform;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "./shared-string-xform": 122 }], 124: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var TextXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(TextXform2, _BaseXform);
        var _super = _createSuper2(TextXform2);
        function TextXform2() {
          _classCallCheck2(this, TextXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(TextXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode("t");
          if (/^\s|\n|\s$/.test(model)) {
            xmlStream.addAttribute("xml:space", "preserve");
          }
          xmlStream.writeText(model);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "t":
              this._text = [];
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          this._text.push(text);
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "t";
        } }, { key: "model", get: function get() {
          return this._text.join("").replace(/_x([0-9A-F]{4})_/g, function($0, $1) {
            return String.fromCharCode(parseInt($1, 16));
          });
        } }]);
        return TextXform2;
      }(BaseXform);
      module2.exports = TextXform;
    }, { "../base-xform": 31 }], 125: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var Enums = require2("../../../doc/enums");
      var utils = require2("../../../utils/utils");
      var BaseXform = require2("../base-xform");
      var validation = { horizontalValues: ["left", "center", "right", "fill", "centerContinuous", "distributed", "justify"].reduce(function(p, v) {
        p[v] = true;
        return p;
      }, {}), horizontal: function horizontal(value) {
        return this.horizontalValues[value] ? value : void 0;
      }, verticalValues: ["top", "middle", "bottom", "distributed", "justify"].reduce(function(p, v) {
        p[v] = true;
        return p;
      }, {}), vertical: function vertical(value) {
        if (value === "middle")
          return "center";
        return this.verticalValues[value] ? value : void 0;
      }, wrapText: function wrapText(value) {
        return value ? true : void 0;
      }, shrinkToFit: function shrinkToFit(value) {
        return value ? true : void 0;
      }, textRotation: function textRotation(value) {
        switch (value) {
          case "vertical":
            return value;
          default:
            value = utils.validInt(value);
            return value >= -90 && value <= 90 ? value : void 0;
        }
      }, indent: function indent(value) {
        value = utils.validInt(value);
        return Math.max(0, value);
      }, readingOrder: function readingOrder(value) {
        switch (value) {
          case "ltr":
            return Enums.ReadingOrder.LeftToRight;
          case "rtl":
            return Enums.ReadingOrder.RightToLeft;
          default:
            return void 0;
        }
      } };
      var textRotationXform = { toXml: function toXml(textRotation) {
        textRotation = validation.textRotation(textRotation);
        if (textRotation) {
          if (textRotation === "vertical") {
            return 255;
          }
          var tr = Math.round(textRotation);
          if (tr >= 0 && tr <= 90) {
            return tr;
          }
          if (tr < 0 && tr >= -90) {
            return 90 - tr;
          }
        }
        return void 0;
      }, toModel: function toModel(textRotation) {
        var tr = utils.validInt(textRotation);
        if (tr !== void 0) {
          if (tr === 255) {
            return "vertical";
          }
          if (tr >= 0 && tr <= 90) {
            return tr;
          }
          if (tr > 90 && tr <= 180) {
            return 90 - tr;
          }
        }
        return void 0;
      } };
      var AlignmentXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(AlignmentXform2, _BaseXform);
        var _super = _createSuper2(AlignmentXform2);
        function AlignmentXform2() {
          _classCallCheck2(this, AlignmentXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(AlignmentXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.addRollback();
          xmlStream.openNode("alignment");
          var isValid2 = false;
          function add(name, value) {
            if (value) {
              xmlStream.addAttribute(name, value);
              isValid2 = true;
            }
          }
          add("horizontal", validation.horizontal(model.horizontal));
          add("vertical", validation.vertical(model.vertical));
          add("wrapText", validation.wrapText(model.wrapText) ? "1" : false);
          add("shrinkToFit", validation.shrinkToFit(model.shrinkToFit) ? "1" : false);
          add("indent", validation.indent(model.indent));
          add("textRotation", textRotationXform.toXml(model.textRotation));
          add("readingOrder", validation.readingOrder(model.readingOrder));
          xmlStream.closeNode();
          if (isValid2) {
            xmlStream.commit();
          } else {
            xmlStream.rollback();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          var model = {};
          var valid = false;
          function add(truthy, name, value) {
            if (truthy) {
              model[name] = value;
              valid = true;
            }
          }
          add(node.attributes.horizontal, "horizontal", node.attributes.horizontal);
          add(node.attributes.vertical, "vertical", node.attributes.vertical === "center" ? "middle" : node.attributes.vertical);
          add(node.attributes.wrapText, "wrapText", !!node.attributes.wrapText);
          add(node.attributes.shrinkToFit, "shrinkToFit", !!node.attributes.shrinkToFit);
          add(node.attributes.indent, "indent", parseInt(node.attributes.indent, 10));
          add(node.attributes.textRotation, "textRotation", textRotationXform.toModel(node.attributes.textRotation));
          add(node.attributes.readingOrder, "readingOrder", node.attributes.readingOrder === "2" ? "rtl" : "ltr");
          this.model = valid ? model : null;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "alignment";
        } }]);
        return AlignmentXform2;
      }(BaseXform);
      module2.exports = AlignmentXform;
    }, { "../../../doc/enums": 7, "../../../utils/utils": 26, "../base-xform": 31 }], 126: [function(require2, module2, exports2) {
      function ownKeys2(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys2(Object(source), true).forEach(function(key) {
              _defineProperty2(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys2(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var ColorXform = require2("./color-xform");
      var EdgeXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(EdgeXform2, _BaseXform);
        var _super = _createSuper2(EdgeXform2);
        function EdgeXform2(name) {
          var _this;
          _classCallCheck2(this, EdgeXform2);
          _this = _super.call(this);
          _this.name = name;
          _this.map = { color: new ColorXform() };
          return _this;
        }
        _createClass2(EdgeXform2, [{ key: "render", value: function render15(xmlStream, model, defaultColor) {
          var color = model && model.color || defaultColor || this.defaultColor;
          xmlStream.openNode(this.name);
          if (model && model.style) {
            xmlStream.addAttribute("style", model.style);
            if (color) {
              this.map.color.render(xmlStream, color);
            }
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.name: {
              var style = node.attributes.style;
              if (style) {
                this.model = { style };
              } else {
                this.model = void 0;
              }
              return true;
            }
            case "color":
              this.parser = this.map.color;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          if (name === this.name) {
            if (this.map.color.model) {
              if (!this.model) {
                this.model = {};
              }
              this.model.color = this.map.color.model;
            }
          }
          return false;
        } }, { key: "validStyle", value: function validStyle(value) {
          return EdgeXform2.validStyleValues[value];
        } }, { key: "tag", get: function get() {
          return this.name;
        } }]);
        return EdgeXform2;
      }(BaseXform);
      EdgeXform.validStyleValues = ["thin", "dotted", "dashDot", "hair", "dashDotDot", "slantDashDot", "mediumDashed", "mediumDashDotDot", "mediumDashDot", "medium", "double", "thick"].reduce(function(p, v) {
        p[v] = true;
        return p;
      }, {});
      var BorderXform = /* @__PURE__ */ function(_BaseXform2) {
        _inherits2(BorderXform2, _BaseXform2);
        var _super2 = _createSuper2(BorderXform2);
        function BorderXform2() {
          var _this2;
          _classCallCheck2(this, BorderXform2);
          _this2 = _super2.call(this);
          _this2.map = { top: new EdgeXform("top"), left: new EdgeXform("left"), bottom: new EdgeXform("bottom"), right: new EdgeXform("right"), diagonal: new EdgeXform("diagonal") };
          return _this2;
        }
        _createClass2(BorderXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var color = model.color;
          xmlStream.openNode("border");
          if (model.diagonal && model.diagonal.style) {
            if (model.diagonal.up) {
              xmlStream.addAttribute("diagonalUp", "1");
            }
            if (model.diagonal.down) {
              xmlStream.addAttribute("diagonalDown", "1");
            }
          }
          function add(edgeModel, edgeXform) {
            if (edgeModel && !edgeModel.color && model.color) {
              edgeModel = _objectSpread2(_objectSpread2({}, edgeModel), {}, { color: model.color });
            }
            edgeXform.render(xmlStream, edgeModel, color);
          }
          add(model.left, this.map.left);
          add(model.right, this.map.right);
          add(model.top, this.map.top);
          add(model.bottom, this.map.bottom);
          add(model.diagonal, this.map.diagonal);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "border":
              this.reset();
              this.diagonalUp = !!node.attributes.diagonalUp;
              this.diagonalDown = !!node.attributes.diagonalDown;
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          if (name === "border") {
            var model = this.model = {};
            var add = function add2(key, edgeModel, extensions) {
              if (edgeModel) {
                if (extensions) {
                  Object.assign(edgeModel, extensions);
                }
                model[key] = edgeModel;
              }
            };
            add("left", this.map.left.model);
            add("right", this.map.right.model);
            add("top", this.map.top.model);
            add("bottom", this.map.bottom.model);
            add("diagonal", this.map.diagonal.model, { up: this.diagonalUp, down: this.diagonalDown });
          }
          return false;
        } }]);
        return BorderXform2;
      }(BaseXform);
      module2.exports = BorderXform;
    }, { "../base-xform": 31, "./color-xform": 127 }], 127: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var ColorXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(ColorXform2, _BaseXform);
        var _super = _createSuper2(ColorXform2);
        function ColorXform2(name) {
          var _this;
          _classCallCheck2(this, ColorXform2);
          _this = _super.call(this);
          _this.name = name || "color";
          return _this;
        }
        _createClass2(ColorXform2, [{ key: "render", value: function render15(xmlStream, model) {
          if (model) {
            xmlStream.openNode(this.name);
            if (model.argb) {
              xmlStream.addAttribute("rgb", model.argb);
            } else if (model.theme !== void 0) {
              xmlStream.addAttribute("theme", model.theme);
              if (model.tint !== void 0) {
                xmlStream.addAttribute("tint", model.tint);
              }
            } else if (model.indexed !== void 0) {
              xmlStream.addAttribute("indexed", model.indexed);
            } else {
              xmlStream.addAttribute("auto", "1");
            }
            xmlStream.closeNode();
            return true;
          }
          return false;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.name) {
            if (node.attributes.rgb) {
              this.model = { argb: node.attributes.rgb };
            } else if (node.attributes.theme) {
              this.model = { theme: parseInt(node.attributes.theme, 10) };
              if (node.attributes.tint) {
                this.model.tint = parseFloat(node.attributes.tint);
              }
            } else if (node.attributes.indexed) {
              this.model = { indexed: parseInt(node.attributes.indexed, 10) };
            } else {
              this.model = void 0;
            }
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return this.name;
        } }]);
        return ColorXform2;
      }(BaseXform);
      module2.exports = ColorXform;
    }, { "../base-xform": 31 }], 128: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var AlignmentXform = require2("./alignment-xform");
      var BorderXform = require2("./border-xform");
      var FillXform = require2("./fill-xform");
      var FontXform = require2("./font-xform");
      var NumFmtXform = require2("./numfmt-xform");
      var ProtectionXform = require2("./protection-xform");
      var DxfXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(DxfXform2, _BaseXform);
        var _super = _createSuper2(DxfXform2);
        function DxfXform2() {
          var _this;
          _classCallCheck2(this, DxfXform2);
          _this = _super.call(this);
          _this.map = { alignment: new AlignmentXform(), border: new BorderXform(), fill: new FillXform(), font: new FontXform(), numFmt: new NumFmtXform(), protection: new ProtectionXform() };
          return _this;
        }
        _createClass2(DxfXform2, [{
          key: "render",
          // how do we generate dxfid?
          value: function render15(xmlStream, model) {
            xmlStream.openNode(this.tag);
            if (model.font) {
              this.map.font.render(xmlStream, model.font);
            }
            if (model.numFmt) {
              this.map.numFmt.render(xmlStream, model.numFmt);
            }
            if (model.fill) {
              this.map.fill.render(xmlStream, model.fill);
            }
            if (model.alignment) {
              this.map.alignment.render(xmlStream, model.alignment);
            }
            if (model.border) {
              this.map.border.render(xmlStream, model.border);
            }
            if (model.protection) {
              this.map.protection.render(xmlStream, model.protection);
            }
            xmlStream.closeNode();
          }
        }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.reset();
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              return true;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          if (name === this.tag) {
            this.model = { alignment: this.map.alignment.model, border: this.map.border.model, fill: this.map.fill.model, font: this.map.font.model, numFmt: this.map.numFmt.model, protection: this.map.protection.model };
            return false;
          }
          return true;
        } }, { key: "tag", get: function get() {
          return "dxf";
        } }]);
        return DxfXform2;
      }(BaseXform);
      module2.exports = DxfXform;
    }, { "../base-xform": 31, "./alignment-xform": 125, "./border-xform": 126, "./fill-xform": 129, "./font-xform": 130, "./numfmt-xform": 131, "./protection-xform": 132 }], 129: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var ColorXform = require2("./color-xform");
      var StopXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(StopXform2, _BaseXform);
        var _super = _createSuper2(StopXform2);
        function StopXform2() {
          var _this;
          _classCallCheck2(this, StopXform2);
          _this = _super.call(this);
          _this.map = { color: new ColorXform() };
          return _this;
        }
        _createClass2(StopXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode("stop");
          xmlStream.addAttribute("position", model.position);
          this.map.color.render(xmlStream, model.color);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "stop":
              this.model = { position: parseFloat(node.attributes.position) };
              return true;
            case "color":
              this.parser = this.map.color;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.color = this.parser.model;
              this.parser = void 0;
            }
            return true;
          }
          return false;
        } }, { key: "tag", get: function get() {
          return "stop";
        } }]);
        return StopXform2;
      }(BaseXform);
      var PatternFillXform = /* @__PURE__ */ function(_BaseXform2) {
        _inherits2(PatternFillXform2, _BaseXform2);
        var _super2 = _createSuper2(PatternFillXform2);
        function PatternFillXform2() {
          var _this2;
          _classCallCheck2(this, PatternFillXform2);
          _this2 = _super2.call(this);
          _this2.map = { fgColor: new ColorXform("fgColor"), bgColor: new ColorXform("bgColor") };
          return _this2;
        }
        _createClass2(PatternFillXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode("patternFill");
          xmlStream.addAttribute("patternType", model.pattern);
          if (model.fgColor) {
            this.map.fgColor.render(xmlStream, model.fgColor);
          }
          if (model.bgColor) {
            this.map.bgColor.render(xmlStream, model.bgColor);
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "patternFill":
              this.model = { type: "pattern", pattern: node.attributes.patternType };
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              if (this.parser.model) {
                this.model[name] = this.parser.model;
              }
              this.parser = void 0;
            }
            return true;
          }
          return false;
        } }, { key: "name", get: function get() {
          return "pattern";
        } }, { key: "tag", get: function get() {
          return "patternFill";
        } }]);
        return PatternFillXform2;
      }(BaseXform);
      var GradientFillXform = /* @__PURE__ */ function(_BaseXform3) {
        _inherits2(GradientFillXform2, _BaseXform3);
        var _super3 = _createSuper2(GradientFillXform2);
        function GradientFillXform2() {
          var _this3;
          _classCallCheck2(this, GradientFillXform2);
          _this3 = _super3.call(this);
          _this3.map = { stop: new StopXform() };
          return _this3;
        }
        _createClass2(GradientFillXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode("gradientFill");
          switch (model.gradient) {
            case "angle":
              xmlStream.addAttribute("degree", model.degree);
              break;
            case "path":
              xmlStream.addAttribute("type", "path");
              if (model.center.left) {
                xmlStream.addAttribute("left", model.center.left);
                if (model.center.right === void 0) {
                  xmlStream.addAttribute("right", model.center.left);
                }
              }
              if (model.center.right) {
                xmlStream.addAttribute("right", model.center.right);
              }
              if (model.center.top) {
                xmlStream.addAttribute("top", model.center.top);
                if (model.center.bottom === void 0) {
                  xmlStream.addAttribute("bottom", model.center.top);
                }
              }
              if (model.center.bottom) {
                xmlStream.addAttribute("bottom", model.center.bottom);
              }
              break;
          }
          var stopXform = this.map.stop;
          model.stops.forEach(function(stopModel) {
            stopXform.render(xmlStream, stopModel);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "gradientFill": {
              var model = this.model = { stops: [] };
              if (node.attributes.degree) {
                model.gradient = "angle";
                model.degree = parseInt(node.attributes.degree, 10);
              } else if (node.attributes.type === "path") {
                model.gradient = "path";
                model.center = { left: node.attributes.left ? parseFloat(node.attributes.left) : 0, top: node.attributes.top ? parseFloat(node.attributes.top) : 0 };
                if (node.attributes.right !== node.attributes.left) {
                  model.center.right = node.attributes.right ? parseFloat(node.attributes.right) : 0;
                }
                if (node.attributes.bottom !== node.attributes.top) {
                  model.center.bottom = node.attributes.bottom ? parseFloat(node.attributes.bottom) : 0;
                }
              }
              return true;
            }
            case "stop":
              this.parser = this.map.stop;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.stops.push(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          return false;
        } }, { key: "name", get: function get() {
          return "gradient";
        } }, { key: "tag", get: function get() {
          return "gradientFill";
        } }]);
        return GradientFillXform2;
      }(BaseXform);
      var FillXform = /* @__PURE__ */ function(_BaseXform4) {
        _inherits2(FillXform2, _BaseXform4);
        var _super4 = _createSuper2(FillXform2);
        function FillXform2() {
          var _this4;
          _classCallCheck2(this, FillXform2);
          _this4 = _super4.call(this);
          _this4.map = { patternFill: new PatternFillXform(), gradientFill: new GradientFillXform() };
          return _this4;
        }
        _createClass2(FillXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.addRollback();
          xmlStream.openNode("fill");
          switch (model.type) {
            case "pattern":
              this.map.patternFill.render(xmlStream, model);
              break;
            case "gradient":
              this.map.gradientFill.render(xmlStream, model);
              break;
            default:
              xmlStream.rollback();
              return;
          }
          xmlStream.closeNode();
          xmlStream.commit();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "fill":
              this.model = {};
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
                return true;
              }
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model = this.parser.model;
              this.model.type = this.parser.name;
              this.parser = void 0;
            }
            return true;
          }
          return false;
        } }, { key: "validStyle", value: function validStyle(value) {
          return FillXform2.validPatternValues[value];
        } }, { key: "tag", get: function get() {
          return "fill";
        } }]);
        return FillXform2;
      }(BaseXform);
      FillXform.validPatternValues = ["none", "solid", "darkVertical", "darkGray", "mediumGray", "lightGray", "gray125", "gray0625", "darkHorizontal", "darkVertical", "darkDown", "darkUp", "darkGrid", "darkTrellis", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid", "lightTrellis", "lightGrid"].reduce(function(p, v) {
        p[v] = true;
        return p;
      }, {});
      FillXform.StopXform = StopXform;
      FillXform.PatternFillXform = PatternFillXform;
      FillXform.GradientFillXform = GradientFillXform;
      module2.exports = FillXform;
    }, { "../base-xform": 31, "./color-xform": 127 }], 130: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var ColorXform = require2("./color-xform");
      var BooleanXform = require2("../simple/boolean-xform");
      var IntegerXform = require2("../simple/integer-xform");
      var StringXform = require2("../simple/string-xform");
      var UnderlineXform = require2("./underline-xform");
      var _ = require2("../../../utils/under-dash");
      var BaseXform = require2("../base-xform");
      var FontXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(FontXform2, _BaseXform);
        var _super = _createSuper2(FontXform2);
        function FontXform2(options) {
          var _this;
          _classCallCheck2(this, FontXform2);
          _this = _super.call(this);
          _this.options = options || FontXform2.OPTIONS;
          _this.map = { b: { prop: "bold", xform: new BooleanXform({ tag: "b", attr: "val" }) }, i: { prop: "italic", xform: new BooleanXform({ tag: "i", attr: "val" }) }, u: { prop: "underline", xform: new UnderlineXform() }, charset: { prop: "charset", xform: new IntegerXform({ tag: "charset", attr: "val" }) }, color: { prop: "color", xform: new ColorXform() }, condense: { prop: "condense", xform: new BooleanXform({ tag: "condense", attr: "val" }) }, extend: { prop: "extend", xform: new BooleanXform({ tag: "extend", attr: "val" }) }, family: { prop: "family", xform: new IntegerXform({ tag: "family", attr: "val" }) }, outline: { prop: "outline", xform: new BooleanXform({ tag: "outline", attr: "val" }) }, vertAlign: { prop: "vertAlign", xform: new StringXform({ tag: "vertAlign", attr: "val" }) }, scheme: { prop: "scheme", xform: new StringXform({ tag: "scheme", attr: "val" }) }, shadow: { prop: "shadow", xform: new BooleanXform({ tag: "shadow", attr: "val" }) }, strike: { prop: "strike", xform: new BooleanXform({ tag: "strike", attr: "val" }) }, sz: { prop: "size", xform: new IntegerXform({ tag: "sz", attr: "val" }) } };
          _this.map[_this.options.fontNameTag] = { prop: "name", xform: new StringXform({ tag: _this.options.fontNameTag, attr: "val" }) };
          return _this;
        }
        _createClass2(FontXform2, [{ key: "render", value: function render15(xmlStream, model) {
          var map = this.map;
          xmlStream.openNode(this.options.tagName);
          _.each(this.map, function(defn, tag) {
            map[tag].xform.render(xmlStream, model[defn.prop]);
          });
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          if (this.map[node.name]) {
            this.parser = this.map[node.name].xform;
            return this.parser.parseOpen(node);
          }
          switch (node.name) {
            case this.options.tagName:
              this.model = {};
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser && !this.parser.parseClose(name)) {
            var item = this.map[name];
            if (this.parser.model) {
              this.model[item.prop] = this.parser.model;
            }
            this.parser = void 0;
            return true;
          }
          switch (name) {
            case this.options.tagName:
              return false;
            default:
              return true;
          }
        } }, { key: "tag", get: function get() {
          return this.options.tagName;
        } }]);
        return FontXform2;
      }(BaseXform);
      FontXform.OPTIONS = { tagName: "font", fontNameTag: "name" };
      module2.exports = FontXform;
    }, { "../../../utils/under-dash": 25, "../base-xform": 31, "../simple/boolean-xform": 115, "../simple/integer-xform": 117, "../simple/string-xform": 118, "./color-xform": 127, "./underline-xform": 135 }], 131: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var _ = require2("../../../utils/under-dash");
      var defaultNumFormats = require2("../../defaultnumformats");
      var BaseXform = require2("../base-xform");
      function hashDefaultFormats() {
        var hash = {};
        _.each(defaultNumFormats, function(dnf, id) {
          if (dnf.f) {
            hash[dnf.f] = parseInt(id, 10);
          }
        });
        return hash;
      }
      var defaultFmtHash = hashDefaultFormats();
      var NumFmtXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(NumFmtXform2, _BaseXform);
        var _super = _createSuper2(NumFmtXform2);
        function NumFmtXform2(id, formatCode) {
          var _this;
          _classCallCheck2(this, NumFmtXform2);
          _this = _super.call(this);
          _this.id = id;
          _this.formatCode = formatCode;
          return _this;
        }
        _createClass2(NumFmtXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode("numFmt", { numFmtId: model.id, formatCode: model.formatCode });
        } }, { key: "parseOpen", value: function parseOpen(node) {
          switch (node.name) {
            case "numFmt":
              this.model = { id: parseInt(node.attributes.numFmtId, 10), formatCode: node.attributes.formatCode.replace(/[\\](.)/g, "$1") };
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "numFmt";
        } }]);
        return NumFmtXform2;
      }(BaseXform);
      NumFmtXform.getDefaultFmtId = function getDefaultFmtId(formatCode) {
        return defaultFmtHash[formatCode];
      };
      NumFmtXform.getDefaultFmtCode = function getDefaultFmtCode(numFmtId) {
        return defaultNumFormats[numFmtId] && defaultNumFormats[numFmtId].f;
      };
      module2.exports = NumFmtXform;
    }, { "../../../utils/under-dash": 25, "../../defaultnumformats": 29, "../base-xform": 31 }], 132: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var validation = { boolean: function boolean(value, dflt) {
        if (value === void 0) {
          return dflt;
        }
        return value;
      } };
      var ProtectionXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(ProtectionXform2, _BaseXform);
        var _super = _createSuper2(ProtectionXform2);
        function ProtectionXform2() {
          _classCallCheck2(this, ProtectionXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(ProtectionXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.addRollback();
          xmlStream.openNode("protection");
          var isValid2 = false;
          function add(name, value) {
            if (value !== void 0) {
              xmlStream.addAttribute(name, value);
              isValid2 = true;
            }
          }
          add("locked", validation.boolean(model.locked, true) ? void 0 : "0");
          add("hidden", validation.boolean(model.hidden, false) ? "1" : void 0);
          xmlStream.closeNode();
          if (isValid2) {
            xmlStream.commit();
          } else {
            xmlStream.rollback();
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          var model = { locked: !(node.attributes.locked === "0"), hidden: node.attributes.hidden === "1" };
          var isSignificant = !model.locked || model.hidden;
          this.model = isSignificant ? model : null;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "protection";
        } }]);
        return ProtectionXform2;
      }(BaseXform);
      module2.exports = ProtectionXform;
    }, { "../base-xform": 31 }], 133: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var AlignmentXform = require2("./alignment-xform");
      var ProtectionXform = require2("./protection-xform");
      var StyleXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(StyleXform2, _BaseXform);
        var _super = _createSuper2(StyleXform2);
        function StyleXform2(options) {
          var _this;
          _classCallCheck2(this, StyleXform2);
          _this = _super.call(this);
          _this.xfId = !!(options && options.xfId);
          _this.map = { alignment: new AlignmentXform(), protection: new ProtectionXform() };
          return _this;
        }
        _createClass2(StyleXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.openNode("xf", { numFmtId: model.numFmtId || 0, fontId: model.fontId || 0, fillId: model.fillId || 0, borderId: model.borderId || 0 });
          if (this.xfId) {
            xmlStream.addAttribute("xfId", model.xfId || 0);
          }
          if (model.numFmtId) {
            xmlStream.addAttribute("applyNumberFormat", "1");
          }
          if (model.fontId) {
            xmlStream.addAttribute("applyFont", "1");
          }
          if (model.fillId) {
            xmlStream.addAttribute("applyFill", "1");
          }
          if (model.borderId) {
            xmlStream.addAttribute("applyBorder", "1");
          }
          if (model.alignment) {
            xmlStream.addAttribute("applyAlignment", "1");
          }
          if (model.protection) {
            xmlStream.addAttribute("applyProtection", "1");
          }
          if (model.alignment) {
            this.map.alignment.render(xmlStream, model.alignment);
          }
          if (model.protection) {
            this.map.protection.render(xmlStream, model.protection);
          }
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "xf":
              this.model = { numFmtId: parseInt(node.attributes.numFmtId, 10), fontId: parseInt(node.attributes.fontId, 10), fillId: parseInt(node.attributes.fillId, 10), borderId: parseInt(node.attributes.borderId, 10) };
              if (this.xfId) {
                this.model.xfId = parseInt(node.attributes.xfId, 10);
              }
              return true;
            case "alignment":
              this.parser = this.map.alignment;
              this.parser.parseOpen(node);
              return true;
            case "protection":
              this.parser = this.map.protection;
              this.parser.parseOpen(node);
              return true;
            default:
              return false;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              if (this.map.protection === this.parser) {
                this.model.protection = this.parser.model;
              } else {
                this.model.alignment = this.parser.model;
              }
              this.parser = void 0;
            }
            return true;
          }
          return name !== "xf";
        } }, { key: "tag", get: function get() {
          return "xf";
        } }]);
        return StyleXform2;
      }(BaseXform);
      module2.exports = StyleXform;
    }, { "../base-xform": 31, "./alignment-xform": 125, "./protection-xform": 132 }], 134: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var Enums = require2("../../../doc/enums");
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var StaticXform = require2("../static-xform");
      var ListXform = require2("../list-xform");
      var FontXform = require2("./font-xform");
      var FillXform = require2("./fill-xform");
      var BorderXform = require2("./border-xform");
      var NumFmtXform = require2("./numfmt-xform");
      var StyleXform = require2("./style-xform");
      var DxfXform = require2("./dxf-xform");
      var NUMFMT_BASE = 164;
      var StylesXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(StylesXform2, _BaseXform);
        var _super = _createSuper2(StylesXform2);
        function StylesXform2(initialise) {
          var _this;
          _classCallCheck2(this, StylesXform2);
          _this = _super.call(this);
          _this.map = {
            numFmts: new ListXform({ tag: "numFmts", count: true, childXform: new NumFmtXform() }),
            fonts: new ListXform({ tag: "fonts", count: true, childXform: new FontXform(), $: { "x14ac:knownFonts": 1 } }),
            fills: new ListXform({ tag: "fills", count: true, childXform: new FillXform() }),
            borders: new ListXform({ tag: "borders", count: true, childXform: new BorderXform() }),
            cellStyleXfs: new ListXform({ tag: "cellStyleXfs", count: true, childXform: new StyleXform() }),
            cellXfs: new ListXform({ tag: "cellXfs", count: true, childXform: new StyleXform({ xfId: true }) }),
            dxfs: new ListXform({ tag: "dxfs", always: true, count: true, childXform: new DxfXform() }),
            // for style manager
            numFmt: new NumFmtXform(),
            font: new FontXform(),
            fill: new FillXform(),
            border: new BorderXform(),
            style: new StyleXform({ xfId: true }),
            cellStyles: StylesXform2.STATIC_XFORMS.cellStyles,
            tableStyles: StylesXform2.STATIC_XFORMS.tableStyles,
            extLst: StylesXform2.STATIC_XFORMS.extLst
          };
          if (initialise) {
            _this.init();
          }
          return _this;
        }
        _createClass2(StylesXform2, [{ key: "initIndex", value: function initIndex() {
          this.index = {
            style: {},
            numFmt: {},
            numFmtNextId: 164,
            // start custom format ids here
            font: {},
            border: {},
            fill: {}
          };
        } }, { key: "init", value: function init() {
          this.model = { styles: [], numFmts: [], fonts: [], borders: [], fills: [], dxfs: [] };
          this.initIndex();
          this._addBorder({});
          this._addStyle({ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 });
          this._addFill({ type: "pattern", pattern: "none" });
          this._addFill({ type: "pattern", pattern: "gray125" });
          this.weakMap = /* @__PURE__ */ new WeakMap();
        } }, { key: "render", value: function render15(xmlStream, model) {
          model = model || this.model;
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode("styleSheet", StylesXform2.STYLESHEET_ATTRIBUTES);
          if (this.index) {
            if (model.numFmts && model.numFmts.length) {
              xmlStream.openNode("numFmts", { count: model.numFmts.length });
              model.numFmts.forEach(function(numFmtXml) {
                xmlStream.writeXml(numFmtXml);
              });
              xmlStream.closeNode();
            }
            if (!model.fonts.length) {
              this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" });
            }
            xmlStream.openNode("fonts", { count: model.fonts.length, "x14ac:knownFonts": 1 });
            model.fonts.forEach(function(fontXml) {
              xmlStream.writeXml(fontXml);
            });
            xmlStream.closeNode();
            xmlStream.openNode("fills", { count: model.fills.length });
            model.fills.forEach(function(fillXml) {
              xmlStream.writeXml(fillXml);
            });
            xmlStream.closeNode();
            xmlStream.openNode("borders", { count: model.borders.length });
            model.borders.forEach(function(borderXml) {
              xmlStream.writeXml(borderXml);
            });
            xmlStream.closeNode();
            this.map.cellStyleXfs.render(xmlStream, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]);
            xmlStream.openNode("cellXfs", { count: model.styles.length });
            model.styles.forEach(function(styleXml) {
              xmlStream.writeXml(styleXml);
            });
            xmlStream.closeNode();
          } else {
            this.map.numFmts.render(xmlStream, model.numFmts);
            this.map.fonts.render(xmlStream, model.fonts);
            this.map.fills.render(xmlStream, model.fills);
            this.map.borders.render(xmlStream, model.borders);
            this.map.cellStyleXfs.render(xmlStream, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]);
            this.map.cellXfs.render(xmlStream, model.styles);
          }
          StylesXform2.STATIC_XFORMS.cellStyles.render(xmlStream);
          this.map.dxfs.render(xmlStream, model.dxfs);
          StylesXform2.STATIC_XFORMS.tableStyles.render(xmlStream);
          StylesXform2.STATIC_XFORMS.extLst.render(xmlStream);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case "styleSheet":
              this.initIndex();
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              return true;
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, {
          key: "parseClose",
          value: function parseClose(name) {
            var _this2 = this;
            if (this.parser) {
              if (!this.parser.parseClose(name)) {
                this.parser = void 0;
              }
              return true;
            }
            switch (name) {
              case "styleSheet": {
                this.model = {};
                var add = function add2(propName, xform) {
                  if (xform.model && xform.model.length) {
                    _this2.model[propName] = xform.model;
                  }
                };
                add("numFmts", this.map.numFmts);
                add("fonts", this.map.fonts);
                add("fills", this.map.fills);
                add("borders", this.map.borders);
                add("styles", this.map.cellXfs);
                add("dxfs", this.map.dxfs);
                this.index = { model: [], numFmt: [] };
                if (this.model.numFmts) {
                  var numFmtIndex = this.index.numFmt;
                  this.model.numFmts.forEach(function(numFmt) {
                    numFmtIndex[numFmt.id] = numFmt.formatCode;
                  });
                }
                return false;
              }
              default:
                return true;
            }
          }
          // add a cell's style model to the collection
          // each style property is processed and cross-referenced, etc.
          // the styleId is returned. Note: cellType is used when numFmt not defined
        }, {
          key: "addStyleModel",
          value: function addStyleModel(model, cellType) {
            if (!model) {
              return 0;
            }
            if (!this.model.fonts.length) {
              this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" });
            }
            if (this.weakMap && this.weakMap.has(model)) {
              return this.weakMap.get(model);
            }
            var style = {};
            cellType = cellType || Enums.ValueType.Number;
            if (model.numFmt) {
              style.numFmtId = this._addNumFmtStr(model.numFmt);
            } else {
              switch (cellType) {
                case Enums.ValueType.Number:
                  style.numFmtId = this._addNumFmtStr("General");
                  break;
                case Enums.ValueType.Date:
                  style.numFmtId = this._addNumFmtStr("mm-dd-yy");
                  break;
              }
            }
            if (model.font) {
              style.fontId = this._addFont(model.font);
            }
            if (model.border) {
              style.borderId = this._addBorder(model.border);
            }
            if (model.fill) {
              style.fillId = this._addFill(model.fill);
            }
            if (model.alignment) {
              style.alignment = model.alignment;
            }
            if (model.protection) {
              style.protection = model.protection;
            }
            var styleId = this._addStyle(style);
            if (this.weakMap) {
              this.weakMap.set(model, styleId);
            }
            return styleId;
          }
          // given a styleId (i.e. s="n"), get the cell's style model
          // objects are shared where possible.
        }, { key: "getStyleModel", value: function getStyleModel(id) {
          var style = this.model.styles[id];
          if (!style)
            return null;
          var model = this.index.model[id];
          if (model)
            return model;
          model = this.index.model[id] = {};
          if (style.numFmtId) {
            var numFmt = this.index.numFmt[style.numFmtId] || NumFmtXform.getDefaultFmtCode(style.numFmtId);
            if (numFmt) {
              model.numFmt = numFmt;
            }
          }
          function addStyle(name, group, styleId) {
            if (styleId || styleId === 0) {
              var part = group[styleId];
              if (part) {
                model[name] = part;
              }
            }
          }
          addStyle("font", this.model.fonts, style.fontId);
          addStyle("border", this.model.borders, style.borderId);
          addStyle("fill", this.model.fills, style.fillId);
          if (style.alignment) {
            model.alignment = style.alignment;
          }
          if (style.protection) {
            model.protection = style.protection;
          }
          return model;
        } }, { key: "addDxfStyle", value: function addDxfStyle(style) {
          this.model.dxfs.push(style);
          return this.model.dxfs.length - 1;
        } }, {
          key: "getDxfStyle",
          value: function getDxfStyle(id) {
            return this.model.dxfs[id];
          }
          // =========================================================================
          // Private Interface
        }, {
          key: "_addStyle",
          value: function _addStyle(style) {
            var xml = this.map.style.toXml(style);
            var index2 = this.index.style[xml];
            if (index2 === void 0) {
              index2 = this.index.style[xml] = this.model.styles.length;
              this.model.styles.push(xml);
            }
            return index2;
          }
          // =========================================================================
          // Number Formats
        }, {
          key: "_addNumFmtStr",
          value: function _addNumFmtStr(formatCode) {
            var index2 = NumFmtXform.getDefaultFmtId(formatCode);
            if (index2 !== void 0)
              return index2;
            index2 = this.index.numFmt[formatCode];
            if (index2 !== void 0)
              return index2;
            index2 = this.index.numFmt[formatCode] = NUMFMT_BASE + this.model.numFmts.length;
            var xml = this.map.numFmt.toXml({ id: index2, formatCode });
            this.model.numFmts.push(xml);
            return index2;
          }
          // =========================================================================
          // Fonts
        }, {
          key: "_addFont",
          value: function _addFont(font) {
            var xml = this.map.font.toXml(font);
            var index2 = this.index.font[xml];
            if (index2 === void 0) {
              index2 = this.index.font[xml] = this.model.fonts.length;
              this.model.fonts.push(xml);
            }
            return index2;
          }
          // =========================================================================
          // Borders
        }, {
          key: "_addBorder",
          value: function _addBorder(border) {
            var xml = this.map.border.toXml(border);
            var index2 = this.index.border[xml];
            if (index2 === void 0) {
              index2 = this.index.border[xml] = this.model.borders.length;
              this.model.borders.push(xml);
            }
            return index2;
          }
          // =========================================================================
          // Fills
        }, {
          key: "_addFill",
          value: function _addFill(fill) {
            var xml = this.map.fill.toXml(fill);
            var index2 = this.index.fill[xml];
            if (index2 === void 0) {
              index2 = this.index.fill[xml] = this.model.fills.length;
              this.model.fills.push(xml);
            }
            return index2;
          }
          // =========================================================================
        }]);
        return StylesXform2;
      }(BaseXform);
      StylesXform.STYLESHEET_ATTRIBUTES = { xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main", "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006", "mc:Ignorable": "x14ac x16r2", "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac", "xmlns:x16r2": "http://schemas.microsoft.com/office/spreadsheetml/2015/02/main" };
      StylesXform.STATIC_XFORMS = { cellStyles: new StaticXform({ tag: "cellStyles", $: { count: 1 }, c: [{ tag: "cellStyle", $: { name: "Normal", xfId: 0, builtinId: 0 } }] }), dxfs: new StaticXform({ tag: "dxfs", $: { count: 0 } }), tableStyles: new StaticXform({ tag: "tableStyles", $: { count: 0, defaultTableStyle: "TableStyleMedium2", defaultPivotStyle: "PivotStyleLight16" } }), extLst: new StaticXform({ tag: "extLst", c: [{ tag: "ext", $: { uri: "{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}", "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" }, c: [{ tag: "x14:slicerStyles", $: { defaultSlicerStyle: "SlicerStyleLight1" } }] }, { tag: "ext", $: { uri: "{9260A510-F301-46a8-8635-F512D64BE5F5}", "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main" }, c: [{ tag: "x15:timelineStyles", $: { defaultTimelineStyle: "TimeSlicerStyleLight1" } }] }] }) };
      var StylesXformMock = /* @__PURE__ */ function(_StylesXform) {
        _inherits2(StylesXformMock2, _StylesXform);
        var _super2 = _createSuper2(StylesXformMock2);
        function StylesXformMock2() {
          var _this3;
          _classCallCheck2(this, StylesXformMock2);
          _this3 = _super2.call(this);
          _this3.model = { styles: [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }], numFmts: [], fonts: [{ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" }], borders: [{}], fills: [{ type: "pattern", pattern: "none" }, { type: "pattern", pattern: "gray125" }] };
          return _this3;
        }
        _createClass2(StylesXformMock2, [{
          key: "parseStream",
          value: function parseStream(stream) {
            stream.autodrain();
            return Promise.resolve();
          }
          // add a cell's style model to the collection
          // each style property is processed and cross-referenced, etc.
          // the styleId is returned. Note: cellType is used when numFmt not defined
        }, { key: "addStyleModel", value: function addStyleModel(model, cellType) {
          switch (cellType) {
            case Enums.ValueType.Date:
              return this.dateStyleId;
            default:
              return 0;
          }
        } }, {
          key: "getStyleModel",
          // given a styleId (i.e. s="n"), get the cell's style model
          // objects are shared where possible.
          value: function getStyleModel() {
            return {};
          }
        }, { key: "dateStyleId", get: function get() {
          if (!this._dateStyleId) {
            var dateStyle = { numFmtId: NumFmtXform.getDefaultFmtId("mm-dd-yy") };
            this._dateStyleId = this.model.styles.length;
            this.model.styles.push(dateStyle);
          }
          return this._dateStyleId;
        } }]);
        return StylesXformMock2;
      }(StylesXform);
      StylesXform.Mock = StylesXformMock;
      module2.exports = StylesXform;
    }, { "../../../doc/enums": 7, "../../../utils/xml-stream": 27, "../base-xform": 31, "../list-xform": 70, "../static-xform": 119, "./border-xform": 126, "./dxf-xform": 128, "./fill-xform": 129, "./font-xform": 130, "./numfmt-xform": 131, "./style-xform": 133 }], 135: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var UnderlineXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(UnderlineXform2, _BaseXform);
        var _super = _createSuper2(UnderlineXform2);
        function UnderlineXform2(model) {
          var _this;
          _classCallCheck2(this, UnderlineXform2);
          _this = _super.call(this);
          _this.model = model;
          return _this;
        }
        _createClass2(UnderlineXform2, [{ key: "render", value: function render15(xmlStream, model) {
          model = model || this.model;
          if (model === true) {
            xmlStream.leafNode("u");
          } else {
            var attr = UnderlineXform2.Attributes[model];
            if (attr) {
              xmlStream.leafNode("u", attr);
            }
          }
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === "u") {
            this.model = node.attributes.val || true;
          }
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "u";
        } }]);
        return UnderlineXform2;
      }(BaseXform);
      UnderlineXform.Attributes = { single: {}, double: { val: "double" }, singleAccounting: { val: "singleAccounting" }, doubleAccounting: { val: "doubleAccounting" } };
      module2.exports = UnderlineXform;
    }, { "../base-xform": 31 }], 136: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var FilterColumnXform = require2("./filter-column-xform");
      var AutoFilterXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(AutoFilterXform2, _BaseXform);
        var _super = _createSuper2(AutoFilterXform2);
        function AutoFilterXform2() {
          var _this;
          _classCallCheck2(this, AutoFilterXform2);
          _this = _super.call(this);
          _this.map = { filterColumn: new FilterColumnXform() };
          return _this;
        }
        _createClass2(AutoFilterXform2, [{ key: "prepare", value: function prepare(model) {
          var _this2 = this;
          model.columns.forEach(function(column, index2) {
            _this2.map.filterColumn.prepare(column, { index: index2 });
          });
        } }, { key: "render", value: function render15(xmlStream, model) {
          var _this3 = this;
          xmlStream.openNode(this.tag, { ref: model.autoFilterRef });
          model.columns.forEach(function(column) {
            _this3.map.filterColumn.render(xmlStream, column);
          });
          xmlStream.closeNode();
          return true;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          switch (node.name) {
            case this.tag:
              this.model = { autoFilterRef: node.attributes.ref, columns: [] };
              return true;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parseOpen(node);
                return true;
              }
              throw new Error("Unexpected xml node in parseOpen: ".concat(JSON.stringify(node)));
          }
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.model.columns.push(this.parser.model);
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              return false;
            default:
              throw new Error("Unexpected xml node in parseClose: ".concat(name));
          }
        } }, { key: "tag", get: function get() {
          return "autoFilter";
        } }]);
        return AutoFilterXform2;
      }(BaseXform);
      module2.exports = AutoFilterXform;
    }, { "../base-xform": 31, "./filter-column-xform": 137 }], 137: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var FilterColumnXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(FilterColumnXform2, _BaseXform);
        var _super = _createSuper2(FilterColumnXform2);
        function FilterColumnXform2() {
          _classCallCheck2(this, FilterColumnXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(FilterColumnXform2, [{ key: "prepare", value: function prepare(model, options) {
          model.colId = options.index.toString();
        } }, { key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode(this.tag, { colId: model.colId, hiddenButton: model.filterButton ? "0" : "1" });
          return true;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            var attributes = node.attributes;
            this.model = { filterButton: attributes.hiddenButton === "0" };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "filterColumn";
        } }]);
        return FilterColumnXform2;
      }(BaseXform);
      module2.exports = FilterColumnXform;
    }, { "../base-xform": 31 }], 138: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var TableColumnXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(TableColumnXform2, _BaseXform);
        var _super = _createSuper2(TableColumnXform2);
        function TableColumnXform2() {
          _classCallCheck2(this, TableColumnXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(TableColumnXform2, [{ key: "prepare", value: function prepare(model, options) {
          model.id = options.index + 1;
        } }, { key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode(this.tag, { id: model.id.toString(), name: model.name, totalsRowLabel: model.totalsRowLabel, totalsRowFunction: model.totalsRowFunction, dxfId: model.dxfId });
          return true;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            var attributes = node.attributes;
            this.model = { name: attributes.name, totalsRowLabel: attributes.totalsRowLabel, totalsRowFunction: attributes.totalsRowFunction, dxfId: attributes.dxfId };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "tableColumn";
        } }]);
        return TableColumnXform2;
      }(BaseXform);
      module2.exports = TableColumnXform;
    }, { "../base-xform": 31 }], 139: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var BaseXform = require2("../base-xform");
      var TableStyleInfoXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(TableStyleInfoXform2, _BaseXform);
        var _super = _createSuper2(TableStyleInfoXform2);
        function TableStyleInfoXform2() {
          _classCallCheck2(this, TableStyleInfoXform2);
          return _super.apply(this, arguments);
        }
        _createClass2(TableStyleInfoXform2, [{ key: "render", value: function render15(xmlStream, model) {
          xmlStream.leafNode(this.tag, { name: model.theme ? model.theme : void 0, showFirstColumn: model.showFirstColumn ? "1" : "0", showLastColumn: model.showLastColumn ? "1" : "0", showRowStripes: model.showRowStripes ? "1" : "0", showColumnStripes: model.showColumnStripes ? "1" : "0" });
          return true;
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (node.name === this.tag) {
            var attributes = node.attributes;
            this.model = { theme: attributes.name ? attributes.name : null, showFirstColumn: attributes.showFirstColumn === "1", showLastColumn: attributes.showLastColumn === "1", showRowStripes: attributes.showRowStripes === "1", showColumnStripes: attributes.showColumnStripes === "1" };
            return true;
          }
          return false;
        } }, { key: "parseText", value: function parseText() {
        } }, { key: "parseClose", value: function parseClose() {
          return false;
        } }, { key: "tag", get: function get() {
          return "tableStyleInfo";
        } }]);
        return TableStyleInfoXform2;
      }(BaseXform);
      module2.exports = TableStyleInfoXform;
    }, { "../base-xform": 31 }], 140: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function ownKeys2(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys2(Object(source), true).forEach(function(key) {
              _defineProperty2(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys2(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf2(subClass, superClass);
      }
      function _setPrototypeOf2(o, p) {
        _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf2(o, p);
      }
      function _createSuper2(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct2();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf2(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn2(this, result);
        };
      }
      function _possibleConstructorReturn2(self2, call) {
        if (call && (_typeof2(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized2(self2);
      }
      function _assertThisInitialized2(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct2() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Date.prototype.toString.call(Reflect.construct(Date, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf2(o) {
        _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf2(o);
      }
      var XmlStream = require2("../../../utils/xml-stream");
      var BaseXform = require2("../base-xform");
      var ListXform = require2("../list-xform");
      var AutoFilterXform = require2("./auto-filter-xform");
      var TableColumnXform = require2("./table-column-xform");
      var TableStyleInfoXform = require2("./table-style-info-xform");
      var TableXform = /* @__PURE__ */ function(_BaseXform) {
        _inherits2(TableXform2, _BaseXform);
        var _super = _createSuper2(TableXform2);
        function TableXform2() {
          var _this;
          _classCallCheck2(this, TableXform2);
          _this = _super.call(this);
          _this.map = { autoFilter: new AutoFilterXform(), tableColumns: new ListXform({ tag: "tableColumns", count: true, empty: true, childXform: new TableColumnXform() }), tableStyleInfo: new TableStyleInfoXform() };
          return _this;
        }
        _createClass2(TableXform2, [{ key: "prepare", value: function prepare(model, options) {
          this.map.autoFilter.prepare(model);
          this.map.tableColumns.prepare(model.columns, options);
        } }, { key: "render", value: function render15(xmlStream, model) {
          xmlStream.openXml(XmlStream.StdDocAttributes);
          xmlStream.openNode(this.tag, _objectSpread2(_objectSpread2({}, TableXform2.TABLE_ATTRIBUTES), {}, { id: model.id, name: model.name, displayName: model.displayName || model.name, ref: model.tableRef, totalsRowCount: model.totalsRow ? "1" : void 0, totalsRowShown: model.totalsRow ? void 0 : "1", headerRowCount: model.headerRow ? "1" : "0" }));
          this.map.autoFilter.render(xmlStream, model);
          this.map.tableColumns.render(xmlStream, model.columns);
          this.map.tableStyleInfo.render(xmlStream, model.style);
          xmlStream.closeNode();
        } }, { key: "parseOpen", value: function parseOpen(node) {
          if (this.parser) {
            this.parser.parseOpen(node);
            return true;
          }
          var name = node.name, attributes = node.attributes;
          switch (name) {
            case this.tag:
              this.reset();
              this.model = { name: attributes.name, displayName: attributes.displayName || attributes.name, tableRef: attributes.ref, totalsRow: attributes.totalsRowCount === "1", headerRow: attributes.headerRowCount === "1" };
              break;
            default:
              this.parser = this.map[node.name];
              if (this.parser) {
                this.parser.parseOpen(node);
              }
              break;
          }
          return true;
        } }, { key: "parseText", value: function parseText(text) {
          if (this.parser) {
            this.parser.parseText(text);
          }
        } }, { key: "parseClose", value: function parseClose(name) {
          var _this2 = this;
          if (this.parser) {
            if (!this.parser.parseClose(name)) {
              this.parser = void 0;
            }
            return true;
          }
          switch (name) {
            case this.tag:
              this.model.columns = this.map.tableColumns.model;
              if (this.map.autoFilter.model) {
                this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef;
                this.map.autoFilter.model.columns.forEach(function(column, index2) {
                  _this2.model.columns[index2].filterButton = column.filterButton;
                });
              }
              this.model.style = this.map.tableStyleInfo.model;
              return false;
            default:
              return true;
          }
        } }, { key: "reconcile", value: function reconcile(model, options) {
          model.columns.forEach(function(column) {
            if (column.dxfId !== void 0) {
              column.style = options.styles.getDxfStyle(column.dxfId);
            }
          });
        } }, { key: "tag", get: function get() {
          return "table";
        } }]);
        return TableXform2;
      }(BaseXform);
      TableXform.TABLE_ATTRIBUTES = {
        xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "mc:Ignorable": "xr xr3",
        "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision",
        "xmlns:xr3": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision3"
        // 'xr:uid': '{00000000-000C-0000-FFFF-FFFF00000000}',
      };
      module2.exports = TableXform;
    }, { "../../../utils/xml-stream": 27, "../base-xform": 31, "../list-xform": 70, "./auto-filter-xform": 136, "./table-column-xform": 138, "./table-style-info-xform": 139 }], 141: [function(require2, module2, exports2) {
      (function(process, Buffer) {
        function asyncGeneratorStep2(gen, resolve, reject, _next, _throw, key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }
          if (info.done) {
            resolve(value);
          } else {
            Promise.resolve(value).then(_next, _throw);
          }
        }
        function _asyncToGenerator2(fn) {
          return function() {
            var self2 = this, args = arguments;
            return new Promise(function(resolve, reject) {
              var gen = fn.apply(self2, args);
              function _next(value) {
                asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "next", value);
              }
              function _throw(err) {
                asyncGeneratorStep2(gen, resolve, reject, _next, _throw, "throw", err);
              }
              _next(void 0);
            });
          };
        }
        function _classCallCheck2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties2(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _asyncIterator(iterable) {
          var method;
          if (typeof Symbol !== "undefined") {
            if (Symbol.asyncIterator) {
              method = iterable[Symbol.asyncIterator];
              if (method != null)
                return method.call(iterable);
            }
            if (Symbol.iterator) {
              method = iterable[Symbol.iterator];
              if (method != null)
                return method.call(iterable);
            }
          }
          throw new TypeError("Object is not async iterable");
        }
        var fs = require2("fs");
        var JSZip = require2("jszip");
        var _require = require2("readable-stream"), PassThrough = _require.PassThrough;
        var ZipStream = require2("../utils/zip-stream");
        var StreamBuf = require2("../utils/stream-buf");
        var utils = require2("../utils/utils");
        var XmlStream = require2("../utils/xml-stream");
        var _require2 = require2("../utils/browser-buffer-decode"), bufferToString = _require2.bufferToString;
        var StylesXform = require2("./xform/style/styles-xform");
        var CoreXform = require2("./xform/core/core-xform");
        var SharedStringsXform = require2("./xform/strings/shared-strings-xform");
        var RelationshipsXform = require2("./xform/core/relationships-xform");
        var ContentTypesXform = require2("./xform/core/content-types-xform");
        var AppXform = require2("./xform/core/app-xform");
        var WorkbookXform = require2("./xform/book/workbook-xform");
        var WorksheetXform = require2("./xform/sheet/worksheet-xform");
        var DrawingXform = require2("./xform/drawing/drawing-xform");
        var TableXform = require2("./xform/table/table-xform");
        var CommentsXform = require2("./xform/comment/comments-xform");
        var VmlNotesXform = require2("./xform/comment/vml-notes-xform");
        var theme1Xml = require2("./xml/theme1.js");
        function fsReadFileAsync(filename, options) {
          return new Promise(function(resolve, reject) {
            fs.readFile(filename, options, function(error, data) {
              if (error) {
                reject(error);
              } else {
                resolve(data);
              }
            });
          });
        }
        var XLSX = /* @__PURE__ */ function() {
          function XLSX2(workbook) {
            _classCallCheck2(this, XLSX2);
            this.workbook = workbook;
          }
          _createClass2(XLSX2, [{ key: "readFile", value: function() {
            var _readFile = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee(filename, options) {
              var stream, workbook;
              return regenerator.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return utils.fs.exists(filename);
                    case 2:
                      if (_context.sent) {
                        _context.next = 4;
                        break;
                      }
                      throw new Error("File not found: ".concat(filename));
                    case 4:
                      stream = fs.createReadStream(filename);
                      _context.prev = 5;
                      _context.next = 8;
                      return this.read(stream, options);
                    case 8:
                      workbook = _context.sent;
                      stream.close();
                      return _context.abrupt("return", workbook);
                    case 13:
                      _context.prev = 13;
                      _context.t0 = _context["catch"](5);
                      stream.close();
                      throw _context.t0;
                    case 17:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this, [[5, 13]]);
            }));
            function readFile(_x, _x2) {
              return _readFile.apply(this, arguments);
            }
            return readFile;
          }() }, { key: "parseRels", value: function parseRels(stream) {
            var xform = new RelationshipsXform();
            return xform.parseStream(stream);
          } }, { key: "parseWorkbook", value: function parseWorkbook(stream) {
            var xform = new WorkbookXform();
            return xform.parseStream(stream);
          } }, { key: "parseSharedStrings", value: function parseSharedStrings(stream) {
            var xform = new SharedStringsXform();
            return xform.parseStream(stream);
          } }, { key: "reconcile", value: function reconcile(model, options) {
            var workbookXform = new WorkbookXform();
            var worksheetXform = new WorksheetXform(options);
            var drawingXform = new DrawingXform();
            var tableXform = new TableXform();
            workbookXform.reconcile(model);
            var drawingOptions = { media: model.media, mediaIndex: model.mediaIndex };
            Object.keys(model.drawings).forEach(function(name) {
              var drawing = model.drawings[name];
              var drawingRel = model.drawingRels[name];
              if (drawingRel) {
                drawingOptions.rels = drawingRel.reduce(function(o, rel) {
                  o[rel.Id] = rel;
                  return o;
                }, {});
                (drawing.anchors || []).forEach(function(anchor) {
                  var hyperlinks = anchor.picture && anchor.picture.hyperlinks;
                  if (hyperlinks && drawingOptions.rels[hyperlinks.rId]) {
                    hyperlinks.hyperlink = drawingOptions.rels[hyperlinks.rId].Target;
                    delete hyperlinks.rId;
                  }
                });
                drawingXform.reconcile(drawing, drawingOptions);
              }
            });
            var tableOptions = { styles: model.styles };
            Object.values(model.tables).forEach(function(table) {
              tableXform.reconcile(table, tableOptions);
            });
            var sheetOptions = { styles: model.styles, sharedStrings: model.sharedStrings, media: model.media, mediaIndex: model.mediaIndex, date1904: model.properties && model.properties.date1904, drawings: model.drawings, comments: model.comments, tables: model.tables, vmlDrawings: model.vmlDrawings };
            model.worksheets.forEach(function(worksheet) {
              worksheet.relationships = model.worksheetRels[worksheet.sheetNo];
              worksheetXform.reconcile(worksheet, sheetOptions);
            });
            delete model.worksheetHash;
            delete model.worksheetRels;
            delete model.globalRels;
            delete model.sharedStrings;
            delete model.workbookRels;
            delete model.sheetDefs;
            delete model.styles;
            delete model.mediaIndex;
            delete model.drawings;
            delete model.drawingRels;
            delete model.vmlDrawings;
          } }, { key: "_processWorksheetEntry", value: function() {
            var _processWorksheetEntry2 = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee2(stream, model, sheetNo, options, path) {
              var xform, worksheet;
              return regenerator.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      xform = new WorksheetXform(options);
                      _context2.next = 3;
                      return xform.parseStream(stream);
                    case 3:
                      worksheet = _context2.sent;
                      worksheet.sheetNo = sheetNo;
                      model.worksheetHash[path] = worksheet;
                      model.worksheets.push(worksheet);
                    case 7:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }));
            function _processWorksheetEntry(_x3, _x4, _x5, _x6, _x7) {
              return _processWorksheetEntry2.apply(this, arguments);
            }
            return _processWorksheetEntry;
          }() }, { key: "_processCommentEntry", value: function() {
            var _processCommentEntry2 = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee3(stream, model, name) {
              var xform, comments;
              return regenerator.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      xform = new CommentsXform();
                      _context3.next = 3;
                      return xform.parseStream(stream);
                    case 3:
                      comments = _context3.sent;
                      model.comments["../".concat(name, ".xml")] = comments;
                    case 5:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            }));
            function _processCommentEntry(_x8, _x9, _x10) {
              return _processCommentEntry2.apply(this, arguments);
            }
            return _processCommentEntry;
          }() }, { key: "_processTableEntry", value: function() {
            var _processTableEntry2 = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee4(stream, model, name) {
              var xform, table;
              return regenerator.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      xform = new TableXform();
                      _context4.next = 3;
                      return xform.parseStream(stream);
                    case 3:
                      table = _context4.sent;
                      model.tables["../tables/".concat(name, ".xml")] = table;
                    case 5:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }));
            function _processTableEntry(_x11, _x12, _x13) {
              return _processTableEntry2.apply(this, arguments);
            }
            return _processTableEntry;
          }() }, { key: "_processWorksheetRelsEntry", value: function() {
            var _processWorksheetRelsEntry2 = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee5(stream, model, sheetNo) {
              var xform, relationships;
              return regenerator.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      xform = new RelationshipsXform();
                      _context5.next = 3;
                      return xform.parseStream(stream);
                    case 3:
                      relationships = _context5.sent;
                      model.worksheetRels[sheetNo] = relationships;
                    case 5:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            }));
            function _processWorksheetRelsEntry(_x14, _x15, _x16) {
              return _processWorksheetRelsEntry2.apply(this, arguments);
            }
            return _processWorksheetRelsEntry;
          }() }, { key: "_processMediaEntry", value: function() {
            var _processMediaEntry2 = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee6(entry, model, filename) {
              var lastDot, extension, name;
              return regenerator.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      lastDot = filename.lastIndexOf(".");
                      if (!(lastDot >= 1)) {
                        _context6.next = 6;
                        break;
                      }
                      extension = filename.substr(lastDot + 1);
                      name = filename.substr(0, lastDot);
                      _context6.next = 6;
                      return new Promise(function(resolve, reject) {
                        var streamBuf = new StreamBuf();
                        streamBuf.on("finish", function() {
                          model.mediaIndex[filename] = model.media.length;
                          model.mediaIndex[name] = model.media.length;
                          var medium = { type: "image", name, extension, buffer: streamBuf.toBuffer() };
                          model.media.push(medium);
                          resolve();
                        });
                        entry.on("error", function(error) {
                          reject(error);
                        });
                        entry.pipe(streamBuf);
                      });
                    case 6:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6);
            }));
            function _processMediaEntry(_x17, _x18, _x19) {
              return _processMediaEntry2.apply(this, arguments);
            }
            return _processMediaEntry;
          }() }, { key: "_processDrawingEntry", value: function() {
            var _processDrawingEntry2 = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee7(entry, model, name) {
              var xform, drawing;
              return regenerator.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      xform = new DrawingXform();
                      _context7.next = 3;
                      return xform.parseStream(entry);
                    case 3:
                      drawing = _context7.sent;
                      model.drawings[name] = drawing;
                    case 5:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7);
            }));
            function _processDrawingEntry(_x20, _x21, _x22) {
              return _processDrawingEntry2.apply(this, arguments);
            }
            return _processDrawingEntry;
          }() }, { key: "_processDrawingRelsEntry", value: function() {
            var _processDrawingRelsEntry2 = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee8(entry, model, name) {
              var xform, relationships;
              return regenerator.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      xform = new RelationshipsXform();
                      _context8.next = 3;
                      return xform.parseStream(entry);
                    case 3:
                      relationships = _context8.sent;
                      model.drawingRels[name] = relationships;
                    case 5:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8);
            }));
            function _processDrawingRelsEntry(_x23, _x24, _x25) {
              return _processDrawingRelsEntry2.apply(this, arguments);
            }
            return _processDrawingRelsEntry;
          }() }, { key: "_processVmlDrawingEntry", value: function() {
            var _processVmlDrawingEntry2 = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee9(entry, model, name) {
              var xform, vmlDrawing;
              return regenerator.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      xform = new VmlNotesXform();
                      _context9.next = 3;
                      return xform.parseStream(entry);
                    case 3:
                      vmlDrawing = _context9.sent;
                      model.vmlDrawings["../drawings/".concat(name, ".vml")] = vmlDrawing;
                    case 5:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9);
            }));
            function _processVmlDrawingEntry(_x26, _x27, _x28) {
              return _processVmlDrawingEntry2.apply(this, arguments);
            }
            return _processVmlDrawingEntry;
          }() }, {
            key: "_processThemeEntry",
            value: function() {
              var _processThemeEntry2 = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee10(entry, model, name) {
                return regenerator.wrap(function _callee10$(_context10) {
                  while (1) {
                    switch (_context10.prev = _context10.next) {
                      case 0:
                        _context10.next = 2;
                        return new Promise(function(resolve, reject) {
                          var stream = new StreamBuf();
                          entry.on("error", reject);
                          stream.on("error", reject);
                          stream.on("finish", function() {
                            model.themes[name] = stream.read().toString();
                            resolve();
                          });
                          entry.pipe(stream);
                        });
                      case 2:
                      case "end":
                        return _context10.stop();
                    }
                  }
                }, _callee10);
              }));
              function _processThemeEntry(_x29, _x30, _x31) {
                return _processThemeEntry2.apply(this, arguments);
              }
              return _processThemeEntry;
            }()
            /**
            * @deprecated since version 4.0. You should use `#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
            */
          }, { key: "createInputStream", value: function createInputStream() {
            throw new Error("`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md");
          } }, { key: "read", value: function() {
            var _read = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee11(stream, options) {
              var chunks, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;
              return regenerator.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      if (!stream[Symbol.asyncIterator] && stream.pipe) {
                        stream = stream.pipe(new PassThrough());
                      }
                      chunks = [];
                      _iteratorNormalCompletion = true;
                      _didIteratorError = false;
                      _context11.prev = 4;
                      _iterator = _asyncIterator(stream);
                    case 6:
                      _context11.next = 8;
                      return _iterator.next();
                    case 8:
                      _step = _context11.sent;
                      _iteratorNormalCompletion = _step.done;
                      _context11.next = 12;
                      return _step.value;
                    case 12:
                      _value = _context11.sent;
                      if (_iteratorNormalCompletion) {
                        _context11.next = 19;
                        break;
                      }
                      chunk = _value;
                      chunks.push(chunk);
                    case 16:
                      _iteratorNormalCompletion = true;
                      _context11.next = 6;
                      break;
                    case 19:
                      _context11.next = 25;
                      break;
                    case 21:
                      _context11.prev = 21;
                      _context11.t0 = _context11["catch"](4);
                      _didIteratorError = true;
                      _iteratorError = _context11.t0;
                    case 25:
                      _context11.prev = 25;
                      _context11.prev = 26;
                      if (!(!_iteratorNormalCompletion && _iterator.return != null)) {
                        _context11.next = 30;
                        break;
                      }
                      _context11.next = 30;
                      return _iterator.return();
                    case 30:
                      _context11.prev = 30;
                      if (!_didIteratorError) {
                        _context11.next = 33;
                        break;
                      }
                      throw _iteratorError;
                    case 33:
                      return _context11.finish(30);
                    case 34:
                      return _context11.finish(25);
                    case 35:
                      return _context11.abrupt("return", this.load(Buffer.concat(chunks), options));
                    case 36:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this, [[4, 21, 25, 35], [26, , 30, 34]]);
            }));
            function read(_x32, _x33) {
              return _read.apply(this, arguments);
            }
            return read;
          }() }, {
            key: "load",
            value: function() {
              var _load = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee12(data, options) {
                var buffer, model, zip, _i, _Object$values, entry, entryName, stream, content, chunkSize, i, workbook, appXform, appProperties, coreXform, coreProperties, match;
                return regenerator.wrap(function _callee12$(_context12) {
                  while (1) {
                    switch (_context12.prev = _context12.next) {
                      case 0:
                        if (options && options.base64) {
                          buffer = Buffer.from(data.toString(), "base64");
                        } else {
                          buffer = data;
                        }
                        model = { worksheets: [], worksheetHash: {}, worksheetRels: [], themes: {}, media: [], mediaIndex: {}, drawings: {}, drawingRels: {}, comments: {}, tables: {}, vmlDrawings: {} };
                        _context12.next = 4;
                        return JSZip.loadAsync(buffer);
                      case 4:
                        zip = _context12.sent;
                        _i = 0, _Object$values = Object.values(zip.files);
                      case 6:
                        if (!(_i < _Object$values.length)) {
                          _context12.next = 126;
                          break;
                        }
                        entry = _Object$values[_i];
                        if (entry.dir) {
                          _context12.next = 123;
                          break;
                        }
                        entryName = entry.name;
                        if (entryName[0] === "/") {
                          entryName = entryName.substr(1);
                        }
                        stream = void 0;
                        if (!(entryName.match(/xl\/media\//) || // themes are not parsed as stream
                        entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/))) {
                          _context12.next = 21;
                          break;
                        }
                        stream = new PassThrough();
                        _context12.t0 = stream;
                        _context12.next = 17;
                        return entry.async("nodebuffer");
                      case 17:
                        _context12.t1 = _context12.sent;
                        _context12.t0.write.call(_context12.t0, _context12.t1);
                        _context12.next = 36;
                        break;
                      case 21:
                        stream = new PassThrough({ writableObjectMode: true, readableObjectMode: true });
                        content = void 0;
                        if (!process.browser) {
                          _context12.next = 31;
                          break;
                        }
                        _context12.t2 = bufferToString;
                        _context12.next = 27;
                        return entry.async("nodebuffer");
                      case 27:
                        _context12.t3 = _context12.sent;
                        content = (0, _context12.t2)(_context12.t3);
                        _context12.next = 34;
                        break;
                      case 31:
                        _context12.next = 33;
                        return entry.async("string");
                      case 33:
                        content = _context12.sent;
                      case 34:
                        chunkSize = 16 * 1024;
                        for (i = 0; i < content.length; i += chunkSize) {
                          stream.write(content.substring(i, i + chunkSize));
                        }
                      case 36:
                        stream.end();
                        _context12.t4 = entryName;
                        _context12.next = _context12.t4 === "_rels/.rels" ? 40 : _context12.t4 === "xl/workbook.xml" ? 44 : _context12.t4 === "xl/_rels/workbook.xml.rels" ? 53 : _context12.t4 === "xl/sharedStrings.xml" ? 57 : _context12.t4 === "xl/styles.xml" ? 61 : _context12.t4 === "docProps/app.xml" ? 65 : _context12.t4 === "docProps/core.xml" ? 72 : 78;
                        break;
                      case 40:
                        _context12.next = 42;
                        return this.parseRels(stream);
                      case 42:
                        model.globalRels = _context12.sent;
                        return _context12.abrupt("break", 123);
                      case 44:
                        _context12.next = 46;
                        return this.parseWorkbook(stream);
                      case 46:
                        workbook = _context12.sent;
                        model.sheets = workbook.sheets;
                        model.definedNames = workbook.definedNames;
                        model.views = workbook.views;
                        model.properties = workbook.properties;
                        model.calcProperties = workbook.calcProperties;
                        return _context12.abrupt("break", 123);
                      case 53:
                        _context12.next = 55;
                        return this.parseRels(stream);
                      case 55:
                        model.workbookRels = _context12.sent;
                        return _context12.abrupt("break", 123);
                      case 57:
                        model.sharedStrings = new SharedStringsXform();
                        _context12.next = 60;
                        return model.sharedStrings.parseStream(stream);
                      case 60:
                        return _context12.abrupt("break", 123);
                      case 61:
                        model.styles = new StylesXform();
                        _context12.next = 64;
                        return model.styles.parseStream(stream);
                      case 64:
                        return _context12.abrupt("break", 123);
                      case 65:
                        appXform = new AppXform();
                        _context12.next = 68;
                        return appXform.parseStream(stream);
                      case 68:
                        appProperties = _context12.sent;
                        model.company = appProperties.company;
                        model.manager = appProperties.manager;
                        return _context12.abrupt("break", 123);
                      case 72:
                        coreXform = new CoreXform();
                        _context12.next = 75;
                        return coreXform.parseStream(stream);
                      case 75:
                        coreProperties = _context12.sent;
                        Object.assign(model, coreProperties);
                        return _context12.abrupt("break", 123);
                      case 78:
                        match = entryName.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
                        if (!match) {
                          _context12.next = 83;
                          break;
                        }
                        _context12.next = 82;
                        return this._processWorksheetEntry(stream, model, match[1], options, entryName);
                      case 82:
                        return _context12.abrupt("break", 123);
                      case 83:
                        match = entryName.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/);
                        if (!match) {
                          _context12.next = 88;
                          break;
                        }
                        _context12.next = 87;
                        return this._processWorksheetRelsEntry(stream, model, match[1]);
                      case 87:
                        return _context12.abrupt("break", 123);
                      case 88:
                        match = entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/);
                        if (!match) {
                          _context12.next = 93;
                          break;
                        }
                        _context12.next = 92;
                        return this._processThemeEntry(stream, model, match[1]);
                      case 92:
                        return _context12.abrupt("break", 123);
                      case 93:
                        match = entryName.match(/xl\/media\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/);
                        if (!match) {
                          _context12.next = 98;
                          break;
                        }
                        _context12.next = 97;
                        return this._processMediaEntry(stream, model, match[1]);
                      case 97:
                        return _context12.abrupt("break", 123);
                      case 98:
                        match = entryName.match(/xl\/drawings\/([a-zA-Z0-9]+)[.]xml/);
                        if (!match) {
                          _context12.next = 103;
                          break;
                        }
                        _context12.next = 102;
                        return this._processDrawingEntry(stream, model, match[1]);
                      case 102:
                        return _context12.abrupt("break", 123);
                      case 103:
                        match = entryName.match(/xl\/(comments\d+)[.]xml/);
                        if (!match) {
                          _context12.next = 108;
                          break;
                        }
                        _context12.next = 107;
                        return this._processCommentEntry(stream, model, match[1]);
                      case 107:
                        return _context12.abrupt("break", 123);
                      case 108:
                        match = entryName.match(/xl\/tables\/(table\d+)[.]xml/);
                        if (!match) {
                          _context12.next = 113;
                          break;
                        }
                        _context12.next = 112;
                        return this._processTableEntry(stream, model, match[1]);
                      case 112:
                        return _context12.abrupt("break", 123);
                      case 113:
                        match = entryName.match(/xl\/drawings\/_rels\/([a-zA-Z0-9]+)[.]xml[.]rels/);
                        if (!match) {
                          _context12.next = 118;
                          break;
                        }
                        _context12.next = 117;
                        return this._processDrawingRelsEntry(stream, model, match[1]);
                      case 117:
                        return _context12.abrupt("break", 123);
                      case 118:
                        match = entryName.match(/xl\/drawings\/(vmlDrawing\d+)[.]vml/);
                        if (!match) {
                          _context12.next = 123;
                          break;
                        }
                        _context12.next = 122;
                        return this._processVmlDrawingEntry(stream, model, match[1]);
                      case 122:
                        return _context12.abrupt("break", 123);
                      case 123:
                        _i++;
                        _context12.next = 6;
                        break;
                      case 126:
                        this.reconcile(model, options);
                        this.workbook.model = model;
                        return _context12.abrupt("return", this.workbook);
                      case 129:
                      case "end":
                        return _context12.stop();
                    }
                  }
                }, _callee12, this);
              }));
              function load(_x34, _x35) {
                return _load.apply(this, arguments);
              }
              return load;
            }()
            // =========================================================================
            // Write
          }, { key: "addMedia", value: function() {
            var _addMedia = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee14(zip, model) {
              return regenerator.wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      _context14.next = 2;
                      return Promise.all(model.media.map(/* @__PURE__ */ function() {
                        var _ref = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee13(medium) {
                          var filename, data, dataimg64, content;
                          return regenerator.wrap(function _callee13$(_context13) {
                            while (1) {
                              switch (_context13.prev = _context13.next) {
                                case 0:
                                  if (!(medium.type === "image")) {
                                    _context13.next = 13;
                                    break;
                                  }
                                  filename = "xl/media/".concat(medium.name, ".").concat(medium.extension);
                                  if (!medium.filename) {
                                    _context13.next = 7;
                                    break;
                                  }
                                  _context13.next = 5;
                                  return fsReadFileAsync(medium.filename);
                                case 5:
                                  data = _context13.sent;
                                  return _context13.abrupt("return", zip.append(data, { name: filename }));
                                case 7:
                                  if (!medium.buffer) {
                                    _context13.next = 9;
                                    break;
                                  }
                                  return _context13.abrupt("return", zip.append(medium.buffer, { name: filename }));
                                case 9:
                                  if (!medium.base64) {
                                    _context13.next = 13;
                                    break;
                                  }
                                  dataimg64 = medium.base64;
                                  content = dataimg64.substring(dataimg64.indexOf(",") + 1);
                                  return _context13.abrupt("return", zip.append(content, { name: filename, base64: true }));
                                case 13:
                                  throw new Error("Unsupported media");
                                case 14:
                                case "end":
                                  return _context13.stop();
                              }
                            }
                          }, _callee13);
                        }));
                        return function(_x38) {
                          return _ref.apply(this, arguments);
                        };
                      }()));
                    case 2:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14);
            }));
            function addMedia(_x36, _x37) {
              return _addMedia.apply(this, arguments);
            }
            return addMedia;
          }() }, { key: "addDrawings", value: function addDrawings(zip, model) {
            var drawingXform = new DrawingXform();
            var relsXform = new RelationshipsXform();
            model.worksheets.forEach(function(worksheet) {
              var drawing = worksheet.drawing;
              if (drawing) {
                drawingXform.prepare(drawing, {});
                var xml = drawingXform.toXml(drawing);
                zip.append(xml, { name: "xl/drawings/".concat(drawing.name, ".xml") });
                xml = relsXform.toXml(drawing.rels);
                zip.append(xml, { name: "xl/drawings/_rels/".concat(drawing.name, ".xml.rels") });
              }
            });
          } }, { key: "addTables", value: function addTables(zip, model) {
            var tableXform = new TableXform();
            model.worksheets.forEach(function(worksheet) {
              var tables = worksheet.tables;
              tables.forEach(function(table) {
                tableXform.prepare(table, {});
                var tableXml = tableXform.toXml(table);
                zip.append(tableXml, { name: "xl/tables/".concat(table.target) });
              });
            });
          } }, { key: "addContentTypes", value: function() {
            var _addContentTypes = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee15(zip, model) {
              var xform, xml;
              return regenerator.wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      xform = new ContentTypesXform();
                      xml = xform.toXml(model);
                      zip.append(xml, { name: "[Content_Types].xml" });
                    case 3:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15);
            }));
            function addContentTypes(_x39, _x40) {
              return _addContentTypes.apply(this, arguments);
            }
            return addContentTypes;
          }() }, { key: "addApp", value: function() {
            var _addApp = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee16(zip, model) {
              var xform, xml;
              return regenerator.wrap(function _callee16$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      xform = new AppXform();
                      xml = xform.toXml(model);
                      zip.append(xml, { name: "docProps/app.xml" });
                    case 3:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee16);
            }));
            function addApp(_x41, _x42) {
              return _addApp.apply(this, arguments);
            }
            return addApp;
          }() }, { key: "addCore", value: function() {
            var _addCore = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee17(zip, model) {
              var coreXform;
              return regenerator.wrap(function _callee17$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      coreXform = new CoreXform();
                      zip.append(coreXform.toXml(model), { name: "docProps/core.xml" });
                    case 2:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee17);
            }));
            function addCore(_x43, _x44) {
              return _addCore.apply(this, arguments);
            }
            return addCore;
          }() }, { key: "addThemes", value: function() {
            var _addThemes = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee18(zip, model) {
              var themes;
              return regenerator.wrap(function _callee18$(_context18) {
                while (1) {
                  switch (_context18.prev = _context18.next) {
                    case 0:
                      themes = model.themes || { theme1: theme1Xml };
                      Object.keys(themes).forEach(function(name) {
                        var xml = themes[name];
                        var path = "xl/theme/".concat(name, ".xml");
                        zip.append(xml, { name: path });
                      });
                    case 2:
                    case "end":
                      return _context18.stop();
                  }
                }
              }, _callee18);
            }));
            function addThemes(_x45, _x46) {
              return _addThemes.apply(this, arguments);
            }
            return addThemes;
          }() }, { key: "addOfficeRels", value: function() {
            var _addOfficeRels = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee19(zip) {
              var xform, xml;
              return regenerator.wrap(function _callee19$(_context19) {
                while (1) {
                  switch (_context19.prev = _context19.next) {
                    case 0:
                      xform = new RelationshipsXform();
                      xml = xform.toXml([{ Id: "rId1", Type: XLSX2.RelType.OfficeDocument, Target: "xl/workbook.xml" }, { Id: "rId2", Type: XLSX2.RelType.CoreProperties, Target: "docProps/core.xml" }, { Id: "rId3", Type: XLSX2.RelType.ExtenderProperties, Target: "docProps/app.xml" }]);
                      zip.append(xml, { name: "_rels/.rels" });
                    case 3:
                    case "end":
                      return _context19.stop();
                  }
                }
              }, _callee19);
            }));
            function addOfficeRels(_x47) {
              return _addOfficeRels.apply(this, arguments);
            }
            return addOfficeRels;
          }() }, { key: "addWorkbookRels", value: function() {
            var _addWorkbookRels = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee20(zip, model) {
              var count, relationships, xform, xml;
              return regenerator.wrap(function _callee20$(_context20) {
                while (1) {
                  switch (_context20.prev = _context20.next) {
                    case 0:
                      count = 1;
                      relationships = [{ Id: "rId".concat(count++), Type: XLSX2.RelType.Styles, Target: "styles.xml" }, { Id: "rId".concat(count++), Type: XLSX2.RelType.Theme, Target: "theme/theme1.xml" }];
                      if (model.sharedStrings.count) {
                        relationships.push({ Id: "rId".concat(count++), Type: XLSX2.RelType.SharedStrings, Target: "sharedStrings.xml" });
                      }
                      model.worksheets.forEach(function(worksheet) {
                        worksheet.rId = "rId".concat(count++);
                        relationships.push({ Id: worksheet.rId, Type: XLSX2.RelType.Worksheet, Target: "worksheets/sheet".concat(worksheet.id, ".xml") });
                      });
                      xform = new RelationshipsXform();
                      xml = xform.toXml(relationships);
                      zip.append(xml, { name: "xl/_rels/workbook.xml.rels" });
                    case 7:
                    case "end":
                      return _context20.stop();
                  }
                }
              }, _callee20);
            }));
            function addWorkbookRels(_x48, _x49) {
              return _addWorkbookRels.apply(this, arguments);
            }
            return addWorkbookRels;
          }() }, { key: "addSharedStrings", value: function() {
            var _addSharedStrings = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee21(zip, model) {
              return regenerator.wrap(function _callee21$(_context21) {
                while (1) {
                  switch (_context21.prev = _context21.next) {
                    case 0:
                      if (model.sharedStrings && model.sharedStrings.count) {
                        zip.append(model.sharedStrings.xml, { name: "xl/sharedStrings.xml" });
                      }
                    case 1:
                    case "end":
                      return _context21.stop();
                  }
                }
              }, _callee21);
            }));
            function addSharedStrings(_x50, _x51) {
              return _addSharedStrings.apply(this, arguments);
            }
            return addSharedStrings;
          }() }, { key: "addStyles", value: function() {
            var _addStyles = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee22(zip, model) {
              var xml;
              return regenerator.wrap(function _callee22$(_context22) {
                while (1) {
                  switch (_context22.prev = _context22.next) {
                    case 0:
                      xml = model.styles.xml;
                      if (xml) {
                        zip.append(xml, { name: "xl/styles.xml" });
                      }
                    case 2:
                    case "end":
                      return _context22.stop();
                  }
                }
              }, _callee22);
            }));
            function addStyles(_x52, _x53) {
              return _addStyles.apply(this, arguments);
            }
            return addStyles;
          }() }, { key: "addWorkbook", value: function() {
            var _addWorkbook = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee23(zip, model) {
              var xform;
              return regenerator.wrap(function _callee23$(_context23) {
                while (1) {
                  switch (_context23.prev = _context23.next) {
                    case 0:
                      xform = new WorkbookXform();
                      zip.append(xform.toXml(model), { name: "xl/workbook.xml" });
                    case 2:
                    case "end":
                      return _context23.stop();
                  }
                }
              }, _callee23);
            }));
            function addWorkbook(_x54, _x55) {
              return _addWorkbook.apply(this, arguments);
            }
            return addWorkbook;
          }() }, { key: "addWorksheets", value: function() {
            var _addWorksheets = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee24(zip, model) {
              var worksheetXform, relationshipsXform, commentsXform, vmlNotesXform;
              return regenerator.wrap(function _callee24$(_context24) {
                while (1) {
                  switch (_context24.prev = _context24.next) {
                    case 0:
                      worksheetXform = new WorksheetXform();
                      relationshipsXform = new RelationshipsXform();
                      commentsXform = new CommentsXform();
                      vmlNotesXform = new VmlNotesXform();
                      model.worksheets.forEach(function(worksheet) {
                        var xmlStream = new XmlStream();
                        worksheetXform.render(xmlStream, worksheet);
                        zip.append(xmlStream.xml, { name: "xl/worksheets/sheet".concat(worksheet.id, ".xml") });
                        if (worksheet.rels && worksheet.rels.length) {
                          xmlStream = new XmlStream();
                          relationshipsXform.render(xmlStream, worksheet.rels);
                          zip.append(xmlStream.xml, { name: "xl/worksheets/_rels/sheet".concat(worksheet.id, ".xml.rels") });
                        }
                        if (worksheet.comments.length > 0) {
                          xmlStream = new XmlStream();
                          commentsXform.render(xmlStream, worksheet);
                          zip.append(xmlStream.xml, { name: "xl/comments".concat(worksheet.id, ".xml") });
                          xmlStream = new XmlStream();
                          vmlNotesXform.render(xmlStream, worksheet);
                          zip.append(xmlStream.xml, { name: "xl/drawings/vmlDrawing".concat(worksheet.id, ".vml") });
                        }
                      });
                    case 5:
                    case "end":
                      return _context24.stop();
                  }
                }
              }, _callee24);
            }));
            function addWorksheets(_x56, _x57) {
              return _addWorksheets.apply(this, arguments);
            }
            return addWorksheets;
          }() }, { key: "_finalize", value: function _finalize(zip) {
            var _this = this;
            return new Promise(function(resolve, reject) {
              zip.on("finish", function() {
                resolve(_this);
              });
              zip.on("error", reject);
              zip.finalize();
            });
          } }, { key: "prepareModel", value: function prepareModel(model, options) {
            model.creator = model.creator || "ExcelJS";
            model.lastModifiedBy = model.lastModifiedBy || "ExcelJS";
            model.created = model.created || /* @__PURE__ */ new Date();
            model.modified = model.modified || /* @__PURE__ */ new Date();
            model.useSharedStrings = options.useSharedStrings !== void 0 ? options.useSharedStrings : true;
            model.useStyles = options.useStyles !== void 0 ? options.useStyles : true;
            model.sharedStrings = new SharedStringsXform();
            model.styles = model.useStyles ? new StylesXform(true) : new StylesXform.Mock();
            var workbookXform = new WorkbookXform();
            var worksheetXform = new WorksheetXform();
            workbookXform.prepare(model);
            var worksheetOptions = { sharedStrings: model.sharedStrings, styles: model.styles, date1904: model.properties.date1904, drawingsCount: 0, media: model.media };
            worksheetOptions.drawings = model.drawings = [];
            worksheetOptions.commentRefs = model.commentRefs = [];
            var tableCount = 0;
            model.tables = [];
            model.worksheets.forEach(function(worksheet) {
              worksheet.tables.forEach(function(table) {
                tableCount++;
                table.target = "table".concat(tableCount, ".xml");
                table.id = tableCount;
                model.tables.push(table);
              });
              worksheetXform.prepare(worksheet, worksheetOptions);
            });
          } }, { key: "write", value: function() {
            var _write = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee25(stream, options) {
              var model, zip;
              return regenerator.wrap(function _callee25$(_context25) {
                while (1) {
                  switch (_context25.prev = _context25.next) {
                    case 0:
                      options = options || {};
                      model = this.workbook.model;
                      zip = new ZipStream.ZipWriter(options.zip);
                      zip.pipe(stream);
                      this.prepareModel(model, options);
                      _context25.next = 7;
                      return this.addContentTypes(zip, model);
                    case 7:
                      _context25.next = 9;
                      return this.addOfficeRels(zip, model);
                    case 9:
                      _context25.next = 11;
                      return this.addWorkbookRels(zip, model);
                    case 11:
                      _context25.next = 13;
                      return this.addWorksheets(zip, model);
                    case 13:
                      _context25.next = 15;
                      return this.addSharedStrings(zip, model);
                    case 15:
                      _context25.next = 17;
                      return this.addDrawings(zip, model);
                    case 17:
                      _context25.next = 19;
                      return this.addTables(zip, model);
                    case 19:
                      _context25.next = 21;
                      return Promise.all([this.addThemes(zip, model), this.addStyles(zip, model)]);
                    case 21:
                      _context25.next = 23;
                      return this.addMedia(zip, model);
                    case 23:
                      _context25.next = 25;
                      return Promise.all([this.addApp(zip, model), this.addCore(zip, model)]);
                    case 25:
                      _context25.next = 27;
                      return this.addWorkbook(zip, model);
                    case 27:
                      return _context25.abrupt("return", this._finalize(zip));
                    case 28:
                    case "end":
                      return _context25.stop();
                  }
                }
              }, _callee25, this);
            }));
            function write(_x58, _x59) {
              return _write.apply(this, arguments);
            }
            return write;
          }() }, { key: "writeFile", value: function writeFile(filename, options) {
            var _this2 = this;
            var stream = fs.createWriteStream(filename);
            return new Promise(function(resolve, reject) {
              stream.on("finish", function() {
                resolve();
              });
              stream.on("error", function(error) {
                reject(error);
              });
              _this2.write(stream, options).then(function() {
                stream.end();
              });
            });
          } }, { key: "writeBuffer", value: function() {
            var _writeBuffer = _asyncToGenerator2(/* @__PURE__ */ regenerator.mark(function _callee26(options) {
              var stream;
              return regenerator.wrap(function _callee26$(_context26) {
                while (1) {
                  switch (_context26.prev = _context26.next) {
                    case 0:
                      stream = new StreamBuf();
                      _context26.next = 3;
                      return this.write(stream, options);
                    case 3:
                      return _context26.abrupt("return", stream.read());
                    case 4:
                    case "end":
                      return _context26.stop();
                  }
                }
              }, _callee26, this);
            }));
            function writeBuffer(_x60) {
              return _writeBuffer.apply(this, arguments);
            }
            return writeBuffer;
          }() }]);
          return XLSX2;
        }();
        XLSX.RelType = require2("./rel-type");
        module2.exports = XLSX;
      }).call(this, require2("_process"), require2("buffer").Buffer);
    }, { "../utils/browser-buffer-decode": 16, "../utils/stream-buf": 23, "../utils/utils": 26, "../utils/xml-stream": 27, "../utils/zip-stream": 28, "./rel-type": 30, "./xform/book/workbook-xform": 37, "./xform/comment/comments-xform": 39, "./xform/comment/vml-notes-xform": 44, "./xform/core/app-xform": 50, "./xform/core/content-types-xform": 51, "./xform/core/core-xform": 52, "./xform/core/relationships-xform": 54, "./xform/drawing/drawing-xform": 61, "./xform/sheet/worksheet-xform": 114, "./xform/strings/shared-strings-xform": 123, "./xform/style/styles-xform": 134, "./xform/table/table-xform": 140, "./xml/theme1.js": 142, "_process": 467, "buffer": 216, "fs": 215, "jszip": 399, "readable-stream": 491 }], 142: [function(require2, module2, exports2) {
      module2.exports = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"> <a:themeElements> <a:clrScheme name="Office"> <a:dk1> <a:sysClr val="windowText" lastClr="000000"/> </a:dk1> <a:lt1> <a:sysClr val="window" lastClr="FFFFFF"/> </a:lt1> <a:dk2> <a:srgbClr val="1F497D"/> </a:dk2> <a:lt2> <a:srgbClr val="EEECE1"/> </a:lt2> <a:accent1> <a:srgbClr val="4F81BD"/> </a:accent1> <a:accent2> <a:srgbClr val="C0504D"/> </a:accent2> <a:accent3> <a:srgbClr val="9BBB59"/> </a:accent3> <a:accent4> <a:srgbClr val="8064A2"/> </a:accent4> <a:accent5> <a:srgbClr val="4BACC6"/> </a:accent5> <a:accent6> <a:srgbClr val="F79646"/> </a:accent6> <a:hlink> <a:srgbClr val="0000FF"/> </a:hlink> <a:folHlink> <a:srgbClr val="800080"/> </a:folHlink> </a:clrScheme> <a:fontScheme name="Office"> <a:majorFont> <a:latin typeface="Cambria"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface=" "/> <a:font script="Hang" typeface=" "/> <a:font script="Hans" typeface=""/> <a:font script="Hant" typeface=""/> <a:font script="Arab" typeface="Times New Roman"/> <a:font script="Hebr" typeface="Times New Roman"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="MoolBoran"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Times New Roman"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:majorFont> <a:minorFont> <a:latin typeface="Calibri"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface=" "/> <a:font script="Hang" typeface=" "/> <a:font script="Hans" typeface=""/> <a:font script="Hant" typeface=""/> <a:font script="Arab" typeface="Arial"/> <a:font script="Hebr" typeface="Arial"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="DaunPenh"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Arial"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name="Office"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="35000"> <a:schemeClr val="phClr"> <a:tint val="37000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="15000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="1"/> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="100000"/> <a:shade val="100000"/> <a:satMod val="130000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:shade val="100000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="0"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"> <a:shade val="95000"/> <a:satMod val="105000"/> </a:schemeClr> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="38000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst="orthographicFront"> <a:rot lat="0" lon="0" rev="0"/> </a:camera> <a:lightRig rig="threePt" dir="t"> <a:rot lat="0" lon="0" rev="1200000"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w="63500" h="25400"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="40000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="40000"> <a:schemeClr val="phClr"> <a:tint val="45000"/> <a:shade val="99000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="20000"/> <a:satMod val="255000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="-80000" r="50000" b="180000"/> </a:path> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="80000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="30000"/> <a:satMod val="200000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="50000" r="50000" b="50000"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="1"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="3"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="2"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="lt1"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="2"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="0"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="1"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="tx1"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>';
    }, {}], 143: [function(require2, module2, exports2) {
      (function(Buffer) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        function _classCallCheck2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties2(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _inherits2(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
          if (superClass)
            _setPrototypeOf2(subClass, superClass);
        }
        function _setPrototypeOf2(o, p) {
          _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf2(o, p);
        }
        function _createSuper2(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct2();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf2(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf2(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn2(this, result);
          };
        }
        function _possibleConstructorReturn2(self2, call) {
          if (call && (_typeof2(call) === "object" || typeof call === "function")) {
            return call;
          }
          return _assertThisInitialized2(self2);
        }
        function _assertThisInitialized2(self2) {
          if (self2 === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        function _isNativeReflectConstruct2() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            }));
            return true;
          } catch (e) {
            return false;
          }
        }
        function _getPrototypeOf2(o) {
          _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return _getPrototypeOf2(o);
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.CsvFormatterStream = void 0;
        var stream_1 = require2("stream");
        var formatter_1 = require2("./formatter");
        var CsvFormatterStream = /* @__PURE__ */ function(_stream_1$Transform) {
          _inherits2(CsvFormatterStream2, _stream_1$Transform);
          var _super = _createSuper2(CsvFormatterStream2);
          function CsvFormatterStream2(formatterOptions) {
            var _this;
            _classCallCheck2(this, CsvFormatterStream2);
            _this = _super.call(this, { writableObjectMode: formatterOptions.objectMode });
            _this.hasWrittenBOM = false;
            _this.formatterOptions = formatterOptions;
            _this.rowFormatter = new formatter_1.RowFormatter(formatterOptions);
            _this.hasWrittenBOM = !formatterOptions.writeBOM;
            return _this;
          }
          _createClass2(CsvFormatterStream2, [{ key: "transform", value: function transform(transformFunction) {
            this.rowFormatter.rowTransform = transformFunction;
            return this;
          } }, { key: "_transform", value: function _transform(row, encoding, cb) {
            var _this2 = this;
            var cbCalled = false;
            try {
              if (!this.hasWrittenBOM) {
                this.push(this.formatterOptions.BOM);
                this.hasWrittenBOM = true;
              }
              this.rowFormatter.format(row, function(err, rows) {
                if (err) {
                  cbCalled = true;
                  return cb(err);
                }
                if (rows) {
                  rows.forEach(function(r) {
                    _this2.push(Buffer.from(r, "utf8"));
                  });
                }
                cbCalled = true;
                return cb();
              });
            } catch (e) {
              if (cbCalled) {
                throw e;
              }
              cb(e);
            }
          } }, { key: "_flush", value: function _flush(cb) {
            var _this3 = this;
            this.rowFormatter.finish(function(err, rows) {
              if (err) {
                return cb(err);
              }
              if (rows) {
                rows.forEach(function(r) {
                  _this3.push(Buffer.from(r, "utf8"));
                });
              }
              return cb();
            });
          } }]);
          return CsvFormatterStream2;
        }(stream_1.Transform);
        exports2.CsvFormatterStream = CsvFormatterStream;
      }).call(this, require2("buffer").Buffer);
    }, { "./formatter": 147, "buffer": 216, "stream": 506 }], 144: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FormatterOptions = void 0;
      var FormatterOptions = function FormatterOptions2() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        _classCallCheck2(this, FormatterOptions2);
        var _a;
        this.objectMode = true;
        this.delimiter = ",";
        this.rowDelimiter = "\n";
        this.quote = '"';
        this.escape = this.quote;
        this.quoteColumns = false;
        this.quoteHeaders = this.quoteColumns;
        this.headers = null;
        this.includeEndRowDelimiter = false;
        this.writeBOM = false;
        this.BOM = "\uFEFF";
        this.alwaysWriteHeaders = false;
        Object.assign(this, opts || {});
        if (typeof (opts === null || opts === void 0 ? void 0 : opts.quoteHeaders) === "undefined") {
          this.quoteHeaders = this.quoteColumns;
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.quote) === true) {
          this.quote = '"';
        } else if ((opts === null || opts === void 0 ? void 0 : opts.quote) === false) {
          this.quote = "";
        }
        if (typeof (opts === null || opts === void 0 ? void 0 : opts.escape) !== "string") {
          this.escape = this.quote;
        }
        this.shouldWriteHeaders = !!this.headers && ((_a = opts.writeHeaders) !== null && _a !== void 0 ? _a : true);
        this.headers = Array.isArray(this.headers) ? this.headers : null;
        this.escapedQuote = "".concat(this.escape).concat(this.quote);
      };
      exports2.FormatterOptions = FormatterOptions;
    }, {}], 145: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FieldFormatter = void 0;
      var lodash_isboolean_1 = __importDefault(require2("lodash.isboolean"));
      var lodash_isnil_1 = __importDefault(require2("lodash.isnil"));
      var lodash_escaperegexp_1 = __importDefault(require2("lodash.escaperegexp"));
      var FieldFormatter = /* @__PURE__ */ function() {
        function FieldFormatter2(formatterOptions) {
          _classCallCheck2(this, FieldFormatter2);
          this._headers = null;
          this.formatterOptions = formatterOptions;
          if (formatterOptions.headers !== null) {
            this.headers = formatterOptions.headers;
          }
          this.REPLACE_REGEXP = new RegExp(formatterOptions.quote, "g");
          var escapePattern = "[".concat(formatterOptions.delimiter).concat(lodash_escaperegexp_1.default(formatterOptions.rowDelimiter), "|\r|\n']");
          this.ESCAPE_REGEXP = new RegExp(escapePattern);
        }
        _createClass2(FieldFormatter2, [{ key: "shouldQuote", value: function shouldQuote(fieldIndex, isHeader) {
          var quoteConfig = isHeader ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;
          if (lodash_isboolean_1.default(quoteConfig)) {
            return quoteConfig;
          }
          if (Array.isArray(quoteConfig)) {
            return quoteConfig[fieldIndex];
          }
          if (this._headers !== null) {
            return quoteConfig[this._headers[fieldIndex]];
          }
          return false;
        } }, { key: "format", value: function format(field, fieldIndex, isHeader) {
          var preparedField = "".concat(lodash_isnil_1.default(field) ? "" : field).replace(/\0/g, "");
          var formatterOptions = this.formatterOptions;
          if (formatterOptions.quote !== "") {
            var shouldEscape = preparedField.indexOf(formatterOptions.quote) !== -1;
            if (shouldEscape) {
              return this.quoteField(preparedField.replace(this.REPLACE_REGEXP, formatterOptions.escapedQuote));
            }
          }
          var hasEscapeCharacters = preparedField.search(this.ESCAPE_REGEXP) !== -1;
          if (hasEscapeCharacters || this.shouldQuote(fieldIndex, isHeader)) {
            return this.quoteField(preparedField);
          }
          return preparedField;
        } }, { key: "quoteField", value: function quoteField(field) {
          var quote = this.formatterOptions.quote;
          return "".concat(quote).concat(field).concat(quote);
        } }, { key: "headers", set: function set(headers) {
          this._headers = headers;
        } }]);
        return FieldFormatter2;
      }();
      exports2.FieldFormatter = FieldFormatter;
    }, { "lodash.escaperegexp": 426, "lodash.isboolean": 428, "lodash.isnil": 431 }], 146: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RowFormatter = void 0;
      var lodash_isfunction_1 = __importDefault(require2("lodash.isfunction"));
      var lodash_isequal_1 = __importDefault(require2("lodash.isequal"));
      var FieldFormatter_1 = require2("./FieldFormatter");
      var types_1 = require2("../types");
      var RowFormatter = /* @__PURE__ */ function() {
        function RowFormatter2(formatterOptions) {
          _classCallCheck2(this, RowFormatter2);
          this.rowCount = 0;
          this.formatterOptions = formatterOptions;
          this.fieldFormatter = new FieldFormatter_1.FieldFormatter(formatterOptions);
          this.headers = formatterOptions.headers;
          this.shouldWriteHeaders = formatterOptions.shouldWriteHeaders;
          this.hasWrittenHeaders = false;
          if (this.headers !== null) {
            this.fieldFormatter.headers = this.headers;
          }
          if (formatterOptions.transform) {
            this.rowTransform = formatterOptions.transform;
          }
        }
        _createClass2(RowFormatter2, [{ key: "format", value: function format(row, cb) {
          var _this = this;
          this.callTransformer(row, function(err, transformedRow) {
            if (err) {
              return cb(err);
            }
            if (!row) {
              return cb(null);
            }
            var rows = [];
            if (transformedRow) {
              var _this$checkHeaders = _this.checkHeaders(transformedRow), shouldFormatColumns = _this$checkHeaders.shouldFormatColumns, headers = _this$checkHeaders.headers;
              if (_this.shouldWriteHeaders && headers && !_this.hasWrittenHeaders) {
                rows.push(_this.formatColumns(headers, true));
                _this.hasWrittenHeaders = true;
              }
              if (shouldFormatColumns) {
                var columns = _this.gatherColumns(transformedRow);
                rows.push(_this.formatColumns(columns, false));
              }
            }
            return cb(null, rows);
          });
        } }, {
          key: "finish",
          value: function finish(cb) {
            var rows = [];
            if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {
              if (!this.headers) {
                return cb(new Error("`alwaysWriteHeaders` option is set to true but `headers` option not provided."));
              }
              rows.push(this.formatColumns(this.headers, true));
            }
            if (this.formatterOptions.includeEndRowDelimiter) {
              rows.push(this.formatterOptions.rowDelimiter);
            }
            return cb(null, rows);
          }
          // check if we need to write header return true if we should also write a row
          // could be false if headers is true and the header row(first item) is passed in
        }, {
          key: "checkHeaders",
          value: function checkHeaders(row) {
            if (this.headers) {
              return { shouldFormatColumns: true, headers: this.headers };
            }
            var headers = RowFormatter2.gatherHeaders(row);
            this.headers = headers;
            this.fieldFormatter.headers = headers;
            if (!this.shouldWriteHeaders) {
              return { shouldFormatColumns: true, headers: null };
            }
            return { shouldFormatColumns: !lodash_isequal_1.default(headers, row), headers };
          }
          // todo change this method to unknown[]
        }, { key: "gatherColumns", value: function gatherColumns(row) {
          if (this.headers === null) {
            throw new Error("Headers is currently null");
          }
          if (!Array.isArray(row)) {
            return this.headers.map(function(header) {
              return row[header];
            });
          }
          if (RowFormatter2.isHashArray(row)) {
            return this.headers.map(function(header, i) {
              var col = row[i];
              if (col) {
                return col[1];
              }
              return "";
            });
          }
          return this.headers.map(function(header, i) {
            return row[i];
          });
        } }, { key: "callTransformer", value: function callTransformer(row, cb) {
          if (!this._rowTransform) {
            return cb(null, row);
          }
          return this._rowTransform(row, cb);
        } }, { key: "formatColumns", value: function formatColumns(columns, isHeadersRow) {
          var _this2 = this;
          var formattedCols = columns.map(function(field, i) {
            return _this2.fieldFormatter.format(field, i, isHeadersRow);
          }).join(this.formatterOptions.delimiter);
          var rowCount = this.rowCount;
          this.rowCount += 1;
          if (rowCount) {
            return [this.formatterOptions.rowDelimiter, formattedCols].join("");
          }
          return formattedCols;
        } }, { key: "rowTransform", set: function set(transformFunction) {
          if (!lodash_isfunction_1.default(transformFunction)) {
            throw new TypeError("The transform should be a function");
          }
          this._rowTransform = RowFormatter2.createTransform(transformFunction);
        } }], [{
          key: "isHashArray",
          value: function isHashArray(row) {
            if (Array.isArray(row)) {
              return Array.isArray(row[0]) && row[0].length === 2;
            }
            return false;
          }
          // get headers from a row item
        }, { key: "gatherHeaders", value: function gatherHeaders(row) {
          if (RowFormatter2.isHashArray(row)) {
            return row.map(function(it) {
              return it[0];
            });
          }
          if (Array.isArray(row)) {
            return row;
          }
          return Object.keys(row);
        } }, { key: "createTransform", value: function createTransform(transformFunction) {
          if (types_1.isSyncTransform(transformFunction)) {
            return function(row, cb) {
              var transformedRow = null;
              try {
                transformedRow = transformFunction(row);
              } catch (e) {
                return cb(e);
              }
              return cb(null, transformedRow);
            };
          }
          return function(row, cb) {
            transformFunction(row, cb);
          };
        } }]);
        return RowFormatter2;
      }();
      exports2.RowFormatter = RowFormatter;
    }, { "../types": 149, "./FieldFormatter": 145, "lodash.isequal": 429, "lodash.isfunction": 430 }], 147: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      var RowFormatter_1 = require2("./RowFormatter");
      Object.defineProperty(exports2, "RowFormatter", { enumerable: true, get: function get() {
        return RowFormatter_1.RowFormatter;
      } });
      var FieldFormatter_1 = require2("./FieldFormatter");
      Object.defineProperty(exports2, "FieldFormatter", { enumerable: true, get: function get() {
        return FieldFormatter_1.FieldFormatter;
      } });
    }, { "./FieldFormatter": 145, "./RowFormatter": 146 }], 148: [function(require2, module2, exports2) {
      (function(Buffer) {
        var __createBinding = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          Object.defineProperty(o, k2, { enumerable: true, get: function get() {
            return m[k];
          } });
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        var __importStar = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null)
            for (var k in mod) {
              if (k !== "default" && Object.hasOwnProperty.call(mod, k))
                __createBinding(result, mod, k);
            }
          __setModuleDefault(result, mod);
          return result;
        };
        var __exportStar = function(m, exports3) {
          for (var p in m) {
            if (p !== "default" && !exports3.hasOwnProperty(p))
              __createBinding(exports3, m, p);
          }
        };
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.writeToPath = exports2.writeToString = exports2.writeToBuffer = exports2.writeToStream = exports2.write = exports2.format = void 0;
        var util_1 = require2("util");
        var stream_1 = require2("stream");
        var fs = __importStar(require2("fs"));
        var FormatterOptions_1 = require2("./FormatterOptions");
        var CsvFormatterStream_1 = require2("./CsvFormatterStream");
        __exportStar(require2("./types"), exports2);
        var CsvFormatterStream_2 = require2("./CsvFormatterStream");
        Object.defineProperty(exports2, "CsvFormatterStream", { enumerable: true, get: function get() {
          return CsvFormatterStream_2.CsvFormatterStream;
        } });
        var FormatterOptions_2 = require2("./FormatterOptions");
        Object.defineProperty(exports2, "FormatterOptions", { enumerable: true, get: function get() {
          return FormatterOptions_2.FormatterOptions;
        } });
        exports2.format = function(options) {
          return new CsvFormatterStream_1.CsvFormatterStream(new FormatterOptions_1.FormatterOptions(options));
        };
        exports2.write = function(rows, options) {
          var csvStream = exports2.format(options);
          var promiseWrite = util_1.promisify(function(row, cb) {
            csvStream.write(row, void 0, cb);
          });
          rows.reduce(function(prev, row) {
            return prev.then(function() {
              return promiseWrite(row);
            });
          }, Promise.resolve()).then(function() {
            return csvStream.end();
          }).catch(function(err) {
            csvStream.emit("error", err);
          });
          return csvStream;
        };
        exports2.writeToStream = function(ws, rows, options) {
          return exports2.write(rows, options).pipe(ws);
        };
        exports2.writeToBuffer = function(rows) {
          var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var buffers = [];
          var ws = new stream_1.Writable({ write: function write(data, enc, writeCb) {
            buffers.push(data);
            writeCb();
          } });
          return new Promise(function(res, rej) {
            ws.on("error", rej).on("finish", function() {
              return res(Buffer.concat(buffers));
            });
            exports2.write(rows, opts).pipe(ws);
          });
        };
        exports2.writeToString = function(rows, options) {
          return exports2.writeToBuffer(rows, options).then(function(buffer) {
            return buffer.toString();
          });
        };
        exports2.writeToPath = function(path, rows, options) {
          var stream = fs.createWriteStream(path, { encoding: "utf8" });
          return exports2.write(rows, options).pipe(stream);
        };
      }).call(this, require2("buffer").Buffer);
    }, { "./CsvFormatterStream": 143, "./FormatterOptions": 144, "./types": 149, "buffer": 216, "fs": 215, "stream": 506, "util": 525 }], 149: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isSyncTransform = void 0;
      exports2.isSyncTransform = function(transform) {
        return transform.length === 1;
      };
    }, {}], 150: [function(require2, module2, exports2) {
      (function(setImmediate) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        function _classCallCheck2(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties2(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass2(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties2(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties2(Constructor, staticProps);
          return Constructor;
        }
        function _get2(target, property, receiver) {
          if (typeof Reflect !== "undefined" && Reflect.get) {
            _get2 = Reflect.get;
          } else {
            _get2 = function _get3(target2, property2, receiver2) {
              var base = _superPropBase2(target2, property2);
              if (!base)
                return;
              var desc = Object.getOwnPropertyDescriptor(base, property2);
              if (desc.get) {
                return desc.get.call(receiver2);
              }
              return desc.value;
            };
          }
          return _get2(target, property, receiver || target);
        }
        function _superPropBase2(object, property) {
          while (!Object.prototype.hasOwnProperty.call(object, property)) {
            object = _getPrototypeOf2(object);
            if (object === null)
              break;
          }
          return object;
        }
        function _inherits2(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
          if (superClass)
            _setPrototypeOf2(subClass, superClass);
        }
        function _setPrototypeOf2(o, p) {
          _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf2(o, p);
        }
        function _createSuper2(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct2();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf2(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf2(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn2(this, result);
          };
        }
        function _possibleConstructorReturn2(self2, call) {
          if (call && (_typeof2(call) === "object" || typeof call === "function")) {
            return call;
          }
          return _assertThisInitialized2(self2);
        }
        function _assertThisInitialized2(self2) {
          if (self2 === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        function _isNativeReflectConstruct2() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            }));
            return true;
          } catch (e) {
            return false;
          }
        }
        function _getPrototypeOf2(o) {
          _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return _getPrototypeOf2(o);
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.CsvParserStream = void 0;
        var string_decoder_1 = require2("string_decoder");
        var stream_1 = require2("stream");
        var transforms_1 = require2("./transforms");
        var parser_1 = require2("./parser");
        var CsvParserStream = /* @__PURE__ */ function(_stream_1$Transform) {
          _inherits2(CsvParserStream2, _stream_1$Transform);
          var _super = _createSuper2(CsvParserStream2);
          function CsvParserStream2(parserOptions) {
            var _this;
            _classCallCheck2(this, CsvParserStream2);
            _this = _super.call(this, { objectMode: parserOptions.objectMode });
            _this.lines = "";
            _this.rowCount = 0;
            _this.parsedRowCount = 0;
            _this.parsedLineCount = 0;
            _this.endEmitted = false;
            _this.headersEmitted = false;
            _this.parserOptions = parserOptions;
            _this.parser = new parser_1.Parser(parserOptions);
            _this.headerTransformer = new transforms_1.HeaderTransformer(parserOptions);
            _this.decoder = new string_decoder_1.StringDecoder(parserOptions.encoding);
            _this.rowTransformerValidator = new transforms_1.RowTransformerValidator();
            return _this;
          }
          _createClass2(CsvParserStream2, [{ key: "transform", value: function transform(transformFunction) {
            this.rowTransformerValidator.rowTransform = transformFunction;
            return this;
          } }, {
            key: "validate",
            value: function validate(validateFunction) {
              this.rowTransformerValidator.rowValidator = validateFunction;
              return this;
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
          }, { key: "emit", value: function emit(event) {
            var _get22;
            if (event === "end") {
              if (!this.endEmitted) {
                this.endEmitted = true;
                _get2(_getPrototypeOf2(CsvParserStream2.prototype), "emit", this).call(this, "end", this.rowCount);
              }
              return false;
            }
            for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              rest[_key - 1] = arguments[_key];
            }
            return (_get22 = _get2(_getPrototypeOf2(CsvParserStream2.prototype), "emit", this)).call.apply(_get22, [this, event].concat(rest));
          } }, { key: "_transform", value: function _transform(data, encoding, done) {
            if (this.hasHitRowLimit) {
              return done();
            }
            try {
              var lines = this.lines;
              var newLine = lines + this.decoder.write(data);
              var rows = this.parse(newLine, true);
              return this.processRows(rows, done);
            } catch (e) {
              return done(e);
            }
          } }, { key: "_flush", value: function _flush(done) {
            if (this.hasHitRowLimit) {
              return done();
            }
            try {
              var newLine = this.lines + this.decoder.end();
              var rows = this.parse(newLine, false);
              return this.processRows(rows, done);
            } catch (e) {
              return done(e);
            }
          } }, { key: "parse", value: function parse(data, hasMoreData) {
            if (!data) {
              return [];
            }
            var _this$parser$parse = this.parser.parse(data, hasMoreData), line = _this$parser$parse.line, rows = _this$parser$parse.rows;
            this.lines = line;
            return rows;
          } }, { key: "processRows", value: function processRows(rows, cb) {
            var _this2 = this;
            var rowsLength = rows.length;
            var iterate = function iterate2(i) {
              var callNext = function callNext2(err) {
                if (err) {
                  return cb(err);
                }
                if (i % 100 === 0) {
                  setImmediate(function() {
                    return iterate2(i + 1);
                  });
                  return void 0;
                }
                return iterate2(i + 1);
              };
              _this2.checkAndEmitHeaders();
              if (i >= rowsLength || _this2.hasHitRowLimit) {
                return cb();
              }
              _this2.parsedLineCount += 1;
              if (_this2.shouldSkipLine) {
                return callNext();
              }
              var row = rows[i];
              _this2.rowCount += 1;
              _this2.parsedRowCount += 1;
              var nextRowCount = _this2.rowCount;
              return _this2.transformRow(row, function(err, transformResult) {
                if (err) {
                  _this2.rowCount -= 1;
                  return callNext(err);
                }
                if (!transformResult) {
                  return callNext(new Error("expected transform result"));
                }
                if (!transformResult.isValid) {
                  _this2.emit("data-invalid", transformResult.row, nextRowCount, transformResult.reason);
                } else if (transformResult.row) {
                  return _this2.pushRow(transformResult.row, callNext);
                }
                return callNext();
              });
            };
            iterate(0);
          } }, { key: "transformRow", value: function transformRow(parsedRow, cb) {
            var _this3 = this;
            try {
              this.headerTransformer.transform(parsedRow, function(err, withHeaders) {
                if (err) {
                  return cb(err);
                }
                if (!withHeaders) {
                  return cb(new Error("Expected result from header transform"));
                }
                if (!withHeaders.isValid) {
                  if (_this3.shouldEmitRows) {
                    return cb(null, { isValid: false, row: parsedRow });
                  }
                  return _this3.skipRow(cb);
                }
                if (withHeaders.row) {
                  if (_this3.shouldEmitRows) {
                    return _this3.rowTransformerValidator.transformAndValidate(withHeaders.row, cb);
                  }
                  return _this3.skipRow(cb);
                }
                _this3.rowCount -= 1;
                _this3.parsedRowCount -= 1;
                return cb(null, { row: null, isValid: true });
              });
            } catch (e) {
              cb(e);
            }
          } }, { key: "checkAndEmitHeaders", value: function checkAndEmitHeaders() {
            if (!this.headersEmitted && this.headerTransformer.headers) {
              this.headersEmitted = true;
              this.emit("headers", this.headerTransformer.headers);
            }
          } }, { key: "skipRow", value: function skipRow(cb) {
            this.rowCount -= 1;
            return cb(null, { row: null, isValid: true });
          } }, { key: "pushRow", value: function pushRow(row, cb) {
            try {
              if (!this.parserOptions.objectMode) {
                this.push(JSON.stringify(row));
              } else {
                this.push(row);
              }
              cb();
            } catch (e) {
              cb(e);
            }
          } }, { key: "hasHitRowLimit", get: function get() {
            return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;
          } }, { key: "shouldEmitRows", get: function get() {
            return this.parsedRowCount > this.parserOptions.skipRows;
          } }, { key: "shouldSkipLine", get: function get() {
            return this.parsedLineCount <= this.parserOptions.skipLines;
          } }]);
          return CsvParserStream2;
        }(stream_1.Transform);
        exports2.CsvParserStream = CsvParserStream;
      }).call(this, require2("timers").setImmediate);
    }, { "./parser": 162, "./transforms": 165, "stream": 506, "string_decoder": 520, "timers": 521 }], 151: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ParserOptions = void 0;
      var lodash_escaperegexp_1 = __importDefault(require2("lodash.escaperegexp"));
      var lodash_isnil_1 = __importDefault(require2("lodash.isnil"));
      var ParserOptions = function ParserOptions2(opts) {
        _classCallCheck2(this, ParserOptions2);
        var _a;
        this.objectMode = true;
        this.delimiter = ",";
        this.ignoreEmpty = false;
        this.quote = '"';
        this.escape = null;
        this.escapeChar = this.quote;
        this.comment = null;
        this.supportsComments = false;
        this.ltrim = false;
        this.rtrim = false;
        this.trim = false;
        this.headers = null;
        this.renameHeaders = false;
        this.strictColumnHandling = false;
        this.discardUnmappedColumns = false;
        this.carriageReturn = "\r";
        this.encoding = "utf8";
        this.limitRows = false;
        this.maxRows = 0;
        this.skipLines = 0;
        this.skipRows = 0;
        Object.assign(this, opts || {});
        if (this.delimiter.length > 1) {
          throw new Error("delimiter option must be one character long");
        }
        this.escapedDelimiter = lodash_escaperegexp_1.default(this.delimiter);
        this.escapeChar = (_a = this.escape) !== null && _a !== void 0 ? _a : this.quote;
        this.supportsComments = !lodash_isnil_1.default(this.comment);
        this.NEXT_TOKEN_REGEXP = new RegExp("([^\\s]|\\r\\n|\\n|\\r|".concat(this.escapedDelimiter, ")"));
        if (this.maxRows > 0) {
          this.limitRows = true;
        }
      };
      exports2.ParserOptions = ParserOptions;
    }, { "lodash.escaperegexp": 426, "lodash.isnil": 431 }], 152: [function(require2, module2, exports2) {
      var __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function get() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      var __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null)
          for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
          }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = function(m, exports3) {
        for (var p in m) {
          if (p !== "default" && !exports3.hasOwnProperty(p))
            __createBinding(exports3, m, p);
        }
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseString = exports2.parseFile = exports2.parseStream = exports2.parse = void 0;
      var fs = __importStar(require2("fs"));
      var stream_1 = require2("stream");
      var ParserOptions_1 = require2("./ParserOptions");
      var CsvParserStream_1 = require2("./CsvParserStream");
      __exportStar(require2("./types"), exports2);
      var CsvParserStream_2 = require2("./CsvParserStream");
      Object.defineProperty(exports2, "CsvParserStream", { enumerable: true, get: function get() {
        return CsvParserStream_2.CsvParserStream;
      } });
      var ParserOptions_2 = require2("./ParserOptions");
      Object.defineProperty(exports2, "ParserOptions", { enumerable: true, get: function get() {
        return ParserOptions_2.ParserOptions;
      } });
      exports2.parse = function(args) {
        return new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(args));
      };
      exports2.parseStream = function(stream, options) {
        return stream.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
      };
      exports2.parseFile = function(location) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return fs.createReadStream(location).pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
      };
      exports2.parseString = function(string, options) {
        var rs = new stream_1.Readable();
        rs.push(string);
        rs.push(null);
        return rs.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
      };
    }, { "./CsvParserStream": 150, "./ParserOptions": 151, "./types": 166, "fs": 215, "stream": 506 }], 153: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Parser = void 0;
      var Scanner_1 = require2("./Scanner");
      var RowParser_1 = require2("./RowParser");
      var Token_1 = require2("./Token");
      var EMPTY_ROW_REGEXP = /^\s*(?:''|"")?\s*(?:,\s*(?:''|"")?\s*)*$/;
      var Parser = /* @__PURE__ */ function() {
        function Parser2(parserOptions) {
          _classCallCheck2(this, Parser2);
          this.parserOptions = parserOptions;
          this.rowParser = new RowParser_1.RowParser(this.parserOptions);
        }
        _createClass2(Parser2, [{ key: "parse", value: function parse(line, hasMoreData) {
          var scanner = new Scanner_1.Scanner({ line: Parser2.removeBOM(line), parserOptions: this.parserOptions, hasMoreData });
          if (this.parserOptions.supportsComments) {
            return this.parseWithComments(scanner);
          }
          return this.parseWithoutComments(scanner);
        } }, { key: "parseWithoutComments", value: function parseWithoutComments(scanner) {
          var rows = [];
          var shouldContinue = true;
          while (shouldContinue) {
            shouldContinue = this.parseRow(scanner, rows);
          }
          return { line: scanner.line, rows };
        } }, { key: "parseWithComments", value: function parseWithComments(scanner) {
          var parserOptions = this.parserOptions;
          var rows = [];
          for (var nextToken = scanner.nextCharacterToken; nextToken !== null; nextToken = scanner.nextCharacterToken) {
            if (Token_1.Token.isTokenComment(nextToken, parserOptions)) {
              var cursor = scanner.advancePastLine();
              if (cursor === null) {
                return { line: scanner.lineFromCursor, rows };
              }
              if (!scanner.hasMoreCharacters) {
                return { line: scanner.lineFromCursor, rows };
              }
              scanner.truncateToCursor();
            } else if (!this.parseRow(scanner, rows)) {
              break;
            }
          }
          return { line: scanner.line, rows };
        } }, { key: "parseRow", value: function parseRow(scanner, rows) {
          var nextToken = scanner.nextNonSpaceToken;
          if (!nextToken) {
            return false;
          }
          var row = this.rowParser.parse(scanner);
          if (row === null) {
            return false;
          }
          if (this.parserOptions.ignoreEmpty && EMPTY_ROW_REGEXP.test(row.join(""))) {
            return true;
          }
          rows.push(row);
          return true;
        } }], [{ key: "removeBOM", value: function removeBOM(line) {
          if (line && line.charCodeAt(0) === 65279) {
            return line.slice(1);
          }
          return line;
        } }]);
        return Parser2;
      }();
      exports2.Parser = Parser;
    }, { "./RowParser": 154, "./Scanner": 155, "./Token": 156 }], 154: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RowParser = void 0;
      var column_1 = require2("./column");
      var Token_1 = require2("./Token");
      var _Token_1$Token = Token_1.Token, isTokenRowDelimiter = _Token_1$Token.isTokenRowDelimiter, isTokenCarriageReturn = _Token_1$Token.isTokenCarriageReturn, isTokenDelimiter = _Token_1$Token.isTokenDelimiter;
      var RowParser = /* @__PURE__ */ function() {
        function RowParser2(parserOptions) {
          _classCallCheck2(this, RowParser2);
          this.parserOptions = parserOptions;
          this.columnParser = new column_1.ColumnParser(parserOptions);
        }
        _createClass2(RowParser2, [{ key: "parse", value: function parse(scanner) {
          var parserOptions = this.parserOptions;
          var hasMoreData = scanner.hasMoreData;
          var currentScanner = scanner;
          var columns = [];
          var currentToken = this.getStartToken(currentScanner, columns);
          while (currentToken) {
            if (isTokenRowDelimiter(currentToken)) {
              currentScanner.advancePastToken(currentToken);
              if (!currentScanner.hasMoreCharacters && isTokenCarriageReturn(currentToken, parserOptions) && hasMoreData) {
                return null;
              }
              currentScanner.truncateToCursor();
              return columns;
            }
            if (!this.shouldSkipColumnParse(currentScanner, currentToken, columns)) {
              var item = this.columnParser.parse(currentScanner);
              if (item === null) {
                return null;
              }
              columns.push(item);
            }
            currentToken = currentScanner.nextNonSpaceToken;
          }
          if (!hasMoreData) {
            currentScanner.truncateToCursor();
            return columns;
          }
          return null;
        } }, { key: "getStartToken", value: function getStartToken(scanner, columns) {
          var currentToken = scanner.nextNonSpaceToken;
          if (currentToken !== null && isTokenDelimiter(currentToken, this.parserOptions)) {
            columns.push("");
            return scanner.nextNonSpaceToken;
          }
          return currentToken;
        } }, { key: "shouldSkipColumnParse", value: function shouldSkipColumnParse(scanner, currentToken, columns) {
          var parserOptions = this.parserOptions;
          if (isTokenDelimiter(currentToken, parserOptions)) {
            scanner.advancePastToken(currentToken);
            var nextToken = scanner.nextCharacterToken;
            if (!scanner.hasMoreCharacters || nextToken !== null && isTokenRowDelimiter(nextToken)) {
              columns.push("");
              return true;
            }
            if (nextToken !== null && isTokenDelimiter(nextToken, parserOptions)) {
              columns.push("");
              return true;
            }
          }
          return false;
        } }]);
        return RowParser2;
      }();
      exports2.RowParser = RowParser;
    }, { "./Token": 156, "./column": 161 }], 155: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Scanner = void 0;
      var Token_1 = require2("./Token");
      var ROW_DELIMITER = /((?:\r\n)|\n|\r)/;
      var Scanner = /* @__PURE__ */ function() {
        function Scanner2(args) {
          _classCallCheck2(this, Scanner2);
          this.cursor = 0;
          this.line = args.line;
          this.lineLength = this.line.length;
          this.parserOptions = args.parserOptions;
          this.hasMoreData = args.hasMoreData;
          this.cursor = args.cursor || 0;
        }
        _createClass2(Scanner2, [{ key: "advancePastLine", value: function advancePastLine() {
          var match = ROW_DELIMITER.exec(this.lineFromCursor);
          if (!match) {
            if (this.hasMoreData) {
              return null;
            }
            this.cursor = this.lineLength;
            return this;
          }
          this.cursor += (match.index || 0) + match[0].length;
          return this;
        } }, { key: "advanceTo", value: function advanceTo(cursor) {
          this.cursor = cursor;
          return this;
        } }, { key: "advanceToToken", value: function advanceToToken(token) {
          this.cursor = token.startCursor;
          return this;
        } }, { key: "advancePastToken", value: function advancePastToken(token) {
          this.cursor = token.endCursor + 1;
          return this;
        } }, { key: "truncateToCursor", value: function truncateToCursor() {
          this.line = this.lineFromCursor;
          this.lineLength = this.line.length;
          this.cursor = 0;
          return this;
        } }, { key: "hasMoreCharacters", get: function get() {
          return this.lineLength > this.cursor;
        } }, { key: "nextNonSpaceToken", get: function get() {
          var lineFromCursor = this.lineFromCursor;
          var regex = this.parserOptions.NEXT_TOKEN_REGEXP;
          if (lineFromCursor.search(regex) === -1) {
            return null;
          }
          var match = regex.exec(lineFromCursor);
          if (match == null) {
            return null;
          }
          var token = match[1];
          var startCursor = this.cursor + (match.index || 0);
          return new Token_1.Token({ token, startCursor, endCursor: startCursor + token.length - 1 });
        } }, { key: "nextCharacterToken", get: function get() {
          var cursor = this.cursor, lineLength = this.lineLength;
          if (lineLength <= cursor) {
            return null;
          }
          return new Token_1.Token({ token: this.line[cursor], startCursor: cursor, endCursor: cursor });
        } }, { key: "lineFromCursor", get: function get() {
          return this.line.substr(this.cursor);
        } }]);
        return Scanner2;
      }();
      exports2.Scanner = Scanner;
    }, { "./Token": 156 }], 156: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Token = void 0;
      var Token = /* @__PURE__ */ function() {
        function Token2(tokenArgs) {
          _classCallCheck2(this, Token2);
          this.token = tokenArgs.token;
          this.startCursor = tokenArgs.startCursor;
          this.endCursor = tokenArgs.endCursor;
        }
        _createClass2(Token2, null, [{ key: "isTokenRowDelimiter", value: function isTokenRowDelimiter(token) {
          var content = token.token;
          return content === "\r" || content === "\n" || content === "\r\n";
        } }, { key: "isTokenCarriageReturn", value: function isTokenCarriageReturn(token, parserOptions) {
          return token.token === parserOptions.carriageReturn;
        } }, { key: "isTokenComment", value: function isTokenComment(token, parserOptions) {
          return parserOptions.supportsComments && !!token && token.token === parserOptions.comment;
        } }, { key: "isTokenEscapeCharacter", value: function isTokenEscapeCharacter(token, parserOptions) {
          return token.token === parserOptions.escapeChar;
        } }, { key: "isTokenQuote", value: function isTokenQuote(token, parserOptions) {
          return token.token === parserOptions.quote;
        } }, { key: "isTokenDelimiter", value: function isTokenDelimiter(token, parserOptions) {
          return token.token === parserOptions.delimiter;
        } }]);
        return Token2;
      }();
      exports2.Token = Token;
    }, {}], 157: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ColumnFormatter = void 0;
      var ColumnFormatter = function ColumnFormatter2(parserOptions) {
        _classCallCheck2(this, ColumnFormatter2);
        if (parserOptions.trim) {
          this.format = function(col) {
            return col.trim();
          };
        } else if (parserOptions.ltrim) {
          this.format = function(col) {
            return col.trimLeft();
          };
        } else if (parserOptions.rtrim) {
          this.format = function(col) {
            return col.trimRight();
          };
        } else {
          this.format = function(col) {
            return col;
          };
        }
      };
      exports2.ColumnFormatter = ColumnFormatter;
    }, {}], 158: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ColumnParser = void 0;
      var NonQuotedColumnParser_1 = require2("./NonQuotedColumnParser");
      var QuotedColumnParser_1 = require2("./QuotedColumnParser");
      var Token_1 = require2("../Token");
      var ColumnParser = /* @__PURE__ */ function() {
        function ColumnParser2(parserOptions) {
          _classCallCheck2(this, ColumnParser2);
          this.parserOptions = parserOptions;
          this.quotedColumnParser = new QuotedColumnParser_1.QuotedColumnParser(parserOptions);
          this.nonQuotedColumnParser = new NonQuotedColumnParser_1.NonQuotedColumnParser(parserOptions);
        }
        _createClass2(ColumnParser2, [{ key: "parse", value: function parse(scanner) {
          var nextNonSpaceToken = scanner.nextNonSpaceToken;
          if (nextNonSpaceToken !== null && Token_1.Token.isTokenQuote(nextNonSpaceToken, this.parserOptions)) {
            scanner.advanceToToken(nextNonSpaceToken);
            return this.quotedColumnParser.parse(scanner);
          }
          return this.nonQuotedColumnParser.parse(scanner);
        } }]);
        return ColumnParser2;
      }();
      exports2.ColumnParser = ColumnParser;
    }, { "../Token": 156, "./NonQuotedColumnParser": 159, "./QuotedColumnParser": 160 }], 159: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NonQuotedColumnParser = void 0;
      var ColumnFormatter_1 = require2("./ColumnFormatter");
      var Token_1 = require2("../Token");
      var _Token_1$Token = Token_1.Token, isTokenDelimiter = _Token_1$Token.isTokenDelimiter, isTokenRowDelimiter = _Token_1$Token.isTokenRowDelimiter;
      var NonQuotedColumnParser = /* @__PURE__ */ function() {
        function NonQuotedColumnParser2(parserOptions) {
          _classCallCheck2(this, NonQuotedColumnParser2);
          this.parserOptions = parserOptions;
          this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
        }
        _createClass2(NonQuotedColumnParser2, [{ key: "parse", value: function parse(scanner) {
          if (!scanner.hasMoreCharacters) {
            return null;
          }
          var parserOptions = this.parserOptions;
          var characters = [];
          var nextToken = scanner.nextCharacterToken;
          for (; nextToken; nextToken = scanner.nextCharacterToken) {
            if (isTokenDelimiter(nextToken, parserOptions) || isTokenRowDelimiter(nextToken)) {
              break;
            }
            characters.push(nextToken.token);
            scanner.advancePastToken(nextToken);
          }
          return this.columnFormatter.format(characters.join(""));
        } }]);
        return NonQuotedColumnParser2;
      }();
      exports2.NonQuotedColumnParser = NonQuotedColumnParser;
    }, { "../Token": 156, "./ColumnFormatter": 157 }], 160: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.QuotedColumnParser = void 0;
      var ColumnFormatter_1 = require2("./ColumnFormatter");
      var Token_1 = require2("../Token");
      var _Token_1$Token = Token_1.Token, isTokenDelimiter = _Token_1$Token.isTokenDelimiter, isTokenRowDelimiter = _Token_1$Token.isTokenRowDelimiter, isTokenEscapeCharacter = _Token_1$Token.isTokenEscapeCharacter, isTokenQuote = _Token_1$Token.isTokenQuote;
      var QuotedColumnParser = /* @__PURE__ */ function() {
        function QuotedColumnParser2(parserOptions) {
          _classCallCheck2(this, QuotedColumnParser2);
          this.parserOptions = parserOptions;
          this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
        }
        _createClass2(QuotedColumnParser2, [{ key: "parse", value: function parse(scanner) {
          if (!scanner.hasMoreCharacters) {
            return null;
          }
          var originalCursor = scanner.cursor;
          var _this$gatherDataBetwe = this.gatherDataBetweenQuotes(scanner), foundClosingQuote = _this$gatherDataBetwe.foundClosingQuote, col = _this$gatherDataBetwe.col;
          if (!foundClosingQuote) {
            scanner.advanceTo(originalCursor);
            if (!scanner.hasMoreData) {
              throw new Error("Parse Error: missing closing: '".concat(this.parserOptions.quote || "", "' in line: at '").concat(scanner.lineFromCursor.replace(/[\r\n]/g, "\\n'"), "'"));
            }
            return null;
          }
          this.checkForMalformedColumn(scanner);
          return col;
        } }, { key: "gatherDataBetweenQuotes", value: function gatherDataBetweenQuotes(scanner) {
          var parserOptions = this.parserOptions;
          var foundStartingQuote = false;
          var foundClosingQuote = false;
          var characters = [];
          var nextToken = scanner.nextCharacterToken;
          for (; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken) {
            var isQuote = isTokenQuote(nextToken, parserOptions);
            if (!foundStartingQuote && isQuote) {
              foundStartingQuote = true;
            } else if (foundStartingQuote) {
              if (isTokenEscapeCharacter(nextToken, parserOptions)) {
                scanner.advancePastToken(nextToken);
                var tokenFollowingEscape = scanner.nextCharacterToken;
                if (tokenFollowingEscape !== null && (isTokenQuote(tokenFollowingEscape, parserOptions) || isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {
                  characters.push(tokenFollowingEscape.token);
                  nextToken = tokenFollowingEscape;
                } else if (isQuote) {
                  foundClosingQuote = true;
                } else {
                  characters.push(nextToken.token);
                }
              } else if (isQuote) {
                foundClosingQuote = true;
              } else {
                characters.push(nextToken.token);
              }
            }
            scanner.advancePastToken(nextToken);
          }
          return { col: this.columnFormatter.format(characters.join("")), foundClosingQuote };
        } }, { key: "checkForMalformedColumn", value: function checkForMalformedColumn(scanner) {
          var parserOptions = this.parserOptions;
          var nextNonSpaceToken = scanner.nextNonSpaceToken;
          if (nextNonSpaceToken) {
            var isNextTokenADelimiter = isTokenDelimiter(nextNonSpaceToken, parserOptions);
            var isNextTokenARowDelimiter = isTokenRowDelimiter(nextNonSpaceToken);
            if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {
              var linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\r\n]/g, "\\n'");
              throw new Error("Parse Error: expected: '".concat(parserOptions.escapedDelimiter, "' OR new line got: '").concat(nextNonSpaceToken.token, "'. at '").concat(linePreview));
            }
            scanner.advanceToToken(nextNonSpaceToken);
          } else if (!scanner.hasMoreData) {
            scanner.advancePastLine();
          }
        } }]);
        return QuotedColumnParser2;
      }();
      exports2.QuotedColumnParser = QuotedColumnParser;
    }, { "../Token": 156, "./ColumnFormatter": 157 }], 161: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      var ColumnParser_1 = require2("./ColumnParser");
      Object.defineProperty(exports2, "ColumnParser", { enumerable: true, get: function get() {
        return ColumnParser_1.ColumnParser;
      } });
      var NonQuotedColumnParser_1 = require2("./NonQuotedColumnParser");
      Object.defineProperty(exports2, "NonQuotedColumnParser", { enumerable: true, get: function get() {
        return NonQuotedColumnParser_1.NonQuotedColumnParser;
      } });
      var QuotedColumnParser_1 = require2("./QuotedColumnParser");
      Object.defineProperty(exports2, "QuotedColumnParser", { enumerable: true, get: function get() {
        return QuotedColumnParser_1.QuotedColumnParser;
      } });
      var ColumnFormatter_1 = require2("./ColumnFormatter");
      Object.defineProperty(exports2, "ColumnFormatter", { enumerable: true, get: function get() {
        return ColumnFormatter_1.ColumnFormatter;
      } });
    }, { "./ColumnFormatter": 157, "./ColumnParser": 158, "./NonQuotedColumnParser": 159, "./QuotedColumnParser": 160 }], 162: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      var Parser_1 = require2("./Parser");
      Object.defineProperty(exports2, "Parser", { enumerable: true, get: function get() {
        return Parser_1.Parser;
      } });
      var RowParser_1 = require2("./RowParser");
      Object.defineProperty(exports2, "RowParser", { enumerable: true, get: function get() {
        return RowParser_1.RowParser;
      } });
      var Scanner_1 = require2("./Scanner");
      Object.defineProperty(exports2, "Scanner", { enumerable: true, get: function get() {
        return Scanner_1.Scanner;
      } });
      var Token_1 = require2("./Token");
      Object.defineProperty(exports2, "Token", { enumerable: true, get: function get() {
        return Token_1.Token;
      } });
      var column_1 = require2("./column");
      Object.defineProperty(exports2, "ColumnParser", { enumerable: true, get: function get() {
        return column_1.ColumnParser;
      } });
      Object.defineProperty(exports2, "NonQuotedColumnParser", { enumerable: true, get: function get() {
        return column_1.NonQuotedColumnParser;
      } });
      Object.defineProperty(exports2, "QuotedColumnParser", { enumerable: true, get: function get() {
        return column_1.QuotedColumnParser;
      } });
    }, { "./Parser": 153, "./RowParser": 154, "./Scanner": 155, "./Token": 156, "./column": 161 }], 163: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.HeaderTransformer = void 0;
      var lodash_isundefined_1 = __importDefault(require2("lodash.isundefined"));
      var lodash_isfunction_1 = __importDefault(require2("lodash.isfunction"));
      var lodash_uniq_1 = __importDefault(require2("lodash.uniq"));
      var lodash_groupby_1 = __importDefault(require2("lodash.groupby"));
      var HeaderTransformer = /* @__PURE__ */ function() {
        function HeaderTransformer2(parserOptions) {
          _classCallCheck2(this, HeaderTransformer2);
          this.headers = null;
          this.receivedHeaders = false;
          this.shouldUseFirstRow = false;
          this.processedFirstRow = false;
          this.headersLength = 0;
          this.parserOptions = parserOptions;
          if (parserOptions.headers === true) {
            this.shouldUseFirstRow = true;
          } else if (Array.isArray(parserOptions.headers)) {
            this.setHeaders(parserOptions.headers);
          } else if (lodash_isfunction_1.default(parserOptions.headers)) {
            this.headersTransform = parserOptions.headers;
          }
        }
        _createClass2(HeaderTransformer2, [{ key: "transform", value: function transform(row, cb) {
          if (!this.shouldMapRow(row)) {
            return cb(null, { row: null, isValid: true });
          }
          return cb(null, this.processRow(row));
        } }, { key: "shouldMapRow", value: function shouldMapRow(row) {
          var parserOptions = this.parserOptions;
          if (!this.headersTransform && parserOptions.renameHeaders && !this.processedFirstRow) {
            if (!this.receivedHeaders) {
              throw new Error("Error renaming headers: new headers must be provided in an array");
            }
            this.processedFirstRow = true;
            return false;
          }
          if (!this.receivedHeaders && Array.isArray(row)) {
            if (this.headersTransform) {
              this.setHeaders(this.headersTransform(row));
            } else if (this.shouldUseFirstRow) {
              this.setHeaders(row);
            } else {
              return true;
            }
            return false;
          }
          return true;
        } }, { key: "processRow", value: function processRow(row) {
          if (!this.headers) {
            return { row, isValid: true };
          }
          var parserOptions = this.parserOptions;
          if (!parserOptions.discardUnmappedColumns && row.length > this.headersLength) {
            if (!parserOptions.strictColumnHandling) {
              throw new Error("Unexpected Error: column header mismatch expected: ".concat(this.headersLength, " columns got: ").concat(row.length));
            }
            return { row, isValid: false, reason: "Column header mismatch expected: ".concat(this.headersLength, " columns got: ").concat(row.length) };
          }
          if (parserOptions.strictColumnHandling && row.length < this.headersLength) {
            return { row, isValid: false, reason: "Column header mismatch expected: ".concat(this.headersLength, " columns got: ").concat(row.length) };
          }
          return { row: this.mapHeaders(row), isValid: true };
        } }, { key: "mapHeaders", value: function mapHeaders(row) {
          var rowMap = {};
          var headers = this.headers, headersLength = this.headersLength;
          for (var i = 0; i < headersLength; i += 1) {
            var header = headers[i];
            if (!lodash_isundefined_1.default(header)) {
              var val = row[i];
              if (lodash_isundefined_1.default(val)) {
                rowMap[header] = "";
              } else {
                rowMap[header] = val;
              }
            }
          }
          return rowMap;
        } }, { key: "setHeaders", value: function setHeaders(headers) {
          var _a;
          var filteredHeaders = headers.filter(function(h3) {
            return !!h3;
          });
          if (lodash_uniq_1.default(filteredHeaders).length !== filteredHeaders.length) {
            var grouped = lodash_groupby_1.default(filteredHeaders);
            var duplicates = Object.keys(grouped).filter(function(dup) {
              return grouped[dup].length > 1;
            });
            throw new Error("Duplicate headers found ".concat(JSON.stringify(duplicates)));
          }
          this.headers = headers;
          this.receivedHeaders = true;
          this.headersLength = ((_a = this.headers) === null || _a === void 0 ? void 0 : _a.length) || 0;
        } }]);
        return HeaderTransformer2;
      }();
      exports2.HeaderTransformer = HeaderTransformer;
    }, { "lodash.groupby": 427, "lodash.isfunction": 430, "lodash.isundefined": 432, "lodash.uniq": 433 }], 164: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RowTransformerValidator = void 0;
      var lodash_isfunction_1 = __importDefault(require2("lodash.isfunction"));
      var types_1 = require2("../types");
      var RowTransformerValidator = /* @__PURE__ */ function() {
        function RowTransformerValidator2() {
          _classCallCheck2(this, RowTransformerValidator2);
          this._rowTransform = null;
          this._rowValidator = null;
        }
        _createClass2(RowTransformerValidator2, [{ key: "transformAndValidate", value: function transformAndValidate(row, cb) {
          var _this = this;
          return this.callTransformer(row, function(transformErr, transformedRow) {
            if (transformErr) {
              return cb(transformErr);
            }
            if (!transformedRow) {
              return cb(null, { row: null, isValid: true });
            }
            return _this.callValidator(transformedRow, function(validateErr, validationResult) {
              if (validateErr) {
                return cb(validateErr);
              }
              if (validationResult && !validationResult.isValid) {
                return cb(null, { row: transformedRow, isValid: false, reason: validationResult.reason });
              }
              return cb(null, { row: transformedRow, isValid: true });
            });
          });
        } }, { key: "callTransformer", value: function callTransformer(row, cb) {
          if (!this._rowTransform) {
            return cb(null, row);
          }
          return this._rowTransform(row, cb);
        } }, { key: "callValidator", value: function callValidator(row, cb) {
          if (!this._rowValidator) {
            return cb(null, { row, isValid: true });
          }
          return this._rowValidator(row, cb);
        } }, { key: "rowTransform", set: function set(transformFunction) {
          if (!lodash_isfunction_1.default(transformFunction)) {
            throw new TypeError("The transform should be a function");
          }
          this._rowTransform = RowTransformerValidator2.createTransform(transformFunction);
        } }, { key: "rowValidator", set: function set(validateFunction) {
          if (!lodash_isfunction_1.default(validateFunction)) {
            throw new TypeError("The validate should be a function");
          }
          this._rowValidator = RowTransformerValidator2.createValidator(validateFunction);
        } }], [{ key: "createTransform", value: function createTransform(transformFunction) {
          if (types_1.isSyncTransform(transformFunction)) {
            return function(row, cb) {
              var transformed = null;
              try {
                transformed = transformFunction(row);
              } catch (e) {
                return cb(e);
              }
              return cb(null, transformed);
            };
          }
          return transformFunction;
        } }, { key: "createValidator", value: function createValidator(validateFunction) {
          if (types_1.isSyncValidate(validateFunction)) {
            return function(row, cb) {
              cb(null, { row, isValid: validateFunction(row) });
            };
          }
          return function(row, cb) {
            validateFunction(row, function(err, isValid2, reason) {
              if (err) {
                return cb(err);
              }
              if (isValid2) {
                return cb(null, { row, isValid: isValid2, reason });
              }
              return cb(null, { row, isValid: false, reason });
            });
          };
        } }]);
        return RowTransformerValidator2;
      }();
      exports2.RowTransformerValidator = RowTransformerValidator;
    }, { "../types": 166, "lodash.isfunction": 430 }], 165: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      var RowTransformerValidator_1 = require2("./RowTransformerValidator");
      Object.defineProperty(exports2, "RowTransformerValidator", { enumerable: true, get: function get() {
        return RowTransformerValidator_1.RowTransformerValidator;
      } });
      var HeaderTransformer_1 = require2("./HeaderTransformer");
      Object.defineProperty(exports2, "HeaderTransformer", { enumerable: true, get: function get() {
        return HeaderTransformer_1.HeaderTransformer;
      } });
    }, { "./HeaderTransformer": 163, "./RowTransformerValidator": 164 }], 166: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isSyncValidate = exports2.isSyncTransform = void 0;
      exports2.isSyncTransform = function(transform) {
        return transform.length === 1;
      };
      exports2.isSyncValidate = function(validate) {
        return validate.length === 1;
      };
    }, {}], 167: [function(require2, module2, exports2) {
      var asn1 = exports2;
      asn1.bignum = require2("bn.js");
      asn1.define = require2("./asn1/api").define;
      asn1.base = require2("./asn1/base");
      asn1.constants = require2("./asn1/constants");
      asn1.decoders = require2("./asn1/decoders");
      asn1.encoders = require2("./asn1/encoders");
    }, { "./asn1/api": 168, "./asn1/base": 170, "./asn1/constants": 174, "./asn1/decoders": 176, "./asn1/encoders": 179, "bn.js": 181 }], 168: [function(require2, module2, exports2) {
      var encoders = require2("./encoders");
      var decoders = require2("./decoders");
      var inherits = require2("inherits");
      var api = exports2;
      api.define = function define(name, body) {
        return new Entity(name, body);
      };
      function Entity(name, body) {
        this.name = name;
        this.body = body;
        this.decoders = {};
        this.encoders = {};
      }
      Entity.prototype._createNamed = function createNamed(Base) {
        var name = this.name;
        function Generated(entity) {
          this._initNamed(entity, name);
        }
        inherits(Generated, Base);
        Generated.prototype._initNamed = function _initNamed(entity, name2) {
          Base.call(this, entity, name2);
        };
        return new Generated(this);
      };
      Entity.prototype._getDecoder = function _getDecoder(enc) {
        enc = enc || "der";
        if (!this.decoders.hasOwnProperty(enc))
          this.decoders[enc] = this._createNamed(decoders[enc]);
        return this.decoders[enc];
      };
      Entity.prototype.decode = function decode(data, enc, options) {
        return this._getDecoder(enc).decode(data, options);
      };
      Entity.prototype._getEncoder = function _getEncoder(enc) {
        enc = enc || "der";
        if (!this.encoders.hasOwnProperty(enc))
          this.encoders[enc] = this._createNamed(encoders[enc]);
        return this.encoders[enc];
      };
      Entity.prototype.encode = function encode(data, enc, reporter) {
        return this._getEncoder(enc).encode(data, reporter);
      };
    }, { "./decoders": 176, "./encoders": 179, "inherits": 387 }], 169: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var inherits = require2("inherits");
      var Reporter = require2("../base/reporter").Reporter;
      var Buffer = require2("safer-buffer").Buffer;
      function DecoderBuffer(base, options) {
        Reporter.call(this, options);
        if (!Buffer.isBuffer(base)) {
          this.error("Input not Buffer");
          return;
        }
        this.base = base;
        this.offset = 0;
        this.length = base.length;
      }
      inherits(DecoderBuffer, Reporter);
      exports2.DecoderBuffer = DecoderBuffer;
      DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
        if (data instanceof DecoderBuffer) {
          return true;
        }
        var isCompatible = _typeof2(data) === "object" && Buffer.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
        return isCompatible;
      };
      DecoderBuffer.prototype.save = function save() {
        return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
      };
      DecoderBuffer.prototype.restore = function restore(save) {
        var res = new DecoderBuffer(this.base);
        res.offset = save.offset;
        res.length = this.offset;
        this.offset = save.offset;
        Reporter.prototype.restore.call(this, save.reporter);
        return res;
      };
      DecoderBuffer.prototype.isEmpty = function isEmpty() {
        return this.offset === this.length;
      };
      DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
        if (this.offset + 1 <= this.length)
          return this.base.readUInt8(this.offset++, true);
        else
          return this.error(fail || "DecoderBuffer overrun");
      };
      DecoderBuffer.prototype.skip = function skip(bytes, fail) {
        if (!(this.offset + bytes <= this.length))
          return this.error(fail || "DecoderBuffer overrun");
        var res = new DecoderBuffer(this.base);
        res._reporterState = this._reporterState;
        res.offset = this.offset;
        res.length = this.offset + bytes;
        this.offset += bytes;
        return res;
      };
      DecoderBuffer.prototype.raw = function raw(save) {
        return this.base.slice(save ? save.offset : this.offset, this.length);
      };
      function EncoderBuffer(value, reporter) {
        if (Array.isArray(value)) {
          this.length = 0;
          this.value = value.map(function(item) {
            if (!EncoderBuffer.isEncoderBuffer(item))
              item = new EncoderBuffer(item, reporter);
            this.length += item.length;
            return item;
          }, this);
        } else if (typeof value === "number") {
          if (!(0 <= value && value <= 255))
            return reporter.error("non-byte EncoderBuffer value");
          this.value = value;
          this.length = 1;
        } else if (typeof value === "string") {
          this.value = value;
          this.length = Buffer.byteLength(value);
        } else if (Buffer.isBuffer(value)) {
          this.value = value;
          this.length = value.length;
        } else {
          return reporter.error("Unsupported type: " + _typeof2(value));
        }
      }
      exports2.EncoderBuffer = EncoderBuffer;
      EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
        if (data instanceof EncoderBuffer) {
          return true;
        }
        var isCompatible = _typeof2(data) === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
        return isCompatible;
      };
      EncoderBuffer.prototype.join = function join(out, offset) {
        if (!out)
          out = Buffer.alloc(this.length);
        if (!offset)
          offset = 0;
        if (this.length === 0)
          return out;
        if (Array.isArray(this.value)) {
          this.value.forEach(function(item) {
            item.join(out, offset);
            offset += item.length;
          });
        } else {
          if (typeof this.value === "number")
            out[offset] = this.value;
          else if (typeof this.value === "string")
            out.write(this.value, offset);
          else if (Buffer.isBuffer(this.value))
            this.value.copy(out, offset);
          offset += this.length;
        }
        return out;
      };
    }, { "../base/reporter": 172, "inherits": 387, "safer-buffer": 495 }], 170: [function(require2, module2, exports2) {
      var base = exports2;
      base.Reporter = require2("./reporter").Reporter;
      base.DecoderBuffer = require2("./buffer").DecoderBuffer;
      base.EncoderBuffer = require2("./buffer").EncoderBuffer;
      base.Node = require2("./node");
    }, { "./buffer": 169, "./node": 171, "./reporter": 172 }], 171: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var Reporter = require2("../base/reporter").Reporter;
      var EncoderBuffer = require2("../base/buffer").EncoderBuffer;
      var DecoderBuffer = require2("../base/buffer").DecoderBuffer;
      var assert = require2("minimalistic-assert");
      var tags = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"];
      var methods = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(tags);
      var overrided = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
      function Node(enc, parent, name) {
        var state = {};
        this._baseState = state;
        state.name = name;
        state.enc = enc;
        state.parent = parent || null;
        state.children = null;
        state.tag = null;
        state.args = null;
        state.reverseArgs = null;
        state.choice = null;
        state.optional = false;
        state.any = false;
        state.obj = false;
        state.use = null;
        state.useDecoder = null;
        state.key = null;
        state["default"] = null;
        state.explicit = null;
        state.implicit = null;
        state.contains = null;
        if (!state.parent) {
          state.children = [];
          this._wrap();
        }
      }
      module2.exports = Node;
      var stateProps = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
      Node.prototype.clone = function clone2() {
        var state = this._baseState;
        var cstate = {};
        stateProps.forEach(function(prop) {
          cstate[prop] = state[prop];
        });
        var res = new this.constructor(cstate.parent);
        res._baseState = cstate;
        return res;
      };
      Node.prototype._wrap = function wrap() {
        var state = this._baseState;
        methods.forEach(function(method) {
          this[method] = function _wrappedMethod() {
            var clone2 = new this.constructor(this);
            state.children.push(clone2);
            return clone2[method].apply(clone2, arguments);
          };
        }, this);
      };
      Node.prototype._init = function init(body) {
        var state = this._baseState;
        assert(state.parent === null);
        body.call(this);
        state.children = state.children.filter(function(child) {
          return child._baseState.parent === this;
        }, this);
        assert.equal(state.children.length, 1, "Root node can have only one child");
      };
      Node.prototype._useArgs = function useArgs(args) {
        var state = this._baseState;
        var children = args.filter(function(arg) {
          return arg instanceof this.constructor;
        }, this);
        args = args.filter(function(arg) {
          return !(arg instanceof this.constructor);
        }, this);
        if (children.length !== 0) {
          assert(state.children === null);
          state.children = children;
          children.forEach(function(child) {
            child._baseState.parent = this;
          }, this);
        }
        if (args.length !== 0) {
          assert(state.args === null);
          state.args = args;
          state.reverseArgs = args.map(function(arg) {
            if (_typeof2(arg) !== "object" || arg.constructor !== Object)
              return arg;
            var res = {};
            Object.keys(arg).forEach(function(key) {
              if (key == (key | 0))
                key |= 0;
              var value = arg[key];
              res[value] = key;
            });
            return res;
          });
        }
      };
      overrided.forEach(function(method) {
        Node.prototype[method] = function _overrided() {
          var state = this._baseState;
          throw new Error(method + " not implemented for encoding: " + state.enc);
        };
      });
      tags.forEach(function(tag) {
        Node.prototype[tag] = function _tagMethod() {
          var state = this._baseState;
          var args = Array.prototype.slice.call(arguments);
          assert(state.tag === null);
          state.tag = tag;
          this._useArgs(args);
          return this;
        };
      });
      Node.prototype.use = function use(item) {
        assert(item);
        var state = this._baseState;
        assert(state.use === null);
        state.use = item;
        return this;
      };
      Node.prototype.optional = function optional() {
        var state = this._baseState;
        state.optional = true;
        return this;
      };
      Node.prototype.def = function def(val) {
        var state = this._baseState;
        assert(state["default"] === null);
        state["default"] = val;
        state.optional = true;
        return this;
      };
      Node.prototype.explicit = function explicit(num) {
        var state = this._baseState;
        assert(state.explicit === null && state.implicit === null);
        state.explicit = num;
        return this;
      };
      Node.prototype.implicit = function implicit(num) {
        var state = this._baseState;
        assert(state.explicit === null && state.implicit === null);
        state.implicit = num;
        return this;
      };
      Node.prototype.obj = function obj() {
        var state = this._baseState;
        var args = Array.prototype.slice.call(arguments);
        state.obj = true;
        if (args.length !== 0)
          this._useArgs(args);
        return this;
      };
      Node.prototype.key = function key(newKey) {
        var state = this._baseState;
        assert(state.key === null);
        state.key = newKey;
        return this;
      };
      Node.prototype.any = function any() {
        var state = this._baseState;
        state.any = true;
        return this;
      };
      Node.prototype.choice = function choice(obj) {
        var state = this._baseState;
        assert(state.choice === null);
        state.choice = obj;
        this._useArgs(Object.keys(obj).map(function(key) {
          return obj[key];
        }));
        return this;
      };
      Node.prototype.contains = function contains(item) {
        var state = this._baseState;
        assert(state.use === null);
        state.contains = item;
        return this;
      };
      Node.prototype._decode = function decode(input, options) {
        var state = this._baseState;
        if (state.parent === null)
          return input.wrapResult(state.children[0]._decode(input, options));
        var result = state["default"];
        var present = true;
        var prevKey = null;
        if (state.key !== null)
          prevKey = input.enterKey(state.key);
        if (state.optional) {
          var tag = null;
          if (state.explicit !== null)
            tag = state.explicit;
          else if (state.implicit !== null)
            tag = state.implicit;
          else if (state.tag !== null)
            tag = state.tag;
          if (tag === null && !state.any) {
            var save = input.save();
            try {
              if (state.choice === null)
                this._decodeGeneric(state.tag, input, options);
              else
                this._decodeChoice(input, options);
              present = true;
            } catch (e) {
              present = false;
            }
            input.restore(save);
          } else {
            present = this._peekTag(input, tag, state.any);
            if (input.isError(present))
              return present;
          }
        }
        var prevObj;
        if (state.obj && present)
          prevObj = input.enterObject();
        if (present) {
          if (state.explicit !== null) {
            var explicit = this._decodeTag(input, state.explicit);
            if (input.isError(explicit))
              return explicit;
            input = explicit;
          }
          var start = input.offset;
          if (state.use === null && state.choice === null) {
            var _save;
            if (state.any)
              _save = input.save();
            var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
            if (input.isError(body))
              return body;
            if (state.any)
              result = input.raw(_save);
            else
              input = body;
          }
          if (options && options.track && state.tag !== null)
            options.track(input.path(), start, input.length, "tagged");
          if (options && options.track && state.tag !== null)
            options.track(input.path(), input.offset, input.length, "content");
          if (state.any)
            ;
          else if (state.choice === null) {
            result = this._decodeGeneric(state.tag, input, options);
          } else {
            result = this._decodeChoice(input, options);
          }
          if (input.isError(result))
            return result;
          if (!state.any && state.choice === null && state.children !== null) {
            state.children.forEach(function decodeChildren(child) {
              child._decode(input, options);
            });
          }
          if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
            var data = new DecoderBuffer(result);
            result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
          }
        }
        if (state.obj && present)
          result = input.leaveObject(prevObj);
        if (state.key !== null && (result !== null || present === true))
          input.leaveKey(prevKey, state.key, result);
        else if (prevKey !== null)
          input.exitKey(prevKey);
        return result;
      };
      Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
        var state = this._baseState;
        if (tag === "seq" || tag === "set")
          return null;
        if (tag === "seqof" || tag === "setof")
          return this._decodeList(input, tag, state.args[0], options);
        else if (/str$/.test(tag))
          return this._decodeStr(input, tag, options);
        else if (tag === "objid" && state.args)
          return this._decodeObjid(input, state.args[0], state.args[1], options);
        else if (tag === "objid")
          return this._decodeObjid(input, null, null, options);
        else if (tag === "gentime" || tag === "utctime")
          return this._decodeTime(input, tag, options);
        else if (tag === "null_")
          return this._decodeNull(input, options);
        else if (tag === "bool")
          return this._decodeBool(input, options);
        else if (tag === "objDesc")
          return this._decodeStr(input, tag, options);
        else if (tag === "int" || tag === "enum")
          return this._decodeInt(input, state.args && state.args[0], options);
        if (state.use !== null) {
          return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
        } else {
          return input.error("unknown tag: " + tag);
        }
      };
      Node.prototype._getUse = function _getUse(entity, obj) {
        var state = this._baseState;
        state.useDecoder = this._use(entity, obj);
        assert(state.useDecoder._baseState.parent === null);
        state.useDecoder = state.useDecoder._baseState.children[0];
        if (state.implicit !== state.useDecoder._baseState.implicit) {
          state.useDecoder = state.useDecoder.clone();
          state.useDecoder._baseState.implicit = state.implicit;
        }
        return state.useDecoder;
      };
      Node.prototype._decodeChoice = function decodeChoice(input, options) {
        var state = this._baseState;
        var result = null;
        var match = false;
        Object.keys(state.choice).some(function(key) {
          var save = input.save();
          var node = state.choice[key];
          try {
            var value = node._decode(input, options);
            if (input.isError(value))
              return false;
            result = { type: key, value };
            match = true;
          } catch (e) {
            input.restore(save);
            return false;
          }
          return true;
        }, this);
        if (!match)
          return input.error("Choice not matched");
        return result;
      };
      Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
        return new EncoderBuffer(data, this.reporter);
      };
      Node.prototype._encode = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state["default"] !== null && state["default"] === data)
          return;
        var result = this._encodeValue(data, reporter, parent);
        if (result === void 0)
          return;
        if (this._skipDefault(result, reporter, parent))
          return;
        return result;
      };
      Node.prototype._encodeValue = function encode(data, reporter, parent) {
        var state = this._baseState;
        if (state.parent === null)
          return state.children[0]._encode(data, reporter || new Reporter());
        var result = null;
        this.reporter = reporter;
        if (state.optional && data === void 0) {
          if (state["default"] !== null)
            data = state["default"];
          else
            return;
        }
        var content = null;
        var primitive = false;
        if (state.any) {
          result = this._createEncoderBuffer(data);
        } else if (state.choice) {
          result = this._encodeChoice(data, reporter);
        } else if (state.contains) {
          content = this._getUse(state.contains, parent)._encode(data, reporter);
          primitive = true;
        } else if (state.children) {
          content = state.children.map(function(child2) {
            if (child2._baseState.tag === "null_")
              return child2._encode(null, reporter, data);
            if (child2._baseState.key === null)
              return reporter.error("Child should have a key");
            var prevKey = reporter.enterKey(child2._baseState.key);
            if (_typeof2(data) !== "object")
              return reporter.error("Child expected, but input is not object");
            var res = child2._encode(data[child2._baseState.key], reporter, data);
            reporter.leaveKey(prevKey);
            return res;
          }, this).filter(function(child2) {
            return child2;
          });
          content = this._createEncoderBuffer(content);
        } else {
          if (state.tag === "seqof" || state.tag === "setof") {
            if (!(state.args && state.args.length === 1))
              return reporter.error("Too many args for : " + state.tag);
            if (!Array.isArray(data))
              return reporter.error("seqof/setof, but data is not Array");
            var child = this.clone();
            child._baseState.implicit = null;
            content = this._createEncoderBuffer(data.map(function(item) {
              var state2 = this._baseState;
              return this._getUse(state2.args[0], data)._encode(item, reporter);
            }, child));
          } else if (state.use !== null) {
            result = this._getUse(state.use, parent)._encode(data, reporter);
          } else {
            content = this._encodePrimitive(state.tag, data);
            primitive = true;
          }
        }
        if (!state.any && state.choice === null) {
          var tag = state.implicit !== null ? state.implicit : state.tag;
          var cls = state.implicit === null ? "universal" : "context";
          if (tag === null) {
            if (state.use === null)
              reporter.error("Tag could be omitted only for .use()");
          } else {
            if (state.use === null)
              result = this._encodeComposite(tag, primitive, cls, content);
          }
        }
        if (state.explicit !== null)
          result = this._encodeComposite(state.explicit, false, "context", result);
        return result;
      };
      Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
        var state = this._baseState;
        var node = state.choice[data.type];
        if (!node) {
          assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
        }
        return node._encode(data.value, reporter);
      };
      Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
        var state = this._baseState;
        if (/str$/.test(tag))
          return this._encodeStr(data, tag);
        else if (tag === "objid" && state.args)
          return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
        else if (tag === "objid")
          return this._encodeObjid(data, null, null);
        else if (tag === "gentime" || tag === "utctime")
          return this._encodeTime(data, tag);
        else if (tag === "null_")
          return this._encodeNull();
        else if (tag === "int" || tag === "enum")
          return this._encodeInt(data, state.args && state.reverseArgs[0]);
        else if (tag === "bool")
          return this._encodeBool(data);
        else if (tag === "objDesc")
          return this._encodeStr(data, tag);
        else
          throw new Error("Unsupported tag: " + tag);
      };
      Node.prototype._isNumstr = function isNumstr(str) {
        return /^[0-9 ]*$/.test(str);
      };
      Node.prototype._isPrintstr = function isPrintstr(str) {
        return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
      };
    }, { "../base/buffer": 169, "../base/reporter": 172, "minimalistic-assert": 437 }], 172: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      function Reporter(options) {
        this._reporterState = { obj: null, path: [], options: options || {}, errors: [] };
      }
      exports2.Reporter = Reporter;
      Reporter.prototype.isError = function isError(obj) {
        return obj instanceof ReporterError;
      };
      Reporter.prototype.save = function save() {
        var state = this._reporterState;
        return { obj: state.obj, pathLen: state.path.length };
      };
      Reporter.prototype.restore = function restore(data) {
        var state = this._reporterState;
        state.obj = data.obj;
        state.path = state.path.slice(0, data.pathLen);
      };
      Reporter.prototype.enterKey = function enterKey(key) {
        return this._reporterState.path.push(key);
      };
      Reporter.prototype.exitKey = function exitKey(index2) {
        var state = this._reporterState;
        state.path = state.path.slice(0, index2 - 1);
      };
      Reporter.prototype.leaveKey = function leaveKey(index2, key, value) {
        var state = this._reporterState;
        this.exitKey(index2);
        if (state.obj !== null)
          state.obj[key] = value;
      };
      Reporter.prototype.path = function path() {
        return this._reporterState.path.join("/");
      };
      Reporter.prototype.enterObject = function enterObject() {
        var state = this._reporterState;
        var prev = state.obj;
        state.obj = {};
        return prev;
      };
      Reporter.prototype.leaveObject = function leaveObject(prev) {
        var state = this._reporterState;
        var now = state.obj;
        state.obj = prev;
        return now;
      };
      Reporter.prototype.error = function error(msg) {
        var err;
        var state = this._reporterState;
        var inherited = msg instanceof ReporterError;
        if (inherited) {
          err = msg;
        } else {
          err = new ReporterError(state.path.map(function(elem) {
            return "[" + JSON.stringify(elem) + "]";
          }).join(""), msg.message || msg, msg.stack);
        }
        if (!state.options.partial)
          throw err;
        if (!inherited)
          state.errors.push(err);
        return err;
      };
      Reporter.prototype.wrapResult = function wrapResult(result) {
        var state = this._reporterState;
        if (!state.options.partial)
          return result;
        return { result: this.isError(result) ? null : result, errors: state.errors };
      };
      function ReporterError(path, msg) {
        this.path = path;
        this.rethrow(msg);
      }
      inherits(ReporterError, Error);
      ReporterError.prototype.rethrow = function rethrow(msg) {
        this.message = msg + " at: " + (this.path || "(shallow)");
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, ReporterError);
        if (!this.stack) {
          try {
            throw new Error(this.message);
          } catch (e) {
            this.stack = e.stack;
          }
        }
        return this;
      };
    }, { "inherits": 387 }], 173: [function(require2, module2, exports2) {
      function reverse(map) {
        var res = {};
        Object.keys(map).forEach(function(key) {
          if ((key | 0) == key)
            key = key | 0;
          var value = map[key];
          res[value] = key;
        });
        return res;
      }
      exports2.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
      exports2.tagClassByName = reverse(exports2.tagClass);
      exports2.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
      exports2.tagByName = reverse(exports2.tag);
    }, {}], 174: [function(require2, module2, exports2) {
      var constants = exports2;
      constants._reverse = function reverse(map) {
        var res = {};
        Object.keys(map).forEach(function(key) {
          if ((key | 0) == key)
            key = key | 0;
          var value = map[key];
          res[value] = key;
        });
        return res;
      };
      constants.der = require2("./der");
    }, { "./der": 173 }], 175: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var bignum = require2("bn.js");
      var DecoderBuffer = require2("../base/buffer").DecoderBuffer;
      var Node = require2("../base/node");
      var der = require2("../constants/der");
      function DERDecoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
      }
      module2.exports = DERDecoder;
      DERDecoder.prototype.decode = function decode(data, options) {
        if (!DecoderBuffer.isDecoderBuffer(data)) {
          data = new DecoderBuffer(data, options);
        }
        return this.tree._decode(data, options);
      };
      function DERNode(parent) {
        Node.call(this, "der", parent);
      }
      inherits(DERNode, Node);
      DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
        if (buffer.isEmpty())
          return false;
        var state = buffer.save();
        var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
        if (buffer.isError(decodedTag))
          return decodedTag;
        buffer.restore(state);
        return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
      };
      DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
        var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
        if (buffer.isError(decodedTag))
          return decodedTag;
        var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
        if (buffer.isError(len))
          return len;
        if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
          return buffer.error('Failed to match tag: "' + tag + '"');
        }
        if (decodedTag.primitive || len !== null)
          return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
        var state = buffer.save();
        var res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
        if (buffer.isError(res))
          return res;
        len = buffer.offset - state.offset;
        buffer.restore(state);
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
      };
      DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
        for (; ; ) {
          var tag = derDecodeTag(buffer, fail);
          if (buffer.isError(tag))
            return tag;
          var len = derDecodeLen(buffer, tag.primitive, fail);
          if (buffer.isError(len))
            return len;
          var res = void 0;
          if (tag.primitive || len !== null)
            res = buffer.skip(len);
          else
            res = this._skipUntilEnd(buffer, fail);
          if (buffer.isError(res))
            return res;
          if (tag.tagStr === "end")
            break;
        }
      };
      DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
        var result = [];
        while (!buffer.isEmpty()) {
          var possibleEnd = this._peekTag(buffer, "end");
          if (buffer.isError(possibleEnd))
            return possibleEnd;
          var res = decoder.decode(buffer, "der", options);
          if (buffer.isError(res) && possibleEnd)
            break;
          result.push(res);
        }
        return result;
      };
      DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
        if (tag === "bitstr") {
          var unused = buffer.readUInt8();
          if (buffer.isError(unused))
            return unused;
          return { unused, data: buffer.raw() };
        } else if (tag === "bmpstr") {
          var raw = buffer.raw();
          if (raw.length % 2 === 1)
            return buffer.error("Decoding of string type: bmpstr length mismatch");
          var str = "";
          for (var i = 0; i < raw.length / 2; i++) {
            str += String.fromCharCode(raw.readUInt16BE(i * 2));
          }
          return str;
        } else if (tag === "numstr") {
          var numstr = buffer.raw().toString("ascii");
          if (!this._isNumstr(numstr)) {
            return buffer.error("Decoding of string type: numstr unsupported characters");
          }
          return numstr;
        } else if (tag === "octstr") {
          return buffer.raw();
        } else if (tag === "objDesc") {
          return buffer.raw();
        } else if (tag === "printstr") {
          var printstr = buffer.raw().toString("ascii");
          if (!this._isPrintstr(printstr)) {
            return buffer.error("Decoding of string type: printstr unsupported characters");
          }
          return printstr;
        } else if (/str$/.test(tag)) {
          return buffer.raw().toString();
        } else {
          return buffer.error("Decoding of string type: " + tag + " unsupported");
        }
      };
      DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
        var result;
        var identifiers = [];
        var ident = 0;
        var subident = 0;
        while (!buffer.isEmpty()) {
          subident = buffer.readUInt8();
          ident <<= 7;
          ident |= subident & 127;
          if ((subident & 128) === 0) {
            identifiers.push(ident);
            ident = 0;
          }
        }
        if (subident & 128)
          identifiers.push(ident);
        var first = identifiers[0] / 40 | 0;
        var second = identifiers[0] % 40;
        if (relative)
          result = identifiers;
        else
          result = [first, second].concat(identifiers.slice(1));
        if (values) {
          var tmp = values[result.join(" ")];
          if (tmp === void 0)
            tmp = values[result.join(".")];
          if (tmp !== void 0)
            result = tmp;
        }
        return result;
      };
      DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
        var str = buffer.raw().toString();
        var year;
        var mon;
        var day;
        var hour;
        var min;
        var sec;
        if (tag === "gentime") {
          year = str.slice(0, 4) | 0;
          mon = str.slice(4, 6) | 0;
          day = str.slice(6, 8) | 0;
          hour = str.slice(8, 10) | 0;
          min = str.slice(10, 12) | 0;
          sec = str.slice(12, 14) | 0;
        } else if (tag === "utctime") {
          year = str.slice(0, 2) | 0;
          mon = str.slice(2, 4) | 0;
          day = str.slice(4, 6) | 0;
          hour = str.slice(6, 8) | 0;
          min = str.slice(8, 10) | 0;
          sec = str.slice(10, 12) | 0;
          if (year < 70)
            year = 2e3 + year;
          else
            year = 1900 + year;
        } else {
          return buffer.error("Decoding " + tag + " time is not supported yet");
        }
        return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
      };
      DERNode.prototype._decodeNull = function decodeNull() {
        return null;
      };
      DERNode.prototype._decodeBool = function decodeBool(buffer) {
        var res = buffer.readUInt8();
        if (buffer.isError(res))
          return res;
        else
          return res !== 0;
      };
      DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
        var raw = buffer.raw();
        var res = new bignum(raw);
        if (values)
          res = values[res.toString(10)] || res;
        return res;
      };
      DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function")
          entity = entity(obj);
        return entity._getDecoder("der").tree;
      };
      function derDecodeTag(buf, fail) {
        var tag = buf.readUInt8(fail);
        if (buf.isError(tag))
          return tag;
        var cls = der.tagClass[tag >> 6];
        var primitive = (tag & 32) === 0;
        if ((tag & 31) === 31) {
          var oct = tag;
          tag = 0;
          while ((oct & 128) === 128) {
            oct = buf.readUInt8(fail);
            if (buf.isError(oct))
              return oct;
            tag <<= 7;
            tag |= oct & 127;
          }
        } else {
          tag &= 31;
        }
        var tagStr = der.tag[tag];
        return { cls, primitive, tag, tagStr };
      }
      function derDecodeLen(buf, primitive, fail) {
        var len = buf.readUInt8(fail);
        if (buf.isError(len))
          return len;
        if (!primitive && len === 128)
          return null;
        if ((len & 128) === 0) {
          return len;
        }
        var num = len & 127;
        if (num > 4)
          return buf.error("length octect is too long");
        len = 0;
        for (var i = 0; i < num; i++) {
          len <<= 8;
          var j = buf.readUInt8(fail);
          if (buf.isError(j))
            return j;
          len |= j;
        }
        return len;
      }
    }, { "../base/buffer": 169, "../base/node": 171, "../constants/der": 173, "bn.js": 181, "inherits": 387 }], 176: [function(require2, module2, exports2) {
      var decoders = exports2;
      decoders.der = require2("./der");
      decoders.pem = require2("./pem");
    }, { "./der": 175, "./pem": 177 }], 177: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Buffer = require2("safer-buffer").Buffer;
      var DERDecoder = require2("./der");
      function PEMDecoder(entity) {
        DERDecoder.call(this, entity);
        this.enc = "pem";
      }
      inherits(PEMDecoder, DERDecoder);
      module2.exports = PEMDecoder;
      PEMDecoder.prototype.decode = function decode(data, options) {
        var lines = data.toString().split(/[\r\n]+/g);
        var label = options.label.toUpperCase();
        var re = /^-----(BEGIN|END) ([^-]+)-----$/;
        var start = -1;
        var end = -1;
        for (var i = 0; i < lines.length; i++) {
          var match = lines[i].match(re);
          if (match === null)
            continue;
          if (match[2] !== label)
            continue;
          if (start === -1) {
            if (match[1] !== "BEGIN")
              break;
            start = i;
          } else {
            if (match[1] !== "END")
              break;
            end = i;
            break;
          }
        }
        if (start === -1 || end === -1)
          throw new Error("PEM section not found for: " + label);
        var base64 = lines.slice(start + 1, end).join("");
        base64.replace(/[^a-z0-9+/=]+/gi, "");
        var input = Buffer.from(base64, "base64");
        return DERDecoder.prototype.decode.call(this, input, options);
      };
    }, { "./der": 175, "inherits": 387, "safer-buffer": 495 }], 178: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Buffer = require2("safer-buffer").Buffer;
      var Node = require2("../base/node");
      var der = require2("../constants/der");
      function DEREncoder(entity) {
        this.enc = "der";
        this.name = entity.name;
        this.entity = entity;
        this.tree = new DERNode();
        this.tree._init(entity.body);
      }
      module2.exports = DEREncoder;
      DEREncoder.prototype.encode = function encode(data, reporter) {
        return this.tree._encode(data, reporter).join();
      };
      function DERNode(parent) {
        Node.call(this, "der", parent);
      }
      inherits(DERNode, Node);
      DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
        var encodedTag = encodeTag(tag, primitive, cls, this.reporter);
        if (content.length < 128) {
          var _header = Buffer.alloc(2);
          _header[0] = encodedTag;
          _header[1] = content.length;
          return this._createEncoderBuffer([_header, content]);
        }
        var lenOctets = 1;
        for (var i = content.length; i >= 256; i >>= 8) {
          lenOctets++;
        }
        var header = Buffer.alloc(1 + 1 + lenOctets);
        header[0] = encodedTag;
        header[1] = 128 | lenOctets;
        for (var _i = 1 + lenOctets, j = content.length; j > 0; _i--, j >>= 8) {
          header[_i] = j & 255;
        }
        return this._createEncoderBuffer([header, content]);
      };
      DERNode.prototype._encodeStr = function encodeStr(str, tag) {
        if (tag === "bitstr") {
          return this._createEncoderBuffer([str.unused | 0, str.data]);
        } else if (tag === "bmpstr") {
          var buf = Buffer.alloc(str.length * 2);
          for (var i = 0; i < str.length; i++) {
            buf.writeUInt16BE(str.charCodeAt(i), i * 2);
          }
          return this._createEncoderBuffer(buf);
        } else if (tag === "numstr") {
          if (!this._isNumstr(str)) {
            return this.reporter.error("Encoding of string type: numstr supports only digits and space");
          }
          return this._createEncoderBuffer(str);
        } else if (tag === "printstr") {
          if (!this._isPrintstr(str)) {
            return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
          }
          return this._createEncoderBuffer(str);
        } else if (/str$/.test(tag)) {
          return this._createEncoderBuffer(str);
        } else if (tag === "objDesc") {
          return this._createEncoderBuffer(str);
        } else {
          return this.reporter.error("Encoding of string type: " + tag + " unsupported");
        }
      };
      DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
        if (typeof id === "string") {
          if (!values)
            return this.reporter.error("string objid given, but no values map found");
          if (!values.hasOwnProperty(id))
            return this.reporter.error("objid not found in values map");
          id = values[id].split(/[\s.]+/g);
          for (var i = 0; i < id.length; i++) {
            id[i] |= 0;
          }
        } else if (Array.isArray(id)) {
          id = id.slice();
          for (var _i2 = 0; _i2 < id.length; _i2++) {
            id[_i2] |= 0;
          }
        }
        if (!Array.isArray(id)) {
          return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
        }
        if (!relative) {
          if (id[1] >= 40)
            return this.reporter.error("Second objid identifier OOB");
          id.splice(0, 2, id[0] * 40 + id[1]);
        }
        var size = 0;
        for (var _i3 = 0; _i3 < id.length; _i3++) {
          var ident = id[_i3];
          for (size++; ident >= 128; ident >>= 7) {
            size++;
          }
        }
        var objid = Buffer.alloc(size);
        var offset = objid.length - 1;
        for (var _i4 = id.length - 1; _i4 >= 0; _i4--) {
          var _ident = id[_i4];
          objid[offset--] = _ident & 127;
          while ((_ident >>= 7) > 0) {
            objid[offset--] = 128 | _ident & 127;
          }
        }
        return this._createEncoderBuffer(objid);
      };
      function two(num) {
        if (num < 10)
          return "0" + num;
        else
          return num;
      }
      DERNode.prototype._encodeTime = function encodeTime(time, tag) {
        var str;
        var date = new Date(time);
        if (tag === "gentime") {
          str = [two(date.getUTCFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
        } else if (tag === "utctime") {
          str = [two(date.getUTCFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), "Z"].join("");
        } else {
          this.reporter.error("Encoding " + tag + " time is not supported yet");
        }
        return this._encodeStr(str, "octstr");
      };
      DERNode.prototype._encodeNull = function encodeNull() {
        return this._createEncoderBuffer("");
      };
      DERNode.prototype._encodeInt = function encodeInt(num, values) {
        if (typeof num === "string") {
          if (!values)
            return this.reporter.error("String int or enum given, but no values map");
          if (!values.hasOwnProperty(num)) {
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
          }
          num = values[num];
        }
        if (typeof num !== "number" && !Buffer.isBuffer(num)) {
          var numArray = num.toArray();
          if (!num.sign && numArray[0] & 128) {
            numArray.unshift(0);
          }
          num = Buffer.from(numArray);
        }
        if (Buffer.isBuffer(num)) {
          var _size = num.length;
          if (num.length === 0)
            _size++;
          var _out = Buffer.alloc(_size);
          num.copy(_out);
          if (num.length === 0)
            _out[0] = 0;
          return this._createEncoderBuffer(_out);
        }
        if (num < 128)
          return this._createEncoderBuffer(num);
        if (num < 256)
          return this._createEncoderBuffer([0, num]);
        var size = 1;
        for (var i = num; i >= 256; i >>= 8) {
          size++;
        }
        var out = new Array(size);
        for (var _i5 = out.length - 1; _i5 >= 0; _i5--) {
          out[_i5] = num & 255;
          num >>= 8;
        }
        if (out[0] & 128) {
          out.unshift(0);
        }
        return this._createEncoderBuffer(Buffer.from(out));
      };
      DERNode.prototype._encodeBool = function encodeBool(value) {
        return this._createEncoderBuffer(value ? 255 : 0);
      };
      DERNode.prototype._use = function use(entity, obj) {
        if (typeof entity === "function")
          entity = entity(obj);
        return entity._getEncoder("der").tree;
      };
      DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
        var state = this._baseState;
        var i;
        if (state["default"] === null)
          return false;
        var data = dataBuffer.join();
        if (state.defaultBuffer === void 0)
          state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
        if (data.length !== state.defaultBuffer.length)
          return false;
        for (i = 0; i < data.length; i++) {
          if (data[i] !== state.defaultBuffer[i])
            return false;
        }
        return true;
      };
      function encodeTag(tag, primitive, cls, reporter) {
        var res;
        if (tag === "seqof")
          tag = "seq";
        else if (tag === "setof")
          tag = "set";
        if (der.tagByName.hasOwnProperty(tag))
          res = der.tagByName[tag];
        else if (typeof tag === "number" && (tag | 0) === tag)
          res = tag;
        else
          return reporter.error("Unknown tag: " + tag);
        if (res >= 31)
          return reporter.error("Multi-octet tag encoding unsupported");
        if (!primitive)
          res |= 32;
        res |= der.tagClassByName[cls || "universal"] << 6;
        return res;
      }
    }, { "../base/node": 171, "../constants/der": 173, "inherits": 387, "safer-buffer": 495 }], 179: [function(require2, module2, exports2) {
      var encoders = exports2;
      encoders.der = require2("./der");
      encoders.pem = require2("./pem");
    }, { "./der": 178, "./pem": 180 }], 180: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var DEREncoder = require2("./der");
      function PEMEncoder(entity) {
        DEREncoder.call(this, entity);
        this.enc = "pem";
      }
      inherits(PEMEncoder, DEREncoder);
      module2.exports = PEMEncoder;
      PEMEncoder.prototype.encode = function encode(data, options) {
        var buf = DEREncoder.prototype.encode.call(this, data);
        var p = buf.toString("base64");
        var out = ["-----BEGIN " + options.label + "-----"];
        for (var i = 0; i < p.length; i += 64) {
          out.push(p.slice(i, i + 64));
        }
        out.push("-----END " + options.label + "-----");
        return out.join("\n");
      };
    }, { "./der": 178, "inherits": 387 }], 181: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      (function(module3, exports3) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function TempCtor2() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (_typeof2(module3) === "object") {
          module3.exports = BN;
        } else {
          exports3.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer;
        try {
          Buffer = require2("buffer").Buffer;
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && _typeof2(num) === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (_typeof2(number) === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
          }
          if (base === 16) {
            this._parseHex(number, start);
          } else {
            this._parseBase(number, base, start);
          }
          if (number[0] === "-") {
            this.negative = 1;
          }
          this.strip();
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [number & 67108863, number / 67108864 & 67108863];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [number & 67108863, number / 67108864 & 67108863, 1];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex(str, start, end) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r <<= 4;
            if (c >= 49 && c <= 54) {
              r |= c - 49 + 10;
            } else if (c >= 17 && c <= 22) {
              r |= c - 17 + 10;
            } else {
              r |= c & 15;
            }
          }
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          for (i = number.length - 6, j = 0; i >= start; i -= 6) {
            w = parseHex(number, i, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
          if (i + 6 !== start) {
            w = parseHex(number, start, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
        };
        BN.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN.prototype.clone = function clone2() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
        var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
        var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        BN.prototype.toString = function toString2(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          assert(typeof Buffer !== "undefined");
          return this.toArrayLike(Buffer, endian, length);
        };
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t2 = w;
            var r = 0;
            if (t2 >= 4096) {
              r += 13;
              t2 >>>= 13;
            }
            if (t2 >= 64) {
              r += 7;
              t2 >>>= 7;
            }
            if (t2 >= 8) {
              r += 4;
              t2 >>>= 4;
            }
            if (t2 >= 2) {
              r += 2;
              t2 >>>= 2;
            }
            return r + t2;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t2 = w;
          var r = 0;
          if ((t2 & 8191) === 0) {
            r += 13;
            t2 >>>= 13;
          }
          if ((t2 & 127) === 0) {
            r += 7;
            t2 >>>= 7;
          }
          if ((t2 & 15) === 0) {
            r += 4;
            t2 >>>= 4;
          }
          if ((t2 & 3) === 0) {
            r += 2;
            t2 >>>= 2;
          }
          if ((t2 & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width2) {
          if (this.negative !== 0) {
            return this.abs().inotn(width2).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width2) {
          if (this.testn(width2 - 1)) {
            return this.notn(width2).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width2) {
          assert(typeof width2 === "number" && width2 >= 0);
          var bytesNeeded = Math.ceil(width2 / 26) | 0;
          var bitsLeft = width2 % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN.prototype.notn = function notn(width2) {
          return this.clone().inotn(width2);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t2 = new Array(N);
          var l = BN.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t2[i] = this.revBin(i, l, N);
          }
          return t2;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t2 = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t2;
            t2 = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t2;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert(carry === 0);
          assert((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h3;
          if (hint) {
            h3 = (hint - hint % 26) / 26;
          } else {
            h3 = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h3 -= s;
          h3 = Math.max(0, h3);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h3); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return { div: q || null, mod: a };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return { div: new BN(0), mod: new BN(0) };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return { div, mod };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return { div, mod: res.mod };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return { div: res.div, mod };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return { div: new BN(0), mod: this };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return { div: this.divn(num.words[0]), mod: null };
            }
            if (mode === "mod") {
              return { div: null, mod: new BN(this.modn(num.words[0])) };
            }
            return { div: this.divn(num.words[0]), mod: new BN(this.modn(num.words[0])) };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modn = function modn(num) {
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN.prototype.idivn = function idivn(num) {
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
            }
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
            }
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return { a: C, b: D, gcd: y.iushln(g) };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
            }
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
            }
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t2 = a;
              a = b;
              b = t2;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = { k256: null, p224: null, p192: null, p25519: null };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(a.red && a.red === b.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t2 = this.pow(a, q);
          var m = s;
          while (t2.cmp(one) !== 0) {
            var tmp = t2;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t2 = t2.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t2 = a.imul(b);
          var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t2.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t2 = a.mul(b);
          var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t2.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, void 0);
    }, { "buffer": 185 }], 182: [function(require2, module2, exports2) {
      exports2.byteLength = byteLength;
      exports2.toByteArray = toByteArray;
      exports2.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
        }
        return parts.join("");
      }
    }, {}], 183: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      (function(module3, exports3) {
        function assert(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function TempCtor2() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN(number, base, endian) {
          if (BN.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (_typeof2(module3) === "object") {
          module3.exports = BN;
        } else {
          exports3.BN = BN;
        }
        BN.BN = BN;
        BN.wordSize = 26;
        var Buffer;
        try {
          Buffer = require2("buffer").Buffer;
        } catch (e) {
        }
        BN.isBN = function isBN(num) {
          if (num instanceof BN) {
            return true;
          }
          return num !== null && _typeof2(num) === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
        };
        BN.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (_typeof2(number) === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
          }
          if (base === 16) {
            this._parseHex(number, start);
          } else {
            this._parseBase(number, base, start);
          }
          if (number[0] === "-") {
            this.negative = 1;
          }
          this._strip();
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [number & 67108863, number / 67108864 & 67108863];
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            this.words = [number & 67108863, number / 67108864 & 67108863, 1];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN.prototype._initArray = function _initArray(number, base, endian) {
          assert(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
              w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number.length; i += 3) {
              w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex(str, start, end) {
          var r = 0;
          var len = Math.min(str.length, end);
          var z = 0;
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r <<= 4;
            var b;
            if (c >= 49 && c <= 54) {
              b = c - 49 + 10;
            } else if (c >= 17 && c <= 22) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            r |= b;
            z |= b;
          }
          assert(!(z & 240), "Invalid character in " + str);
          return r;
        }
        BN.prototype._parseHex = function _parseHex(number, start) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          for (i = number.length - 6, j = 0; i >= start; i -= 6) {
            w = parseHex(number, i, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
          if (i + 6 !== start) {
            w = parseHex(number, start, i + 6);
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] |= w >>> 26 - off & 4194303;
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
        };
        BN.prototype.copy = function copy2(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN.prototype.clone = function clone2() {
          var r = new BN(null);
          this.copy(r);
          return r;
        };
        BN.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
          } catch (e) {
            BN.prototype.inspect = inspect;
          }
        } else {
          BN.prototype.inspect = inspect;
        }
        function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
        var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
        var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        BN.prototype.toString = function toString2(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert(false, "Base should be between 2 and 36");
        };
        BN.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer) {
          BN.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer, endian, length);
          };
        }
        BN.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType, size) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
          }
          return new ArrayType(size);
        };
        BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert(byteLength <= reqLength, "byte array longer than desired length");
          assert(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN.prototype._countBits = function _countBits(w) {
            var t2 = w;
            var r = 0;
            if (t2 >= 4096) {
              r += 13;
              t2 >>>= 13;
            }
            if (t2 >= 64) {
              r += 7;
              t2 >>>= 7;
            }
            if (t2 >= 8) {
              r += 4;
              t2 >>>= 4;
            }
            if (t2 >= 2) {
              r += 2;
              t2 >>>= 2;
            }
            return r + t2;
          };
        }
        BN.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t2 = w;
          var r = 0;
          if ((t2 & 8191) === 0) {
            r += 13;
            t2 >>>= 13;
          }
          if ((t2 & 127) === 0) {
            r += 7;
            t2 >>>= 7;
          }
          if ((t2 & 15) === 0) {
            r += 4;
            t2 >>>= 4;
          }
          if ((t2 & 3) === 0) {
            r += 2;
            t2 >>>= 2;
          }
          if ((t2 & 1) === 0) {
            r++;
          }
          return r;
        };
        BN.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN.prototype.toTwos = function toTwos(width2) {
          if (this.negative !== 0) {
            return this.abs().inotn(width2).iaddn(1);
          }
          return this.clone();
        };
        BN.prototype.fromTwos = function fromTwos(width2) {
          if (this.testn(width2 - 1)) {
            return this.notn(width2).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN.prototype.ior = function ior(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN.prototype.iand = function iand(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN.prototype.ixor = function ixor(num) {
          assert((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN.prototype.inotn = function inotn(width2) {
          assert(typeof width2 === "number" && width2 >= 0);
          var bytesNeeded = Math.ceil(width2 / 26) | 0;
          var bitsLeft = width2 % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN.prototype.notn = function notn(width2) {
          return this.clone().inotn(width2);
        };
        BN.prototype.setn = function setn(bit, val) {
          assert(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        BN.prototype.mul = function mul(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN.prototype.mulf = function mulf(num) {
          var out = new BN(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(typeof num === "number");
          assert(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN.prototype.iushln = function iushln(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN.prototype.ishln = function ishln(bits) {
          assert(this.negative === 0);
          return this.iushln(bits);
        };
        BN.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert(typeof bits === "number" && bits >= 0);
          var h3;
          if (hint) {
            h3 = (hint - hint % 26) / 26;
          } else {
            h3 = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h3 -= s;
          h3 = Math.max(0, h3);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0)
            ;
          else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h3); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN.prototype.testn = function testn(bit) {
          assert(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN.prototype.imaskn = function imaskn(bits) {
          assert(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN.prototype.iaddn = function iaddn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN.prototype.isubn = function isubn(num) {
          assert(typeof num === "number");
          assert(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return { div: q || null, mod: a };
        };
        BN.prototype.divmod = function divmod(num, mode, positive) {
          assert(!num.isZero());
          if (this.isZero()) {
            return { div: new BN(0), mod: new BN(0) };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return { div, mod };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return { div, mod: res.mod };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return { div: res.div, mod };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return { div: new BN(0), mod: this };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return { div: this.divn(num.words[0]), mod: null };
            }
            if (mode === "mod") {
              return { div: null, mod: new BN(this.modrn(num.words[0])) };
            }
            return { div: this.divn(num.words[0]), mod: new BN(this.modrn(num.words[0])) };
          }
          return this._wordDiv(num, mode);
        };
        BN.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN.prototype.egcd = function egcd(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN(1);
          var B = new BN(0);
          var C = new BN(0);
          var D = new BN(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
            }
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
            }
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return { a: C, b: D, gcd: y.iushln(g) };
        };
        BN.prototype._invmp = function _invmp(p) {
          assert(p.negative === 0);
          assert(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN(1);
          var x2 = new BN(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1) {
            }
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1) {
            }
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t2 = a;
              a = b;
              b = t2;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN.prototype.bincn = function bincn(bit) {
          assert(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN.red = function red(num) {
          return new Red(num);
        };
        BN.prototype.toRed = function toRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          assert(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN.prototype.fromRed = function fromRed() {
          assert(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN.prototype.forceRed = function forceRed(ctx) {
          assert(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN.prototype.redAdd = function redAdd(num) {
          assert(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN.prototype.redIAdd = function redIAdd(num) {
          assert(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN.prototype.redSub = function redSub(num) {
          assert(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN.prototype.redISub = function redISub(num) {
          assert(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN.prototype.redShl = function redShl(num) {
          assert(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN.prototype.redMul = function redMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN.prototype.redIMul = function redIMul(num) {
          assert(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN.prototype.redSqr = function redSqr() {
          assert(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN.prototype.redISqr = function redISqr() {
          assert(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN.prototype.redSqrt = function redSqrt() {
          assert(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN.prototype.redInvm = function redInvm() {
          assert(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN.prototype.redNeg = function redNeg() {
          assert(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN.prototype.redPow = function redPow(num) {
          assert(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = { k256: null, p224: null, p192: null, p25519: null };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output.words[i] = input.words[i];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert(a.negative === 0, "red works only with positives");
          assert(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert((a.negative | b.negative) === 0, "red works only with positives");
          assert(a.red && a.red === b.red, "red works only with red numbers");
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert(!q.isZero());
          var one = new BN(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t2 = this.pow(a, q);
          var m = s;
          while (t2.cmp(one) !== 0) {
            var tmp = t2;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t2 = t2.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t2 = a.imul(b);
          var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t2.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN(0)._forceRed(this);
          var t2 = a.mul(b);
          var c = t2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t2.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, void 0);
    }, { "buffer": 185 }], 184: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var r;
      module2.exports = function rand(len) {
        if (!r)
          r = new Rand(null);
        return r.generate(len);
      };
      function Rand(rand) {
        this.rand = rand;
      }
      module2.exports.Rand = Rand;
      Rand.prototype.generate = function generate(len) {
        return this._rand(len);
      };
      Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes)
          return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++) {
          res[i] = this.rand.getByte();
        }
        return res;
      };
      if ((typeof self === "undefined" ? "undefined" : _typeof2(self)) === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.crypto.getRandomValues(arr);
            return arr;
          };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.msCrypto.getRandomValues(arr);
            return arr;
          };
        } else if ((typeof window === "undefined" ? "undefined" : _typeof2(window)) === "object") {
          Rand.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
        }
      } else {
        try {
          var crypto2 = require2("crypto");
          if (typeof crypto2.randomBytes !== "function")
            throw new Error("Not supported");
          Rand.prototype._rand = function _rand(n) {
            return crypto2.randomBytes(n);
          };
        } catch (e) {
        }
      }
    }, { "crypto": 185 }], 185: [function(require2, module2, exports2) {
    }, {}], 186: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      function asUInt32Array(buf) {
        if (!Buffer.isBuffer(buf))
          buf = Buffer.from(buf);
        var len = buf.length / 4 | 0;
        var out = new Array(len);
        for (var i = 0; i < len; i++) {
          out[i] = buf.readUInt32BE(i * 4);
        }
        return out;
      }
      function scrubVec(v) {
        for (var i = 0; i < v.length; v++) {
          v[i] = 0;
        }
      }
      function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
        var SUB_MIX0 = SUB_MIX[0];
        var SUB_MIX1 = SUB_MIX[1];
        var SUB_MIX2 = SUB_MIX[2];
        var SUB_MIX3 = SUB_MIX[3];
        var s0 = M[0] ^ keySchedule[0];
        var s1 = M[1] ^ keySchedule[1];
        var s2 = M[2] ^ keySchedule[2];
        var s3 = M[3] ^ keySchedule[3];
        var t0, t1, t2, t3;
        var ksRow = 4;
        for (var round = 1; round < nRounds; round++) {
          t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
          t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
          t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
          t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;
        }
        t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
        t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
        t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
        t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
        t0 = t0 >>> 0;
        t1 = t1 >>> 0;
        t2 = t2 >>> 0;
        t3 = t3 >>> 0;
        return [t0, t1, t2, t3];
      }
      var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var G = function() {
        var d = new Array(256);
        for (var j = 0; j < 256; j++) {
          if (j < 128) {
            d[j] = j << 1;
          } else {
            d[j] = j << 1 ^ 283;
          }
        }
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX = [[], [], [], []];
        var INV_SUB_MIX = [[], [], [], []];
        var x = 0;
        var xi = 0;
        for (var i = 0; i < 256; ++i) {
          var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
          sx = sx >>> 8 ^ sx & 255 ^ 99;
          SBOX[x] = sx;
          INV_SBOX[sx] = x;
          var x2 = d[x];
          var x4 = d[x2];
          var x8 = d[x4];
          var t2 = d[sx] * 257 ^ sx * 16843008;
          SUB_MIX[0][x] = t2 << 24 | t2 >>> 8;
          SUB_MIX[1][x] = t2 << 16 | t2 >>> 16;
          SUB_MIX[2][x] = t2 << 8 | t2 >>> 24;
          SUB_MIX[3][x] = t2;
          t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
          INV_SUB_MIX[0][sx] = t2 << 24 | t2 >>> 8;
          INV_SUB_MIX[1][sx] = t2 << 16 | t2 >>> 16;
          INV_SUB_MIX[2][sx] = t2 << 8 | t2 >>> 24;
          INV_SUB_MIX[3][sx] = t2;
          if (x === 0) {
            x = xi = 1;
          } else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
          }
        }
        return { SBOX, INV_SBOX, SUB_MIX, INV_SUB_MIX };
      }();
      function AES(key) {
        this._key = asUInt32Array(key);
        this._reset();
      }
      AES.blockSize = 4 * 4;
      AES.keySize = 256 / 8;
      AES.prototype.blockSize = AES.blockSize;
      AES.prototype.keySize = AES.keySize;
      AES.prototype._reset = function() {
        var keyWords = this._key;
        var keySize = keyWords.length;
        var nRounds = keySize + 6;
        var ksRows = (nRounds + 1) * 4;
        var keySchedule = [];
        for (var k = 0; k < keySize; k++) {
          keySchedule[k] = keyWords[k];
        }
        for (k = keySize; k < ksRows; k++) {
          var t2 = keySchedule[k - 1];
          if (k % keySize === 0) {
            t2 = t2 << 8 | t2 >>> 24;
            t2 = G.SBOX[t2 >>> 24] << 24 | G.SBOX[t2 >>> 16 & 255] << 16 | G.SBOX[t2 >>> 8 & 255] << 8 | G.SBOX[t2 & 255];
            t2 ^= RCON[k / keySize | 0] << 24;
          } else if (keySize > 6 && k % keySize === 4) {
            t2 = G.SBOX[t2 >>> 24] << 24 | G.SBOX[t2 >>> 16 & 255] << 16 | G.SBOX[t2 >>> 8 & 255] << 8 | G.SBOX[t2 & 255];
          }
          keySchedule[k] = keySchedule[k - keySize] ^ t2;
        }
        var invKeySchedule = [];
        for (var ik = 0; ik < ksRows; ik++) {
          var ksR = ksRows - ik;
          var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
          if (ik < 4 || ksR <= 4) {
            invKeySchedule[ik] = tt;
          } else {
            invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
          }
        }
        this._nRounds = nRounds;
        this._keySchedule = keySchedule;
        this._invKeySchedule = invKeySchedule;
      };
      AES.prototype.encryptBlockRaw = function(M) {
        M = asUInt32Array(M);
        return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
      };
      AES.prototype.encryptBlock = function(M) {
        var out = this.encryptBlockRaw(M);
        var buf = Buffer.allocUnsafe(16);
        buf.writeUInt32BE(out[0], 0);
        buf.writeUInt32BE(out[1], 4);
        buf.writeUInt32BE(out[2], 8);
        buf.writeUInt32BE(out[3], 12);
        return buf;
      };
      AES.prototype.decryptBlock = function(M) {
        M = asUInt32Array(M);
        var m1 = M[1];
        M[1] = M[3];
        M[3] = m1;
        var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
        var buf = Buffer.allocUnsafe(16);
        buf.writeUInt32BE(out[0], 0);
        buf.writeUInt32BE(out[3], 4);
        buf.writeUInt32BE(out[2], 8);
        buf.writeUInt32BE(out[1], 12);
        return buf;
      };
      AES.prototype.scrub = function() {
        scrubVec(this._keySchedule);
        scrubVec(this._invKeySchedule);
        scrubVec(this._key);
      };
      module2.exports.AES = AES;
    }, { "safe-buffer": 494 }], 187: [function(require2, module2, exports2) {
      var aes = require2("./aes");
      var Buffer = require2("safe-buffer").Buffer;
      var Transform = require2("cipher-base");
      var inherits = require2("inherits");
      var GHASH = require2("./ghash");
      var xor = require2("buffer-xor");
      var incr32 = require2("./incr32");
      function xorTest(a, b) {
        var out = 0;
        if (a.length !== b.length)
          out++;
        var len = Math.min(a.length, b.length);
        for (var i = 0; i < len; ++i) {
          out += a[i] ^ b[i];
        }
        return out;
      }
      function calcIv(self2, iv, ck) {
        if (iv.length === 12) {
          self2._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])]);
          return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])]);
        }
        var ghash = new GHASH(ck);
        var len = iv.length;
        var toPad = len % 16;
        ghash.update(iv);
        if (toPad) {
          toPad = 16 - toPad;
          ghash.update(Buffer.alloc(toPad, 0));
        }
        ghash.update(Buffer.alloc(8, 0));
        var ivBits = len * 8;
        var tail = Buffer.alloc(8);
        tail.writeUIntBE(ivBits, 0, 8);
        ghash.update(tail);
        self2._finID = ghash.state;
        var out = Buffer.from(self2._finID);
        incr32(out);
        return out;
      }
      function StreamCipher(mode, key, iv, decrypt) {
        Transform.call(this);
        var h3 = Buffer.alloc(4, 0);
        this._cipher = new aes.AES(key);
        var ck = this._cipher.encryptBlock(h3);
        this._ghash = new GHASH(ck);
        iv = calcIv(this, iv, ck);
        this._prev = Buffer.from(iv);
        this._cache = Buffer.allocUnsafe(0);
        this._secCache = Buffer.allocUnsafe(0);
        this._decrypt = decrypt;
        this._alen = 0;
        this._len = 0;
        this._mode = mode;
        this._authTag = null;
        this._called = false;
      }
      inherits(StreamCipher, Transform);
      StreamCipher.prototype._update = function(chunk) {
        if (!this._called && this._alen) {
          var rump = 16 - this._alen % 16;
          if (rump < 16) {
            rump = Buffer.alloc(rump, 0);
            this._ghash.update(rump);
          }
        }
        this._called = true;
        var out = this._mode.encrypt(this, chunk);
        if (this._decrypt) {
          this._ghash.update(chunk);
        } else {
          this._ghash.update(out);
        }
        this._len += chunk.length;
        return out;
      };
      StreamCipher.prototype._final = function() {
        if (this._decrypt && !this._authTag)
          throw new Error("Unsupported state or unable to authenticate data");
        var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
        if (this._decrypt && xorTest(tag, this._authTag))
          throw new Error("Unsupported state or unable to authenticate data");
        this._authTag = tag;
        this._cipher.scrub();
      };
      StreamCipher.prototype.getAuthTag = function getAuthTag() {
        if (this._decrypt || !Buffer.isBuffer(this._authTag))
          throw new Error("Attempting to get auth tag in unsupported state");
        return this._authTag;
      };
      StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
        if (!this._decrypt)
          throw new Error("Attempting to set auth tag in unsupported state");
        this._authTag = tag;
      };
      StreamCipher.prototype.setAAD = function setAAD(buf) {
        if (this._called)
          throw new Error("Attempting to set AAD in unsupported state");
        this._ghash.update(buf);
        this._alen += buf.length;
      };
      module2.exports = StreamCipher;
    }, { "./aes": 186, "./ghash": 191, "./incr32": 192, "buffer-xor": 217, "cipher-base": 218, "inherits": 387, "safe-buffer": 494 }], 188: [function(require2, module2, exports2) {
      var ciphers = require2("./encrypter");
      var deciphers = require2("./decrypter");
      var modes = require2("./modes/list.json");
      function getCiphers() {
        return Object.keys(modes);
      }
      exports2.createCipher = exports2.Cipher = ciphers.createCipher;
      exports2.createCipheriv = exports2.Cipheriv = ciphers.createCipheriv;
      exports2.createDecipher = exports2.Decipher = deciphers.createDecipher;
      exports2.createDecipheriv = exports2.Decipheriv = deciphers.createDecipheriv;
      exports2.listCiphers = exports2.getCiphers = getCiphers;
    }, { "./decrypter": 189, "./encrypter": 190, "./modes/list.json": 200 }], 189: [function(require2, module2, exports2) {
      var AuthCipher = require2("./authCipher");
      var Buffer = require2("safe-buffer").Buffer;
      var MODES = require2("./modes");
      var StreamCipher = require2("./streamCipher");
      var Transform = require2("cipher-base");
      var aes = require2("./aes");
      var ebtk = require2("evp_bytestokey");
      var inherits = require2("inherits");
      function Decipher(mode, key, iv) {
        Transform.call(this);
        this._cache = new Splitter();
        this._last = void 0;
        this._cipher = new aes.AES(key);
        this._prev = Buffer.from(iv);
        this._mode = mode;
        this._autopadding = true;
      }
      inherits(Decipher, Transform);
      Decipher.prototype._update = function(data) {
        this._cache.add(data);
        var chunk;
        var thing;
        var out = [];
        while (chunk = this._cache.get(this._autopadding)) {
          thing = this._mode.decrypt(this, chunk);
          out.push(thing);
        }
        return Buffer.concat(out);
      };
      Decipher.prototype._final = function() {
        var chunk = this._cache.flush();
        if (this._autopadding) {
          return unpad(this._mode.decrypt(this, chunk));
        } else if (chunk) {
          throw new Error("data not multiple of block length");
        }
      };
      Decipher.prototype.setAutoPadding = function(setTo) {
        this._autopadding = !!setTo;
        return this;
      };
      function Splitter() {
        this.cache = Buffer.allocUnsafe(0);
      }
      Splitter.prototype.add = function(data) {
        this.cache = Buffer.concat([this.cache, data]);
      };
      Splitter.prototype.get = function(autoPadding) {
        var out;
        if (autoPadding) {
          if (this.cache.length > 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
          }
        } else {
          if (this.cache.length >= 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
          }
        }
        return null;
      };
      Splitter.prototype.flush = function() {
        if (this.cache.length)
          return this.cache;
      };
      function unpad(last) {
        var padded = last[15];
        if (padded < 1 || padded > 16) {
          throw new Error("unable to decrypt data");
        }
        var i = -1;
        while (++i < padded) {
          if (last[i + (16 - padded)] !== padded) {
            throw new Error("unable to decrypt data");
          }
        }
        if (padded === 16)
          return;
        return last.slice(0, 16 - padded);
      }
      function createDecipheriv(suite, password, iv) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        if (typeof iv === "string")
          iv = Buffer.from(iv);
        if (config.mode !== "GCM" && iv.length !== config.iv)
          throw new TypeError("invalid iv length " + iv.length);
        if (typeof password === "string")
          password = Buffer.from(password);
        if (password.length !== config.key / 8)
          throw new TypeError("invalid key length " + password.length);
        if (config.type === "stream") {
          return new StreamCipher(config.module, password, iv, true);
        } else if (config.type === "auth") {
          return new AuthCipher(config.module, password, iv, true);
        }
        return new Decipher(config.module, password, iv);
      }
      function createDecipher(suite, password) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        var keys = ebtk(password, false, config.key, config.iv);
        return createDecipheriv(suite, keys.key, keys.iv);
      }
      exports2.createDecipher = createDecipher;
      exports2.createDecipheriv = createDecipheriv;
    }, { "./aes": 186, "./authCipher": 187, "./modes": 199, "./streamCipher": 202, "cipher-base": 218, "evp_bytestokey": 368, "inherits": 387, "safe-buffer": 494 }], 190: [function(require2, module2, exports2) {
      var MODES = require2("./modes");
      var AuthCipher = require2("./authCipher");
      var Buffer = require2("safe-buffer").Buffer;
      var StreamCipher = require2("./streamCipher");
      var Transform = require2("cipher-base");
      var aes = require2("./aes");
      var ebtk = require2("evp_bytestokey");
      var inherits = require2("inherits");
      function Cipher(mode, key, iv) {
        Transform.call(this);
        this._cache = new Splitter();
        this._cipher = new aes.AES(key);
        this._prev = Buffer.from(iv);
        this._mode = mode;
        this._autopadding = true;
      }
      inherits(Cipher, Transform);
      Cipher.prototype._update = function(data) {
        this._cache.add(data);
        var chunk;
        var thing;
        var out = [];
        while (chunk = this._cache.get()) {
          thing = this._mode.encrypt(this, chunk);
          out.push(thing);
        }
        return Buffer.concat(out);
      };
      var PADDING = Buffer.alloc(16, 16);
      Cipher.prototype._final = function() {
        var chunk = this._cache.flush();
        if (this._autopadding) {
          chunk = this._mode.encrypt(this, chunk);
          this._cipher.scrub();
          return chunk;
        }
        if (!chunk.equals(PADDING)) {
          this._cipher.scrub();
          throw new Error("data not multiple of block length");
        }
      };
      Cipher.prototype.setAutoPadding = function(setTo) {
        this._autopadding = !!setTo;
        return this;
      };
      function Splitter() {
        this.cache = Buffer.allocUnsafe(0);
      }
      Splitter.prototype.add = function(data) {
        this.cache = Buffer.concat([this.cache, data]);
      };
      Splitter.prototype.get = function() {
        if (this.cache.length > 15) {
          var out = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          return out;
        }
        return null;
      };
      Splitter.prototype.flush = function() {
        var len = 16 - this.cache.length;
        var padBuff = Buffer.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          padBuff.writeUInt8(len, i);
        }
        return Buffer.concat([this.cache, padBuff]);
      };
      function createCipheriv(suite, password, iv) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        if (typeof password === "string")
          password = Buffer.from(password);
        if (password.length !== config.key / 8)
          throw new TypeError("invalid key length " + password.length);
        if (typeof iv === "string")
          iv = Buffer.from(iv);
        if (config.mode !== "GCM" && iv.length !== config.iv)
          throw new TypeError("invalid iv length " + iv.length);
        if (config.type === "stream") {
          return new StreamCipher(config.module, password, iv);
        } else if (config.type === "auth") {
          return new AuthCipher(config.module, password, iv);
        }
        return new Cipher(config.module, password, iv);
      }
      function createCipher(suite, password) {
        var config = MODES[suite.toLowerCase()];
        if (!config)
          throw new TypeError("invalid suite type");
        var keys = ebtk(password, false, config.key, config.iv);
        return createCipheriv(suite, keys.key, keys.iv);
      }
      exports2.createCipheriv = createCipheriv;
      exports2.createCipher = createCipher;
    }, { "./aes": 186, "./authCipher": 187, "./modes": 199, "./streamCipher": 202, "cipher-base": 218, "evp_bytestokey": 368, "inherits": 387, "safe-buffer": 494 }], 191: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var ZEROES = Buffer.alloc(16, 0);
      function toArray(buf) {
        return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];
      }
      function fromArray(out) {
        var buf = Buffer.allocUnsafe(16);
        buf.writeUInt32BE(out[0] >>> 0, 0);
        buf.writeUInt32BE(out[1] >>> 0, 4);
        buf.writeUInt32BE(out[2] >>> 0, 8);
        buf.writeUInt32BE(out[3] >>> 0, 12);
        return buf;
      }
      function GHASH(key) {
        this.h = key;
        this.state = Buffer.alloc(16, 0);
        this.cache = Buffer.allocUnsafe(0);
      }
      GHASH.prototype.ghash = function(block) {
        var i = -1;
        while (++i < block.length) {
          this.state[i] ^= block[i];
        }
        this._multiply();
      };
      GHASH.prototype._multiply = function() {
        var Vi = toArray(this.h);
        var Zi = [0, 0, 0, 0];
        var j, xi, lsbVi;
        var i = -1;
        while (++i < 128) {
          xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
          if (xi) {
            Zi[0] ^= Vi[0];
            Zi[1] ^= Vi[1];
            Zi[2] ^= Vi[2];
            Zi[3] ^= Vi[3];
          }
          lsbVi = (Vi[3] & 1) !== 0;
          for (j = 3; j > 0; j--) {
            Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
          }
          Vi[0] = Vi[0] >>> 1;
          if (lsbVi) {
            Vi[0] = Vi[0] ^ 225 << 24;
          }
        }
        this.state = fromArray(Zi);
      };
      GHASH.prototype.update = function(buf) {
        this.cache = Buffer.concat([this.cache, buf]);
        var chunk;
        while (this.cache.length >= 16) {
          chunk = this.cache.slice(0, 16);
          this.cache = this.cache.slice(16);
          this.ghash(chunk);
        }
      };
      GHASH.prototype.final = function(abl, bl) {
        if (this.cache.length) {
          this.ghash(Buffer.concat([this.cache, ZEROES], 16));
        }
        this.ghash(fromArray([0, abl, 0, bl]));
        return this.state;
      };
      module2.exports = GHASH;
    }, { "safe-buffer": 494 }], 192: [function(require2, module2, exports2) {
      function incr32(iv) {
        var len = iv.length;
        var item;
        while (len--) {
          item = iv.readUInt8(len);
          if (item === 255) {
            iv.writeUInt8(0, len);
          } else {
            item++;
            iv.writeUInt8(item, len);
            break;
          }
        }
      }
      module2.exports = incr32;
    }, {}], 193: [function(require2, module2, exports2) {
      var xor = require2("buffer-xor");
      exports2.encrypt = function(self2, block) {
        var data = xor(block, self2._prev);
        self2._prev = self2._cipher.encryptBlock(data);
        return self2._prev;
      };
      exports2.decrypt = function(self2, block) {
        var pad = self2._prev;
        self2._prev = block;
        var out = self2._cipher.decryptBlock(block);
        return xor(out, pad);
      };
    }, { "buffer-xor": 217 }], 194: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var xor = require2("buffer-xor");
      function encryptStart(self2, data, decrypt) {
        var len = data.length;
        var out = xor(data, self2._cache);
        self2._cache = self2._cache.slice(len);
        self2._prev = Buffer.concat([self2._prev, decrypt ? data : out]);
        return out;
      }
      exports2.encrypt = function(self2, data, decrypt) {
        var out = Buffer.allocUnsafe(0);
        var len;
        while (data.length) {
          if (self2._cache.length === 0) {
            self2._cache = self2._cipher.encryptBlock(self2._prev);
            self2._prev = Buffer.allocUnsafe(0);
          }
          if (self2._cache.length <= data.length) {
            len = self2._cache.length;
            out = Buffer.concat([out, encryptStart(self2, data.slice(0, len), decrypt)]);
            data = data.slice(len);
          } else {
            out = Buffer.concat([out, encryptStart(self2, data, decrypt)]);
            break;
          }
        }
        return out;
      };
    }, { "buffer-xor": 217, "safe-buffer": 494 }], 195: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      function encryptByte(self2, byteParam, decrypt) {
        var pad;
        var i = -1;
        var len = 8;
        var out = 0;
        var bit, value;
        while (++i < len) {
          pad = self2._cipher.encryptBlock(self2._prev);
          bit = byteParam & 1 << 7 - i ? 128 : 0;
          value = pad[0] ^ bit;
          out += (value & 128) >> i % 8;
          self2._prev = shiftIn(self2._prev, decrypt ? bit : value);
        }
        return out;
      }
      function shiftIn(buffer, value) {
        var len = buffer.length;
        var i = -1;
        var out = Buffer.allocUnsafe(buffer.length);
        buffer = Buffer.concat([buffer, Buffer.from([value])]);
        while (++i < len) {
          out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
        }
        return out;
      }
      exports2.encrypt = function(self2, chunk, decrypt) {
        var len = chunk.length;
        var out = Buffer.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          out[i] = encryptByte(self2, chunk[i], decrypt);
        }
        return out;
      };
    }, { "safe-buffer": 494 }], 196: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      function encryptByte(self2, byteParam, decrypt) {
        var pad = self2._cipher.encryptBlock(self2._prev);
        var out = pad[0] ^ byteParam;
        self2._prev = Buffer.concat([self2._prev.slice(1), Buffer.from([decrypt ? byteParam : out])]);
        return out;
      }
      exports2.encrypt = function(self2, chunk, decrypt) {
        var len = chunk.length;
        var out = Buffer.allocUnsafe(len);
        var i = -1;
        while (++i < len) {
          out[i] = encryptByte(self2, chunk[i], decrypt);
        }
        return out;
      };
    }, { "safe-buffer": 494 }], 197: [function(require2, module2, exports2) {
      var xor = require2("buffer-xor");
      var Buffer = require2("safe-buffer").Buffer;
      var incr32 = require2("../incr32");
      function getBlock(self2) {
        var out = self2._cipher.encryptBlockRaw(self2._prev);
        incr32(self2._prev);
        return out;
      }
      var blockSize = 16;
      exports2.encrypt = function(self2, chunk) {
        var chunkNum = Math.ceil(chunk.length / blockSize);
        var start = self2._cache.length;
        self2._cache = Buffer.concat([self2._cache, Buffer.allocUnsafe(chunkNum * blockSize)]);
        for (var i = 0; i < chunkNum; i++) {
          var out = getBlock(self2);
          var offset = start + i * blockSize;
          self2._cache.writeUInt32BE(out[0], offset + 0);
          self2._cache.writeUInt32BE(out[1], offset + 4);
          self2._cache.writeUInt32BE(out[2], offset + 8);
          self2._cache.writeUInt32BE(out[3], offset + 12);
        }
        var pad = self2._cache.slice(0, chunk.length);
        self2._cache = self2._cache.slice(chunk.length);
        return xor(chunk, pad);
      };
    }, { "../incr32": 192, "buffer-xor": 217, "safe-buffer": 494 }], 198: [function(require2, module2, exports2) {
      exports2.encrypt = function(self2, block) {
        return self2._cipher.encryptBlock(block);
      };
      exports2.decrypt = function(self2, block) {
        return self2._cipher.decryptBlock(block);
      };
    }, {}], 199: [function(require2, module2, exports2) {
      var modeModules = { ECB: require2("./ecb"), CBC: require2("./cbc"), CFB: require2("./cfb"), CFB8: require2("./cfb8"), CFB1: require2("./cfb1"), OFB: require2("./ofb"), CTR: require2("./ctr"), GCM: require2("./ctr") };
      var modes = require2("./list.json");
      for (var key in modes) {
        modes[key].module = modeModules[modes[key].mode];
      }
      module2.exports = modes;
    }, { "./cbc": 193, "./cfb": 194, "./cfb1": 195, "./cfb8": 196, "./ctr": 197, "./ecb": 198, "./list.json": 200, "./ofb": 201 }], 200: [function(require2, module2, exports2) {
      module2.exports = { "aes-128-ecb": { "cipher": "AES", "key": 128, "iv": 0, "mode": "ECB", "type": "block" }, "aes-192-ecb": { "cipher": "AES", "key": 192, "iv": 0, "mode": "ECB", "type": "block" }, "aes-256-ecb": { "cipher": "AES", "key": 256, "iv": 0, "mode": "ECB", "type": "block" }, "aes-128-cbc": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CBC", "type": "block" }, "aes-192-cbc": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CBC", "type": "block" }, "aes-256-cbc": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CBC", "type": "block" }, "aes128": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CBC", "type": "block" }, "aes192": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CBC", "type": "block" }, "aes256": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CBC", "type": "block" }, "aes-128-cfb": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB", "type": "stream" }, "aes-192-cfb": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB", "type": "stream" }, "aes-256-cfb": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB", "type": "stream" }, "aes-128-cfb8": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB8", "type": "stream" }, "aes-192-cfb8": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB8", "type": "stream" }, "aes-256-cfb8": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB8", "type": "stream" }, "aes-128-cfb1": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CFB1", "type": "stream" }, "aes-192-cfb1": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CFB1", "type": "stream" }, "aes-256-cfb1": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CFB1", "type": "stream" }, "aes-128-ofb": { "cipher": "AES", "key": 128, "iv": 16, "mode": "OFB", "type": "stream" }, "aes-192-ofb": { "cipher": "AES", "key": 192, "iv": 16, "mode": "OFB", "type": "stream" }, "aes-256-ofb": { "cipher": "AES", "key": 256, "iv": 16, "mode": "OFB", "type": "stream" }, "aes-128-ctr": { "cipher": "AES", "key": 128, "iv": 16, "mode": "CTR", "type": "stream" }, "aes-192-ctr": { "cipher": "AES", "key": 192, "iv": 16, "mode": "CTR", "type": "stream" }, "aes-256-ctr": { "cipher": "AES", "key": 256, "iv": 16, "mode": "CTR", "type": "stream" }, "aes-128-gcm": { "cipher": "AES", "key": 128, "iv": 12, "mode": "GCM", "type": "auth" }, "aes-192-gcm": { "cipher": "AES", "key": 192, "iv": 12, "mode": "GCM", "type": "auth" }, "aes-256-gcm": { "cipher": "AES", "key": 256, "iv": 12, "mode": "GCM", "type": "auth" } };
    }, {}], 201: [function(require2, module2, exports2) {
      (function(Buffer) {
        var xor = require2("buffer-xor");
        function getBlock(self2) {
          self2._prev = self2._cipher.encryptBlock(self2._prev);
          return self2._prev;
        }
        exports2.encrypt = function(self2, chunk) {
          while (self2._cache.length < chunk.length) {
            self2._cache = Buffer.concat([self2._cache, getBlock(self2)]);
          }
          var pad = self2._cache.slice(0, chunk.length);
          self2._cache = self2._cache.slice(chunk.length);
          return xor(chunk, pad);
        };
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 216, "buffer-xor": 217 }], 202: [function(require2, module2, exports2) {
      var aes = require2("./aes");
      var Buffer = require2("safe-buffer").Buffer;
      var Transform = require2("cipher-base");
      var inherits = require2("inherits");
      function StreamCipher(mode, key, iv, decrypt) {
        Transform.call(this);
        this._cipher = new aes.AES(key);
        this._prev = Buffer.from(iv);
        this._cache = Buffer.allocUnsafe(0);
        this._secCache = Buffer.allocUnsafe(0);
        this._decrypt = decrypt;
        this._mode = mode;
      }
      inherits(StreamCipher, Transform);
      StreamCipher.prototype._update = function(chunk) {
        return this._mode.encrypt(this, chunk, this._decrypt);
      };
      StreamCipher.prototype._final = function() {
        this._cipher.scrub();
      };
      module2.exports = StreamCipher;
    }, { "./aes": 186, "cipher-base": 218, "inherits": 387, "safe-buffer": 494 }], 203: [function(require2, module2, exports2) {
      var DES = require2("browserify-des");
      var aes = require2("browserify-aes/browser");
      var aesModes = require2("browserify-aes/modes");
      var desModes = require2("browserify-des/modes");
      var ebtk = require2("evp_bytestokey");
      function createCipher(suite, password) {
        suite = suite.toLowerCase();
        var keyLen, ivLen;
        if (aesModes[suite]) {
          keyLen = aesModes[suite].key;
          ivLen = aesModes[suite].iv;
        } else if (desModes[suite]) {
          keyLen = desModes[suite].key * 8;
          ivLen = desModes[suite].iv;
        } else {
          throw new TypeError("invalid suite type");
        }
        var keys = ebtk(password, false, keyLen, ivLen);
        return createCipheriv(suite, keys.key, keys.iv);
      }
      function createDecipher(suite, password) {
        suite = suite.toLowerCase();
        var keyLen, ivLen;
        if (aesModes[suite]) {
          keyLen = aesModes[suite].key;
          ivLen = aesModes[suite].iv;
        } else if (desModes[suite]) {
          keyLen = desModes[suite].key * 8;
          ivLen = desModes[suite].iv;
        } else {
          throw new TypeError("invalid suite type");
        }
        var keys = ebtk(password, false, keyLen, ivLen);
        return createDecipheriv(suite, keys.key, keys.iv);
      }
      function createCipheriv(suite, key, iv) {
        suite = suite.toLowerCase();
        if (aesModes[suite])
          return aes.createCipheriv(suite, key, iv);
        if (desModes[suite])
          return new DES({ key, iv, mode: suite });
        throw new TypeError("invalid suite type");
      }
      function createDecipheriv(suite, key, iv) {
        suite = suite.toLowerCase();
        if (aesModes[suite])
          return aes.createDecipheriv(suite, key, iv);
        if (desModes[suite])
          return new DES({ key, iv, mode: suite, decrypt: true });
        throw new TypeError("invalid suite type");
      }
      function getCiphers() {
        return Object.keys(desModes).concat(aes.getCiphers());
      }
      exports2.createCipher = exports2.Cipher = createCipher;
      exports2.createCipheriv = exports2.Cipheriv = createCipheriv;
      exports2.createDecipher = exports2.Decipher = createDecipher;
      exports2.createDecipheriv = exports2.Decipheriv = createDecipheriv;
      exports2.listCiphers = exports2.getCiphers = getCiphers;
    }, { "browserify-aes/browser": 188, "browserify-aes/modes": 199, "browserify-des": 204, "browserify-des/modes": 205, "evp_bytestokey": 368 }], 204: [function(require2, module2, exports2) {
      var CipherBase = require2("cipher-base");
      var des = require2("des.js");
      var inherits = require2("inherits");
      var Buffer = require2("safe-buffer").Buffer;
      var modes = { "des-ede3-cbc": des.CBC.instantiate(des.EDE), "des-ede3": des.EDE, "des-ede-cbc": des.CBC.instantiate(des.EDE), "des-ede": des.EDE, "des-cbc": des.CBC.instantiate(des.DES), "des-ecb": des.DES };
      modes.des = modes["des-cbc"];
      modes.des3 = modes["des-ede3-cbc"];
      module2.exports = DES;
      inherits(DES, CipherBase);
      function DES(opts) {
        CipherBase.call(this);
        var modeName = opts.mode.toLowerCase();
        var mode = modes[modeName];
        var type;
        if (opts.decrypt) {
          type = "decrypt";
        } else {
          type = "encrypt";
        }
        var key = opts.key;
        if (!Buffer.isBuffer(key)) {
          key = Buffer.from(key);
        }
        if (modeName === "des-ede" || modeName === "des-ede-cbc") {
          key = Buffer.concat([key, key.slice(0, 8)]);
        }
        var iv = opts.iv;
        if (!Buffer.isBuffer(iv)) {
          iv = Buffer.from(iv);
        }
        this._des = mode.create({ key, iv, type });
      }
      DES.prototype._update = function(data) {
        return Buffer.from(this._des.update(data));
      };
      DES.prototype._final = function() {
        return Buffer.from(this._des.final());
      };
    }, { "cipher-base": 218, "des.js": 339, "inherits": 387, "safe-buffer": 494 }], 205: [function(require2, module2, exports2) {
      exports2["des-ecb"] = { key: 8, iv: 0 };
      exports2["des-cbc"] = exports2.des = { key: 8, iv: 8 };
      exports2["des-ede3-cbc"] = exports2.des3 = { key: 24, iv: 8 };
      exports2["des-ede3"] = { key: 24, iv: 0 };
      exports2["des-ede-cbc"] = { key: 16, iv: 8 };
      exports2["des-ede"] = { key: 16, iv: 0 };
    }, {}], 206: [function(require2, module2, exports2) {
      (function(Buffer) {
        var bn = require2("bn.js");
        var randomBytes = require2("randombytes");
        module2.exports = crt;
        function blind(priv) {
          var r = getr(priv);
          var blinder = r.toRed(bn.mont(priv.modulus)).redPow(new bn(priv.publicExponent)).fromRed();
          return { blinder, unblinder: r.invm(priv.modulus) };
        }
        function crt(msg, priv) {
          var blinds = blind(priv);
          var len = priv.modulus.byteLength();
          bn.mont(priv.modulus);
          var blinded = new bn(msg).mul(blinds.blinder).umod(priv.modulus);
          var c1 = blinded.toRed(bn.mont(priv.prime1));
          var c2 = blinded.toRed(bn.mont(priv.prime2));
          var qinv = priv.coefficient;
          var p = priv.prime1;
          var q = priv.prime2;
          var m1 = c1.redPow(priv.exponent1);
          var m2 = c2.redPow(priv.exponent2);
          m1 = m1.fromRed();
          m2 = m2.fromRed();
          var h3 = m1.isub(m2).imul(qinv).umod(p);
          h3.imul(q);
          m2.iadd(h3);
          return new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, len));
        }
        crt.getr = getr;
        function getr(priv) {
          var len = priv.modulus.byteLength();
          var r = new bn(randomBytes(len));
          while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2)) {
            r = new bn(randomBytes(len));
          }
          return r;
        }
      }).call(this, require2("buffer").Buffer);
    }, { "bn.js": 207, "buffer": 216, "randombytes": 475 }], 207: [function(require2, module2, exports2) {
      arguments[4][181][0].apply(exports2, arguments);
    }, { "buffer": 185, "dup": 181 }], 208: [function(require2, module2, exports2) {
      module2.exports = require2("./browser/algorithms.json");
    }, { "./browser/algorithms.json": 209 }], 209: [function(require2, module2, exports2) {
      module2.exports = { "sha224WithRSAEncryption": { "sign": "rsa", "hash": "sha224", "id": "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { "sign": "ecdsa/rsa", "hash": "sha224", "id": "302d300d06096086480165030402040500041c" }, "sha256WithRSAEncryption": { "sign": "rsa", "hash": "sha256", "id": "3031300d060960864801650304020105000420" }, "RSA-SHA256": { "sign": "ecdsa/rsa", "hash": "sha256", "id": "3031300d060960864801650304020105000420" }, "sha384WithRSAEncryption": { "sign": "rsa", "hash": "sha384", "id": "3041300d060960864801650304020205000430" }, "RSA-SHA384": { "sign": "ecdsa/rsa", "hash": "sha384", "id": "3041300d060960864801650304020205000430" }, "sha512WithRSAEncryption": { "sign": "rsa", "hash": "sha512", "id": "3051300d060960864801650304020305000440" }, "RSA-SHA512": { "sign": "ecdsa/rsa", "hash": "sha512", "id": "3051300d060960864801650304020305000440" }, "RSA-SHA1": { "sign": "rsa", "hash": "sha1", "id": "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { "sign": "ecdsa", "hash": "sha1", "id": "" }, "sha256": { "sign": "ecdsa", "hash": "sha256", "id": "" }, "sha224": { "sign": "ecdsa", "hash": "sha224", "id": "" }, "sha384": { "sign": "ecdsa", "hash": "sha384", "id": "" }, "sha512": { "sign": "ecdsa", "hash": "sha512", "id": "" }, "DSA-SHA": { "sign": "dsa", "hash": "sha1", "id": "" }, "DSA-SHA1": { "sign": "dsa", "hash": "sha1", "id": "" }, "DSA": { "sign": "dsa", "hash": "sha1", "id": "" }, "DSA-WITH-SHA224": { "sign": "dsa", "hash": "sha224", "id": "" }, "DSA-SHA224": { "sign": "dsa", "hash": "sha224", "id": "" }, "DSA-WITH-SHA256": { "sign": "dsa", "hash": "sha256", "id": "" }, "DSA-SHA256": { "sign": "dsa", "hash": "sha256", "id": "" }, "DSA-WITH-SHA384": { "sign": "dsa", "hash": "sha384", "id": "" }, "DSA-SHA384": { "sign": "dsa", "hash": "sha384", "id": "" }, "DSA-WITH-SHA512": { "sign": "dsa", "hash": "sha512", "id": "" }, "DSA-SHA512": { "sign": "dsa", "hash": "sha512", "id": "" }, "DSA-RIPEMD160": { "sign": "dsa", "hash": "rmd160", "id": "" }, "ripemd160WithRSA": { "sign": "rsa", "hash": "rmd160", "id": "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { "sign": "rsa", "hash": "rmd160", "id": "3021300906052b2403020105000414" }, "md5WithRSAEncryption": { "sign": "rsa", "hash": "md5", "id": "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { "sign": "rsa", "hash": "md5", "id": "3020300c06082a864886f70d020505000410" } };
    }, {}], 210: [function(require2, module2, exports2) {
      module2.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
    }, {}], 211: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var createHash = require2("create-hash");
      var stream = require2("readable-stream");
      var inherits = require2("inherits");
      var sign = require2("./sign");
      var verify = require2("./verify");
      var algorithms = require2("./algorithms.json");
      Object.keys(algorithms).forEach(function(key) {
        algorithms[key].id = Buffer.from(algorithms[key].id, "hex");
        algorithms[key.toLowerCase()] = algorithms[key];
      });
      function Sign(algorithm) {
        stream.Writable.call(this);
        var data = algorithms[algorithm];
        if (!data)
          throw new Error("Unknown message digest");
        this._hashType = data.hash;
        this._hash = createHash(data.hash);
        this._tag = data.id;
        this._signType = data.sign;
      }
      inherits(Sign, stream.Writable);
      Sign.prototype._write = function _write(data, _, done) {
        this._hash.update(data);
        done();
      };
      Sign.prototype.update = function update(data, enc) {
        if (typeof data === "string")
          data = Buffer.from(data, enc);
        this._hash.update(data);
        return this;
      };
      Sign.prototype.sign = function signMethod(key, enc) {
        this.end();
        var hash = this._hash.digest();
        var sig = sign(hash, key, this._hashType, this._signType, this._tag);
        return enc ? sig.toString(enc) : sig;
      };
      function Verify(algorithm) {
        stream.Writable.call(this);
        var data = algorithms[algorithm];
        if (!data)
          throw new Error("Unknown message digest");
        this._hash = createHash(data.hash);
        this._tag = data.id;
        this._signType = data.sign;
      }
      inherits(Verify, stream.Writable);
      Verify.prototype._write = function _write(data, _, done) {
        this._hash.update(data);
        done();
      };
      Verify.prototype.update = function update(data, enc) {
        if (typeof data === "string")
          data = Buffer.from(data, enc);
        this._hash.update(data);
        return this;
      };
      Verify.prototype.verify = function verifyMethod(key, sig, enc) {
        if (typeof sig === "string")
          sig = Buffer.from(sig, enc);
        this.end();
        var hash = this._hash.digest();
        return verify(sig, hash, key, this._signType, this._tag);
      };
      function createSign(algorithm) {
        return new Sign(algorithm);
      }
      function createVerify(algorithm) {
        return new Verify(algorithm);
      }
      module2.exports = { Sign: createSign, Verify: createVerify, createSign, createVerify };
    }, { "./algorithms.json": 209, "./sign": 212, "./verify": 213, "create-hash": 331, "inherits": 387, "readable-stream": 491, "safe-buffer": 214 }], 212: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var createHmac = require2("create-hmac");
      var crt = require2("browserify-rsa");
      var EC = require2("elliptic").ec;
      var BN = require2("bn.js");
      var parseKeys = require2("parse-asn1");
      var curves = require2("./curves.json");
      function sign(hash, key, hashType, signType, tag) {
        var priv = parseKeys(key);
        if (priv.curve) {
          if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong private key type");
          return ecSign(hash, priv);
        } else if (priv.type === "dsa") {
          if (signType !== "dsa")
            throw new Error("wrong private key type");
          return dsaSign(hash, priv, hashType);
        } else {
          if (signType !== "rsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong private key type");
        }
        hash = Buffer.concat([tag, hash]);
        var len = priv.modulus.byteLength();
        var pad = [0, 1];
        while (hash.length + pad.length + 1 < len) {
          pad.push(255);
        }
        pad.push(0);
        var i = -1;
        while (++i < hash.length) {
          pad.push(hash[i]);
        }
        var out = crt(pad, priv);
        return out;
      }
      function ecSign(hash, priv) {
        var curveId = curves[priv.curve.join(".")];
        if (!curveId)
          throw new Error("unknown curve " + priv.curve.join("."));
        var curve = new EC(curveId);
        var key = curve.keyFromPrivate(priv.privateKey);
        var out = key.sign(hash);
        return Buffer.from(out.toDER());
      }
      function dsaSign(hash, priv, algo) {
        var x = priv.params.priv_key;
        var p = priv.params.p;
        var q = priv.params.q;
        var g = priv.params.g;
        var r = new BN(0);
        var k;
        var H = bits2int(hash, q).mod(q);
        var s = false;
        var kv = getKey(x, q, hash, algo);
        while (s === false) {
          k = makeKey(q, kv, algo);
          r = makeR(g, k, p, q);
          s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
          if (s.cmpn(0) === 0) {
            s = false;
            r = new BN(0);
          }
        }
        return toDER(r, s);
      }
      function toDER(r, s) {
        r = r.toArray();
        s = s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        var total = r.length + s.length + 4;
        var res = [48, total, 2, r.length];
        res = res.concat(r, [2, s.length], s);
        return Buffer.from(res);
      }
      function getKey(x, q, hash, algo) {
        x = Buffer.from(x.toArray());
        if (x.length < q.byteLength()) {
          var zeros = Buffer.alloc(q.byteLength() - x.length);
          x = Buffer.concat([zeros, x]);
        }
        var hlen = hash.length;
        var hbits = bits2octets(hash, q);
        var v = Buffer.alloc(hlen);
        v.fill(1);
        var k = Buffer.alloc(hlen);
        k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest();
        v = createHmac(algo, k).update(v).digest();
        k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest();
        v = createHmac(algo, k).update(v).digest();
        return { k, v };
      }
      function bits2int(obits, q) {
        var bits = new BN(obits);
        var shift = (obits.length << 3) - q.bitLength();
        if (shift > 0)
          bits.ishrn(shift);
        return bits;
      }
      function bits2octets(bits, q) {
        bits = bits2int(bits, q);
        bits = bits.mod(q);
        var out = Buffer.from(bits.toArray());
        if (out.length < q.byteLength()) {
          var zeros = Buffer.alloc(q.byteLength() - out.length);
          out = Buffer.concat([zeros, out]);
        }
        return out;
      }
      function makeKey(q, kv, algo) {
        var t2;
        var k;
        do {
          t2 = Buffer.alloc(0);
          while (t2.length * 8 < q.bitLength()) {
            kv.v = createHmac(algo, kv.k).update(kv.v).digest();
            t2 = Buffer.concat([t2, kv.v]);
          }
          k = bits2int(t2, q);
          kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest();
          kv.v = createHmac(algo, kv.k).update(kv.v).digest();
        } while (k.cmp(q) !== -1);
        return k;
      }
      function makeR(g, k, p, q) {
        return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
      }
      module2.exports = sign;
      module2.exports.getKey = getKey;
      module2.exports.makeKey = makeKey;
    }, { "./curves.json": 210, "bn.js": 183, "browserify-rsa": 206, "create-hmac": 333, "elliptic": 350, "parse-asn1": 459, "safe-buffer": 214 }], 213: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var BN = require2("bn.js");
      var EC = require2("elliptic").ec;
      var parseKeys = require2("parse-asn1");
      var curves = require2("./curves.json");
      function verify(sig, hash, key, signType, tag) {
        var pub = parseKeys(key);
        if (pub.type === "ec") {
          if (signType !== "ecdsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong public key type");
          return ecVerify(sig, hash, pub);
        } else if (pub.type === "dsa") {
          if (signType !== "dsa")
            throw new Error("wrong public key type");
          return dsaVerify(sig, hash, pub);
        } else {
          if (signType !== "rsa" && signType !== "ecdsa/rsa")
            throw new Error("wrong public key type");
        }
        hash = Buffer.concat([tag, hash]);
        var len = pub.modulus.byteLength();
        var pad = [1];
        var padNum = 0;
        while (hash.length + pad.length + 2 < len) {
          pad.push(255);
          padNum++;
        }
        pad.push(0);
        var i = -1;
        while (++i < hash.length) {
          pad.push(hash[i]);
        }
        pad = Buffer.from(pad);
        var red = BN.mont(pub.modulus);
        sig = new BN(sig).toRed(red);
        sig = sig.redPow(new BN(pub.publicExponent));
        sig = Buffer.from(sig.fromRed().toArray());
        var out = padNum < 8 ? 1 : 0;
        len = Math.min(sig.length, pad.length);
        if (sig.length !== pad.length)
          out = 1;
        i = -1;
        while (++i < len) {
          out |= sig[i] ^ pad[i];
        }
        return out === 0;
      }
      function ecVerify(sig, hash, pub) {
        var curveId = curves[pub.data.algorithm.curve.join(".")];
        if (!curveId)
          throw new Error("unknown curve " + pub.data.algorithm.curve.join("."));
        var curve = new EC(curveId);
        var pubkey = pub.data.subjectPrivateKey.data;
        return curve.verify(hash, sig, pubkey);
      }
      function dsaVerify(sig, hash, pub) {
        var p = pub.data.p;
        var q = pub.data.q;
        var g = pub.data.g;
        var y = pub.data.pub_key;
        var unpacked = parseKeys.signature.decode(sig, "der");
        var s = unpacked.s;
        var r = unpacked.r;
        checkValue(s, q);
        checkValue(r, q);
        var montp = BN.mont(p);
        var w = s.invm(q);
        var v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
        return v.cmp(r) === 0;
      }
      function checkValue(b, q) {
        if (b.cmpn(0) <= 0)
          throw new Error("invalid sig");
        if (b.cmp(q) >= q)
          throw new Error("invalid sig");
      }
      module2.exports = verify;
    }, { "./curves.json": 210, "bn.js": 183, "elliptic": 350, "parse-asn1": 459, "safe-buffer": 214 }], 214: [function(require2, module2, exports2) {
      /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
      var buffer = require2("buffer");
      var Buffer = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
        module2.exports = buffer;
      } else {
        copyProps(buffer, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
      }
      SafeBuffer.prototype = Object.create(Buffer.prototype);
      copyProps(Buffer, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }, { "buffer": 216 }], 215: [function(require2, module2, exports2) {
      arguments[4][185][0].apply(exports2, arguments);
    }, { "dup": 185 }], 216: [function(require2, module2, exports2) {
      (function(Buffer) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        var base64 = require2("base64-js");
        var ieee754 = require2("ieee754");
        exports2.Buffer = Buffer;
        exports2.SlowBuffer = SlowBuffer;
        exports2.INSPECT_MAX_BYTES = 50;
        var K_MAX_LENGTH = 2147483647;
        exports2.kMaxLength = K_MAX_LENGTH;
        Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
        if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
          console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
        }
        function typedArraySupport() {
          try {
            var arr = new Uint8Array(1);
            arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function foo() {
              return 42;
            } };
            return arr.foo() === 42;
          } catch (e) {
            return false;
          }
        }
        Object.defineProperty(Buffer.prototype, "parent", { enumerable: true, get: function get() {
          if (!Buffer.isBuffer(this))
            return void 0;
          return this.buffer;
        } });
        Object.defineProperty(Buffer.prototype, "offset", { enumerable: true, get: function get() {
          if (!Buffer.isBuffer(this))
            return void 0;
          return this.byteOffset;
        } });
        function createBuffer(length) {
          if (length > K_MAX_LENGTH) {
            throw new RangeError('The value "' + length + '" is invalid for option "size"');
          }
          var buf = new Uint8Array(length);
          buf.__proto__ = Buffer.prototype;
          return buf;
        }
        function Buffer(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            if (typeof encodingOrOffset === "string") {
              throw new TypeError('The "string" argument must be of type string. Received type number');
            }
            return allocUnsafe(arg);
          }
          return from(arg, encodingOrOffset, length);
        }
        if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
          Object.defineProperty(Buffer, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false });
        }
        Buffer.poolSize = 8192;
        function from(value, encodingOrOffset, length) {
          if (typeof value === "string") {
            return fromString(value, encodingOrOffset);
          }
          if (ArrayBuffer.isView(value)) {
            return fromArrayLike(value);
          }
          if (value == null) {
            throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + _typeof2(value));
          }
          if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
          }
          if (typeof value === "number") {
            throw new TypeError('The "value" argument must not be of type number. Received type number');
          }
          var valueOf = value.valueOf && value.valueOf();
          if (valueOf != null && valueOf !== value) {
            return Buffer.from(valueOf, encodingOrOffset, length);
          }
          var b = fromObject(value);
          if (b)
            return b;
          if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
            return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
          }
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + _typeof2(value));
        }
        Buffer.from = function(value, encodingOrOffset, length) {
          return from(value, encodingOrOffset, length);
        };
        Buffer.prototype.__proto__ = Uint8Array.prototype;
        Buffer.__proto__ = Uint8Array;
        function assertSize(size) {
          if (typeof size !== "number") {
            throw new TypeError('"size" argument must be of type number');
          } else if (size < 0) {
            throw new RangeError('The value "' + size + '" is invalid for option "size"');
          }
        }
        function alloc(size, fill, encoding) {
          assertSize(size);
          if (size <= 0) {
            return createBuffer(size);
          }
          if (fill !== void 0) {
            return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
          }
          return createBuffer(size);
        }
        Buffer.alloc = function(size, fill, encoding) {
          return alloc(size, fill, encoding);
        };
        function allocUnsafe(size) {
          assertSize(size);
          return createBuffer(size < 0 ? 0 : checked(size) | 0);
        }
        Buffer.allocUnsafe = function(size) {
          return allocUnsafe(size);
        };
        Buffer.allocUnsafeSlow = function(size) {
          return allocUnsafe(size);
        };
        function fromString(string, encoding) {
          if (typeof encoding !== "string" || encoding === "") {
            encoding = "utf8";
          }
          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          var length = byteLength(string, encoding) | 0;
          var buf = createBuffer(length);
          var actual = buf.write(string, encoding);
          if (actual !== length) {
            buf = buf.slice(0, actual);
          }
          return buf;
        }
        function fromArrayLike(array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0;
          var buf = createBuffer(length);
          for (var i = 0; i < length; i += 1) {
            buf[i] = array[i] & 255;
          }
          return buf;
        }
        function fromArrayBuffer(array, byteOffset, length) {
          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError('"offset" is outside of buffer bounds');
          }
          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError('"length" is outside of buffer bounds');
          }
          var buf;
          if (byteOffset === void 0 && length === void 0) {
            buf = new Uint8Array(array);
          } else if (length === void 0) {
            buf = new Uint8Array(array, byteOffset);
          } else {
            buf = new Uint8Array(array, byteOffset, length);
          }
          buf.__proto__ = Buffer.prototype;
          return buf;
        }
        function fromObject(obj) {
          if (Buffer.isBuffer(obj)) {
            var len = checked(obj.length) | 0;
            var buf = createBuffer(len);
            if (buf.length === 0) {
              return buf;
            }
            obj.copy(buf, 0, 0, len);
            return buf;
          }
          if (obj.length !== void 0) {
            if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
              return createBuffer(0);
            }
            return fromArrayLike(obj);
          }
          if (obj.type === "Buffer" && Array.isArray(obj.data)) {
            return fromArrayLike(obj.data);
          }
        }
        function checked(length) {
          if (length >= K_MAX_LENGTH) {
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
          }
          return length | 0;
        }
        function SlowBuffer(length) {
          if (+length != length) {
            length = 0;
          }
          return Buffer.alloc(+length);
        }
        Buffer.isBuffer = function isBuffer(b) {
          return b != null && b._isBuffer === true && b !== Buffer.prototype;
        };
        Buffer.compare = function compare(a, b) {
          if (isInstance(a, Uint8Array))
            a = Buffer.from(a, a.offset, a.byteLength);
          if (isInstance(b, Uint8Array))
            b = Buffer.from(b, b.offset, b.byteLength);
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          }
          if (a === b)
            return 0;
          var x = a.length;
          var y = b.length;
          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y = b[i];
              break;
            }
          }
          if (x < y)
            return -1;
          if (y < x)
            return 1;
          return 0;
        };
        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        };
        Buffer.concat = function concat(list, length) {
          if (!Array.isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          if (list.length === 0) {
            return Buffer.alloc(0);
          }
          var i;
          if (length === void 0) {
            length = 0;
            for (i = 0; i < list.length; ++i) {
              length += list[i].length;
            }
          }
          var buffer = Buffer.allocUnsafe(length);
          var pos = 0;
          for (i = 0; i < list.length; ++i) {
            var buf = list[i];
            if (isInstance(buf, Uint8Array)) {
              buf = Buffer.from(buf);
            }
            if (!Buffer.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            buf.copy(buffer, pos);
            pos += buf.length;
          }
          return buffer;
        };
        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) {
            return string.length;
          }
          if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
            return string.byteLength;
          }
          if (typeof string !== "string") {
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + _typeof2(string));
          }
          var len = string.length;
          var mustMatch = arguments.length > 2 && arguments[2] === true;
          if (!mustMatch && len === 0)
            return 0;
          var loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len;
              case "utf8":
              case "utf-8":
                return utf8ToBytes(string).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return len * 2;
              case "hex":
                return len >>> 1;
              case "base64":
                return base64ToBytes(string).length;
              default:
                if (loweredCase) {
                  return mustMatch ? -1 : utf8ToBytes(string).length;
                }
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer.byteLength = byteLength;
        function slowToString(encoding, start, end) {
          var loweredCase = false;
          if (start === void 0 || start < 0) {
            start = 0;
          }
          if (start > this.length) {
            return "";
          }
          if (end === void 0 || end > this.length) {
            end = this.length;
          }
          if (end <= 0) {
            return "";
          }
          end >>>= 0;
          start >>>= 0;
          if (end <= start) {
            return "";
          }
          if (!encoding)
            encoding = "utf8";
          while (true) {
            switch (encoding) {
              case "hex":
                return hexSlice(this, start, end);
              case "utf8":
              case "utf-8":
                return utf8Slice(this, start, end);
              case "ascii":
                return asciiSlice(this, start, end);
              case "latin1":
              case "binary":
                return latin1Slice(this, start, end);
              case "base64":
                return base64Slice(this, start, end);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return utf16leSlice(this, start, end);
              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding);
                encoding = (encoding + "").toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer.prototype._isBuffer = true;
        function swap(b, n, m) {
          var i = b[n];
          b[n] = b[m];
          b[m] = i;
        }
        Buffer.prototype.swap16 = function swap16() {
          var len = this.length;
          if (len % 2 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 16-bits");
          }
          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1);
          }
          return this;
        };
        Buffer.prototype.swap32 = function swap32() {
          var len = this.length;
          if (len % 4 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 32-bits");
          }
          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3);
            swap(this, i + 1, i + 2);
          }
          return this;
        };
        Buffer.prototype.swap64 = function swap64() {
          var len = this.length;
          if (len % 8 !== 0) {
            throw new RangeError("Buffer size must be a multiple of 64-bits");
          }
          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7);
            swap(this, i + 1, i + 6);
            swap(this, i + 2, i + 5);
            swap(this, i + 3, i + 4);
          }
          return this;
        };
        Buffer.prototype.toString = function toString2() {
          var length = this.length;
          if (length === 0)
            return "";
          if (arguments.length === 0)
            return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments);
        };
        Buffer.prototype.toLocaleString = Buffer.prototype.toString;
        Buffer.prototype.equals = function equals2(b) {
          if (!Buffer.isBuffer(b))
            throw new TypeError("Argument must be a Buffer");
          if (this === b)
            return true;
          return Buffer.compare(this, b) === 0;
        };
        Buffer.prototype.inspect = function inspect() {
          var str = "";
          var max = exports2.INSPECT_MAX_BYTES;
          str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
          if (this.length > max)
            str += " ... ";
          return "<Buffer " + str + ">";
        };
        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
          if (isInstance(target, Uint8Array)) {
            target = Buffer.from(target, target.offset, target.byteLength);
          }
          if (!Buffer.isBuffer(target)) {
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + _typeof2(target));
          }
          if (start === void 0) {
            start = 0;
          }
          if (end === void 0) {
            end = target ? target.length : 0;
          }
          if (thisStart === void 0) {
            thisStart = 0;
          }
          if (thisEnd === void 0) {
            thisEnd = this.length;
          }
          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError("out of range index");
          }
          if (thisStart >= thisEnd && start >= end) {
            return 0;
          }
          if (thisStart >= thisEnd) {
            return -1;
          }
          if (start >= end) {
            return 1;
          }
          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;
          if (this === target)
            return 0;
          var x = thisEnd - thisStart;
          var y = end - start;
          var len = Math.min(x, y);
          var thisCopy = this.slice(thisStart, thisEnd);
          var targetCopy = target.slice(start, end);
          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i];
              y = targetCopy[i];
              break;
            }
          }
          if (x < y)
            return -1;
          if (y < x)
            return 1;
          return 0;
        };
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          if (buffer.length === 0)
            return -1;
          if (typeof byteOffset === "string") {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 2147483647) {
            byteOffset = 2147483647;
          } else if (byteOffset < -2147483648) {
            byteOffset = -2147483648;
          }
          byteOffset = +byteOffset;
          if (numberIsNaN(byteOffset)) {
            byteOffset = dir ? 0 : buffer.length - 1;
          }
          if (byteOffset < 0)
            byteOffset = buffer.length + byteOffset;
          if (byteOffset >= buffer.length) {
            if (dir)
              return -1;
            else
              byteOffset = buffer.length - 1;
          } else if (byteOffset < 0) {
            if (dir)
              byteOffset = 0;
            else
              return -1;
          }
          if (typeof val === "string") {
            val = Buffer.from(val, encoding);
          }
          if (Buffer.isBuffer(val)) {
            if (val.length === 0) {
              return -1;
            }
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
          } else if (typeof val === "number") {
            val = val & 255;
            if (typeof Uint8Array.prototype.indexOf === "function") {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
              }
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
          }
          throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1;
          var arrLength = arr.length;
          var valLength = val.length;
          if (encoding !== void 0) {
            encoding = String(encoding).toLowerCase();
            if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
              if (arr.length < 2 || val.length < 2) {
                return -1;
              }
              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }
          function read(buf, i2) {
            if (indexSize === 1) {
              return buf[i2];
            } else {
              return buf.readUInt16BE(i2 * indexSize);
            }
          }
          var i;
          if (dir) {
            var foundIndex = -1;
            for (i = byteOffset; i < arrLength; i++) {
              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1)
                  foundIndex = i;
                if (i - foundIndex + 1 === valLength)
                  return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1)
                  i -= i - foundIndex;
                foundIndex = -1;
              }
            }
          } else {
            if (byteOffset + valLength > arrLength)
              byteOffset = arrLength - valLength;
            for (i = byteOffset; i >= 0; i--) {
              var found = true;
              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false;
                  break;
                }
              }
              if (found)
                return i;
            }
          }
          return -1;
        }
        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };
        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };
        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }
          var strLen = string.length;
          if (length > strLen / 2) {
            length = strLen / 2;
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (numberIsNaN(parsed))
              return i;
            buf[offset + i] = parsed;
          }
          return i;
        }
        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length);
        }
        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length);
        }
        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }
        Buffer.prototype.write = function write(string, offset, length, encoding) {
          if (offset === void 0) {
            encoding = "utf8";
            length = this.length;
            offset = 0;
          } else if (length === void 0 && typeof offset === "string") {
            encoding = offset;
            length = this.length;
            offset = 0;
          } else if (isFinite(offset)) {
            offset = offset >>> 0;
            if (isFinite(length)) {
              length = length >>> 0;
              if (encoding === void 0)
                encoding = "utf8";
            } else {
              encoding = length;
              length = void 0;
            }
          } else {
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          }
          var remaining = this.length - offset;
          if (length === void 0 || length > remaining)
            length = remaining;
          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
            throw new RangeError("Attempt to write outside buffer bounds");
          }
          if (!encoding)
            encoding = "utf8";
          var loweredCase = false;
          for (; ; ) {
            switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length);
              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length);
              case "ascii":
                return asciiWrite(this, string, offset, length);
              case "latin1":
              case "binary":
                return latin1Write(this, string, offset, length);
              case "base64":
                return base64Write(this, string, offset, length);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length);
              default:
                if (loweredCase)
                  throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        };
        Buffer.prototype.toJSON = function toJSON() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf);
          } else {
            return base64.fromByteArray(buf.slice(start, end));
          }
        }
        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];
          var i = start;
          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;
              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 128) {
                    codePoint = firstByte;
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 192) === 128) {
                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                    if (tempCodePoint > 127) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                      codePoint = tempCodePoint;
                    }
                  }
              }
            }
            if (codePoint === null) {
              codePoint = 65533;
              bytesPerSequence = 1;
            } else if (codePoint > 65535) {
              codePoint -= 65536;
              res.push(codePoint >>> 10 & 1023 | 55296);
              codePoint = 56320 | codePoint & 1023;
            }
            res.push(codePoint);
            i += bytesPerSequence;
          }
          return decodeCodePointsArray(res);
        }
        var MAX_ARGUMENTS_LENGTH = 4096;
        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints);
          }
          var res = "";
          var i = 0;
          while (i < len) {
            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
          }
          return res;
        }
        function asciiSlice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 127);
          }
          return ret;
        }
        function latin1Slice(buf, start, end) {
          var ret = "";
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i]);
          }
          return ret;
        }
        function hexSlice(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0)
            start = 0;
          if (!end || end < 0 || end > len)
            end = len;
          var out = "";
          for (var i = start; i < end; ++i) {
            out += toHex2(buf[i]);
          }
          return out;
        }
        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = "";
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }
          return res;
        }
        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === void 0 ? len : ~~end;
          if (start < 0) {
            start += len;
            if (start < 0)
              start = 0;
          } else if (start > len) {
            start = len;
          }
          if (end < 0) {
            end += len;
            if (end < 0)
              end = 0;
          } else if (end > len) {
            end = len;
          }
          if (end < start)
            end = start;
          var newBuf = this.subarray(start, end);
          newBuf.__proto__ = Buffer.prototype;
          return newBuf;
        };
        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0)
            throw new RangeError("offset is not uint");
          if (offset + ext > length)
            throw new RangeError("Trying to access beyond buffer length");
        }
        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert)
            checkOffset(offset, byteLength2, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength2 && (mul *= 256)) {
            val += this[offset + i] * mul;
          }
          return val;
        };
        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert) {
            checkOffset(offset, byteLength2, this.length);
          }
          var val = this[offset + --byteLength2];
          var mul = 1;
          while (byteLength2 > 0 && (mul *= 256)) {
            val += this[offset + --byteLength2] * mul;
          }
          return val;
        };
        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 1, this.length);
          return this[offset];
        };
        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 2, this.length);
          return this[offset] | this[offset + 1] << 8;
        };
        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 2, this.length);
          return this[offset] << 8 | this[offset + 1];
        };
        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
        };
        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert)
            checkOffset(offset, byteLength2, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength2 && (mul *= 256)) {
            val += this[offset + i] * mul;
          }
          mul *= 128;
          if (val >= mul)
            val -= Math.pow(2, 8 * byteLength2);
          return val;
        };
        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert)
            checkOffset(offset, byteLength2, this.length);
          var i = byteLength2;
          var mul = 1;
          var val = this[offset + --i];
          while (i > 0 && (mul *= 256)) {
            val += this[offset + --i] * mul;
          }
          mul *= 128;
          if (val >= mul)
            val -= Math.pow(2, 8 * byteLength2);
          return val;
        };
        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 1, this.length);
          if (!(this[offset] & 128))
            return this[offset];
          return (255 - this[offset] + 1) * -1;
        };
        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 2, this.length);
          var val = this[offset] | this[offset + 1] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 2, this.length);
          var val = this[offset + 1] | this[offset] << 8;
          return val & 32768 ? val | 4294901760 : val;
        };
        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, true, 23, 4);
        };
        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, false, 23, 4);
        };
        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, true, 52, 8);
        };
        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          offset = offset >>> 0;
          if (!noAssert)
            checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf))
            throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max || value < min)
            throw new RangeError('"value" argument is out of bounds');
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range");
        }
        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
            checkInt(this, value, offset, byteLength2, maxBytes, 0);
          }
          var mul = 1;
          var i = 0;
          this[offset] = value & 255;
          while (++i < byteLength2 && (mul *= 256)) {
            this[offset + i] = value / mul & 255;
          }
          return offset + byteLength2;
        };
        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset >>> 0;
          byteLength2 = byteLength2 >>> 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
            checkInt(this, value, offset, byteLength2, maxBytes, 0);
          }
          var i = byteLength2 - 1;
          var mul = 1;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            this[offset + i] = value / mul & 255;
          }
          return offset + byteLength2;
        };
        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 1, 255, 0);
          this[offset] = value & 255;
          return offset + 1;
        };
        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 2, 65535, 0);
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          return offset + 2;
        };
        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 2, 65535, 0);
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
          return offset + 2;
        };
        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 4294967295, 0);
          this[offset + 3] = value >>> 24;
          this[offset + 2] = value >>> 16;
          this[offset + 1] = value >>> 8;
          this[offset] = value & 255;
          return offset + 4;
        };
        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 4294967295, 0);
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
          return offset + 4;
        };
        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength2 - 1);
            checkInt(this, value, offset, byteLength2, limit - 1, -limit);
          }
          var i = 0;
          var mul = 1;
          var sub = 0;
          this[offset] = value & 255;
          while (++i < byteLength2 && (mul *= 256)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub & 255;
          }
          return offset + byteLength2;
        };
        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength2 - 1);
            checkInt(this, value, offset, byteLength2, limit - 1, -limit);
          }
          var i = byteLength2 - 1;
          var mul = 1;
          var sub = 0;
          this[offset + i] = value & 255;
          while (--i >= 0 && (mul *= 256)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub & 255;
          }
          return offset + byteLength2;
        };
        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 1, 127, -128);
          if (value < 0)
            value = 255 + value + 1;
          this[offset] = value & 255;
          return offset + 1;
        };
        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 2, 32767, -32768);
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          return offset + 2;
        };
        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 2, 32767, -32768);
          this[offset] = value >>> 8;
          this[offset + 1] = value & 255;
          return offset + 2;
        };
        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 2147483647, -2147483648);
          this[offset] = value & 255;
          this[offset + 1] = value >>> 8;
          this[offset + 2] = value >>> 16;
          this[offset + 3] = value >>> 24;
          return offset + 4;
        };
        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert)
            checkInt(this, value, offset, 4, 2147483647, -2147483648);
          if (value < 0)
            value = 4294967295 + value + 1;
          this[offset] = value >>> 24;
          this[offset + 1] = value >>> 16;
          this[offset + 2] = value >>> 8;
          this[offset + 3] = value & 255;
          return offset + 4;
        };
        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length)
            throw new RangeError("Index out of range");
          if (offset < 0)
            throw new RangeError("Index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4);
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }
        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          value = +value;
          offset = offset >>> 0;
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8);
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }
        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert);
        };
        Buffer.prototype.copy = function copy2(target, targetStart, start, end) {
          if (!Buffer.isBuffer(target))
            throw new TypeError("argument should be a Buffer");
          if (!start)
            start = 0;
          if (!end && end !== 0)
            end = this.length;
          if (targetStart >= target.length)
            targetStart = target.length;
          if (!targetStart)
            targetStart = 0;
          if (end > 0 && end < start)
            end = start;
          if (end === start)
            return 0;
          if (target.length === 0 || this.length === 0)
            return 0;
          if (targetStart < 0) {
            throw new RangeError("targetStart out of bounds");
          }
          if (start < 0 || start >= this.length)
            throw new RangeError("Index out of range");
          if (end < 0)
            throw new RangeError("sourceEnd out of bounds");
          if (end > this.length)
            end = this.length;
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start;
          }
          var len = end - start;
          if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
            this.copyWithin(targetStart, start, end);
          } else if (this === target && start < targetStart && targetStart < end) {
            for (var i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start];
            }
          } else {
            Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
          }
          return len;
        };
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          if (typeof val === "string") {
            if (typeof start === "string") {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === "string") {
              encoding = end;
              end = this.length;
            }
            if (encoding !== void 0 && typeof encoding !== "string") {
              throw new TypeError("encoding must be a string");
            }
            if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0);
              if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
              }
            }
          } else if (typeof val === "number") {
            val = val & 255;
          }
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError("Out of range index");
          }
          if (end <= start) {
            return this;
          }
          start = start >>> 0;
          end = end === void 0 ? this.length : end >>> 0;
          if (!val)
            val = 0;
          var i;
          if (typeof val === "number") {
            for (i = start; i < end; ++i) {
              this[i] = val;
            }
          } else {
            var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
            var len = bytes.length;
            if (len === 0) {
              throw new TypeError('The value "' + val + '" is invalid for argument "value"');
            }
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len];
            }
          }
          return this;
        };
        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
        function base64clean(str) {
          str = str.split("=")[0];
          str = str.trim().replace(INVALID_BASE64_RE, "");
          if (str.length < 2)
            return "";
          while (str.length % 4 !== 0) {
            str = str + "=";
          }
          return str;
        }
        function toHex2(n) {
          if (n < 16)
            return "0" + n.toString(16);
          return n.toString(16);
        }
        function utf8ToBytes(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];
          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i);
            if (codePoint > 55295 && codePoint < 57344) {
              if (!leadSurrogate) {
                if (codePoint > 56319) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  continue;
                } else if (i + 1 === length) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  continue;
                }
                leadSurrogate = codePoint;
                continue;
              }
              if (codePoint < 56320) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
              }
              codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
            } else if (leadSurrogate) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
            }
            leadSurrogate = null;
            if (codePoint < 128) {
              if ((units -= 1) < 0)
                break;
              bytes.push(codePoint);
            } else if (codePoint < 2048) {
              if ((units -= 2) < 0)
                break;
              bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
            } else if (codePoint < 65536) {
              if ((units -= 3) < 0)
                break;
              bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
            } else if (codePoint < 1114112) {
              if ((units -= 4) < 0)
                break;
              bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
            } else {
              throw new Error("Invalid code point");
            }
          }
          return bytes;
        }
        function asciiToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            byteArray.push(str.charCodeAt(i) & 255);
          }
          return byteArray;
        }
        function utf16leToBytes(str, units) {
          var c, hi, lo;
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0)
              break;
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }
          return byteArray;
        }
        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length)
              break;
            dst[i + offset] = src[i];
          }
          return i;
        }
        function isInstance(obj, type) {
          return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
        }
        function numberIsNaN(obj) {
          return obj !== obj;
        }
      }).call(this, require2("buffer").Buffer);
    }, { "base64-js": 182, "buffer": 216, "ieee754": 385 }], 217: [function(require2, module2, exports2) {
      (function(Buffer) {
        module2.exports = function xor(a, b) {
          var length = Math.min(a.length, b.length);
          var buffer = new Buffer(length);
          for (var i = 0; i < length; ++i) {
            buffer[i] = a[i] ^ b[i];
          }
          return buffer;
        };
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 216 }], 218: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var Transform = require2("stream").Transform;
      var StringDecoder = require2("string_decoder").StringDecoder;
      var inherits = require2("inherits");
      function CipherBase(hashMode) {
        Transform.call(this);
        this.hashMode = typeof hashMode === "string";
        if (this.hashMode) {
          this[hashMode] = this._finalOrDigest;
        } else {
          this.final = this._finalOrDigest;
        }
        if (this._final) {
          this.__final = this._final;
          this._final = null;
        }
        this._decoder = null;
        this._encoding = null;
      }
      inherits(CipherBase, Transform);
      CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
        if (typeof data === "string") {
          data = Buffer.from(data, inputEnc);
        }
        var outData = this._update(data);
        if (this.hashMode)
          return this;
        if (outputEnc) {
          outData = this._toString(outData, outputEnc);
        }
        return outData;
      };
      CipherBase.prototype.setAutoPadding = function() {
      };
      CipherBase.prototype.getAuthTag = function() {
        throw new Error("trying to get auth tag in unsupported state");
      };
      CipherBase.prototype.setAuthTag = function() {
        throw new Error("trying to set auth tag in unsupported state");
      };
      CipherBase.prototype.setAAD = function() {
        throw new Error("trying to set aad in unsupported state");
      };
      CipherBase.prototype._transform = function(data, _, next) {
        var err;
        try {
          if (this.hashMode) {
            this._update(data);
          } else {
            this.push(this._update(data));
          }
        } catch (e) {
          err = e;
        } finally {
          next(err);
        }
      };
      CipherBase.prototype._flush = function(done) {
        var err;
        try {
          this.push(this.__final());
        } catch (e) {
          err = e;
        }
        done(err);
      };
      CipherBase.prototype._finalOrDigest = function(outputEnc) {
        var outData = this.__final() || Buffer.alloc(0);
        if (outputEnc) {
          outData = this._toString(outData, outputEnc, true);
        }
        return outData;
      };
      CipherBase.prototype._toString = function(value, enc, fin) {
        if (!this._decoder) {
          this._decoder = new StringDecoder(enc);
          this._encoding = enc;
        }
        if (this._encoding !== enc)
          throw new Error("can't switch encodings");
        var out = this._decoder.write(value);
        if (fin) {
          out += this._decoder.end();
        }
        return out;
      };
      module2.exports = CipherBase;
    }, { "inherits": 387, "safe-buffer": 494, "stream": 506, "string_decoder": 520 }], 219: [function(require2, module2, exports2) {
      module2.exports = function(it) {
        if (typeof it != "function") {
          throw TypeError(String(it) + " is not a function");
        }
        return it;
      };
    }, {}], 220: [function(require2, module2, exports2) {
      var isObject = require2("../internals/is-object");
      module2.exports = function(it) {
        if (!isObject(it) && it !== null) {
          throw TypeError("Can't set " + String(it) + " as a prototype");
        }
        return it;
      };
    }, { "../internals/is-object": 263 }], 221: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var create = require2("../internals/object-create");
      var definePropertyModule = require2("../internals/object-define-property");
      var UNSCOPABLES = wellKnownSymbol("unscopables");
      var ArrayPrototype = Array.prototype;
      if (ArrayPrototype[UNSCOPABLES] == void 0) {
        definePropertyModule.f(ArrayPrototype, UNSCOPABLES, { configurable: true, value: create(null) });
      }
      module2.exports = function(key) {
        ArrayPrototype[UNSCOPABLES][key] = true;
      };
    }, { "../internals/object-create": 276, "../internals/object-define-property": 278, "../internals/well-known-symbol": 314 }], 222: [function(require2, module2, exports2) {
      module2.exports = function(it, Constructor, name) {
        if (!(it instanceof Constructor)) {
          throw TypeError("Incorrect " + (name ? name + " " : "") + "invocation");
        }
        return it;
      };
    }, {}], 223: [function(require2, module2, exports2) {
      var isObject = require2("../internals/is-object");
      module2.exports = function(it) {
        if (!isObject(it)) {
          throw TypeError(String(it) + " is not an object");
        }
        return it;
      };
    }, { "../internals/is-object": 263 }], 224: [function(require2, module2, exports2) {
      var toIndexedObject = require2("../internals/to-indexed-object");
      var toLength = require2("../internals/to-length");
      var toAbsoluteIndex = require2("../internals/to-absolute-index");
      var createMethod = function createMethod2(IS_INCLUDES) {
        return function($this, el, fromIndex) {
          var O = toIndexedObject($this);
          var length = toLength(O.length);
          var index2 = toAbsoluteIndex(fromIndex, length);
          var value;
          if (IS_INCLUDES && el != el)
            while (length > index2) {
              value = O[index2++];
              if (value != value)
                return true;
            }
          else
            for (; length > index2; index2++) {
              if ((IS_INCLUDES || index2 in O) && O[index2] === el)
                return IS_INCLUDES || index2 || 0;
            }
          return !IS_INCLUDES && -1;
        };
      };
      module2.exports = {
        // `Array.prototype.includes` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.includes
        includes: createMethod(true),
        // `Array.prototype.indexOf` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
        indexOf: createMethod(false)
      };
    }, { "../internals/to-absolute-index": 304, "../internals/to-indexed-object": 305, "../internals/to-length": 307 }], 225: [function(require2, module2, exports2) {
      var bind2 = require2("../internals/function-bind-context");
      var IndexedObject = require2("../internals/indexed-object");
      var toObject = require2("../internals/to-object");
      var toLength = require2("../internals/to-length");
      var arraySpeciesCreate = require2("../internals/array-species-create");
      var push = [].push;
      var createMethod = function createMethod2(TYPE) {
        var IS_MAP = TYPE == 1;
        var IS_FILTER = TYPE == 2;
        var IS_SOME = TYPE == 3;
        var IS_EVERY = TYPE == 4;
        var IS_FIND_INDEX = TYPE == 6;
        var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
        return function($this, callbackfn, that, specificCreate) {
          var O = toObject($this);
          var self2 = IndexedObject(O);
          var boundFunction = bind2(callbackfn, that, 3);
          var length = toLength(self2.length);
          var index2 = 0;
          var create = specificCreate || arraySpeciesCreate;
          var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : void 0;
          var value, result;
          for (; length > index2; index2++)
            if (NO_HOLES || index2 in self2) {
              value = self2[index2];
              result = boundFunction(value, index2, O);
              if (TYPE) {
                if (IS_MAP)
                  target[index2] = result;
                else if (result)
                  switch (TYPE) {
                    case 3:
                      return true;
                    case 5:
                      return value;
                    case 6:
                      return index2;
                    case 2:
                      push.call(target, value);
                  }
                else if (IS_EVERY)
                  return false;
              }
            }
          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
        };
      };
      module2.exports = {
        // `Array.prototype.forEach` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
        forEach: createMethod(0),
        // `Array.prototype.map` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.map
        map: createMethod(1),
        // `Array.prototype.filter` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.filter
        filter: createMethod(2),
        // `Array.prototype.some` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.some
        some: createMethod(3),
        // `Array.prototype.every` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.every
        every: createMethod(4),
        // `Array.prototype.find` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.find
        find: createMethod(5),
        // `Array.prototype.findIndex` method
        // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
        findIndex: createMethod(6)
      };
    }, { "../internals/array-species-create": 227, "../internals/function-bind-context": 248, "../internals/indexed-object": 257, "../internals/to-length": 307, "../internals/to-object": 308 }], 226: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var fails = require2("../internals/fails");
      var has = require2("../internals/has");
      var defineProperty = Object.defineProperty;
      var cache2 = {};
      var thrower = function thrower2(it) {
        throw it;
      };
      module2.exports = function(METHOD_NAME, options) {
        if (has(cache2, METHOD_NAME))
          return cache2[METHOD_NAME];
        if (!options)
          options = {};
        var method = [][METHOD_NAME];
        var ACCESSORS = has(options, "ACCESSORS") ? options.ACCESSORS : false;
        var argument0 = has(options, 0) ? options[0] : thrower;
        var argument1 = has(options, 1) ? options[1] : void 0;
        return cache2[METHOD_NAME] = !!method && !fails(function() {
          if (ACCESSORS && !DESCRIPTORS)
            return true;
          var O = { length: -1 };
          if (ACCESSORS)
            defineProperty(O, 1, { enumerable: true, get: thrower });
          else
            O[1] = 1;
          method.call(O, argument0, argument1);
        });
      };
    }, { "../internals/descriptors": 240, "../internals/fails": 247, "../internals/has": 252 }], 227: [function(require2, module2, exports2) {
      var isObject = require2("../internals/is-object");
      var isArray = require2("../internals/is-array");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var SPECIES = wellKnownSymbol("species");
      module2.exports = function(originalArray, length) {
        var C;
        if (isArray(originalArray)) {
          C = originalArray.constructor;
          if (typeof C == "function" && (C === Array || isArray(C.prototype)))
            C = void 0;
          else if (isObject(C)) {
            C = C[SPECIES];
            if (C === null)
              C = void 0;
          }
        }
        return new (C === void 0 ? Array : C)(length === 0 ? 0 : length);
      };
    }, { "../internals/is-array": 261, "../internals/is-object": 263, "../internals/well-known-symbol": 314 }], 228: [function(require2, module2, exports2) {
      var anObject = require2("../internals/an-object");
      module2.exports = function(iterator, fn, value, ENTRIES) {
        try {
          return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
        } catch (error) {
          var returnMethod = iterator["return"];
          if (returnMethod !== void 0)
            anObject(returnMethod.call(iterator));
          throw error;
        }
      };
    }, { "../internals/an-object": 223 }], 229: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var ITERATOR = wellKnownSymbol("iterator");
      var SAFE_CLOSING = false;
      try {
        var called = 0;
        var iteratorWithReturn = { next: function next() {
          return { done: !!called++ };
        }, "return": function _return() {
          SAFE_CLOSING = true;
        } };
        iteratorWithReturn[ITERATOR] = function() {
          return this;
        };
        Array.from(iteratorWithReturn, function() {
          throw 2;
        });
      } catch (error) {
      }
      module2.exports = function(exec, SKIP_CLOSING) {
        if (!SKIP_CLOSING && !SAFE_CLOSING)
          return false;
        var ITERATION_SUPPORT = false;
        try {
          var object = {};
          object[ITERATOR] = function() {
            return { next: function next() {
              return { done: ITERATION_SUPPORT = true };
            } };
          };
          exec(object);
        } catch (error) {
        }
        return ITERATION_SUPPORT;
      };
    }, { "../internals/well-known-symbol": 314 }], 230: [function(require2, module2, exports2) {
      var toString2 = {}.toString;
      module2.exports = function(it) {
        return toString2.call(it).slice(8, -1);
      };
    }, {}], 231: [function(require2, module2, exports2) {
      var TO_STRING_TAG_SUPPORT = require2("../internals/to-string-tag-support");
      var classofRaw = require2("../internals/classof-raw");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var CORRECT_ARGUMENTS = classofRaw(function() {
        return arguments;
      }()) == "Arguments";
      var tryGet = function tryGet2(it, key) {
        try {
          return it[key];
        } catch (error) {
        }
      };
      module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
        var O, tag, result;
        return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
      };
    }, { "../internals/classof-raw": 230, "../internals/to-string-tag-support": 310, "../internals/well-known-symbol": 314 }], 232: [function(require2, module2, exports2) {
      var has = require2("../internals/has");
      var ownKeys2 = require2("../internals/own-keys");
      var getOwnPropertyDescriptorModule = require2("../internals/object-get-own-property-descriptor");
      var definePropertyModule = require2("../internals/object-define-property");
      module2.exports = function(target, source) {
        var keys = ownKeys2(source);
        var defineProperty = definePropertyModule.f;
        var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (!has(target, key))
            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
        }
      };
    }, { "../internals/has": 252, "../internals/object-define-property": 278, "../internals/object-get-own-property-descriptor": 279, "../internals/own-keys": 289 }], 233: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var MATCH = wellKnownSymbol("match");
      module2.exports = function(METHOD_NAME) {
        var regexp = /./;
        try {
          "/./"[METHOD_NAME](regexp);
        } catch (e) {
          try {
            regexp[MATCH] = false;
            return "/./"[METHOD_NAME](regexp);
          } catch (f) {
          }
        }
        return false;
      };
    }, { "../internals/well-known-symbol": 314 }], 234: [function(require2, module2, exports2) {
      var fails = require2("../internals/fails");
      module2.exports = !fails(function() {
        function F() {
        }
        F.prototype.constructor = null;
        return Object.getPrototypeOf(new F()) !== F.prototype;
      });
    }, { "../internals/fails": 247 }], 235: [function(require2, module2, exports2) {
      var IteratorPrototype = require2("../internals/iterators-core").IteratorPrototype;
      var create = require2("../internals/object-create");
      var createPropertyDescriptor = require2("../internals/create-property-descriptor");
      var setToStringTag = require2("../internals/set-to-string-tag");
      var Iterators = require2("../internals/iterators");
      var returnThis = function returnThis2() {
        return this;
      };
      module2.exports = function(IteratorConstructor, NAME, next) {
        var TO_STRING_TAG = NAME + " Iterator";
        IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
        setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
        Iterators[TO_STRING_TAG] = returnThis;
        return IteratorConstructor;
      };
    }, { "../internals/create-property-descriptor": 237, "../internals/iterators": 268, "../internals/iterators-core": 267, "../internals/object-create": 276, "../internals/set-to-string-tag": 298 }], 236: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var definePropertyModule = require2("../internals/object-define-property");
      var createPropertyDescriptor = require2("../internals/create-property-descriptor");
      module2.exports = DESCRIPTORS ? function(object, key, value) {
        return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
      } : function(object, key, value) {
        object[key] = value;
        return object;
      };
    }, { "../internals/create-property-descriptor": 237, "../internals/descriptors": 240, "../internals/object-define-property": 278 }], 237: [function(require2, module2, exports2) {
      module2.exports = function(bitmap, value) {
        return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value };
      };
    }, {}], 238: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      var createIteratorConstructor = require2("../internals/create-iterator-constructor");
      var getPrototypeOf = require2("../internals/object-get-prototype-of");
      var setPrototypeOf = require2("../internals/object-set-prototype-of");
      var setToStringTag = require2("../internals/set-to-string-tag");
      var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
      var redefine = require2("../internals/redefine");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var IS_PURE = require2("../internals/is-pure");
      var Iterators = require2("../internals/iterators");
      var IteratorsCore = require2("../internals/iterators-core");
      var IteratorPrototype = IteratorsCore.IteratorPrototype;
      var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
      var ITERATOR = wellKnownSymbol("iterator");
      var KEYS = "keys";
      var VALUES = "values";
      var ENTRIES = "entries";
      var returnThis = function returnThis2() {
        return this;
      };
      module2.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
        createIteratorConstructor(IteratorConstructor, NAME, next);
        var getIterationMethod = function getIterationMethod2(KIND) {
          if (KIND === DEFAULT && defaultIterator)
            return defaultIterator;
          if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
            return IterablePrototype[KIND];
          switch (KIND) {
            case KEYS:
              return function keys() {
                return new IteratorConstructor(this, KIND);
              };
            case VALUES:
              return function values() {
                return new IteratorConstructor(this, KIND);
              };
            case ENTRIES:
              return function entries() {
                return new IteratorConstructor(this, KIND);
              };
          }
          return function() {
            return new IteratorConstructor(this);
          };
        };
        var TO_STRING_TAG = NAME + " Iterator";
        var INCORRECT_VALUES_NAME = false;
        var IterablePrototype = Iterable.prototype;
        var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
        var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
        var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
        var CurrentIteratorPrototype, methods, KEY;
        if (anyNativeIterator) {
          CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
          if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
              if (setPrototypeOf) {
                setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
              } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
              }
            }
            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
            if (IS_PURE)
              Iterators[TO_STRING_TAG] = returnThis;
          }
        }
        if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
          INCORRECT_VALUES_NAME = true;
          defaultIterator = function values() {
            return nativeIterator.call(this);
          };
        }
        if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
          createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
        }
        Iterators[NAME] = defaultIterator;
        if (DEFAULT) {
          methods = { values: getIterationMethod(VALUES), keys: IS_SET ? defaultIterator : getIterationMethod(KEYS), entries: getIterationMethod(ENTRIES) };
          if (FORCED)
            for (KEY in methods) {
              if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                redefine(IterablePrototype, KEY, methods[KEY]);
              }
            }
          else
            $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
        }
        return methods;
      };
    }, { "../internals/create-iterator-constructor": 235, "../internals/create-non-enumerable-property": 236, "../internals/export": 246, "../internals/is-pure": 264, "../internals/iterators": 268, "../internals/iterators-core": 267, "../internals/object-get-prototype-of": 283, "../internals/object-set-prototype-of": 287, "../internals/redefine": 294, "../internals/set-to-string-tag": 298, "../internals/well-known-symbol": 314 }], 239: [function(require2, module2, exports2) {
      var path = require2("../internals/path");
      var has = require2("../internals/has");
      var wrappedWellKnownSymbolModule = require2("../internals/well-known-symbol-wrapped");
      var defineProperty = require2("../internals/object-define-property").f;
      module2.exports = function(NAME) {
        var Symbol2 = path.Symbol || (path.Symbol = {});
        if (!has(Symbol2, NAME))
          defineProperty(Symbol2, NAME, { value: wrappedWellKnownSymbolModule.f(NAME) });
      };
    }, { "../internals/has": 252, "../internals/object-define-property": 278, "../internals/path": 290, "../internals/well-known-symbol-wrapped": 313 }], 240: [function(require2, module2, exports2) {
      var fails = require2("../internals/fails");
      module2.exports = !fails(function() {
        return Object.defineProperty({}, 1, { get: function get() {
          return 7;
        } })[1] != 7;
      });
    }, { "../internals/fails": 247 }], 241: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var isObject = require2("../internals/is-object");
      var document2 = global2.document;
      var EXISTS = isObject(document2) && isObject(document2.createElement);
      module2.exports = function(it) {
        return EXISTS ? document2.createElement(it) : {};
      };
    }, { "../internals/global": 251, "../internals/is-object": 263 }], 242: [function(require2, module2, exports2) {
      var userAgent = require2("../internals/engine-user-agent");
      module2.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);
    }, { "../internals/engine-user-agent": 243 }], 243: [function(require2, module2, exports2) {
      var getBuiltIn = require2("../internals/get-built-in");
      module2.exports = getBuiltIn("navigator", "userAgent") || "";
    }, { "../internals/get-built-in": 249 }], 244: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var userAgent = require2("../internals/engine-user-agent");
      var process = global2.process;
      var versions = process && process.versions;
      var v8 = versions && versions.v8;
      var match, version;
      if (v8) {
        match = v8.split(".");
        version = match[0] + match[1];
      } else if (userAgent) {
        match = userAgent.match(/Edge\/(\d+)/);
        if (!match || match[1] >= 74) {
          match = userAgent.match(/Chrome\/(\d+)/);
          if (match)
            version = match[1];
        }
      }
      module2.exports = version && +version;
    }, { "../internals/engine-user-agent": 243, "../internals/global": 251 }], 245: [function(require2, module2, exports2) {
      module2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
    }, {}], 246: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var getOwnPropertyDescriptor = require2("../internals/object-get-own-property-descriptor").f;
      var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
      var redefine = require2("../internals/redefine");
      var setGlobal = require2("../internals/set-global");
      var copyConstructorProperties = require2("../internals/copy-constructor-properties");
      var isForced = require2("../internals/is-forced");
      module2.exports = function(options, source) {
        var TARGET = options.target;
        var GLOBAL = options.global;
        var STATIC = options.stat;
        var FORCED, target, key, targetProperty, sourceProperty, descriptor;
        if (GLOBAL) {
          target = global2;
        } else if (STATIC) {
          target = global2[TARGET] || setGlobal(TARGET, {});
        } else {
          target = (global2[TARGET] || {}).prototype;
        }
        if (target)
          for (key in source) {
            sourceProperty = source[key];
            if (options.noTargetGet) {
              descriptor = getOwnPropertyDescriptor(target, key);
              targetProperty = descriptor && descriptor.value;
            } else
              targetProperty = target[key];
            FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
            if (!FORCED && targetProperty !== void 0) {
              if (typeof sourceProperty === typeof targetProperty)
                continue;
              copyConstructorProperties(sourceProperty, targetProperty);
            }
            if (options.sham || targetProperty && targetProperty.sham) {
              createNonEnumerableProperty(sourceProperty, "sham", true);
            }
            redefine(target, key, sourceProperty, options);
          }
      };
    }, { "../internals/copy-constructor-properties": 232, "../internals/create-non-enumerable-property": 236, "../internals/global": 251, "../internals/is-forced": 262, "../internals/object-get-own-property-descriptor": 279, "../internals/redefine": 294, "../internals/set-global": 296 }], 247: [function(require2, module2, exports2) {
      module2.exports = function(exec) {
        try {
          return !!exec();
        } catch (error) {
          return true;
        }
      };
    }, {}], 248: [function(require2, module2, exports2) {
      var aFunction = require2("../internals/a-function");
      module2.exports = function(fn, that, length) {
        aFunction(fn);
        if (that === void 0)
          return fn;
        switch (length) {
          case 0:
            return function() {
              return fn.call(that);
            };
          case 1:
            return function(a) {
              return fn.call(that, a);
            };
          case 2:
            return function(a, b) {
              return fn.call(that, a, b);
            };
          case 3:
            return function(a, b, c) {
              return fn.call(that, a, b, c);
            };
        }
        return function() {
          return fn.apply(that, arguments);
        };
      };
    }, { "../internals/a-function": 219 }], 249: [function(require2, module2, exports2) {
      var path = require2("../internals/path");
      var global2 = require2("../internals/global");
      var aFunction = function aFunction2(variable) {
        return typeof variable == "function" ? variable : void 0;
      };
      module2.exports = function(namespace, method) {
        return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global2[namespace]) : path[namespace] && path[namespace][method] || global2[namespace] && global2[namespace][method];
      };
    }, { "../internals/global": 251, "../internals/path": 290 }], 250: [function(require2, module2, exports2) {
      var classof = require2("../internals/classof");
      var Iterators = require2("../internals/iterators");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var ITERATOR = wellKnownSymbol("iterator");
      module2.exports = function(it) {
        if (it != void 0)
          return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
      };
    }, { "../internals/classof": 231, "../internals/iterators": 268, "../internals/well-known-symbol": 314 }], 251: [function(require2, module2, exports2) {
      (function(global2) {
        var check = function check2(it) {
          return it && it.Math == Math && it;
        };
        module2.exports = // eslint-disable-next-line no-undef
        check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof global2 == "object" && global2) || // eslint-disable-next-line no-new-func
        Function("return this")();
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 252: [function(require2, module2, exports2) {
      var hasOwnProperty3 = {}.hasOwnProperty;
      module2.exports = function(it, key) {
        return hasOwnProperty3.call(it, key);
      };
    }, {}], 253: [function(require2, module2, exports2) {
      module2.exports = {};
    }, {}], 254: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      module2.exports = function(a, b) {
        var console2 = global2.console;
        if (console2 && console2.error) {
          arguments.length === 1 ? console2.error(a) : console2.error(a, b);
        }
      };
    }, { "../internals/global": 251 }], 255: [function(require2, module2, exports2) {
      var getBuiltIn = require2("../internals/get-built-in");
      module2.exports = getBuiltIn("document", "documentElement");
    }, { "../internals/get-built-in": 249 }], 256: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var fails = require2("../internals/fails");
      var createElement = require2("../internals/document-create-element");
      module2.exports = !DESCRIPTORS && !fails(function() {
        return Object.defineProperty(createElement("div"), "a", { get: function get() {
          return 7;
        } }).a != 7;
      });
    }, { "../internals/descriptors": 240, "../internals/document-create-element": 241, "../internals/fails": 247 }], 257: [function(require2, module2, exports2) {
      var fails = require2("../internals/fails");
      var classof = require2("../internals/classof-raw");
      var split = "".split;
      module2.exports = fails(function() {
        return !Object("z").propertyIsEnumerable(0);
      }) ? function(it) {
        return classof(it) == "String" ? split.call(it, "") : Object(it);
      } : Object;
    }, { "../internals/classof-raw": 230, "../internals/fails": 247 }], 258: [function(require2, module2, exports2) {
      var store = require2("../internals/shared-store");
      var functionToString = Function.toString;
      if (typeof store.inspectSource != "function") {
        store.inspectSource = function(it) {
          return functionToString.call(it);
        };
      }
      module2.exports = store.inspectSource;
    }, { "../internals/shared-store": 300 }], 259: [function(require2, module2, exports2) {
      var NATIVE_WEAK_MAP = require2("../internals/native-weak-map");
      var global2 = require2("../internals/global");
      var isObject = require2("../internals/is-object");
      var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
      var objectHas = require2("../internals/has");
      var sharedKey = require2("../internals/shared-key");
      var hiddenKeys = require2("../internals/hidden-keys");
      var WeakMap2 = global2.WeakMap;
      var set, get, has;
      var enforce = function enforce2(it) {
        return has(it) ? get(it) : set(it, {});
      };
      var getterFor = function getterFor2(TYPE) {
        return function(it) {
          var state;
          if (!isObject(it) || (state = get(it)).type !== TYPE) {
            throw TypeError("Incompatible receiver, " + TYPE + " required");
          }
          return state;
        };
      };
      if (NATIVE_WEAK_MAP) {
        var store = new WeakMap2();
        var wmget = store.get;
        var wmhas = store.has;
        var wmset = store.set;
        set = function set2(it, metadata) {
          wmset.call(store, it, metadata);
          return metadata;
        };
        get = function get2(it) {
          return wmget.call(store, it) || {};
        };
        has = function has2(it) {
          return wmhas.call(store, it);
        };
      } else {
        var STATE = sharedKey("state");
        hiddenKeys[STATE] = true;
        set = function set2(it, metadata) {
          createNonEnumerableProperty(it, STATE, metadata);
          return metadata;
        };
        get = function get2(it) {
          return objectHas(it, STATE) ? it[STATE] : {};
        };
        has = function has2(it) {
          return objectHas(it, STATE);
        };
      }
      module2.exports = { set, get, has, enforce, getterFor };
    }, { "../internals/create-non-enumerable-property": 236, "../internals/global": 251, "../internals/has": 252, "../internals/hidden-keys": 253, "../internals/is-object": 263, "../internals/native-weak-map": 272, "../internals/shared-key": 299 }], 260: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var Iterators = require2("../internals/iterators");
      var ITERATOR = wellKnownSymbol("iterator");
      var ArrayPrototype = Array.prototype;
      module2.exports = function(it) {
        return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
      };
    }, { "../internals/iterators": 268, "../internals/well-known-symbol": 314 }], 261: [function(require2, module2, exports2) {
      var classof = require2("../internals/classof-raw");
      module2.exports = Array.isArray || function isArray(arg) {
        return classof(arg) == "Array";
      };
    }, { "../internals/classof-raw": 230 }], 262: [function(require2, module2, exports2) {
      var fails = require2("../internals/fails");
      var replacement = /#|\.prototype\./;
      var isForced = function isForced2(feature, detection) {
        var value = data[normalize(feature)];
        return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
      };
      var normalize = isForced.normalize = function(string) {
        return String(string).replace(replacement, ".").toLowerCase();
      };
      var data = isForced.data = {};
      var NATIVE = isForced.NATIVE = "N";
      var POLYFILL = isForced.POLYFILL = "P";
      module2.exports = isForced;
    }, { "../internals/fails": 247 }], 263: [function(require2, module2, exports2) {
      module2.exports = function(it) {
        return typeof it === "object" ? it !== null : typeof it === "function";
      };
    }, {}], 264: [function(require2, module2, exports2) {
      module2.exports = false;
    }, {}], 265: [function(require2, module2, exports2) {
      var isObject = require2("../internals/is-object");
      var classof = require2("../internals/classof-raw");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var MATCH = wellKnownSymbol("match");
      module2.exports = function(it) {
        var isRegExp;
        return isObject(it) && ((isRegExp = it[MATCH]) !== void 0 ? !!isRegExp : classof(it) == "RegExp");
      };
    }, { "../internals/classof-raw": 230, "../internals/is-object": 263, "../internals/well-known-symbol": 314 }], 266: [function(require2, module2, exports2) {
      var anObject = require2("../internals/an-object");
      var isArrayIteratorMethod = require2("../internals/is-array-iterator-method");
      var toLength = require2("../internals/to-length");
      var bind2 = require2("../internals/function-bind-context");
      var getIteratorMethod = require2("../internals/get-iterator-method");
      var callWithSafeIterationClosing = require2("../internals/call-with-safe-iteration-closing");
      var Result = function Result2(stopped, result) {
        this.stopped = stopped;
        this.result = result;
      };
      var iterate = module2.exports = function(iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
        var boundFunction = bind2(fn, that, AS_ENTRIES ? 2 : 1);
        var iterator, iterFn, index2, length, result, next, step;
        if (IS_ITERATOR) {
          iterator = iterable;
        } else {
          iterFn = getIteratorMethod(iterable);
          if (typeof iterFn != "function")
            throw TypeError("Target is not iterable");
          if (isArrayIteratorMethod(iterFn)) {
            for (index2 = 0, length = toLength(iterable.length); length > index2; index2++) {
              result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index2])[0], step[1]) : boundFunction(iterable[index2]);
              if (result && result instanceof Result)
                return result;
            }
            return new Result(false);
          }
          iterator = iterFn.call(iterable);
        }
        next = iterator.next;
        while (!(step = next.call(iterator)).done) {
          result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
          if (typeof result == "object" && result && result instanceof Result)
            return result;
        }
        return new Result(false);
      };
      iterate.stop = function(result) {
        return new Result(true, result);
      };
    }, { "../internals/an-object": 223, "../internals/call-with-safe-iteration-closing": 228, "../internals/function-bind-context": 248, "../internals/get-iterator-method": 250, "../internals/is-array-iterator-method": 260, "../internals/to-length": 307 }], 267: [function(require2, module2, exports2) {
      var getPrototypeOf = require2("../internals/object-get-prototype-of");
      var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
      var has = require2("../internals/has");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var IS_PURE = require2("../internals/is-pure");
      var ITERATOR = wellKnownSymbol("iterator");
      var BUGGY_SAFARI_ITERATORS = false;
      var returnThis = function returnThis2() {
        return this;
      };
      var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
      if ([].keys) {
        arrayIterator = [].keys();
        if (!("next" in arrayIterator))
          BUGGY_SAFARI_ITERATORS = true;
        else {
          PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
          if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
            IteratorPrototype = PrototypeOfArrayIteratorPrototype;
        }
      }
      if (IteratorPrototype == void 0)
        IteratorPrototype = {};
      if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
        createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
      }
      module2.exports = { IteratorPrototype, BUGGY_SAFARI_ITERATORS };
    }, { "../internals/create-non-enumerable-property": 236, "../internals/has": 252, "../internals/is-pure": 264, "../internals/object-get-prototype-of": 283, "../internals/well-known-symbol": 314 }], 268: [function(require2, module2, exports2) {
      arguments[4][253][0].apply(exports2, arguments);
    }, { "dup": 253 }], 269: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var getOwnPropertyDescriptor = require2("../internals/object-get-own-property-descriptor").f;
      var classof = require2("../internals/classof-raw");
      var macrotask = require2("../internals/task").set;
      var IS_IOS = require2("../internals/engine-is-ios");
      var MutationObserver2 = global2.MutationObserver || global2.WebKitMutationObserver;
      var process = global2.process;
      var Promise2 = global2.Promise;
      var IS_NODE = classof(process) == "process";
      var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global2, "queueMicrotask");
      var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
      var flush, head, last, notify, toggle, node, promise, then;
      if (!queueMicrotask) {
        flush = function flush2() {
          var parent, fn;
          if (IS_NODE && (parent = process.domain))
            parent.exit();
          while (head) {
            fn = head.fn;
            head = head.next;
            try {
              fn();
            } catch (error) {
              if (head)
                notify();
              else
                last = void 0;
              throw error;
            }
          }
          last = void 0;
          if (parent)
            parent.enter();
        };
        if (IS_NODE) {
          notify = function notify2() {
            process.nextTick(flush);
          };
        } else if (MutationObserver2 && !IS_IOS) {
          toggle = true;
          node = document.createTextNode("");
          new MutationObserver2(flush).observe(node, { characterData: true });
          notify = function notify2() {
            node.data = toggle = !toggle;
          };
        } else if (Promise2 && Promise2.resolve) {
          promise = Promise2.resolve(void 0);
          then = promise.then;
          notify = function notify2() {
            then.call(promise, flush);
          };
        } else {
          notify = function notify2() {
            macrotask.call(global2, flush);
          };
        }
      }
      module2.exports = queueMicrotask || function(fn) {
        var task = { fn, next: void 0 };
        if (last)
          last.next = task;
        if (!head) {
          head = task;
          notify();
        }
        last = task;
      };
    }, { "../internals/classof-raw": 230, "../internals/engine-is-ios": 242, "../internals/global": 251, "../internals/object-get-own-property-descriptor": 279, "../internals/task": 303 }], 270: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      module2.exports = global2.Promise;
    }, { "../internals/global": 251 }], 271: [function(require2, module2, exports2) {
      var fails = require2("../internals/fails");
      module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
        return !String(Symbol());
      });
    }, { "../internals/fails": 247 }], 272: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var inspectSource = require2("../internals/inspect-source");
      var WeakMap2 = global2.WeakMap;
      module2.exports = typeof WeakMap2 === "function" && /native code/.test(inspectSource(WeakMap2));
    }, { "../internals/global": 251, "../internals/inspect-source": 258 }], 273: [function(require2, module2, exports2) {
      var aFunction = require2("../internals/a-function");
      var PromiseCapability = function PromiseCapability2(C) {
        var resolve, reject;
        this.promise = new C(function($$resolve, $$reject) {
          if (resolve !== void 0 || reject !== void 0)
            throw TypeError("Bad Promise constructor");
          resolve = $$resolve;
          reject = $$reject;
        });
        this.resolve = aFunction(resolve);
        this.reject = aFunction(reject);
      };
      module2.exports.f = function(C) {
        return new PromiseCapability(C);
      };
    }, { "../internals/a-function": 219 }], 274: [function(require2, module2, exports2) {
      var isRegExp = require2("../internals/is-regexp");
      module2.exports = function(it) {
        if (isRegExp(it)) {
          throw TypeError("The method doesn't accept regular expressions");
        }
        return it;
      };
    }, { "../internals/is-regexp": 265 }], 275: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var fails = require2("../internals/fails");
      var objectKeys = require2("../internals/object-keys");
      var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
      var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
      var toObject = require2("../internals/to-object");
      var IndexedObject = require2("../internals/indexed-object");
      var nativeAssign = Object.assign;
      var defineProperty = Object.defineProperty;
      module2.exports = !nativeAssign || fails(function() {
        if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, "a", { enumerable: true, get: function get() {
          defineProperty(this, "b", { value: 3, enumerable: false });
        } }), { b: 2 })).b !== 1)
          return true;
        var A = {};
        var B = {};
        var symbol = Symbol();
        var alphabet = "abcdefghijklmnopqrst";
        A[symbol] = 7;
        alphabet.split("").forEach(function(chr) {
          B[chr] = chr;
        });
        return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join("") != alphabet;
      }) ? function assign(target, source) {
        var T = toObject(target);
        var argumentsLength = arguments.length;
        var index2 = 1;
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        var propertyIsEnumerable = propertyIsEnumerableModule.f;
        while (argumentsLength > index2) {
          var S = IndexedObject(arguments[index2++]);
          var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
          var length = keys.length;
          var j = 0;
          var key;
          while (length > j) {
            key = keys[j++];
            if (!DESCRIPTORS || propertyIsEnumerable.call(S, key))
              T[key] = S[key];
          }
        }
        return T;
      } : nativeAssign;
    }, { "../internals/descriptors": 240, "../internals/fails": 247, "../internals/indexed-object": 257, "../internals/object-get-own-property-symbols": 282, "../internals/object-keys": 285, "../internals/object-property-is-enumerable": 286, "../internals/to-object": 308 }], 276: [function(require2, module2, exports2) {
      var anObject = require2("../internals/an-object");
      var defineProperties = require2("../internals/object-define-properties");
      var enumBugKeys = require2("../internals/enum-bug-keys");
      var hiddenKeys = require2("../internals/hidden-keys");
      var html = require2("../internals/html");
      var documentCreateElement = require2("../internals/document-create-element");
      var sharedKey = require2("../internals/shared-key");
      var GT = ">";
      var LT = "<";
      var PROTOTYPE = "prototype";
      var SCRIPT = "script";
      var IE_PROTO = sharedKey("IE_PROTO");
      var EmptyConstructor = function EmptyConstructor2() {
      };
      var scriptTag = function scriptTag2(content) {
        return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
      };
      var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX2(activeXDocument2) {
        activeXDocument2.write(scriptTag(""));
        activeXDocument2.close();
        var temp = activeXDocument2.parentWindow.Object;
        activeXDocument2 = null;
        return temp;
      };
      var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame2() {
        var iframe = documentCreateElement("iframe");
        var JS = "java" + SCRIPT + ":";
        var iframeDocument;
        iframe.style.display = "none";
        html.appendChild(iframe);
        iframe.src = String(JS);
        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(scriptTag("document.F=Object"));
        iframeDocument.close();
        return iframeDocument.F;
      };
      var activeXDocument;
      var _NullProtoObject = function NullProtoObject() {
        try {
          activeXDocument = document.domain && new ActiveXObject("htmlfile");
        } catch (error) {
        }
        _NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
        var length = enumBugKeys.length;
        while (length--)
          delete _NullProtoObject[PROTOTYPE][enumBugKeys[length]];
        return _NullProtoObject();
      };
      hiddenKeys[IE_PROTO] = true;
      module2.exports = Object.create || function create(O, Properties) {
        var result;
        if (O !== null) {
          EmptyConstructor[PROTOTYPE] = anObject(O);
          result = new EmptyConstructor();
          EmptyConstructor[PROTOTYPE] = null;
          result[IE_PROTO] = O;
        } else
          result = _NullProtoObject();
        return Properties === void 0 ? result : defineProperties(result, Properties);
      };
    }, { "../internals/an-object": 223, "../internals/document-create-element": 241, "../internals/enum-bug-keys": 245, "../internals/hidden-keys": 253, "../internals/html": 255, "../internals/object-define-properties": 277, "../internals/shared-key": 299 }], 277: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var definePropertyModule = require2("../internals/object-define-property");
      var anObject = require2("../internals/an-object");
      var objectKeys = require2("../internals/object-keys");
      module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var keys = objectKeys(Properties);
        var length = keys.length;
        var index2 = 0;
        var key;
        while (length > index2)
          definePropertyModule.f(O, key = keys[index2++], Properties[key]);
        return O;
      };
    }, { "../internals/an-object": 223, "../internals/descriptors": 240, "../internals/object-define-property": 278, "../internals/object-keys": 285 }], 278: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var IE8_DOM_DEFINE = require2("../internals/ie8-dom-define");
      var anObject = require2("../internals/an-object");
      var toPrimitive = require2("../internals/to-primitive");
      var nativeDefineProperty = Object.defineProperty;
      exports2.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPrimitive(P, true);
        anObject(Attributes);
        if (IE8_DOM_DEFINE)
          try {
            return nativeDefineProperty(O, P, Attributes);
          } catch (error) {
          }
        if ("get" in Attributes || "set" in Attributes)
          throw TypeError("Accessors not supported");
        if ("value" in Attributes)
          O[P] = Attributes.value;
        return O;
      };
    }, { "../internals/an-object": 223, "../internals/descriptors": 240, "../internals/ie8-dom-define": 256, "../internals/to-primitive": 309 }], 279: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
      var createPropertyDescriptor = require2("../internals/create-property-descriptor");
      var toIndexedObject = require2("../internals/to-indexed-object");
      var toPrimitive = require2("../internals/to-primitive");
      var has = require2("../internals/has");
      var IE8_DOM_DEFINE = require2("../internals/ie8-dom-define");
      var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      exports2.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
        O = toIndexedObject(O);
        P = toPrimitive(P, true);
        if (IE8_DOM_DEFINE)
          try {
            return nativeGetOwnPropertyDescriptor(O, P);
          } catch (error) {
          }
        if (has(O, P))
          return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
      };
    }, { "../internals/create-property-descriptor": 237, "../internals/descriptors": 240, "../internals/has": 252, "../internals/ie8-dom-define": 256, "../internals/object-property-is-enumerable": 286, "../internals/to-indexed-object": 305, "../internals/to-primitive": 309 }], 280: [function(require2, module2, exports2) {
      var toIndexedObject = require2("../internals/to-indexed-object");
      var nativeGetOwnPropertyNames = require2("../internals/object-get-own-property-names").f;
      var toString2 = {}.toString;
      var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
      var getWindowNames = function getWindowNames2(it) {
        try {
          return nativeGetOwnPropertyNames(it);
        } catch (error) {
          return windowNames.slice();
        }
      };
      module2.exports.f = function getOwnPropertyNames(it) {
        return windowNames && toString2.call(it) == "[object Window]" ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
      };
    }, { "../internals/object-get-own-property-names": 281, "../internals/to-indexed-object": 305 }], 281: [function(require2, module2, exports2) {
      var internalObjectKeys = require2("../internals/object-keys-internal");
      var enumBugKeys = require2("../internals/enum-bug-keys");
      var hiddenKeys = enumBugKeys.concat("length", "prototype");
      exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return internalObjectKeys(O, hiddenKeys);
      };
    }, { "../internals/enum-bug-keys": 245, "../internals/object-keys-internal": 284 }], 282: [function(require2, module2, exports2) {
      exports2.f = Object.getOwnPropertySymbols;
    }, {}], 283: [function(require2, module2, exports2) {
      var has = require2("../internals/has");
      var toObject = require2("../internals/to-object");
      var sharedKey = require2("../internals/shared-key");
      var CORRECT_PROTOTYPE_GETTER = require2("../internals/correct-prototype-getter");
      var IE_PROTO = sharedKey("IE_PROTO");
      var ObjectPrototype = Object.prototype;
      module2.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
        O = toObject(O);
        if (has(O, IE_PROTO))
          return O[IE_PROTO];
        if (typeof O.constructor == "function" && O instanceof O.constructor) {
          return O.constructor.prototype;
        }
        return O instanceof Object ? ObjectPrototype : null;
      };
    }, { "../internals/correct-prototype-getter": 234, "../internals/has": 252, "../internals/shared-key": 299, "../internals/to-object": 308 }], 284: [function(require2, module2, exports2) {
      var has = require2("../internals/has");
      var toIndexedObject = require2("../internals/to-indexed-object");
      var indexOf = require2("../internals/array-includes").indexOf;
      var hiddenKeys = require2("../internals/hidden-keys");
      module2.exports = function(object, names2) {
        var O = toIndexedObject(object);
        var i = 0;
        var result = [];
        var key;
        for (key in O)
          !has(hiddenKeys, key) && has(O, key) && result.push(key);
        while (names2.length > i)
          if (has(O, key = names2[i++])) {
            ~indexOf(result, key) || result.push(key);
          }
        return result;
      };
    }, { "../internals/array-includes": 224, "../internals/has": 252, "../internals/hidden-keys": 253, "../internals/to-indexed-object": 305 }], 285: [function(require2, module2, exports2) {
      var internalObjectKeys = require2("../internals/object-keys-internal");
      var enumBugKeys = require2("../internals/enum-bug-keys");
      module2.exports = Object.keys || function keys(O) {
        return internalObjectKeys(O, enumBugKeys);
      };
    }, { "../internals/enum-bug-keys": 245, "../internals/object-keys-internal": 284 }], 286: [function(require2, module2, exports2) {
      var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
      exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
        var descriptor = getOwnPropertyDescriptor(this, V);
        return !!descriptor && descriptor.enumerable;
      } : nativePropertyIsEnumerable;
    }, {}], 287: [function(require2, module2, exports2) {
      var anObject = require2("../internals/an-object");
      var aPossiblePrototype = require2("../internals/a-possible-prototype");
      module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var CORRECT_SETTER = false;
        var test = {};
        var setter;
        try {
          setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
          setter.call(test, []);
          CORRECT_SETTER = test instanceof Array;
        } catch (error) {
        }
        return function setPrototypeOf(O, proto) {
          anObject(O);
          aPossiblePrototype(proto);
          if (CORRECT_SETTER)
            setter.call(O, proto);
          else
            O.__proto__ = proto;
          return O;
        };
      }() : void 0);
    }, { "../internals/a-possible-prototype": 220, "../internals/an-object": 223 }], 288: [function(require2, module2, exports2) {
      var DESCRIPTORS = require2("../internals/descriptors");
      var objectKeys = require2("../internals/object-keys");
      var toIndexedObject = require2("../internals/to-indexed-object");
      var propertyIsEnumerable = require2("../internals/object-property-is-enumerable").f;
      var createMethod = function createMethod2(TO_ENTRIES) {
        return function(it) {
          var O = toIndexedObject(it);
          var keys = objectKeys(O);
          var length = keys.length;
          var i = 0;
          var result = [];
          var key;
          while (length > i) {
            key = keys[i++];
            if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
              result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
            }
          }
          return result;
        };
      };
      module2.exports = {
        // `Object.entries` method
        // https://tc39.github.io/ecma262/#sec-object.entries
        entries: createMethod(true),
        // `Object.values` method
        // https://tc39.github.io/ecma262/#sec-object.values
        values: createMethod(false)
      };
    }, { "../internals/descriptors": 240, "../internals/object-keys": 285, "../internals/object-property-is-enumerable": 286, "../internals/to-indexed-object": 305 }], 289: [function(require2, module2, exports2) {
      var getBuiltIn = require2("../internals/get-built-in");
      var getOwnPropertyNamesModule = require2("../internals/object-get-own-property-names");
      var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
      var anObject = require2("../internals/an-object");
      module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys2(it) {
        var keys = getOwnPropertyNamesModule.f(anObject(it));
        var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
        return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
      };
    }, { "../internals/an-object": 223, "../internals/get-built-in": 249, "../internals/object-get-own-property-names": 281, "../internals/object-get-own-property-symbols": 282 }], 290: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      module2.exports = global2;
    }, { "../internals/global": 251 }], 291: [function(require2, module2, exports2) {
      module2.exports = function(exec) {
        try {
          return { error: false, value: exec() };
        } catch (error) {
          return { error: true, value: error };
        }
      };
    }, {}], 292: [function(require2, module2, exports2) {
      var anObject = require2("../internals/an-object");
      var isObject = require2("../internals/is-object");
      var newPromiseCapability = require2("../internals/new-promise-capability");
      module2.exports = function(C, x) {
        anObject(C);
        if (isObject(x) && x.constructor === C)
          return x;
        var promiseCapability = newPromiseCapability.f(C);
        var resolve = promiseCapability.resolve;
        resolve(x);
        return promiseCapability.promise;
      };
    }, { "../internals/an-object": 223, "../internals/is-object": 263, "../internals/new-promise-capability": 273 }], 293: [function(require2, module2, exports2) {
      var redefine = require2("../internals/redefine");
      module2.exports = function(target, src, options) {
        for (var key in src)
          redefine(target, key, src[key], options);
        return target;
      };
    }, { "../internals/redefine": 294 }], 294: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
      var has = require2("../internals/has");
      var setGlobal = require2("../internals/set-global");
      var inspectSource = require2("../internals/inspect-source");
      var InternalStateModule = require2("../internals/internal-state");
      var getInternalState = InternalStateModule.get;
      var enforceInternalState = InternalStateModule.enforce;
      var TEMPLATE = String(String).split("String");
      (module2.exports = function(O, key, value, options) {
        var unsafe = options ? !!options.unsafe : false;
        var simple = options ? !!options.enumerable : false;
        var noTargetGet = options ? !!options.noTargetGet : false;
        if (typeof value == "function") {
          if (typeof key == "string" && !has(value, "name"))
            createNonEnumerableProperty(value, "name", key);
          enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
        }
        if (O === global2) {
          if (simple)
            O[key] = value;
          else
            setGlobal(key, value);
          return;
        } else if (!unsafe) {
          delete O[key];
        } else if (!noTargetGet && O[key]) {
          simple = true;
        }
        if (simple)
          O[key] = value;
        else
          createNonEnumerableProperty(O, key, value);
      })(Function.prototype, "toString", function toString2() {
        return typeof this == "function" && getInternalState(this).source || inspectSource(this);
      });
    }, { "../internals/create-non-enumerable-property": 236, "../internals/global": 251, "../internals/has": 252, "../internals/inspect-source": 258, "../internals/internal-state": 259, "../internals/set-global": 296 }], 295: [function(require2, module2, exports2) {
      module2.exports = function(it) {
        if (it == void 0)
          throw TypeError("Can't call method on " + it);
        return it;
      };
    }, {}], 296: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
      module2.exports = function(key, value) {
        try {
          createNonEnumerableProperty(global2, key, value);
        } catch (error) {
          global2[key] = value;
        }
        return value;
      };
    }, { "../internals/create-non-enumerable-property": 236, "../internals/global": 251 }], 297: [function(require2, module2, exports2) {
      var getBuiltIn = require2("../internals/get-built-in");
      var definePropertyModule = require2("../internals/object-define-property");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var DESCRIPTORS = require2("../internals/descriptors");
      var SPECIES = wellKnownSymbol("species");
      module2.exports = function(CONSTRUCTOR_NAME) {
        var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
        var defineProperty = definePropertyModule.f;
        if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
          defineProperty(Constructor, SPECIES, { configurable: true, get: function get() {
            return this;
          } });
        }
      };
    }, { "../internals/descriptors": 240, "../internals/get-built-in": 249, "../internals/object-define-property": 278, "../internals/well-known-symbol": 314 }], 298: [function(require2, module2, exports2) {
      var defineProperty = require2("../internals/object-define-property").f;
      var has = require2("../internals/has");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      module2.exports = function(it, TAG, STATIC) {
        if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
          defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
        }
      };
    }, { "../internals/has": 252, "../internals/object-define-property": 278, "../internals/well-known-symbol": 314 }], 299: [function(require2, module2, exports2) {
      var shared = require2("../internals/shared");
      var uid = require2("../internals/uid");
      var keys = shared("keys");
      module2.exports = function(key) {
        return keys[key] || (keys[key] = uid(key));
      };
    }, { "../internals/shared": 301, "../internals/uid": 311 }], 300: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var setGlobal = require2("../internals/set-global");
      var SHARED = "__core-js_shared__";
      var store = global2[SHARED] || setGlobal(SHARED, {});
      module2.exports = store;
    }, { "../internals/global": 251, "../internals/set-global": 296 }], 301: [function(require2, module2, exports2) {
      var IS_PURE = require2("../internals/is-pure");
      var store = require2("../internals/shared-store");
      (module2.exports = function(key, value) {
        return store[key] || (store[key] = value !== void 0 ? value : {});
      })("versions", []).push({ version: "3.6.5", mode: IS_PURE ? "pure" : "global", copyright: " 2020 Denis Pushkarev (zloirock.ru)" });
    }, { "../internals/is-pure": 264, "../internals/shared-store": 300 }], 302: [function(require2, module2, exports2) {
      var anObject = require2("../internals/an-object");
      var aFunction = require2("../internals/a-function");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var SPECIES = wellKnownSymbol("species");
      module2.exports = function(O, defaultConstructor) {
        var C = anObject(O).constructor;
        var S;
        return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? defaultConstructor : aFunction(S);
      };
    }, { "../internals/a-function": 219, "../internals/an-object": 223, "../internals/well-known-symbol": 314 }], 303: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var fails = require2("../internals/fails");
      var classof = require2("../internals/classof-raw");
      var bind2 = require2("../internals/function-bind-context");
      var html = require2("../internals/html");
      var createElement = require2("../internals/document-create-element");
      var IS_IOS = require2("../internals/engine-is-ios");
      var location = global2.location;
      var set = global2.setImmediate;
      var clear = global2.clearImmediate;
      var process = global2.process;
      var MessageChannel = global2.MessageChannel;
      var Dispatch = global2.Dispatch;
      var counter = 0;
      var queue = {};
      var ONREADYSTATECHANGE = "onreadystatechange";
      var defer, channel, port;
      var run = function run2(id) {
        if (queue.hasOwnProperty(id)) {
          var fn = queue[id];
          delete queue[id];
          fn();
        }
      };
      var runner = function runner2(id) {
        return function() {
          run(id);
        };
      };
      var listener = function listener2(event) {
        run(event.data);
      };
      var post = function post2(id) {
        global2.postMessage(id + "", location.protocol + "//" + location.host);
      };
      if (!set || !clear) {
        set = function setImmediate(fn) {
          var args = [];
          var i = 1;
          while (arguments.length > i)
            args.push(arguments[i++]);
          queue[++counter] = function() {
            (typeof fn == "function" ? fn : Function(fn)).apply(void 0, args);
          };
          defer(counter);
          return counter;
        };
        clear = function clearImmediate(id) {
          delete queue[id];
        };
        if (classof(process) == "process") {
          defer = function defer2(id) {
            process.nextTick(runner(id));
          };
        } else if (Dispatch && Dispatch.now) {
          defer = function defer2(id) {
            Dispatch.now(runner(id));
          };
        } else if (MessageChannel && !IS_IOS) {
          channel = new MessageChannel();
          port = channel.port2;
          channel.port1.onmessage = listener;
          defer = bind2(port.postMessage, port, 1);
        } else if (global2.addEventListener && typeof postMessage == "function" && !global2.importScripts && !fails(post) && location.protocol !== "file:") {
          defer = post;
          global2.addEventListener("message", listener, false);
        } else if (ONREADYSTATECHANGE in createElement("script")) {
          defer = function defer2(id) {
            html.appendChild(createElement("script"))[ONREADYSTATECHANGE] = function() {
              html.removeChild(this);
              run(id);
            };
          };
        } else {
          defer = function defer2(id) {
            setTimeout(runner(id), 0);
          };
        }
      }
      module2.exports = { set, clear };
    }, { "../internals/classof-raw": 230, "../internals/document-create-element": 241, "../internals/engine-is-ios": 242, "../internals/fails": 247, "../internals/function-bind-context": 248, "../internals/global": 251, "../internals/html": 255 }], 304: [function(require2, module2, exports2) {
      var toInteger = require2("../internals/to-integer");
      var max = Math.max;
      var min = Math.min;
      module2.exports = function(index2, length) {
        var integer = toInteger(index2);
        return integer < 0 ? max(integer + length, 0) : min(integer, length);
      };
    }, { "../internals/to-integer": 306 }], 305: [function(require2, module2, exports2) {
      var IndexedObject = require2("../internals/indexed-object");
      var requireObjectCoercible = require2("../internals/require-object-coercible");
      module2.exports = function(it) {
        return IndexedObject(requireObjectCoercible(it));
      };
    }, { "../internals/indexed-object": 257, "../internals/require-object-coercible": 295 }], 306: [function(require2, module2, exports2) {
      var ceil = Math.ceil;
      var floor = Math.floor;
      module2.exports = function(argument) {
        return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
      };
    }, {}], 307: [function(require2, module2, exports2) {
      var toInteger = require2("../internals/to-integer");
      var min = Math.min;
      module2.exports = function(argument) {
        return argument > 0 ? min(toInteger(argument), 9007199254740991) : 0;
      };
    }, { "../internals/to-integer": 306 }], 308: [function(require2, module2, exports2) {
      var requireObjectCoercible = require2("../internals/require-object-coercible");
      module2.exports = function(argument) {
        return Object(requireObjectCoercible(argument));
      };
    }, { "../internals/require-object-coercible": 295 }], 309: [function(require2, module2, exports2) {
      var isObject = require2("../internals/is-object");
      module2.exports = function(input, PREFERRED_STRING) {
        if (!isObject(input))
          return input;
        var fn, val;
        if (PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input)))
          return val;
        if (typeof (fn = input.valueOf) == "function" && !isObject(val = fn.call(input)))
          return val;
        if (!PREFERRED_STRING && typeof (fn = input.toString) == "function" && !isObject(val = fn.call(input)))
          return val;
        throw TypeError("Can't convert object to primitive value");
      };
    }, { "../internals/is-object": 263 }], 310: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var TO_STRING_TAG = wellKnownSymbol("toStringTag");
      var test = {};
      test[TO_STRING_TAG] = "z";
      module2.exports = String(test) === "[object z]";
    }, { "../internals/well-known-symbol": 314 }], 311: [function(require2, module2, exports2) {
      var id = 0;
      var postfix = Math.random();
      module2.exports = function(key) {
        return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
      };
    }, {}], 312: [function(require2, module2, exports2) {
      var NATIVE_SYMBOL = require2("../internals/native-symbol");
      module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
    }, { "../internals/native-symbol": 271 }], 313: [function(require2, module2, exports2) {
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      exports2.f = wellKnownSymbol;
    }, { "../internals/well-known-symbol": 314 }], 314: [function(require2, module2, exports2) {
      var global2 = require2("../internals/global");
      var shared = require2("../internals/shared");
      var has = require2("../internals/has");
      var uid = require2("../internals/uid");
      var NATIVE_SYMBOL = require2("../internals/native-symbol");
      var USE_SYMBOL_AS_UID = require2("../internals/use-symbol-as-uid");
      var WellKnownSymbolsStore = shared("wks");
      var Symbol2 = global2.Symbol;
      var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
      module2.exports = function(name) {
        if (!has(WellKnownSymbolsStore, name)) {
          if (NATIVE_SYMBOL && has(Symbol2, name))
            WellKnownSymbolsStore[name] = Symbol2[name];
          else
            WellKnownSymbolsStore[name] = createWellKnownSymbol("Symbol." + name);
        }
        return WellKnownSymbolsStore[name];
      };
    }, { "../internals/global": 251, "../internals/has": 252, "../internals/native-symbol": 271, "../internals/shared": 301, "../internals/uid": 311, "../internals/use-symbol-as-uid": 312 }], 315: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      var $findIndex = require2("../internals/array-iteration").findIndex;
      var addToUnscopables = require2("../internals/add-to-unscopables");
      var arrayMethodUsesToLength = require2("../internals/array-method-uses-to-length");
      var FIND_INDEX = "findIndex";
      var SKIPS_HOLES = true;
      var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);
      if (FIND_INDEX in [])
        Array(1)[FIND_INDEX](function() {
          SKIPS_HOLES = false;
        });
      $({ target: "Array", proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, { findIndex: function findIndex(callbackfn) {
        return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      } });
      addToUnscopables(FIND_INDEX);
    }, { "../internals/add-to-unscopables": 221, "../internals/array-iteration": 225, "../internals/array-method-uses-to-length": 226, "../internals/export": 246 }], 316: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      var $find = require2("../internals/array-iteration").find;
      var addToUnscopables = require2("../internals/add-to-unscopables");
      var arrayMethodUsesToLength = require2("../internals/array-method-uses-to-length");
      var FIND = "find";
      var SKIPS_HOLES = true;
      var USES_TO_LENGTH = arrayMethodUsesToLength(FIND);
      if (FIND in [])
        Array(1)[FIND](function() {
          SKIPS_HOLES = false;
        });
      $({ target: "Array", proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, { find: function find(callbackfn) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
      } });
      addToUnscopables(FIND);
    }, { "../internals/add-to-unscopables": 221, "../internals/array-iteration": 225, "../internals/array-method-uses-to-length": 226, "../internals/export": 246 }], 317: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      var $includes = require2("../internals/array-includes").includes;
      var addToUnscopables = require2("../internals/add-to-unscopables");
      var arrayMethodUsesToLength = require2("../internals/array-method-uses-to-length");
      var USES_TO_LENGTH = arrayMethodUsesToLength("indexOf", { ACCESSORS: true, 1: 0 });
      $({ target: "Array", proto: true, forced: !USES_TO_LENGTH }, { includes: function includes(el) {
        return $includes(this, el, arguments.length > 1 ? arguments[1] : void 0);
      } });
      addToUnscopables("includes");
    }, { "../internals/add-to-unscopables": 221, "../internals/array-includes": 224, "../internals/array-method-uses-to-length": 226, "../internals/export": 246 }], 318: [function(require2, module2, exports2) {
      var toIndexedObject = require2("../internals/to-indexed-object");
      var addToUnscopables = require2("../internals/add-to-unscopables");
      var Iterators = require2("../internals/iterators");
      var InternalStateModule = require2("../internals/internal-state");
      var defineIterator = require2("../internals/define-iterator");
      var ARRAY_ITERATOR = "Array Iterator";
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
      module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
        setInternalState(this, {
          type: ARRAY_ITERATOR,
          target: toIndexedObject(iterated),
          // target
          index: 0,
          // next index
          kind
          // kind
        });
      }, function() {
        var state = getInternalState(this);
        var target = state.target;
        var kind = state.kind;
        var index2 = state.index++;
        if (!target || index2 >= target.length) {
          state.target = void 0;
          return { value: void 0, done: true };
        }
        if (kind == "keys")
          return { value: index2, done: false };
        if (kind == "values")
          return { value: target[index2], done: false };
        return { value: [index2, target[index2]], done: false };
      }, "values");
      Iterators.Arguments = Iterators.Array;
      addToUnscopables("keys");
      addToUnscopables("values");
      addToUnscopables("entries");
    }, { "../internals/add-to-unscopables": 221, "../internals/define-iterator": 238, "../internals/internal-state": 259, "../internals/iterators": 268, "../internals/to-indexed-object": 305 }], 319: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      $({ target: "Number", stat: true }, { isNaN: function isNaN2(number) {
        return number != number;
      } });
    }, { "../internals/export": 246 }], 320: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      var assign = require2("../internals/object-assign");
      $({ target: "Object", stat: true, forced: Object.assign !== assign }, { assign });
    }, { "../internals/export": 246, "../internals/object-assign": 275 }], 321: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      var toObject = require2("../internals/to-object");
      var nativeKeys = require2("../internals/object-keys");
      var fails = require2("../internals/fails");
      var FAILS_ON_PRIMITIVES = fails(function() {
        nativeKeys(1);
      });
      $({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, { keys: function keys(it) {
        return nativeKeys(toObject(it));
      } });
    }, { "../internals/export": 246, "../internals/fails": 247, "../internals/object-keys": 285, "../internals/to-object": 308 }], 322: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      var $values = require2("../internals/object-to-array").values;
      $({ target: "Object", stat: true }, { values: function values(O) {
        return $values(O);
      } });
    }, { "../internals/export": 246, "../internals/object-to-array": 288 }], 323: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      var IS_PURE = require2("../internals/is-pure");
      var global2 = require2("../internals/global");
      var getBuiltIn = require2("../internals/get-built-in");
      var NativePromise = require2("../internals/native-promise-constructor");
      var redefine = require2("../internals/redefine");
      var redefineAll = require2("../internals/redefine-all");
      var setToStringTag = require2("../internals/set-to-string-tag");
      var setSpecies = require2("../internals/set-species");
      var isObject = require2("../internals/is-object");
      var aFunction = require2("../internals/a-function");
      var anInstance = require2("../internals/an-instance");
      var classof = require2("../internals/classof-raw");
      var inspectSource = require2("../internals/inspect-source");
      var iterate = require2("../internals/iterate");
      var checkCorrectnessOfIteration = require2("../internals/check-correctness-of-iteration");
      var speciesConstructor = require2("../internals/species-constructor");
      var task = require2("../internals/task").set;
      var microtask = require2("../internals/microtask");
      var promiseResolve = require2("../internals/promise-resolve");
      var hostReportErrors = require2("../internals/host-report-errors");
      var newPromiseCapabilityModule = require2("../internals/new-promise-capability");
      var perform = require2("../internals/perform");
      var InternalStateModule = require2("../internals/internal-state");
      var isForced = require2("../internals/is-forced");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var V8_VERSION = require2("../internals/engine-v8-version");
      var SPECIES = wellKnownSymbol("species");
      var PROMISE = "Promise";
      var getInternalState = InternalStateModule.get;
      var setInternalState = InternalStateModule.set;
      var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
      var PromiseConstructor = NativePromise;
      var TypeError2 = global2.TypeError;
      var document2 = global2.document;
      var process = global2.process;
      var $fetch = getBuiltIn("fetch");
      var newPromiseCapability = newPromiseCapabilityModule.f;
      var newGenericPromiseCapability = newPromiseCapability;
      var IS_NODE = classof(process) == "process";
      var DISPATCH_EVENT = !!(document2 && document2.createEvent && global2.dispatchEvent);
      var UNHANDLED_REJECTION = "unhandledrejection";
      var REJECTION_HANDLED = "rejectionhandled";
      var PENDING = 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      var HANDLED = 1;
      var UNHANDLED = 2;
      var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
      var FORCED = isForced(PROMISE, function() {
        var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
        if (!GLOBAL_CORE_JS_PROMISE) {
          if (V8_VERSION === 66)
            return true;
          if (!IS_NODE && typeof PromiseRejectionEvent != "function")
            return true;
        }
        if (IS_PURE && !PromiseConstructor.prototype["finally"])
          return true;
        if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor))
          return false;
        var promise = PromiseConstructor.resolve(1);
        var FakePromise = function FakePromise2(exec) {
          exec(function() {
          }, function() {
          });
        };
        var constructor = promise.constructor = {};
        constructor[SPECIES] = FakePromise;
        return !(promise.then(function() {
        }) instanceof FakePromise);
      });
      var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
        PromiseConstructor.all(iterable)["catch"](function() {
        });
      });
      var isThenable = function isThenable2(it) {
        var then;
        return isObject(it) && typeof (then = it.then) == "function" ? then : false;
      };
      var notify = function notify2(promise, state, isReject) {
        if (state.notified)
          return;
        state.notified = true;
        var chain = state.reactions;
        microtask(function() {
          var value = state.value;
          var ok = state.state == FULFILLED;
          var index2 = 0;
          while (chain.length > index2) {
            var reaction = chain[index2++];
            var handler = ok ? reaction.ok : reaction.fail;
            var resolve = reaction.resolve;
            var reject = reaction.reject;
            var domain = reaction.domain;
            var result, then, exited;
            try {
              if (handler) {
                if (!ok) {
                  if (state.rejection === UNHANDLED)
                    onHandleUnhandled(promise, state);
                  state.rejection = HANDLED;
                }
                if (handler === true)
                  result = value;
                else {
                  if (domain)
                    domain.enter();
                  result = handler(value);
                  if (domain) {
                    domain.exit();
                    exited = true;
                  }
                }
                if (result === reaction.promise) {
                  reject(TypeError2("Promise-chain cycle"));
                } else if (then = isThenable(result)) {
                  then.call(result, resolve, reject);
                } else
                  resolve(result);
              } else
                reject(value);
            } catch (error) {
              if (domain && !exited)
                domain.exit();
              reject(error);
            }
          }
          state.reactions = [];
          state.notified = false;
          if (isReject && !state.rejection)
            onUnhandled(promise, state);
        });
      };
      var dispatchEvent = function dispatchEvent2(name, promise, reason) {
        var event, handler;
        if (DISPATCH_EVENT) {
          event = document2.createEvent("Event");
          event.promise = promise;
          event.reason = reason;
          event.initEvent(name, false, true);
          global2.dispatchEvent(event);
        } else
          event = { promise, reason };
        if (handler = global2["on" + name])
          handler(event);
        else if (name === UNHANDLED_REJECTION)
          hostReportErrors("Unhandled promise rejection", reason);
      };
      var onUnhandled = function onUnhandled2(promise, state) {
        task.call(global2, function() {
          var value = state.value;
          var IS_UNHANDLED = isUnhandled(state);
          var result;
          if (IS_UNHANDLED) {
            result = perform(function() {
              if (IS_NODE) {
                process.emit("unhandledRejection", value, promise);
              } else
                dispatchEvent(UNHANDLED_REJECTION, promise, value);
            });
            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
            if (result.error)
              throw result.value;
          }
        });
      };
      var isUnhandled = function isUnhandled2(state) {
        return state.rejection !== HANDLED && !state.parent;
      };
      var onHandleUnhandled = function onHandleUnhandled2(promise, state) {
        task.call(global2, function() {
          if (IS_NODE) {
            process.emit("rejectionHandled", promise);
          } else
            dispatchEvent(REJECTION_HANDLED, promise, state.value);
        });
      };
      var bind2 = function bind3(fn, promise, state, unwrap) {
        return function(value) {
          fn(promise, state, value, unwrap);
        };
      };
      var internalReject = function internalReject2(promise, state, value, unwrap) {
        if (state.done)
          return;
        state.done = true;
        if (unwrap)
          state = unwrap;
        state.value = value;
        state.state = REJECTED;
        notify(promise, state, true);
      };
      var internalResolve = function internalResolve2(promise, state, value, unwrap) {
        if (state.done)
          return;
        state.done = true;
        if (unwrap)
          state = unwrap;
        try {
          if (promise === value)
            throw TypeError2("Promise can't be resolved itself");
          var then = isThenable(value);
          if (then) {
            microtask(function() {
              var wrapper = { done: false };
              try {
                then.call(value, bind2(internalResolve2, promise, wrapper, state), bind2(internalReject, promise, wrapper, state));
              } catch (error) {
                internalReject(promise, wrapper, error, state);
              }
            });
          } else {
            state.value = value;
            state.state = FULFILLED;
            notify(promise, state, false);
          }
        } catch (error) {
          internalReject(promise, { done: false }, error, state);
        }
      };
      if (FORCED) {
        PromiseConstructor = function Promise2(executor) {
          anInstance(this, PromiseConstructor, PROMISE);
          aFunction(executor);
          Internal.call(this);
          var state = getInternalState(this);
          try {
            executor(bind2(internalResolve, this, state), bind2(internalReject, this, state));
          } catch (error) {
            internalReject(this, state, error);
          }
        };
        Internal = function Promise2(executor) {
          setInternalState(this, { type: PROMISE, done: false, notified: false, parent: false, reactions: [], rejection: false, state: PENDING, value: void 0 });
        };
        Internal.prototype = redefineAll(PromiseConstructor.prototype, {
          // `Promise.prototype.then` method
          // https://tc39.github.io/ecma262/#sec-promise.prototype.then
          then: function then(onFulfilled, onRejected) {
            var state = getInternalPromiseState(this);
            var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
            reaction.ok = typeof onFulfilled == "function" ? onFulfilled : true;
            reaction.fail = typeof onRejected == "function" && onRejected;
            reaction.domain = IS_NODE ? process.domain : void 0;
            state.parent = true;
            state.reactions.push(reaction);
            if (state.state != PENDING)
              notify(this, state, false);
            return reaction.promise;
          },
          // `Promise.prototype.catch` method
          // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
          "catch": function _catch(onRejected) {
            return this.then(void 0, onRejected);
          }
        });
        OwnPromiseCapability = function OwnPromiseCapability2() {
          var promise = new Internal();
          var state = getInternalState(promise);
          this.promise = promise;
          this.resolve = bind2(internalResolve, promise, state);
          this.reject = bind2(internalReject, promise, state);
        };
        newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability2(C) {
          return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
        };
        if (!IS_PURE && typeof NativePromise == "function") {
          nativeThen = NativePromise.prototype.then;
          redefine(NativePromise.prototype, "then", function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
              nativeThen.call(that, resolve, reject);
            }).then(onFulfilled, onRejected);
          }, { unsafe: true });
          if (typeof $fetch == "function")
            $({ global: true, enumerable: true, forced: true }, {
              // eslint-disable-next-line no-unused-vars
              fetch: function fetch(input) {
                return promiseResolve(PromiseConstructor, $fetch.apply(global2, arguments));
              }
            });
        }
      }
      $({ global: true, wrap: true, forced: FORCED }, { Promise: PromiseConstructor });
      setToStringTag(PromiseConstructor, PROMISE, false, true);
      setSpecies(PROMISE);
      PromiseWrapper = getBuiltIn(PROMISE);
      $({ target: PROMISE, stat: true, forced: FORCED }, {
        // `Promise.reject` method
        // https://tc39.github.io/ecma262/#sec-promise.reject
        reject: function reject(r) {
          var capability = newPromiseCapability(this);
          capability.reject.call(void 0, r);
          return capability.promise;
        }
      });
      $({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
        // `Promise.resolve` method
        // https://tc39.github.io/ecma262/#sec-promise.resolve
        resolve: function resolve(x) {
          return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
        }
      });
      $({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
        // `Promise.all` method
        // https://tc39.github.io/ecma262/#sec-promise.all
        all: function all(iterable) {
          var C = this;
          var capability = newPromiseCapability(C);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aFunction(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
              var index2 = counter++;
              var alreadyCalled = false;
              values.push(void 0);
              remaining++;
              $promiseResolve.call(C, promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                values[index2] = value;
                --remaining || resolve(values);
              }, reject);
            });
            --remaining || resolve(values);
          });
          if (result.error)
            reject(result.value);
          return capability.promise;
        },
        // `Promise.race` method
        // https://tc39.github.io/ecma262/#sec-promise.race
        race: function race(iterable) {
          var C = this;
          var capability = newPromiseCapability(C);
          var reject = capability.reject;
          var result = perform(function() {
            var $promiseResolve = aFunction(C.resolve);
            iterate(iterable, function(promise) {
              $promiseResolve.call(C, promise).then(capability.resolve, reject);
            });
          });
          if (result.error)
            reject(result.value);
          return capability.promise;
        }
      });
    }, { "../internals/a-function": 219, "../internals/an-instance": 222, "../internals/check-correctness-of-iteration": 229, "../internals/classof-raw": 230, "../internals/engine-v8-version": 244, "../internals/export": 246, "../internals/get-built-in": 249, "../internals/global": 251, "../internals/host-report-errors": 254, "../internals/inspect-source": 258, "../internals/internal-state": 259, "../internals/is-forced": 262, "../internals/is-object": 263, "../internals/is-pure": 264, "../internals/iterate": 266, "../internals/microtask": 269, "../internals/native-promise-constructor": 270, "../internals/new-promise-capability": 273, "../internals/perform": 291, "../internals/promise-resolve": 292, "../internals/redefine": 294, "../internals/redefine-all": 293, "../internals/set-species": 297, "../internals/set-to-string-tag": 298, "../internals/species-constructor": 302, "../internals/task": 303, "../internals/well-known-symbol": 314 }], 324: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      var toAbsoluteIndex = require2("../internals/to-absolute-index");
      var fromCharCode = String.fromCharCode;
      var nativeFromCodePoint = String.fromCodePoint;
      var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1;
      $({ target: "String", stat: true, forced: INCORRECT_LENGTH }, { fromCodePoint: function fromCodePoint(x) {
        var elements = [];
        var length = arguments.length;
        var i = 0;
        var code;
        while (length > i) {
          code = +arguments[i++];
          if (toAbsoluteIndex(code, 1114111) !== code)
            throw RangeError(code + " is not a valid code point");
          elements.push(code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320));
        }
        return elements.join("");
      } });
    }, { "../internals/export": 246, "../internals/to-absolute-index": 304 }], 325: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      var notARegExp = require2("../internals/not-a-regexp");
      var requireObjectCoercible = require2("../internals/require-object-coercible");
      var correctIsRegExpLogic = require2("../internals/correct-is-regexp-logic");
      $({ target: "String", proto: true, forced: !correctIsRegExpLogic("includes") }, { includes: function includes(searchString) {
        return !!~String(requireObjectCoercible(this)).indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : void 0);
      } });
    }, { "../internals/correct-is-regexp-logic": 233, "../internals/export": 246, "../internals/not-a-regexp": 274, "../internals/require-object-coercible": 295 }], 326: [function(require2, module2, exports2) {
      var defineWellKnownSymbol = require2("../internals/define-well-known-symbol");
      defineWellKnownSymbol("asyncIterator");
    }, { "../internals/define-well-known-symbol": 239 }], 327: [function(require2, module2, exports2) {
      var $ = require2("../internals/export");
      var global2 = require2("../internals/global");
      var getBuiltIn = require2("../internals/get-built-in");
      var IS_PURE = require2("../internals/is-pure");
      var DESCRIPTORS = require2("../internals/descriptors");
      var NATIVE_SYMBOL = require2("../internals/native-symbol");
      var USE_SYMBOL_AS_UID = require2("../internals/use-symbol-as-uid");
      var fails = require2("../internals/fails");
      var has = require2("../internals/has");
      var isArray = require2("../internals/is-array");
      var isObject = require2("../internals/is-object");
      var anObject = require2("../internals/an-object");
      var toObject = require2("../internals/to-object");
      var toIndexedObject = require2("../internals/to-indexed-object");
      var toPrimitive = require2("../internals/to-primitive");
      var createPropertyDescriptor = require2("../internals/create-property-descriptor");
      var nativeObjectCreate = require2("../internals/object-create");
      var objectKeys = require2("../internals/object-keys");
      var getOwnPropertyNamesModule = require2("../internals/object-get-own-property-names");
      var getOwnPropertyNamesExternal = require2("../internals/object-get-own-property-names-external");
      var getOwnPropertySymbolsModule = require2("../internals/object-get-own-property-symbols");
      var getOwnPropertyDescriptorModule = require2("../internals/object-get-own-property-descriptor");
      var definePropertyModule = require2("../internals/object-define-property");
      var propertyIsEnumerableModule = require2("../internals/object-property-is-enumerable");
      var createNonEnumerableProperty = require2("../internals/create-non-enumerable-property");
      var redefine = require2("../internals/redefine");
      var shared = require2("../internals/shared");
      var sharedKey = require2("../internals/shared-key");
      var hiddenKeys = require2("../internals/hidden-keys");
      var uid = require2("../internals/uid");
      var wellKnownSymbol = require2("../internals/well-known-symbol");
      var wrappedWellKnownSymbolModule = require2("../internals/well-known-symbol-wrapped");
      var defineWellKnownSymbol = require2("../internals/define-well-known-symbol");
      var setToStringTag = require2("../internals/set-to-string-tag");
      var InternalStateModule = require2("../internals/internal-state");
      var $forEach = require2("../internals/array-iteration").forEach;
      var HIDDEN = sharedKey("hidden");
      var SYMBOL = "Symbol";
      var PROTOTYPE = "prototype";
      var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
      var setInternalState = InternalStateModule.set;
      var getInternalState = InternalStateModule.getterFor(SYMBOL);
      var ObjectPrototype = Object[PROTOTYPE];
      var $Symbol = global2.Symbol;
      var $stringify = getBuiltIn("JSON", "stringify");
      var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
      var nativeDefineProperty = definePropertyModule.f;
      var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
      var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
      var AllSymbols = shared("symbols");
      var ObjectPrototypeSymbols = shared("op-symbols");
      var StringToSymbolRegistry = shared("string-to-symbol-registry");
      var SymbolToStringRegistry = shared("symbol-to-string-registry");
      var WellKnownSymbolsStore = shared("wks");
      var QObject = global2.QObject;
      var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
      var setSymbolDescriptor = DESCRIPTORS && fails(function() {
        return nativeObjectCreate(nativeDefineProperty({}, "a", { get: function get() {
          return nativeDefineProperty(this, "a", { value: 7 }).a;
        } })).a != 7;
      }) ? function(O, P, Attributes) {
        var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
        if (ObjectPrototypeDescriptor)
          delete ObjectPrototype[P];
        nativeDefineProperty(O, P, Attributes);
        if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
          nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
        }
      } : nativeDefineProperty;
      var wrap = function wrap2(tag, description) {
        var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
        setInternalState(symbol, { type: SYMBOL, tag, description });
        if (!DESCRIPTORS)
          symbol.description = description;
        return symbol;
      };
      var isSymbol = USE_SYMBOL_AS_UID ? function(it) {
        return typeof it == "symbol";
      } : function(it) {
        return Object(it) instanceof $Symbol;
      };
      var $defineProperty = function defineProperty(O, P, Attributes) {
        if (O === ObjectPrototype)
          $defineProperty(ObjectPrototypeSymbols, P, Attributes);
        anObject(O);
        var key = toPrimitive(P, true);
        anObject(Attributes);
        if (has(AllSymbols, key)) {
          if (!Attributes.enumerable) {
            if (!has(O, HIDDEN))
              nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
            O[HIDDEN][key] = true;
          } else {
            if (has(O, HIDDEN) && O[HIDDEN][key])
              O[HIDDEN][key] = false;
            Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
          }
          return setSymbolDescriptor(O, key, Attributes);
        }
        return nativeDefineProperty(O, key, Attributes);
      };
      var $defineProperties = function defineProperties(O, Properties) {
        anObject(O);
        var properties = toIndexedObject(Properties);
        var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
        $forEach(keys, function(key) {
          if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key))
            $defineProperty(O, key, properties[key]);
        });
        return O;
      };
      var $create = function create(O, Properties) {
        return Properties === void 0 ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
      };
      var $propertyIsEnumerable = function propertyIsEnumerable(V) {
        var P = toPrimitive(V, true);
        var enumerable = nativePropertyIsEnumerable.call(this, P);
        if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P))
          return false;
        return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
      };
      var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
        var it = toIndexedObject(O);
        var key = toPrimitive(P, true);
        if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key))
          return;
        var descriptor = nativeGetOwnPropertyDescriptor(it, key);
        if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
          descriptor.enumerable = true;
        }
        return descriptor;
      };
      var $getOwnPropertyNames = function getOwnPropertyNames(O) {
        var names2 = nativeGetOwnPropertyNames(toIndexedObject(O));
        var result = [];
        $forEach(names2, function(key) {
          if (!has(AllSymbols, key) && !has(hiddenKeys, key))
            result.push(key);
        });
        return result;
      };
      var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
        var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
        var names2 = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
        var result = [];
        $forEach(names2, function(key) {
          if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
            result.push(AllSymbols[key]);
          }
        });
        return result;
      };
      if (!NATIVE_SYMBOL) {
        $Symbol = function Symbol2() {
          if (this instanceof $Symbol)
            throw TypeError("Symbol is not a constructor");
          var description = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]);
          var tag = uid(description);
          var setter = function setter2(value) {
            if (this === ObjectPrototype)
              setter2.call(ObjectPrototypeSymbols, value);
            if (has(this, HIDDEN) && has(this[HIDDEN], tag))
              this[HIDDEN][tag] = false;
            setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
          };
          if (DESCRIPTORS && USE_SETTER)
            setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
          return wrap(tag, description);
        };
        redefine($Symbol[PROTOTYPE], "toString", function toString2() {
          return getInternalState(this).tag;
        });
        redefine($Symbol, "withoutSetter", function(description) {
          return wrap(uid(description), description);
        });
        propertyIsEnumerableModule.f = $propertyIsEnumerable;
        definePropertyModule.f = $defineProperty;
        getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
        getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
        getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
        wrappedWellKnownSymbolModule.f = function(name) {
          return wrap(wellKnownSymbol(name), name);
        };
        if (DESCRIPTORS) {
          nativeDefineProperty($Symbol[PROTOTYPE], "description", { configurable: true, get: function description() {
            return getInternalState(this).description;
          } });
          if (!IS_PURE) {
            redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
          }
        }
      }
      $({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, { Symbol: $Symbol });
      $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
        defineWellKnownSymbol(name);
      });
      $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
        // `Symbol.for` method
        // https://tc39.github.io/ecma262/#sec-symbol.for
        "for": function _for(key) {
          var string = String(key);
          if (has(StringToSymbolRegistry, string))
            return StringToSymbolRegistry[string];
          var symbol = $Symbol(string);
          StringToSymbolRegistry[string] = symbol;
          SymbolToStringRegistry[symbol] = string;
          return symbol;
        },
        // `Symbol.keyFor` method
        // https://tc39.github.io/ecma262/#sec-symbol.keyfor
        keyFor: function keyFor(sym) {
          if (!isSymbol(sym))
            throw TypeError(sym + " is not a symbol");
          if (has(SymbolToStringRegistry, sym))
            return SymbolToStringRegistry[sym];
        },
        useSetter: function useSetter() {
          USE_SETTER = true;
        },
        useSimple: function useSimple() {
          USE_SETTER = false;
        }
      });
      $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
        // `Object.create` method
        // https://tc39.github.io/ecma262/#sec-object.create
        create: $create,
        // `Object.defineProperty` method
        // https://tc39.github.io/ecma262/#sec-object.defineproperty
        defineProperty: $defineProperty,
        // `Object.defineProperties` method
        // https://tc39.github.io/ecma262/#sec-object.defineproperties
        defineProperties: $defineProperties,
        // `Object.getOwnPropertyDescriptor` method
        // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor
      });
      $({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
        // `Object.getOwnPropertyNames` method
        // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
        getOwnPropertyNames: $getOwnPropertyNames,
        // `Object.getOwnPropertySymbols` method
        // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
        getOwnPropertySymbols: $getOwnPropertySymbols
      });
      $({ target: "Object", stat: true, forced: fails(function() {
        getOwnPropertySymbolsModule.f(1);
      }) }, { getOwnPropertySymbols: function getOwnPropertySymbols(it) {
        return getOwnPropertySymbolsModule.f(toObject(it));
      } });
      if ($stringify) {
        var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
          var symbol = $Symbol();
          return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
        });
        $({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
          // eslint-disable-next-line no-unused-vars
          stringify: function stringify(it, replacer, space) {
            var args = [it];
            var index2 = 1;
            var $replacer;
            while (arguments.length > index2)
              args.push(arguments[index2++]);
            $replacer = replacer;
            if (!isObject(replacer) && it === void 0 || isSymbol(it))
              return;
            if (!isArray(replacer))
              replacer = function replacer2(key, value) {
                if (typeof $replacer == "function")
                  value = $replacer.call(this, key, value);
                if (!isSymbol(value))
                  return value;
              };
            args[1] = replacer;
            return $stringify.apply(null, args);
          }
        });
      }
      if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
        createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
      }
      setToStringTag($Symbol, SYMBOL);
      hiddenKeys[HIDDEN] = true;
    }, { "../internals/an-object": 223, "../internals/array-iteration": 225, "../internals/create-non-enumerable-property": 236, "../internals/create-property-descriptor": 237, "../internals/define-well-known-symbol": 239, "../internals/descriptors": 240, "../internals/export": 246, "../internals/fails": 247, "../internals/get-built-in": 249, "../internals/global": 251, "../internals/has": 252, "../internals/hidden-keys": 253, "../internals/internal-state": 259, "../internals/is-array": 261, "../internals/is-object": 263, "../internals/is-pure": 264, "../internals/native-symbol": 271, "../internals/object-create": 276, "../internals/object-define-property": 278, "../internals/object-get-own-property-descriptor": 279, "../internals/object-get-own-property-names": 281, "../internals/object-get-own-property-names-external": 280, "../internals/object-get-own-property-symbols": 282, "../internals/object-keys": 285, "../internals/object-property-is-enumerable": 286, "../internals/redefine": 294, "../internals/set-to-string-tag": 298, "../internals/shared": 301, "../internals/shared-key": 299, "../internals/to-indexed-object": 305, "../internals/to-object": 308, "../internals/to-primitive": 309, "../internals/uid": 311, "../internals/use-symbol-as-uid": 312, "../internals/well-known-symbol": 314, "../internals/well-known-symbol-wrapped": 313 }], 328: [function(require2, module2, exports2) {
      (function(Buffer) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        function isArray(arg) {
          if (Array.isArray) {
            return Array.isArray(arg);
          }
          return objectToString(arg) === "[object Array]";
        }
        exports2.isArray = isArray;
        function isBoolean(arg) {
          return typeof arg === "boolean";
        }
        exports2.isBoolean = isBoolean;
        function isNull(arg) {
          return arg === null;
        }
        exports2.isNull = isNull;
        function isNullOrUndefined(arg) {
          return arg == null;
        }
        exports2.isNullOrUndefined = isNullOrUndefined;
        function isNumber(arg) {
          return typeof arg === "number";
        }
        exports2.isNumber = isNumber;
        function isString(arg) {
          return typeof arg === "string";
        }
        exports2.isString = isString;
        function isSymbol(arg) {
          return _typeof2(arg) === "symbol";
        }
        exports2.isSymbol = isSymbol;
        function isUndefined(arg) {
          return arg === void 0;
        }
        exports2.isUndefined = isUndefined;
        function isRegExp(re) {
          return objectToString(re) === "[object RegExp]";
        }
        exports2.isRegExp = isRegExp;
        function isObject(arg) {
          return _typeof2(arg) === "object" && arg !== null;
        }
        exports2.isObject = isObject;
        function isDate(d) {
          return objectToString(d) === "[object Date]";
        }
        exports2.isDate = isDate;
        function isError(e) {
          return objectToString(e) === "[object Error]" || e instanceof Error;
        }
        exports2.isError = isError;
        function isFunction(arg) {
          return typeof arg === "function";
        }
        exports2.isFunction = isFunction;
        function isPrimitive(arg) {
          return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || _typeof2(arg) === "symbol" || // ES6 symbol
          typeof arg === "undefined";
        }
        exports2.isPrimitive = isPrimitive;
        exports2.isBuffer = Buffer.isBuffer;
        function objectToString(o) {
          return Object.prototype.toString.call(o);
        }
      }).call(this, { "isBuffer": require2("../../is-buffer/index.js") });
    }, { "../../is-buffer/index.js": 388 }], 329: [function(require2, module2, exports2) {
      (function(Buffer) {
        var elliptic = require2("elliptic");
        var BN = require2("bn.js");
        module2.exports = function createECDH(curve) {
          return new ECDH(curve);
        };
        var aliases = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
        aliases.p224 = aliases.secp224r1;
        aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
        aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
        aliases.p384 = aliases.secp384r1;
        aliases.p521 = aliases.secp521r1;
        function ECDH(curve) {
          this.curveType = aliases[curve];
          if (!this.curveType) {
            this.curveType = { name: curve };
          }
          this.curve = new elliptic.ec(this.curveType.name);
          this.keys = void 0;
        }
        ECDH.prototype.generateKeys = function(enc, format) {
          this.keys = this.curve.genKeyPair();
          return this.getPublicKey(enc, format);
        };
        ECDH.prototype.computeSecret = function(other, inenc, enc) {
          inenc = inenc || "utf8";
          if (!Buffer.isBuffer(other)) {
            other = new Buffer(other, inenc);
          }
          var otherPub = this.curve.keyFromPublic(other).getPublic();
          var out = otherPub.mul(this.keys.getPrivate()).getX();
          return formatReturnValue(out, enc, this.curveType.byteLength);
        };
        ECDH.prototype.getPublicKey = function(enc, format) {
          var key = this.keys.getPublic(format === "compressed", true);
          if (format === "hybrid") {
            if (key[key.length - 1] % 2) {
              key[0] = 7;
            } else {
              key[0] = 6;
            }
          }
          return formatReturnValue(key, enc);
        };
        ECDH.prototype.getPrivateKey = function(enc) {
          return formatReturnValue(this.keys.getPrivate(), enc);
        };
        ECDH.prototype.setPublicKey = function(pub, enc) {
          enc = enc || "utf8";
          if (!Buffer.isBuffer(pub)) {
            pub = new Buffer(pub, enc);
          }
          this.keys._importPublic(pub);
          return this;
        };
        ECDH.prototype.setPrivateKey = function(priv, enc) {
          enc = enc || "utf8";
          if (!Buffer.isBuffer(priv)) {
            priv = new Buffer(priv, enc);
          }
          var _priv = new BN(priv);
          _priv = _priv.toString(16);
          this.keys = this.curve.genKeyPair();
          this.keys._importPrivate(_priv);
          return this;
        };
        function formatReturnValue(bn, enc, len) {
          if (!Array.isArray(bn)) {
            bn = bn.toArray();
          }
          var buf = new Buffer(bn);
          if (len && buf.length < len) {
            var zeros = new Buffer(len - buf.length);
            zeros.fill(0);
            buf = Buffer.concat([zeros, buf]);
          }
          if (!enc) {
            return buf;
          } else {
            return buf.toString(enc);
          }
        }
      }).call(this, require2("buffer").Buffer);
    }, { "bn.js": 330, "buffer": 216, "elliptic": 350 }], 330: [function(require2, module2, exports2) {
      arguments[4][181][0].apply(exports2, arguments);
    }, { "buffer": 185, "dup": 181 }], 331: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var MD5 = require2("md5.js");
      var RIPEMD160 = require2("ripemd160");
      var sha = require2("sha.js");
      var Base = require2("cipher-base");
      function Hash(hash) {
        Base.call(this, "digest");
        this._hash = hash;
      }
      inherits(Hash, Base);
      Hash.prototype._update = function(data) {
        this._hash.update(data);
      };
      Hash.prototype._final = function() {
        return this._hash.digest();
      };
      module2.exports = function createHash(alg) {
        alg = alg.toLowerCase();
        if (alg === "md5")
          return new MD5();
        if (alg === "rmd160" || alg === "ripemd160")
          return new RIPEMD160();
        return new Hash(sha(alg));
      };
    }, { "cipher-base": 218, "inherits": 387, "md5.js": 434, "ripemd160": 493, "sha.js": 499 }], 332: [function(require2, module2, exports2) {
      var MD5 = require2("md5.js");
      module2.exports = function(buffer) {
        return new MD5().update(buffer).digest();
      };
    }, { "md5.js": 434 }], 333: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Legacy = require2("./legacy");
      var Base = require2("cipher-base");
      var Buffer = require2("safe-buffer").Buffer;
      var md5 = require2("create-hash/md5");
      var RIPEMD160 = require2("ripemd160");
      var sha = require2("sha.js");
      var ZEROS = Buffer.alloc(128);
      function Hmac(alg, key) {
        Base.call(this, "digest");
        if (typeof key === "string") {
          key = Buffer.from(key);
        }
        var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        this._alg = alg;
        this._key = key;
        if (key.length > blocksize) {
          var hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
          key = hash.update(key).digest();
        } else if (key.length < blocksize) {
          key = Buffer.concat([key, ZEROS], blocksize);
        }
        var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
        var opad = this._opad = Buffer.allocUnsafe(blocksize);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key[i] ^ 54;
          opad[i] = key[i] ^ 92;
        }
        this._hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
        this._hash.update(ipad);
      }
      inherits(Hmac, Base);
      Hmac.prototype._update = function(data) {
        this._hash.update(data);
      };
      Hmac.prototype._final = function() {
        var h3 = this._hash.digest();
        var hash = this._alg === "rmd160" ? new RIPEMD160() : sha(this._alg);
        return hash.update(this._opad).update(h3).digest();
      };
      module2.exports = function createHmac(alg, key) {
        alg = alg.toLowerCase();
        if (alg === "rmd160" || alg === "ripemd160") {
          return new Hmac("rmd160", key);
        }
        if (alg === "md5") {
          return new Legacy(md5, key);
        }
        return new Hmac(alg, key);
      };
    }, { "./legacy": 334, "cipher-base": 218, "create-hash/md5": 332, "inherits": 387, "ripemd160": 493, "safe-buffer": 494, "sha.js": 499 }], 334: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Buffer = require2("safe-buffer").Buffer;
      var Base = require2("cipher-base");
      var ZEROS = Buffer.alloc(128);
      var blocksize = 64;
      function Hmac(alg, key) {
        Base.call(this, "digest");
        if (typeof key === "string") {
          key = Buffer.from(key);
        }
        this._alg = alg;
        this._key = key;
        if (key.length > blocksize) {
          key = alg(key);
        } else if (key.length < blocksize) {
          key = Buffer.concat([key, ZEROS], blocksize);
        }
        var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
        var opad = this._opad = Buffer.allocUnsafe(blocksize);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key[i] ^ 54;
          opad[i] = key[i] ^ 92;
        }
        this._hash = [ipad];
      }
      inherits(Hmac, Base);
      Hmac.prototype._update = function(data) {
        this._hash.push(data);
      };
      Hmac.prototype._final = function() {
        var h3 = this._alg(Buffer.concat(this._hash));
        return this._alg(Buffer.concat([this._opad, h3]));
      };
      module2.exports = Hmac;
    }, { "cipher-base": 218, "inherits": 387, "safe-buffer": 494 }], 335: [function(require2, module2, exports2) {
      exports2.randomBytes = exports2.rng = exports2.pseudoRandomBytes = exports2.prng = require2("randombytes");
      exports2.createHash = exports2.Hash = require2("create-hash");
      exports2.createHmac = exports2.Hmac = require2("create-hmac");
      var algos = require2("browserify-sign/algos");
      var algoKeys = Object.keys(algos);
      var hashes = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(algoKeys);
      exports2.getHashes = function() {
        return hashes;
      };
      var p = require2("pbkdf2");
      exports2.pbkdf2 = p.pbkdf2;
      exports2.pbkdf2Sync = p.pbkdf2Sync;
      var aes = require2("browserify-cipher");
      exports2.Cipher = aes.Cipher;
      exports2.createCipher = aes.createCipher;
      exports2.Cipheriv = aes.Cipheriv;
      exports2.createCipheriv = aes.createCipheriv;
      exports2.Decipher = aes.Decipher;
      exports2.createDecipher = aes.createDecipher;
      exports2.Decipheriv = aes.Decipheriv;
      exports2.createDecipheriv = aes.createDecipheriv;
      exports2.getCiphers = aes.getCiphers;
      exports2.listCiphers = aes.listCiphers;
      var dh = require2("diffie-hellman");
      exports2.DiffieHellmanGroup = dh.DiffieHellmanGroup;
      exports2.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
      exports2.getDiffieHellman = dh.getDiffieHellman;
      exports2.createDiffieHellman = dh.createDiffieHellman;
      exports2.DiffieHellman = dh.DiffieHellman;
      var sign = require2("browserify-sign");
      exports2.createSign = sign.createSign;
      exports2.Sign = sign.Sign;
      exports2.createVerify = sign.createVerify;
      exports2.Verify = sign.Verify;
      exports2.createECDH = require2("create-ecdh");
      var publicEncrypt = require2("public-encrypt");
      exports2.publicEncrypt = publicEncrypt.publicEncrypt;
      exports2.privateEncrypt = publicEncrypt.privateEncrypt;
      exports2.publicDecrypt = publicEncrypt.publicDecrypt;
      exports2.privateDecrypt = publicEncrypt.privateDecrypt;
      var rf = require2("randomfill");
      exports2.randomFill = rf.randomFill;
      exports2.randomFillSync = rf.randomFillSync;
      exports2.createCredentials = function() {
        throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join("\n"));
      };
      exports2.constants = { "DH_CHECK_P_NOT_SAFE_PRIME": 2, "DH_CHECK_P_NOT_PRIME": 1, "DH_UNABLE_TO_CHECK_GENERATOR": 4, "DH_NOT_SUITABLE_GENERATOR": 8, "NPN_ENABLED": 1, "ALPN_ENABLED": 1, "RSA_PKCS1_PADDING": 1, "RSA_SSLV23_PADDING": 2, "RSA_NO_PADDING": 3, "RSA_PKCS1_OAEP_PADDING": 4, "RSA_X931_PADDING": 5, "RSA_PKCS1_PSS_PADDING": 6, "POINT_CONVERSION_COMPRESSED": 2, "POINT_CONVERSION_UNCOMPRESSED": 4, "POINT_CONVERSION_HYBRID": 6 };
    }, { "browserify-cipher": 203, "browserify-sign": 211, "browserify-sign/algos": 208, "create-ecdh": 329, "create-hash": 331, "create-hmac": 333, "diffie-hellman": 345, "pbkdf2": 460, "public-encrypt": 468, "randombytes": 475, "randomfill": 476 }], 336: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      !function(t2, e) {
        "object" == (typeof exports2 === "undefined" ? "undefined" : _typeof2(exports2)) && "undefined" != typeof module2 ? module2.exports = e() : t2.dayjs = e();
      }(void 0, function() {
        var t2 = "millisecond", e = "second", n = "minute", r = "hour", i = "day", s = "week", u = "month", a = "quarter", o = "year", f = "date", h3 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d+)?$/, c = /\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, d = function d2(t3, e2, n2) {
          var r2 = String(t3);
          return !r2 || r2.length >= e2 ? t3 : "" + Array(e2 + 1 - r2.length).join(n2) + t3;
        }, $ = { s: d, z: function z(t3) {
          var e2 = -t3.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
          return (e2 <= 0 ? "+" : "-") + d(r2, 2, "0") + ":" + d(i2, 2, "0");
        }, m: function t3(e2, n2) {
          if (e2.date() < n2.date())
            return -t3(n2, e2);
          var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.add(r2, u), s2 = n2 - i2 < 0, a2 = e2.add(r2 + (s2 ? -1 : 1), u);
          return +(-(r2 + (n2 - i2) / (s2 ? i2 - a2 : a2 - i2)) || 0);
        }, a: function a2(t3) {
          return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
        }, p: function p2(h4) {
          return { M: u, y: o, w: s, d: i, D: f, h: r, m: n, s: e, ms: t2, Q: a }[h4] || String(h4 || "").toLowerCase().replace(/s$/, "");
        }, u: function u2(t3) {
          return void 0 === t3;
        } }, l = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, y = "en", M = {};
        M[y] = l;
        var m = function m2(t3) {
          return t3 instanceof S;
        }, D = function D2(t3, e2, n2) {
          var r2;
          if (!t3)
            return y;
          if ("string" == typeof t3)
            M[t3] && (r2 = t3), e2 && (M[t3] = e2, r2 = t3);
          else {
            var i2 = t3.name;
            M[i2] = t3, r2 = i2;
          }
          return !n2 && r2 && (y = r2), r2 || !n2 && y;
        }, v = function v2(t3, e2) {
          if (m(t3))
            return t3.clone();
          var n2 = "object" == _typeof2(e2) ? e2 : {};
          return n2.date = t3, n2.args = arguments, new S(n2);
        }, g = $;
        g.l = D, g.i = m, g.w = function(t3, e2) {
          return v(t3, { locale: e2.$L, utc: e2.$u, $offset: e2.$offset });
        };
        var S = function() {
          function d2(t3) {
            this.$L = this.$L || D(t3.locale, null, true), this.parse(t3);
          }
          var $2 = d2.prototype;
          return $2.parse = function(t3) {
            this.$d = function(t4) {
              var e2 = t4.date, n2 = t4.utc;
              if (null === e2)
                return /* @__PURE__ */ new Date(NaN);
              if (g.u(e2))
                return /* @__PURE__ */ new Date();
              if (e2 instanceof Date)
                return new Date(e2);
              if ("string" == typeof e2 && !/Z$/i.test(e2)) {
                var r2 = e2.match(h3);
                if (r2) {
                  var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                  return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
                }
              }
              return new Date(e2);
            }(t3), this.init();
          }, $2.init = function() {
            var t3 = this.$d;
            this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
          }, $2.$utils = function() {
            return g;
          }, $2.isValid = function() {
            return !("Invalid Date" === this.$d.toString());
          }, $2.isSame = function(t3, e2) {
            var n2 = v(t3);
            return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
          }, $2.isAfter = function(t3, e2) {
            return v(t3) < this.startOf(e2);
          }, $2.isBefore = function(t3, e2) {
            return this.endOf(e2) < v(t3);
          }, $2.$g = function(t3, e2, n2) {
            return g.u(t3) ? this[e2] : this.set(n2, t3);
          }, $2.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, $2.valueOf = function() {
            return this.$d.getTime();
          }, $2.startOf = function(t3, a2) {
            var h4 = this, c2 = !!g.u(a2) || a2, d3 = g.p(t3), $3 = function $4(t4, e2) {
              var n2 = g.w(h4.$u ? Date.UTC(h4.$y, e2, t4) : new Date(h4.$y, e2, t4), h4);
              return c2 ? n2 : n2.endOf(i);
            }, l2 = function l3(t4, e2) {
              return g.w(h4.toDate()[t4].apply(h4.toDate("s"), (c2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e2)), h4);
            }, y2 = this.$W, M2 = this.$M, m2 = this.$D, D2 = "set" + (this.$u ? "UTC" : "");
            switch (d3) {
              case o:
                return c2 ? $3(1, 0) : $3(31, 11);
              case u:
                return c2 ? $3(1, M2) : $3(0, M2 + 1);
              case s:
                var v2 = this.$locale().weekStart || 0, S2 = (y2 < v2 ? y2 + 7 : y2) - v2;
                return $3(c2 ? m2 - S2 : m2 + (6 - S2), M2);
              case i:
              case f:
                return l2(D2 + "Hours", 0);
              case r:
                return l2(D2 + "Minutes", 1);
              case n:
                return l2(D2 + "Seconds", 2);
              case e:
                return l2(D2 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, $2.endOf = function(t3) {
            return this.startOf(t3, false);
          }, $2.$set = function(s2, a2) {
            var h4, c2 = g.p(s2), d3 = "set" + (this.$u ? "UTC" : ""), $3 = (h4 = {}, h4[i] = d3 + "Date", h4[f] = d3 + "Date", h4[u] = d3 + "Month", h4[o] = d3 + "FullYear", h4[r] = d3 + "Hours", h4[n] = d3 + "Minutes", h4[e] = d3 + "Seconds", h4[t2] = d3 + "Milliseconds", h4)[c2], l2 = c2 === i ? this.$D + (a2 - this.$W) : a2;
            if (c2 === u || c2 === o) {
              var y2 = this.clone().set(f, 1);
              y2.$d[$3](l2), y2.init(), this.$d = y2.set(f, Math.min(this.$D, y2.daysInMonth())).$d;
            } else
              $3 && this.$d[$3](l2);
            return this.init(), this;
          }, $2.set = function(t3, e2) {
            return this.clone().$set(t3, e2);
          }, $2.get = function(t3) {
            return this[g.p(t3)]();
          }, $2.add = function(t3, a2) {
            var f2, h4 = this;
            t3 = Number(t3);
            var c2 = g.p(a2), d3 = function d4(e2) {
              var n2 = v(h4);
              return g.w(n2.date(n2.date() + Math.round(e2 * t3)), h4);
            };
            if (c2 === u)
              return this.set(u, this.$M + t3);
            if (c2 === o)
              return this.set(o, this.$y + t3);
            if (c2 === i)
              return d3(1);
            if (c2 === s)
              return d3(7);
            var $3 = (f2 = {}, f2[n] = 6e4, f2[r] = 36e5, f2[e] = 1e3, f2)[c2] || 1, l2 = this.$d.getTime() + t3 * $3;
            return g.w(l2, this);
          }, $2.subtract = function(t3, e2) {
            return this.add(-1 * t3, e2);
          }, $2.format = function(t3) {
            var e2 = this;
            if (!this.isValid())
              return "Invalid Date";
            var n2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", r2 = g.z(this), i2 = this.$locale(), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = i2.weekdays, f2 = i2.months, h4 = function h5(t4, r3, i3, s3) {
              return t4 && (t4[r3] || t4(e2, n2)) || i3[r3].substr(0, s3);
            }, d3 = function d4(t4) {
              return g.s(s2 % 12 || 12, t4, "0");
            }, $3 = i2.meridiem || function(t4, e3, n3) {
              var r3 = t4 < 12 ? "AM" : "PM";
              return n3 ? r3.toLowerCase() : r3;
            }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: g.s(a2 + 1, 2, "0"), MMM: h4(i2.monthsShort, a2, f2, 3), MMMM: h4(f2, a2), D: this.$D, DD: g.s(this.$D, 2, "0"), d: String(this.$W), dd: h4(i2.weekdaysMin, this.$W, o2, 2), ddd: h4(i2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: g.s(s2, 2, "0"), h: d3(1), hh: d3(2), a: $3(s2, u2, true), A: $3(s2, u2, false), m: String(u2), mm: g.s(u2, 2, "0"), s: String(this.$s), ss: g.s(this.$s, 2, "0"), SSS: g.s(this.$ms, 3, "0"), Z: r2 };
            return n2.replace(c, function(t4, e3) {
              return e3 || l2[t4] || r2.replace(":", "");
            });
          }, $2.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, $2.diff = function(t3, f2, h4) {
            var c2, d3 = g.p(f2), $3 = v(t3), l2 = 6e4 * ($3.utcOffset() - this.utcOffset()), y2 = this - $3, M2 = g.m(this, $3);
            return M2 = (c2 = {}, c2[o] = M2 / 12, c2[u] = M2, c2[a] = M2 / 3, c2[s] = (y2 - l2) / 6048e5, c2[i] = (y2 - l2) / 864e5, c2[r] = y2 / 36e5, c2[n] = y2 / 6e4, c2[e] = y2 / 1e3, c2)[d3] || y2, h4 ? M2 : g.a(M2);
          }, $2.daysInMonth = function() {
            return this.endOf(u).$D;
          }, $2.$locale = function() {
            return M[this.$L];
          }, $2.locale = function(t3, e2) {
            if (!t3)
              return this.$L;
            var n2 = this.clone(), r2 = D(t3, e2, true);
            return r2 && (n2.$L = r2), n2;
          }, $2.clone = function() {
            return g.w(this.$d, this);
          }, $2.toDate = function() {
            return new Date(this.valueOf());
          }, $2.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, $2.toISOString = function() {
            return this.$d.toISOString();
          }, $2.toString = function() {
            return this.$d.toUTCString();
          }, d2;
        }(), p = S.prototype;
        return v.prototype = p, [["$ms", t2], ["$s", e], ["$m", n], ["$H", r], ["$W", i], ["$M", u], ["$y", o], ["$D", f]].forEach(function(t3) {
          p[t3[1]] = function(e2) {
            return this.$g(e2, t3[0], t3[1]);
          };
        }), v.extend = function(t3, e2) {
          return t3(e2, S, v), v;
        }, v.locale = D, v.isDayjs = m, v.unix = function(t3) {
          return v(1e3 * t3);
        }, v.en = M[y], v.Ls = M, v;
      });
    }, {}], 337: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      !function(t2, e) {
        "object" == (typeof exports2 === "undefined" ? "undefined" : _typeof2(exports2)) && "undefined" != typeof module2 ? module2.exports = e() : t2.dayjs_plugin_customParseFormat = e();
      }(void 0, function() {
        var t2, e = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, o = /\d*[^\s\d-:/()]+/;
        var i = function i2(t3) {
          return function(e2) {
            this[t3] = +e2;
          };
        }, s = [/[+-]\d\d:?\d\d/, function(t3) {
          var e2, n2;
          (this.zone || (this.zone = {})).offset = (e2 = t3.match(/([+-]|\d\d)/g), 0 === (n2 = 60 * e2[1] + +e2[2]) ? 0 : "+" === e2[0] ? -n2 : n2);
        }], a = function a2(e2) {
          var n2 = t2[e2];
          return n2 && (n2.indexOf ? n2 : n2.s.concat(n2.f));
        }, h3 = { A: [/[AP]M/, function(t3) {
          this.afternoon = "PM" === t3;
        }], a: [/[ap]m/, function(t3) {
          this.afternoon = "pm" === t3;
        }], S: [/\d/, function(t3) {
          this.milliseconds = 100 * +t3;
        }], SS: [n, function(t3) {
          this.milliseconds = 10 * +t3;
        }], SSS: [/\d{3}/, function(t3) {
          this.milliseconds = +t3;
        }], s: [r, i("seconds")], ss: [r, i("seconds")], m: [r, i("minutes")], mm: [r, i("minutes")], H: [r, i("hours")], h: [r, i("hours")], HH: [r, i("hours")], hh: [r, i("hours")], D: [r, i("day")], DD: [n, i("day")], Do: [o, function(e2) {
          var n2 = t2.ordinal, r2 = e2.match(/\d+/);
          if (this.day = r2[0], n2)
            for (var o2 = 1; o2 <= 31; o2 += 1) {
              n2(o2).replace(/\[|\]/g, "") === e2 && (this.day = o2);
            }
        }], M: [r, i("month")], MM: [n, i("month")], MMM: [o, function(t3) {
          var e2 = a("months"), n2 = (a("monthsShort") || e2.map(function(t4) {
            return t4.substr(0, 3);
          })).indexOf(t3) + 1;
          if (n2 < 1)
            throw new Error();
          this.month = n2 % 12 || n2;
        }], MMMM: [o, function(t3) {
          var e2 = a("months").indexOf(t3) + 1;
          if (e2 < 1)
            throw new Error();
          this.month = e2 % 12 || e2;
        }], Y: [/[+-]?\d+/, i("year")], YY: [n, function(t3) {
          t3 = +t3, this.year = t3 + (t3 > 68 ? 1900 : 2e3);
        }], YYYY: [/\d{4}/, i("year")], Z: s, ZZ: s };
        var f = function f2(t3, n2, r2) {
          try {
            var o2 = function(t4) {
              for (var n3 = t4.match(e), r3 = n3.length, o3 = 0; o3 < r3; o3 += 1) {
                var i3 = n3[o3], s3 = h3[i3], a3 = s3 && s3[0], f4 = s3 && s3[1];
                n3[o3] = f4 ? { regex: a3, parser: f4 } : i3.replace(/^\[|\]$/g, "");
              }
              return function(t5) {
                for (var e2 = {}, o4 = 0, i4 = 0; o4 < r3; o4 += 1) {
                  var s4 = n3[o4];
                  if ("string" == typeof s4)
                    i4 += s4.length;
                  else {
                    var a4 = s4.regex, h4 = s4.parser, f5 = t5.substr(i4), u2 = a4.exec(f5)[0];
                    h4.call(e2, u2), t5 = t5.replace(u2, "");
                  }
                }
                return function(t6) {
                  var e3 = t6.afternoon;
                  if (void 0 !== e3) {
                    var n4 = t6.hours;
                    e3 ? n4 < 12 && (t6.hours += 12) : 12 === n4 && (t6.hours = 0), delete t6.afternoon;
                  }
                }(e2), e2;
              };
            }(n2)(t3), i2 = o2.year, s2 = o2.month, a2 = o2.day, f3 = o2.hours, u = o2.minutes, d = o2.seconds, c = o2.milliseconds, l = o2.zone, m = /* @__PURE__ */ new Date(), v = a2 || (i2 || s2 ? 1 : m.getDate()), p = i2 || m.getFullYear(), y = 0;
            i2 && !s2 || (y = s2 > 0 ? s2 - 1 : m.getMonth());
            var D = f3 || 0, M = u || 0, g = d || 0, Y = c || 0;
            return l ? new Date(Date.UTC(p, y, v, D, M, g, Y + 60 * l.offset * 1e3)) : r2 ? new Date(Date.UTC(p, y, v, D, M, g, Y)) : new Date(p, y, v, D, M, g, Y);
          } catch (t4) {
            return /* @__PURE__ */ new Date("");
          }
        };
        return function(e2, n2, r2) {
          var o2 = n2.prototype, i2 = o2.parse;
          o2.parse = function(e3) {
            var n3 = e3.date, o3 = e3.utc, s2 = e3.args;
            this.$u = o3;
            var a2 = s2[1];
            if ("string" == typeof a2) {
              var h4 = true === s2[2], u = true === s2[3], d = h4 || u, c = s2[2];
              u && (c = s2[2]), h4 || (t2 = c ? r2.Ls[c] : this.$locale()), this.$d = f(n3, a2, o3), this.init(), c && true !== c && (this.$L = this.locale(c).$L), d && n3 !== this.format(a2) && (this.$d = /* @__PURE__ */ new Date(""));
            } else if (a2 instanceof Array)
              for (var l = a2.length, m = 1; m <= l; m += 1) {
                s2[1] = a2[m - 1];
                var v = r2.apply(this, s2);
                if (v.isValid()) {
                  this.$d = v.$d, this.$L = v.$L, this.init();
                  break;
                }
                m === l && (this.$d = /* @__PURE__ */ new Date(""));
              }
            else
              i2.call(this, e3);
          };
        };
      });
    }, {}], 338: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      !function(t2, i) {
        "object" == (typeof exports2 === "undefined" ? "undefined" : _typeof2(exports2)) && "undefined" != typeof module2 ? module2.exports = i() : t2.dayjs_plugin_utc = i();
      }(void 0, function() {
        return function(t2, i, e) {
          var s = (/* @__PURE__ */ new Date()).getTimezoneOffset(), n = i.prototype;
          e.utc = function(t3) {
            return new i({ date: t3, utc: true, args: arguments });
          }, n.utc = function() {
            return e(this.toDate(), { locale: this.$L, utc: true });
          }, n.local = function() {
            return e(this.toDate(), { locale: this.$L, utc: false });
          };
          var u = n.parse;
          n.parse = function(t3) {
            t3.utc && (this.$u = true), this.$utils().u(t3.$offset) || (this.$offset = t3.$offset), u.call(this, t3);
          };
          var o = n.init;
          n.init = function() {
            if (this.$u) {
              var t3 = this.$d;
              this.$y = t3.getUTCFullYear(), this.$M = t3.getUTCMonth(), this.$D = t3.getUTCDate(), this.$W = t3.getUTCDay(), this.$H = t3.getUTCHours(), this.$m = t3.getUTCMinutes(), this.$s = t3.getUTCSeconds(), this.$ms = t3.getUTCMilliseconds();
            } else
              o.call(this);
          };
          var f = n.utcOffset;
          n.utcOffset = function(t3, i2) {
            var e2 = this.$utils().u;
            if (e2(t3))
              return this.$u ? 0 : e2(this.$offset) ? f.call(this) : this.$offset;
            var n2 = Math.abs(t3) <= 16 ? 60 * t3 : t3, u2 = this;
            return i2 ? (u2.$offset = n2, u2.$u = 0 === t3, u2) : (0 !== t3 ? (u2 = this.local().add(n2 + s, "minute")).$offset = n2 : u2 = this.utc(), u2);
          };
          var r = n.format;
          n.format = function(t3) {
            var i2 = t3 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
            return r.call(this, i2);
          }, n.valueOf = function() {
            var t3 = this.$utils().u(this.$offset) ? 0 : this.$offset + s;
            return this.$d.valueOf() - 6e4 * t3;
          }, n.isUTC = function() {
            return !!this.$u;
          }, n.toISOString = function() {
            return this.toDate().toISOString();
          }, n.toString = function() {
            return this.toDate().toUTCString();
          };
          var a = n.toDate;
          n.toDate = function(t3) {
            return "s" === t3 && this.$offset ? e(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : a.call(this);
          };
          var c = n.diff;
          n.diff = function(t3, i2, s2) {
            var n2 = this.local(), u2 = e(t3).local();
            return c.call(n2, u2, i2, s2);
          };
        };
      });
    }, {}], 339: [function(require2, module2, exports2) {
      exports2.utils = require2("./des/utils");
      exports2.Cipher = require2("./des/cipher");
      exports2.DES = require2("./des/des");
      exports2.CBC = require2("./des/cbc");
      exports2.EDE = require2("./des/ede");
    }, { "./des/cbc": 340, "./des/cipher": 341, "./des/des": 342, "./des/ede": 343, "./des/utils": 344 }], 340: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      var proto = {};
      function CBCState(iv) {
        assert.equal(iv.length, 8, "Invalid IV length");
        this.iv = new Array(8);
        for (var i = 0; i < this.iv.length; i++) {
          this.iv[i] = iv[i];
        }
      }
      function instantiate(Base) {
        function CBC(options) {
          Base.call(this, options);
          this._cbcInit();
        }
        inherits(CBC, Base);
        var keys = Object.keys(proto);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          CBC.prototype[key] = proto[key];
        }
        CBC.create = function create(options) {
          return new CBC(options);
        };
        return CBC;
      }
      exports2.instantiate = instantiate;
      proto._cbcInit = function _cbcInit() {
        var state = new CBCState(this.options.iv);
        this._cbcState = state;
      };
      proto._update = function _update(inp, inOff, out, outOff) {
        var state = this._cbcState;
        var superProto = this.constructor.super_.prototype;
        var iv = state.iv;
        if (this.type === "encrypt") {
          for (var i = 0; i < this.blockSize; i++) {
            iv[i] ^= inp[inOff + i];
          }
          superProto._update.call(this, iv, 0, out, outOff);
          for (var i = 0; i < this.blockSize; i++) {
            iv[i] = out[outOff + i];
          }
        } else {
          superProto._update.call(this, inp, inOff, out, outOff);
          for (var i = 0; i < this.blockSize; i++) {
            out[outOff + i] ^= iv[i];
          }
          for (var i = 0; i < this.blockSize; i++) {
            iv[i] = inp[inOff + i];
          }
        }
      };
    }, { "inherits": 387, "minimalistic-assert": 437 }], 341: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      function Cipher(options) {
        this.options = options;
        this.type = this.options.type;
        this.blockSize = 8;
        this._init();
        this.buffer = new Array(this.blockSize);
        this.bufferOff = 0;
      }
      module2.exports = Cipher;
      Cipher.prototype._init = function _init() {
      };
      Cipher.prototype.update = function update(data) {
        if (data.length === 0)
          return [];
        if (this.type === "decrypt")
          return this._updateDecrypt(data);
        else
          return this._updateEncrypt(data);
      };
      Cipher.prototype._buffer = function _buffer(data, off) {
        var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
        for (var i = 0; i < min; i++) {
          this.buffer[this.bufferOff + i] = data[off + i];
        }
        this.bufferOff += min;
        return min;
      };
      Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
        this._update(this.buffer, 0, out, off);
        this.bufferOff = 0;
        return this.blockSize;
      };
      Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
        var inputOff = 0;
        var outputOff = 0;
        var count = (this.bufferOff + data.length) / this.blockSize | 0;
        var out = new Array(count * this.blockSize);
        if (this.bufferOff !== 0) {
          inputOff += this._buffer(data, inputOff);
          if (this.bufferOff === this.buffer.length)
            outputOff += this._flushBuffer(out, outputOff);
        }
        var max = data.length - (data.length - inputOff) % this.blockSize;
        for (; inputOff < max; inputOff += this.blockSize) {
          this._update(data, inputOff, out, outputOff);
          outputOff += this.blockSize;
        }
        for (; inputOff < data.length; inputOff++, this.bufferOff++) {
          this.buffer[this.bufferOff] = data[inputOff];
        }
        return out;
      };
      Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
        var inputOff = 0;
        var outputOff = 0;
        var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
        var out = new Array(count * this.blockSize);
        for (; count > 0; count--) {
          inputOff += this._buffer(data, inputOff);
          outputOff += this._flushBuffer(out, outputOff);
        }
        inputOff += this._buffer(data, inputOff);
        return out;
      };
      Cipher.prototype.final = function final(buffer) {
        var first;
        if (buffer)
          first = this.update(buffer);
        var last;
        if (this.type === "encrypt")
          last = this._finalEncrypt();
        else
          last = this._finalDecrypt();
        if (first)
          return first.concat(last);
        else
          return last;
      };
      Cipher.prototype._pad = function _pad(buffer, off) {
        if (off === 0)
          return false;
        while (off < buffer.length) {
          buffer[off++] = 0;
        }
        return true;
      };
      Cipher.prototype._finalEncrypt = function _finalEncrypt() {
        if (!this._pad(this.buffer, this.bufferOff))
          return [];
        var out = new Array(this.blockSize);
        this._update(this.buffer, 0, out, 0);
        return out;
      };
      Cipher.prototype._unpad = function _unpad(buffer) {
        return buffer;
      };
      Cipher.prototype._finalDecrypt = function _finalDecrypt() {
        assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
        var out = new Array(this.blockSize);
        this._flushBuffer(out, 0);
        return this._unpad(out);
      };
    }, { "minimalistic-assert": 437 }], 342: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      var utils = require2("./utils");
      var Cipher = require2("./cipher");
      function DESState() {
        this.tmp = new Array(2);
        this.keys = null;
      }
      function DES(options) {
        Cipher.call(this, options);
        var state = new DESState();
        this._desState = state;
        this.deriveKeys(state, options.key);
      }
      inherits(DES, Cipher);
      module2.exports = DES;
      DES.create = function create(options) {
        return new DES(options);
      };
      var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
      DES.prototype.deriveKeys = function deriveKeys(state, key) {
        state.keys = new Array(16 * 2);
        assert.equal(key.length, this.blockSize, "Invalid key length");
        var kL = utils.readUInt32BE(key, 0);
        var kR = utils.readUInt32BE(key, 4);
        utils.pc1(kL, kR, state.tmp, 0);
        kL = state.tmp[0];
        kR = state.tmp[1];
        for (var i = 0; i < state.keys.length; i += 2) {
          var shift = shiftTable[i >>> 1];
          kL = utils.r28shl(kL, shift);
          kR = utils.r28shl(kR, shift);
          utils.pc2(kL, kR, state.keys, i);
        }
      };
      DES.prototype._update = function _update(inp, inOff, out, outOff) {
        var state = this._desState;
        var l = utils.readUInt32BE(inp, inOff);
        var r = utils.readUInt32BE(inp, inOff + 4);
        utils.ip(l, r, state.tmp, 0);
        l = state.tmp[0];
        r = state.tmp[1];
        if (this.type === "encrypt")
          this._encrypt(state, l, r, state.tmp, 0);
        else
          this._decrypt(state, l, r, state.tmp, 0);
        l = state.tmp[0];
        r = state.tmp[1];
        utils.writeUInt32BE(out, l, outOff);
        utils.writeUInt32BE(out, r, outOff + 4);
      };
      DES.prototype._pad = function _pad(buffer, off) {
        var value = buffer.length - off;
        for (var i = off; i < buffer.length; i++) {
          buffer[i] = value;
        }
        return true;
      };
      DES.prototype._unpad = function _unpad(buffer) {
        var pad = buffer[buffer.length - 1];
        for (var i = buffer.length - pad; i < buffer.length; i++) {
          assert.equal(buffer[i], pad);
        }
        return buffer.slice(0, buffer.length - pad);
      };
      DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
        var l = lStart;
        var r = rStart;
        for (var i = 0; i < state.keys.length; i += 2) {
          var keyL = state.keys[i];
          var keyR = state.keys[i + 1];
          utils.expand(r, state.tmp, 0);
          keyL ^= state.tmp[0];
          keyR ^= state.tmp[1];
          var s = utils.substitute(keyL, keyR);
          var f = utils.permute(s);
          var t2 = r;
          r = (l ^ f) >>> 0;
          l = t2;
        }
        utils.rip(r, l, out, off);
      };
      DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
        var l = rStart;
        var r = lStart;
        for (var i = state.keys.length - 2; i >= 0; i -= 2) {
          var keyL = state.keys[i];
          var keyR = state.keys[i + 1];
          utils.expand(l, state.tmp, 0);
          keyL ^= state.tmp[0];
          keyR ^= state.tmp[1];
          var s = utils.substitute(keyL, keyR);
          var f = utils.permute(s);
          var t2 = l;
          l = (r ^ f) >>> 0;
          r = t2;
        }
        utils.rip(l, r, out, off);
      };
    }, { "./cipher": 341, "./utils": 344, "inherits": 387, "minimalistic-assert": 437 }], 343: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      var Cipher = require2("./cipher");
      var DES = require2("./des");
      function EDEState(type, key) {
        assert.equal(key.length, 24, "Invalid key length");
        var k1 = key.slice(0, 8);
        var k2 = key.slice(8, 16);
        var k3 = key.slice(16, 24);
        if (type === "encrypt") {
          this.ciphers = [DES.create({ type: "encrypt", key: k1 }), DES.create({ type: "decrypt", key: k2 }), DES.create({ type: "encrypt", key: k3 })];
        } else {
          this.ciphers = [DES.create({ type: "decrypt", key: k3 }), DES.create({ type: "encrypt", key: k2 }), DES.create({ type: "decrypt", key: k1 })];
        }
      }
      function EDE(options) {
        Cipher.call(this, options);
        var state = new EDEState(this.type, this.options.key);
        this._edeState = state;
      }
      inherits(EDE, Cipher);
      module2.exports = EDE;
      EDE.create = function create(options) {
        return new EDE(options);
      };
      EDE.prototype._update = function _update(inp, inOff, out, outOff) {
        var state = this._edeState;
        state.ciphers[0]._update(inp, inOff, out, outOff);
        state.ciphers[1]._update(out, outOff, out, outOff);
        state.ciphers[2]._update(out, outOff, out, outOff);
      };
      EDE.prototype._pad = DES.prototype._pad;
      EDE.prototype._unpad = DES.prototype._unpad;
    }, { "./cipher": 341, "./des": 342, "inherits": 387, "minimalistic-assert": 437 }], 344: [function(require2, module2, exports2) {
      exports2.readUInt32BE = function readUInt32BE(bytes, off) {
        var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
        return res >>> 0;
      };
      exports2.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
        bytes[0 + off] = value >>> 24;
        bytes[1 + off] = value >>> 16 & 255;
        bytes[2 + off] = value >>> 8 & 255;
        bytes[3 + off] = value & 255;
      };
      exports2.ip = function ip(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 6; i >= 0; i -= 2) {
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inR >>> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inL >>> j + i & 1;
          }
        }
        for (var i = 6; i >= 0; i -= 2) {
          for (var j = 1; j <= 25; j += 8) {
            outR <<= 1;
            outR |= inR >>> j + i & 1;
          }
          for (var j = 1; j <= 25; j += 8) {
            outR <<= 1;
            outR |= inL >>> j + i & 1;
          }
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.rip = function rip(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 0; i < 4; i++) {
          for (var j = 24; j >= 0; j -= 8) {
            outL <<= 1;
            outL |= inR >>> j + i & 1;
            outL <<= 1;
            outL |= inL >>> j + i & 1;
          }
        }
        for (var i = 4; i < 8; i++) {
          for (var j = 24; j >= 0; j -= 8) {
            outR <<= 1;
            outR |= inR >>> j + i & 1;
            outR <<= 1;
            outR |= inL >>> j + i & 1;
          }
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.pc1 = function pc1(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        for (var i = 7; i >= 5; i--) {
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inR >> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outL <<= 1;
            outL |= inL >> j + i & 1;
          }
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >> j + i & 1;
        }
        for (var i = 1; i <= 3; i++) {
          for (var j = 0; j <= 24; j += 8) {
            outR <<= 1;
            outR |= inR >> j + i & 1;
          }
          for (var j = 0; j <= 24; j += 8) {
            outR <<= 1;
            outR |= inL >> j + i & 1;
          }
        }
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inL >> j + i & 1;
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.r28shl = function r28shl(num, shift) {
        return num << shift & 268435455 | num >>> 28 - shift;
      };
      var pc2table = [
        // inL => outL
        14,
        11,
        17,
        4,
        27,
        23,
        25,
        0,
        13,
        22,
        7,
        18,
        5,
        9,
        16,
        24,
        2,
        20,
        12,
        21,
        1,
        8,
        15,
        26,
        // inR => outR
        15,
        4,
        25,
        19,
        9,
        1,
        26,
        16,
        5,
        11,
        23,
        8,
        12,
        7,
        17,
        0,
        22,
        3,
        10,
        14,
        6,
        20,
        27,
        24
      ];
      exports2.pc2 = function pc2(inL, inR, out, off) {
        var outL = 0;
        var outR = 0;
        var len = pc2table.length >>> 1;
        for (var i = 0; i < len; i++) {
          outL <<= 1;
          outL |= inL >>> pc2table[i] & 1;
        }
        for (var i = len; i < pc2table.length; i++) {
          outR <<= 1;
          outR |= inR >>> pc2table[i] & 1;
        }
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      exports2.expand = function expand(r, out, off) {
        var outL = 0;
        var outR = 0;
        outL = (r & 1) << 5 | r >>> 27;
        for (var i = 23; i >= 15; i -= 4) {
          outL <<= 6;
          outL |= r >>> i & 63;
        }
        for (var i = 11; i >= 3; i -= 4) {
          outR |= r >>> i & 63;
          outR <<= 6;
        }
        outR |= (r & 31) << 1 | r >>> 31;
        out[off + 0] = outL >>> 0;
        out[off + 1] = outR >>> 0;
      };
      var sTable = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
      exports2.substitute = function substitute(inL, inR) {
        var out = 0;
        for (var i = 0; i < 4; i++) {
          var b = inL >>> 18 - i * 6 & 63;
          var sb = sTable[i * 64 + b];
          out <<= 4;
          out |= sb;
        }
        for (var i = 0; i < 4; i++) {
          var b = inR >>> 18 - i * 6 & 63;
          var sb = sTable[4 * 64 + i * 64 + b];
          out <<= 4;
          out |= sb;
        }
        return out >>> 0;
      };
      var permuteTable = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
      exports2.permute = function permute(num) {
        var out = 0;
        for (var i = 0; i < permuteTable.length; i++) {
          out <<= 1;
          out |= num >>> permuteTable[i] & 1;
        }
        return out >>> 0;
      };
      exports2.padSplit = function padSplit(num, size, group) {
        var str = num.toString(2);
        while (str.length < size) {
          str = "0" + str;
        }
        var out = [];
        for (var i = 0; i < size; i += group) {
          out.push(str.slice(i, i + group));
        }
        return out.join(" ");
      };
    }, {}], 345: [function(require2, module2, exports2) {
      (function(Buffer) {
        var generatePrime = require2("./lib/generatePrime");
        var primes = require2("./lib/primes.json");
        var DH = require2("./lib/dh");
        function getDiffieHellman(mod) {
          var prime = new Buffer(primes[mod].prime, "hex");
          var gen = new Buffer(primes[mod].gen, "hex");
          return new DH(prime, gen);
        }
        var ENCODINGS = { "binary": true, "hex": true, "base64": true };
        function createDiffieHellman(prime, enc, generator, genc) {
          if (Buffer.isBuffer(enc) || ENCODINGS[enc] === void 0) {
            return createDiffieHellman(prime, "binary", enc, generator);
          }
          enc = enc || "binary";
          genc = genc || "binary";
          generator = generator || new Buffer([2]);
          if (!Buffer.isBuffer(generator)) {
            generator = new Buffer(generator, genc);
          }
          if (typeof prime === "number") {
            return new DH(generatePrime(prime, generator), generator, true);
          }
          if (!Buffer.isBuffer(prime)) {
            prime = new Buffer(prime, enc);
          }
          return new DH(prime, generator, true);
        }
        exports2.DiffieHellmanGroup = exports2.createDiffieHellmanGroup = exports2.getDiffieHellman = getDiffieHellman;
        exports2.createDiffieHellman = exports2.DiffieHellman = createDiffieHellman;
      }).call(this, require2("buffer").Buffer);
    }, { "./lib/dh": 346, "./lib/generatePrime": 347, "./lib/primes.json": 348, "buffer": 216 }], 346: [function(require2, module2, exports2) {
      (function(Buffer) {
        var BN = require2("bn.js");
        var MillerRabin = require2("miller-rabin");
        var millerRabin = new MillerRabin();
        var TWENTYFOUR = new BN(24);
        var ELEVEN = new BN(11);
        var TEN = new BN(10);
        var THREE = new BN(3);
        var SEVEN = new BN(7);
        var primes = require2("./generatePrime");
        var randomBytes = require2("randombytes");
        module2.exports = DH;
        function setPublicKey(pub, enc) {
          enc = enc || "utf8";
          if (!Buffer.isBuffer(pub)) {
            pub = new Buffer(pub, enc);
          }
          this._pub = new BN(pub);
          return this;
        }
        function setPrivateKey(priv, enc) {
          enc = enc || "utf8";
          if (!Buffer.isBuffer(priv)) {
            priv = new Buffer(priv, enc);
          }
          this._priv = new BN(priv);
          return this;
        }
        var primeCache = {};
        function checkPrime(prime, generator) {
          var gen = generator.toString("hex");
          var hex = [gen, prime.toString(16)].join("_");
          if (hex in primeCache) {
            return primeCache[hex];
          }
          var error = 0;
          if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
            error += 1;
            if (gen === "02" || gen === "05") {
              error += 8;
            } else {
              error += 4;
            }
            primeCache[hex] = error;
            return error;
          }
          if (!millerRabin.test(prime.shrn(1))) {
            error += 2;
          }
          var rem;
          switch (gen) {
            case "02":
              if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
                error += 8;
              }
              break;
            case "05":
              rem = prime.mod(TEN);
              if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
                error += 8;
              }
              break;
            default:
              error += 4;
          }
          primeCache[hex] = error;
          return error;
        }
        function DH(prime, generator, malleable) {
          this.setGenerator(generator);
          this.__prime = new BN(prime);
          this._prime = BN.mont(this.__prime);
          this._primeLen = prime.length;
          this._pub = void 0;
          this._priv = void 0;
          this._primeCode = void 0;
          if (malleable) {
            this.setPublicKey = setPublicKey;
            this.setPrivateKey = setPrivateKey;
          } else {
            this._primeCode = 8;
          }
        }
        Object.defineProperty(DH.prototype, "verifyError", { enumerable: true, get: function get() {
          if (typeof this._primeCode !== "number") {
            this._primeCode = checkPrime(this.__prime, this.__gen);
          }
          return this._primeCode;
        } });
        DH.prototype.generateKeys = function() {
          if (!this._priv) {
            this._priv = new BN(randomBytes(this._primeLen));
          }
          this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
          return this.getPublicKey();
        };
        DH.prototype.computeSecret = function(other) {
          other = new BN(other);
          other = other.toRed(this._prime);
          var secret = other.redPow(this._priv).fromRed();
          var out = new Buffer(secret.toArray());
          var prime = this.getPrime();
          if (out.length < prime.length) {
            var front = new Buffer(prime.length - out.length);
            front.fill(0);
            out = Buffer.concat([front, out]);
          }
          return out;
        };
        DH.prototype.getPublicKey = function getPublicKey(enc) {
          return formatReturnValue(this._pub, enc);
        };
        DH.prototype.getPrivateKey = function getPrivateKey(enc) {
          return formatReturnValue(this._priv, enc);
        };
        DH.prototype.getPrime = function(enc) {
          return formatReturnValue(this.__prime, enc);
        };
        DH.prototype.getGenerator = function(enc) {
          return formatReturnValue(this._gen, enc);
        };
        DH.prototype.setGenerator = function(gen, enc) {
          enc = enc || "utf8";
          if (!Buffer.isBuffer(gen)) {
            gen = new Buffer(gen, enc);
          }
          this.__gen = gen;
          this._gen = new BN(gen);
          return this;
        };
        function formatReturnValue(bn, enc) {
          var buf = new Buffer(bn.toArray());
          if (!enc) {
            return buf;
          } else {
            return buf.toString(enc);
          }
        }
      }).call(this, require2("buffer").Buffer);
    }, { "./generatePrime": 347, "bn.js": 349, "buffer": 216, "miller-rabin": 435, "randombytes": 475 }], 347: [function(require2, module2, exports2) {
      var randomBytes = require2("randombytes");
      module2.exports = findPrime;
      findPrime.simpleSieve = simpleSieve;
      findPrime.fermatTest = fermatTest;
      var BN = require2("bn.js");
      var TWENTYFOUR = new BN(24);
      var MillerRabin = require2("miller-rabin");
      var millerRabin = new MillerRabin();
      var ONE = new BN(1);
      var TWO = new BN(2);
      var FIVE = new BN(5);
      new BN(16);
      new BN(8);
      var TEN = new BN(10);
      var THREE = new BN(3);
      new BN(7);
      var ELEVEN = new BN(11);
      var FOUR = new BN(4);
      new BN(12);
      var primes = null;
      function _getPrimes() {
        if (primes !== null)
          return primes;
        var limit = 1048576;
        var res = [];
        res[0] = 2;
        for (var i = 1, k = 3; k < limit; k += 2) {
          var sqrt = Math.ceil(Math.sqrt(k));
          for (var j = 0; j < i && res[j] <= sqrt; j++) {
            if (k % res[j] === 0)
              break;
          }
          if (i !== j && res[j] <= sqrt)
            continue;
          res[i++] = k;
        }
        primes = res;
        return res;
      }
      function simpleSieve(p) {
        var primes2 = _getPrimes();
        for (var i = 0; i < primes2.length; i++) {
          if (p.modn(primes2[i]) === 0) {
            if (p.cmpn(primes2[i]) === 0) {
              return true;
            } else {
              return false;
            }
          }
        }
        return true;
      }
      function fermatTest(p) {
        var red = BN.mont(p);
        return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
      }
      function findPrime(bits, gen) {
        if (bits < 16) {
          if (gen === 2 || gen === 5) {
            return new BN([140, 123]);
          } else {
            return new BN([140, 39]);
          }
        }
        gen = new BN(gen);
        var num, n2;
        while (true) {
          num = new BN(randomBytes(Math.ceil(bits / 8)));
          while (num.bitLength() > bits) {
            num.ishrn(1);
          }
          if (num.isEven()) {
            num.iadd(ONE);
          }
          if (!num.testn(1)) {
            num.iadd(TWO);
          }
          if (!gen.cmp(TWO)) {
            while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
              num.iadd(FOUR);
            }
          } else if (!gen.cmp(FIVE)) {
            while (num.mod(TEN).cmp(THREE)) {
              num.iadd(FOUR);
            }
          }
          n2 = num.shrn(1);
          if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
            return num;
          }
        }
      }
    }, { "bn.js": 349, "miller-rabin": 435, "randombytes": 475 }], 348: [function(require2, module2, exports2) {
      module2.exports = { "modp1": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, "modp2": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, "modp5": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, "modp14": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, "modp15": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, "modp16": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, "modp17": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, "modp18": { "gen": "02", "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
    }, {}], 349: [function(require2, module2, exports2) {
      arguments[4][181][0].apply(exports2, arguments);
    }, { "buffer": 185, "dup": 181 }], 350: [function(require2, module2, exports2) {
      var elliptic = exports2;
      elliptic.version = require2("../package.json").version;
      elliptic.utils = require2("./elliptic/utils");
      elliptic.rand = require2("brorand");
      elliptic.curve = require2("./elliptic/curve");
      elliptic.curves = require2("./elliptic/curves");
      elliptic.ec = require2("./elliptic/ec");
      elliptic.eddsa = require2("./elliptic/eddsa");
    }, { "../package.json": 366, "./elliptic/curve": 353, "./elliptic/curves": 356, "./elliptic/ec": 357, "./elliptic/eddsa": 360, "./elliptic/utils": 364, "brorand": 184 }], 351: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var getNAF = utils.getNAF;
      var getJSF = utils.getJSF;
      var assert = utils.assert;
      function BaseCurve(type, conf) {
        this.type = type;
        this.p = new BN(conf.p, 16);
        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
        this.zero = new BN(0).toRed(this.red);
        this.one = new BN(1).toRed(this.red);
        this.two = new BN(2).toRed(this.red);
        this.n = conf.n && new BN(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
          this.redN = null;
        } else {
          this._maxwellTrick = true;
          this.redN = this.n.toRed(this.red);
        }
      }
      module2.exports = BaseCurve;
      BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1, this._bitLength);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        for (var j = 0; j < naf.length; j += doubles.step) {
          var nafW = 0;
          for (var k = j + doubles.step - 1; k >= j; k--) {
            nafW = (nafW << 1) + naf[k];
          }
          repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
          for (var j = 0; j < repr.length; j++) {
            var nafW = repr[j];
            if (nafW === i)
              b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i)
              b = b.mixedAdd(doubles.points[j].neg());
          }
          a = a.add(b);
        }
        return a.toP();
      };
      BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w, this._bitLength);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
          for (var k = 0; i >= 0 && naf[i] === 0; i--) {
            k++;
          }
          if (i >= 0)
            k++;
          acc = acc.dblp(k);
          if (i < 0)
            break;
          var z = naf[i];
          assert(z !== 0);
          if (p.type === "affine") {
            if (z > 0)
              acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else
              acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
          } else {
            if (z > 0)
              acc = acc.add(wnd[z - 1 >> 1]);
            else
              acc = acc.add(wnd[-z - 1 >> 1].neg());
          }
        }
        return p.type === "affine" ? acc.toP() : acc;
      };
      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max = 0;
        for (var i = 0; i < len; i++) {
          var p = points[i];
          var nafPoints = p._getNAFPoints(defW);
          wndWidth[i] = nafPoints.wnd;
          wnd[i] = nafPoints.points;
        }
        for (var i = len - 1; i >= 1; i -= 2) {
          var a = i - 1;
          var b = i;
          if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
          }
          var comb = [
            points[a],
            /* 1 */
            null,
            /* 3 */
            null,
            /* 5 */
            points[b]
            /* 7 */
          ];
          if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
          } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          }
          var index2 = [
            -3,
            /* -1 -1 */
            -1,
            /* -1 0 */
            -5,
            /* -1 1 */
            -7,
            /* 0 -1 */
            0,
            /* 0 0 */
            7,
            /* 0 1 */
            5,
            /* 1 -1 */
            1,
            /* 1 0 */
            3
            /* 1 1 */
          ];
          var jsf = getJSF(coeffs[a], coeffs[b]);
          max = Math.max(jsf[0].length, max);
          naf[a] = new Array(max);
          naf[b] = new Array(max);
          for (var j = 0; j < max; j++) {
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index2[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
          }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (var i = max; i >= 0; i--) {
          var k = 0;
          while (i >= 0) {
            var zero = true;
            for (var j = 0; j < len; j++) {
              tmp[j] = naf[j][i] | 0;
              if (tmp[j] !== 0)
                zero = false;
            }
            if (!zero)
              break;
            k++;
            i--;
          }
          if (i >= 0)
            k++;
          acc = acc.dblp(k);
          if (i < 0)
            break;
          for (var j = 0; j < len; j++) {
            var z = tmp[j];
            var p;
            if (z === 0)
              continue;
            else if (z > 0)
              p = wnd[j][z - 1 >> 1];
            else if (z < 0)
              p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine")
              acc = acc.mixedAdd(p);
            else
              acc = acc.add(p);
          }
        }
        for (var i = 0; i < len; i++) {
          wnd[i] = null;
        }
        if (jacobianResult)
          return acc;
        else
          return acc.toP();
      };
      function BasePoint(curve, type) {
        this.curve = curve;
        this.type = type;
        this.precomputed = null;
      }
      BaseCurve.BasePoint = BasePoint;
      BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
      };
      BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
      };
      BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        bytes = utils.toArray(bytes, enc);
        var len = this.p.byteLength();
        if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
          if (bytes[0] === 6)
            assert(bytes[bytes.length - 1] % 2 === 0);
          else if (bytes[0] === 7)
            assert(bytes[bytes.length - 1] % 2 === 1);
          var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
          return res;
        } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
          return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
        }
        throw new Error("Unknown point format");
      };
      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
      };
      BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact)
          return [this.getY().isEven() ? 2 : 3].concat(x);
        return [4].concat(x, this.getY().toArray("be", len));
      };
      BasePoint.prototype.encode = function encode(enc, compact) {
        return utils.encode(this._encode(compact), enc);
      };
      BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed)
          return this;
        var precomputed = { doubles: null, naf: null, beta: null };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
      };
      BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed)
          return false;
        var doubles = this.precomputed.doubles;
        if (!doubles)
          return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
      };
      BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        var doubles = [this];
        var acc = this;
        for (var i = 0; i < power; i += step) {
          for (var j = 0; j < step; j++) {
            acc = acc.dbl();
          }
          doubles.push(acc);
        }
        return { step, points: doubles };
      };
      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        var res = [this];
        var max = (1 << wnd) - 1;
        var dbl = max === 1 ? null : this.dbl();
        for (var i = 1; i < max; i++) {
          res[i] = res[i - 1].add(dbl);
        }
        return { wnd, points: res };
      };
      BasePoint.prototype._getBeta = function _getBeta() {
        return null;
      };
      BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++) {
          r = r.dbl();
        }
        return r;
      };
    }, { "../utils": 364, "bn.js": 365 }], 352: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var BN = require2("bn.js");
      var inherits = require2("inherits");
      var Base = require2("./base");
      var assert = utils.assert;
      function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new BN(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
      }
      inherits(EdwardsCurve, Base);
      module2.exports = EdwardsCurve;
      EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
          return num.redNeg();
        else
          return this.a.redMul(num);
      };
      EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
          return num;
        else
          return this.c.redMul(num);
      };
      EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t2) {
        return this.point(x, y, z, t2);
      };
      EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y2 = rhs.redMul(lhs.redInvm());
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new BN(y, 16);
        if (!y.red)
          y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.c2);
        var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
          if (odd)
            throw new Error("invalid point");
          else
            return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        if (x.fromRed().isOdd() !== odd)
          x = x.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity())
          return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
      };
      function Point(curve, x, y, z, t2) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && y === null && z === null) {
          this.x = this.curve.zero;
          this.y = this.curve.one;
          this.z = this.curve.one;
          this.t = this.curve.zero;
          this.zOne = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = z ? new BN(z, 16) : this.curve.one;
          this.t = t2 && new BN(t2, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
          if (this.t && !this.t.red)
            this.t = this.t.toRed(this.curve.red);
          this.zOne = this.z === this.curve.one;
          if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne)
              this.t = this.t.redMul(this.z.redInvm());
          }
        }
      }
      inherits(Point, Base.BasePoint);
      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      EdwardsCurve.prototype.point = function point(x, y, z, t2) {
        return new Point(this, x, y, z, t2);
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      };
      Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f = g.redSub(c);
        var h3 = d.redSub(b);
        var nx = e.redMul(f);
        var ny = g.redMul(h3);
        var nt = e.redMul(h3);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        if (this.curve.twisted) {
          var e = this.curve._mulA(c);
          var f = e.redAdd(d);
          if (this.zOne) {
            nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
            ny = f.redMul(e.redSub(d));
            nz = f.redSqr().redSub(f).redSub(f);
          } else {
            var h3 = this.z.redSqr();
            var j = f.redSub(h3).redISub(h3);
            nx = b.redSub(c).redISub(d).redMul(j);
            ny = f.redMul(e.redSub(d));
            nz = f.redMul(j);
          }
        } else {
          var e = c.redAdd(d);
          var h3 = this.curve._mulC(this.z).redSqr();
          var j = e.redSub(h3).redSub(h3);
          nx = this.curve._mulC(b.redISub(e)).redMul(j);
          ny = this.curve._mulC(e).redMul(c.redISub(d));
          nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extDbl();
        else
          return this._projDbl();
      };
      Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f = d.redSub(c);
        var g = d.redAdd(c);
        var h3 = b.redAdd(a);
        var nx = e.redMul(f);
        var ny = g.redMul(h3);
        var nt = e.redMul(h3);
        var nz = f.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
          ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
          nz = f.redMul(g);
        } else {
          ny = a.redMul(g).redMul(d.redSub(c));
          nz = this.curve._mulC(f).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extAdd(p);
        else
          return this._projAdd(p);
      };
      Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
      };
      Point.prototype.normalize = function normalize() {
        if (this.zOne)
          return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t)
          this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
      };
      Point.prototype.neg = function neg() {
        return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
      };
      Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
      };
      Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t2 = this.curve.redN.redMul(this.z);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t2);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      Point.prototype.toP = Point.prototype.normalize;
      Point.prototype.mixedAdd = Point.prototype.add;
    }, { "../utils": 364, "./base": 351, "bn.js": 365, "inherits": 387 }], 353: [function(require2, module2, exports2) {
      var curve = exports2;
      curve.base = require2("./base");
      curve.short = require2("./short");
      curve.mont = require2("./mont");
      curve.edwards = require2("./edwards");
    }, { "./base": 351, "./edwards": 352, "./mont": 354, "./short": 355 }], 354: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var inherits = require2("inherits");
      var Base = require2("./base");
      var utils = require2("../utils");
      function MontCurve(conf) {
        Base.call(this, "mont", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.i4 = new BN(4).toRed(this.red).redInvm();
        this.two = new BN(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      inherits(MontCurve, Base);
      module2.exports = MontCurve;
      MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
      };
      function Point(curve, x, z) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && z === null) {
          this.x = this.curve.one;
          this.z = this.curve.zero;
        } else {
          this.x = new BN(x, 16);
          this.z = new BN(z, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
        }
      }
      inherits(Point, Base.BasePoint);
      MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
        return this.point(utils.toArray(bytes, enc), 1);
      };
      MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
      };
      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      Point.prototype.precompute = function precompute() {
      };
      Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
      };
      Point.prototype.add = function add() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
      };
      Point.prototype.mul = function mul(k) {
        var t2 = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t2.cmpn(0) !== 0; t2.iushrn(1)) {
          bits.push(t2.andln(1));
        }
        for (var i = bits.length - 1; i >= 0; i--) {
          if (bits[i] === 0) {
            a = a.diffAdd(b, c);
            b = b.dbl();
          } else {
            b = a.diffAdd(b, c);
            a = a.dbl();
          }
        }
        return b;
      };
      Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
      };
      Point.prototype.normalize = function normalize() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
    }, { "../utils": 364, "./base": 351, "bn.js": 365, "inherits": 387 }], 355: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var BN = require2("bn.js");
      var inherits = require2("inherits");
      var Base = require2("./base");
      var assert = utils.assert;
      function ShortCurve(conf) {
        Base.call(this, "short", conf);
        this.a = new BN(conf.a, 16).toRed(this.red);
        this.b = new BN(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
      }
      inherits(ShortCurve, Base);
      module2.exports = ShortCurve;
      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
          return;
        var beta;
        var lambda;
        if (conf.beta) {
          beta = new BN(conf.beta, 16).toRed(this.red);
        } else {
          var betas = this._getEndoRoots(this.p);
          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
          beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
          lambda = new BN(conf.lambda, 16);
        } else {
          var lambdas = this._getEndoRoots(this.n);
          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
            lambda = lambdas[0];
          } else {
            lambda = lambdas[1];
            assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
          }
        }
        var basis;
        if (conf.basis) {
          basis = conf.basis.map(function(vec) {
            return { a: new BN(vec.a, 16), b: new BN(vec.b, 16) };
          });
        } else {
          basis = this._getEndoBasis(lambda);
        }
        return { beta, lambda, basis };
      };
      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red = num === this.p ? this.red : BN.mont(num);
        var tinv = new BN(2).toRed(red).redInvm();
        var ntinv = tinv.redNeg();
        var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [l1, l2];
      };
      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v = this.n.clone();
        var x1 = new BN(1);
        var y1 = new BN(0);
        var x2 = new BN(0);
        var y2 = new BN(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
          var q = v.div(u);
          r = v.sub(q.mul(u));
          x = x2.sub(q.mul(x1));
          var y = y2.sub(q.mul(y1));
          if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
          } else if (a1 && ++i === 2) {
            break;
          }
          prevR = r;
          v = u;
          u = r;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
          a2 = a0;
          b2 = b0;
        }
        if (a1.negative) {
          a1 = a1.neg();
          b1 = b1.neg();
        }
        if (a2.negative) {
          a2 = a2.neg();
          b2 = b2.neg();
        }
        return [{ a: a1, b: b1 }, { a: a2, b: b2 }];
      };
      ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return { k1, k2 };
      };
      ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      ShortCurve.prototype.validate = function validate(point) {
        if (point.inf)
          return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
      };
      ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
          var split = this._endoSplit(coeffs[i]);
          var p = points[i];
          var beta = p._getBeta();
          if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
          }
          if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
          }
          npoints[i * 2] = p;
          npoints[i * 2 + 1] = beta;
          ncoeffs[i * 2] = split.k1;
          ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
          npoints[j] = null;
          ncoeffs[j] = null;
        }
        return res;
      };
      function Point(curve, x, y, isRed) {
        Base.BasePoint.call(this, curve, "affine");
        if (x === null && y === null) {
          this.x = null;
          this.y = null;
          this.inf = true;
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
          }
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          this.inf = false;
        }
      }
      inherits(Point, Base.BasePoint);
      ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
      };
      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
        return Point.fromJSON(this, obj, red);
      };
      Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
          return;
        var pre = this.precomputed;
        if (pre && pre.beta)
          return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
          var curve = this.curve;
          var endoMul = function endoMul2(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
          };
          pre.beta = beta;
          beta.precomputed = { beta: null, naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(endoMul) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(endoMul) } };
        }
        return beta;
      };
      Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed)
          return [this.x, this.y];
        return [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }];
      };
      Point.fromJSON = function fromJSON(curve, obj, red) {
        if (typeof obj === "string")
          obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red);
        if (!obj[2])
          return res;
        function obj2point(obj2) {
          return curve.point(obj2[0], obj2[1], red);
        }
        var pre = obj[2];
        res.precomputed = { beta: null, doubles: pre.doubles && { step: pre.doubles.step, points: [res].concat(pre.doubles.points.map(obj2point)) }, naf: pre.naf && { wnd: pre.naf.wnd, points: [res].concat(pre.naf.points.map(obj2point)) } };
        return res;
      };
      Point.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
      };
      Point.prototype.add = function add(p) {
        if (this.inf)
          return p;
        if (p.inf)
          return this;
        if (this.eq(p))
          return this.dbl();
        if (this.neg().eq(p))
          return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0)
          return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0)
          c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.dbl = function dbl() {
        if (this.inf)
          return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
          return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.getX = function getX() {
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        return this.y.fromRed();
      };
      Point.prototype.mul = function mul(k) {
        k = new BN(k, 16);
        if (this.isInfinity())
          return this;
        else if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else if (this.curve.endo)
          return this.curve._endoWnafMulAdd([this], [k]);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs, true);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
      };
      Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
      };
      Point.prototype.neg = function neg(_precompute) {
        if (this.inf)
          return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
          var pre = this.precomputed;
          var negate = function negate2(p) {
            return p.neg();
          };
          res.precomputed = { naf: pre.naf && { wnd: pre.naf.wnd, points: pre.naf.points.map(negate) }, doubles: pre.doubles && { step: pre.doubles.step, points: pre.doubles.points.map(negate) } };
        }
        return res;
      };
      Point.prototype.toJ = function toJ() {
        if (this.inf)
          return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
      };
      function JPoint(curve, x, y, z) {
        Base.BasePoint.call(this, curve, "jacobian");
        if (x === null && y === null && z === null) {
          this.x = this.curve.one;
          this.y = this.curve.one;
          this.z = new BN(0);
        } else {
          this.x = new BN(x, 16);
          this.y = new BN(y, 16);
          this.z = new BN(z, 16);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
      }
      inherits(JPoint, Base.BasePoint);
      ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
      };
      JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
      };
      JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      };
      JPoint.prototype.add = function add(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h3 = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h3.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h22 = h3.redSqr();
        var h32 = h22.redMul(h3);
        var v = u1.redMul(h22);
        var nx = r.redSqr().redIAdd(h32).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
        var nz = this.z.redMul(p.z).redMul(h3);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity())
          return p.toJ();
        if (p.isInfinity())
          return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h3 = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h3.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h22 = h3.redSqr();
        var h32 = h22.redMul(h3);
        var v = u1.redMul(h22);
        var nx = r.redSqr().redIAdd(h32).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h32));
        var nz = this.z.redMul(h3);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!pow)
          return this.dbl();
        if (this.curve.zeroA || this.curve.threeA) {
          var r = this;
          for (var i = 0; i < pow; i++) {
            r = r.dbl();
          }
          return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (var i = 0; i < pow; i++) {
          var jx2 = jx.redSqr();
          var jyd2 = jyd.redSqr();
          var jyd4 = jyd2.redSqr();
          var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
          var t1 = jx.redMul(jyd2);
          var nx = c.redSqr().redISub(t1.redAdd(t1));
          var t2 = t1.redISub(nx);
          var dny = c.redMul(t2);
          dny = dny.redIAdd(dny).redISub(jyd4);
          var nz = jyd.redMul(jz);
          if (i + 1 < pow)
            jz4 = jz4.redMul(jyd4);
          jx = nx;
          jz = nz;
          jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
      };
      JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.zeroA)
          return this._zeroDbl();
        else if (this.curve.threeA)
          return this._threeDbl();
        else
          return this._dbl();
      };
      JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx);
          var t2 = m.redSqr().redISub(s).redISub(s);
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          nx = t2;
          ny = m.redMul(s.redISub(t2)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var a = this.x.redSqr();
          var b = this.y.redSqr();
          var c = b.redSqr();
          var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
          d = d.redIAdd(d);
          var e = a.redAdd(a).redIAdd(a);
          var f = e.redSqr();
          var c8 = c.redIAdd(c);
          c8 = c8.redIAdd(c8);
          c8 = c8.redIAdd(c8);
          nx = f.redISub(d).redISub(d);
          ny = e.redMul(d.redISub(nx)).redISub(c8);
          nz = this.y.redMul(this.z);
          nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
          var t2 = m.redSqr().redISub(s).redISub(s);
          nx = t2;
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          ny = m.redMul(s.redISub(t2)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var delta = this.z.redSqr();
          var gamma = this.y.redSqr();
          var beta = this.x.redMul(gamma);
          var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
          alpha = alpha.redAdd(alpha).redIAdd(alpha);
          var beta4 = beta.redIAdd(beta);
          beta4 = beta4.redIAdd(beta4);
          var beta8 = beta4.redAdd(beta4);
          nx = alpha.redSqr().redISub(beta8);
          nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
          var ggamma8 = gamma.redSqr();
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t2 = yyyy.redIAdd(yyyy);
        t2 = t2.redIAdd(t2);
        t2 = t2.redIAdd(t2);
        t2 = t2.redIAdd(t2);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t2);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t2.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mul = function mul(k, kbase) {
        k = new BN(k, kbase);
        return this.curve._wnafMul(this, k);
      };
      JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine")
          return this.eq(p.toJ());
        if (this === p)
          return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
          return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
      };
      JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t2 = this.curve.redN.redMul(zs);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t2);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      JPoint.prototype.inspect = function inspect() {
        if (this.isInfinity())
          return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      };
      JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
    }, { "../utils": 364, "./base": 351, "bn.js": 365, "inherits": 387 }], 356: [function(require2, module2, exports2) {
      var curves = exports2;
      var hash = require2("hash.js");
      var curve = require2("./curve");
      var utils = require2("./utils");
      var assert = utils.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve.short(options);
        else if (options.type === "edwards")
          this.curve = new curve.edwards(options);
        else
          this.curve = new curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert(this.g.validate(), "Invalid curve");
        assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name, options) {
        Object.defineProperty(curves, name, { configurable: true, enumerable: true, get: function get() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, { configurable: true, enumerable: true, value: curve2 });
          return curve2;
        } });
      }
      defineCurve("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: hash.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
      defineCurve("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: hash.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
      defineCurve("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: hash.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
      defineCurve("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: hash.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
      defineCurve("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: hash.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
      defineCurve("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: hash.sha256, gRed: false, g: ["9"] });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        // -121665 * (121666^(-1)) (mod P)
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          // 4/5
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = require2("./precomputed/secp256k1");
      } catch (e) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash.sha256,
        // Precomputed endomorphism
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }],
        gRed: false,
        g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", pre]
      });
    }, { "./curve": 353, "./precomputed/secp256k1": 363, "./utils": 364, "hash.js": 372 }], 357: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var BN = require2("bn.js");
      var HmacDRBG = require2("hmac-drbg");
      var utils = require2("../utils");
      var curves = require2("../curves");
      var rand = require2("brorand");
      var assert = utils.assert;
      var KeyPair = require2("./key");
      var Signature = require2("./signature");
      function EC(options) {
        if (!(this instanceof EC))
          return new EC(options);
        if (typeof options === "string") {
          assert(curves.hasOwnProperty(options), "Unknown curve " + options);
          options = curves[options];
        }
        if (options instanceof curves.PresetCurve)
          options = { curve: options };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
      }
      module2.exports = EC;
      EC.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
      };
      EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
      };
      EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
      };
      EC.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
          options = {};
        var drbg = new HmacDRBG({ hash: this.hash, pers: options.pers, persEnc: options.persEnc || "utf8", entropy: options.entropy || rand(this.hash.hmacStrength), entropyEnc: options.entropy && options.entropyEnc || "utf8", nonce: this.n.toArray() });
        var bytes = this.n.byteLength();
        var ns2 = this.n.sub(new BN(2));
        do {
          var priv = new BN(drbg.generate(bytes));
          if (priv.cmp(ns2) > 0)
            continue;
          priv.iaddn(1);
          return this.keyFromPrivate(priv);
        } while (true);
      };
      EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0)
          msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
          return msg.sub(this.n);
        else
          return msg;
      };
      EC.prototype.sign = function sign(msg, key, enc, options) {
        if (_typeof2(enc) === "object") {
          options = enc;
          enc = null;
        }
        if (!options)
          options = {};
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(new BN(msg, 16));
        var bytes = this.n.byteLength();
        var bkey = key.getPrivate().toArray("be", bytes);
        var nonce = msg.toArray("be", bytes);
        var drbg = new HmacDRBG({ hash: this.hash, entropy: bkey, nonce, pers: options.pers, persEnc: options.persEnc || "utf8" });
        var ns1 = this.n.sub(new BN(1));
        for (var iter = 0; true; iter++) {
          var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
          k = this._truncateToN(k, true);
          if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
            continue;
          var kp = this.g.mul(k);
          if (kp.isInfinity())
            continue;
          var kpX = kp.getX();
          var r = kpX.umod(this.n);
          if (r.cmpn(0) === 0)
            continue;
          var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
          s = s.umod(this.n);
          if (s.cmpn(0) === 0)
            continue;
          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
          if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
          }
          return new Signature({ r, s, recoveryParam });
        }
      };
      EC.prototype.verify = function verify(msg, signature, key, enc) {
        msg = this._truncateToN(new BN(msg, 16));
        key = this.keyFromPublic(key, enc);
        signature = new Signature(signature, "hex");
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
          return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
          return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        if (!this.curve._maxwellTrick) {
          var p = this.g.mulAdd(u1, key.getPublic(), u2);
          if (p.isInfinity())
            return false;
          return p.getX().umod(this.n).cmp(r) === 0;
        }
        var p = this.g.jmulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.eqXToP(r);
      };
      EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert((3 & j) === j, "The recovery param is more than two bits");
        signature = new Signature(signature, enc);
        var n = this.n;
        var e = new BN(msg);
        var r = signature.r;
        var s = signature.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
          throw new Error("Unable to find sencond key candinate");
        if (isSecondKey)
          r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
        else
          r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature.r.invm(n);
        var s1 = n.sub(e).mul(rInv).umod(n);
        var s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
      };
      EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        signature = new Signature(signature, enc);
        if (signature.recoveryParam !== null)
          return signature.recoveryParam;
        for (var i = 0; i < 4; i++) {
          var Qprime;
          try {
            Qprime = this.recoverPubKey(e, signature, i);
          } catch (e2) {
            continue;
          }
          if (Qprime.eq(Q))
            return i;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    }, { "../curves": 356, "../utils": 364, "./key": 358, "./signature": 359, "bn.js": 365, "brorand": 184, "hmac-drbg": 384 }], 358: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var assert = utils.assert;
      function KeyPair(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv)
          this._importPrivate(options.priv, options.privEnc);
        if (options.pub)
          this._importPublic(options.pub, options.pubEnc);
      }
      module2.exports = KeyPair;
      KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(ec, { pub, pubEnc: enc });
      };
      KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair)
          return priv;
        return new KeyPair(ec, { priv, privEnc: enc });
      };
      KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity())
          return { result: false, reason: "Invalid public key" };
        if (!pub.validate())
          return { result: false, reason: "Public key is not a point" };
        if (!pub.mul(this.ec.curve.n).isInfinity())
          return { result: false, reason: "Public key * N != O" };
        return { result: true, reason: null };
      };
      KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
          enc = compact;
          compact = null;
        }
        if (!this.pub)
          this.pub = this.ec.g.mul(this.priv);
        if (!enc)
          return this.pub;
        return this.pub.encode(enc, compact);
      };
      KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex")
          return this.priv.toString(16, 2);
        else
          return this.priv;
      };
      KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
      };
      KeyPair.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
          if (this.ec.curve.type === "mont") {
            assert(key.x, "Need x coordinate");
          } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
            assert(key.x && key.y, "Need both x and y coordinate");
          }
          this.pub = this.ec.curve.point(key.x, key.y);
          return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
      };
      KeyPair.prototype.derive = function derive(pub) {
        return pub.mul(this.priv).getX();
      };
      KeyPair.prototype.sign = function sign(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
      };
      KeyPair.prototype.verify = function verify(msg, signature) {
        return this.ec.verify(msg, signature, this);
      };
      KeyPair.prototype.inspect = function inspect() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    }, { "../utils": 364, "bn.js": 365 }], 359: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var assert = utils.assert;
      function Signature(options, enc) {
        if (options instanceof Signature)
          return options;
        if (this._importDER(options, enc))
          return;
        assert(options.r && options.s, "Signature without r or s");
        this.r = new BN(options.r, 16);
        this.s = new BN(options.s, 16);
        if (options.recoveryParam === void 0)
          this.recoveryParam = null;
        else
          this.recoveryParam = options.recoveryParam;
      }
      module2.exports = Signature;
      function Position() {
        this.place = 0;
      }
      function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128)) {
          return initial;
        }
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4) {
          return false;
        }
        var val = 0;
        for (var i = 0, off = p.place; i < octetLen; i++, off++) {
          val <<= 8;
          val |= buf[off];
          val >>>= 0;
        }
        if (val <= 127) {
          return false;
        }
        p.place = off;
        return val;
      }
      function rmPadding(buf) {
        var i = 0;
        var len = buf.length - 1;
        while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
          i++;
        }
        if (i === 0) {
          return buf;
        }
        return buf.slice(i);
      }
      Signature.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        var p = new Position();
        if (data[p.place++] !== 48) {
          return false;
        }
        var len = getLength(data, p);
        if (len === false) {
          return false;
        }
        if (len + p.place !== data.length) {
          return false;
        }
        if (data[p.place++] !== 2) {
          return false;
        }
        var rlen = getLength(data, p);
        if (rlen === false) {
          return false;
        }
        var r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 2) {
          return false;
        }
        var slen = getLength(data, p);
        if (slen === false) {
          return false;
        }
        if (data.length !== slen + p.place) {
          return false;
        }
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0) {
          if (r[1] & 128) {
            r = r.slice(1);
          } else {
            return false;
          }
        }
        if (s[0] === 0) {
          if (s[1] & 128) {
            s = s.slice(1);
          } else {
            return false;
          }
        }
        this.r = new BN(r);
        this.s = new BN(s);
        this.recoveryParam = null;
        return true;
      };
      function constructLength(arr, len) {
        if (len < 128) {
          arr.push(len);
          return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
          arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
      }
      Signature.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
          s = s.slice(1);
        }
        var arr = [2];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [48];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils.encode(res, enc);
      };
    }, { "../utils": 364, "bn.js": 365 }], 360: [function(require2, module2, exports2) {
      var hash = require2("hash.js");
      var curves = require2("../curves");
      var utils = require2("../utils");
      var assert = utils.assert;
      var parseBytes = utils.parseBytes;
      var KeyPair = require2("./key");
      var Signature = require2("./signature");
      function EDDSA(curve) {
        assert(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA))
          return new EDDSA(curve);
        var curve = curves[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash.sha512;
      }
      module2.exports = EDDSA;
      EDDSA.prototype.sign = function sign(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r = this.hashInt(key.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({ R, S, Rencoded });
      };
      EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        var key = this.keyFromPublic(pub);
        var h3 = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h3));
        return RplusAh.eq(SG);
      };
      EDDSA.prototype.hashInt = function hashInt() {
        var hash2 = this.hash();
        for (var i = 0; i < arguments.length; i++) {
          hash2.update(arguments[i]);
        }
        return utils.intFromLE(hash2.digest()).umod(this.curve.n);
      };
      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
      };
      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
      };
      EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature)
          return sig;
        return new Signature(this, sig);
      };
      EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
      };
      EDDSA.prototype.decodePoint = function decodePoint(bytes) {
        bytes = utils.parseBytes(bytes);
        var lastIx = bytes.length - 1;
        var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
        var xIsOdd = (bytes[lastIx] & 128) !== 0;
        var y = utils.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
      };
      EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
      };
      EDDSA.prototype.decodeInt = function decodeInt(bytes) {
        return utils.intFromLE(bytes);
      };
      EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
      };
    }, { "../curves": 356, "../utils": 364, "./key": 361, "./signature": 362, "hash.js": 372 }], 361: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var assert = utils.assert;
      var parseBytes = utils.parseBytes;
      var cachedProperty = utils.cachedProperty;
      function KeyPair(eddsa, params) {
        this.eddsa = eddsa;
        this._secret = parseBytes(params.secret);
        if (eddsa.isPoint(params.pub))
          this._pub = params.pub;
        else
          this._pubBytes = parseBytes(params.pub);
      }
      KeyPair.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(eddsa, { pub });
      };
      KeyPair.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair)
          return secret;
        return new KeyPair(eddsa, { secret });
      };
      KeyPair.prototype.secret = function secret() {
        return this._secret;
      };
      cachedProperty(KeyPair, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
      });
      cachedProperty(KeyPair, "pub", function pub() {
        if (this._pubBytes)
          return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
      });
      cachedProperty(KeyPair, "privBytes", function privBytes() {
        var eddsa = this.eddsa;
        var hash = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a = hash.slice(0, eddsa.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
      });
      cachedProperty(KeyPair, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
      });
      cachedProperty(KeyPair, "hash", function hash() {
        return this.eddsa.hash().update(this.secret()).digest();
      });
      cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
      });
      KeyPair.prototype.sign = function sign(message) {
        assert(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
      };
      KeyPair.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
      };
      KeyPair.prototype.getSecret = function getSecret(enc) {
        assert(this._secret, "KeyPair is public only");
        return utils.encode(this.secret(), enc);
      };
      KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils.encode(this.pubBytes(), enc);
      };
      module2.exports = KeyPair;
    }, { "../utils": 364 }], 362: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var BN = require2("bn.js");
      var utils = require2("../utils");
      var assert = utils.assert;
      var cachedProperty = utils.cachedProperty;
      var parseBytes = utils.parseBytes;
      function Signature(eddsa, sig) {
        this.eddsa = eddsa;
        if (_typeof2(sig) !== "object")
          sig = parseBytes(sig);
        if (Array.isArray(sig)) {
          sig = { R: sig.slice(0, eddsa.encodingLength), S: sig.slice(eddsa.encodingLength) };
        }
        assert(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R))
          this._R = sig.R;
        if (sig.S instanceof BN)
          this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
      }
      cachedProperty(Signature, "S", function S() {
        return this.eddsa.decodeInt(this.Sencoded());
      });
      cachedProperty(Signature, "R", function R() {
        return this.eddsa.decodePoint(this.Rencoded());
      });
      cachedProperty(Signature, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
      });
      cachedProperty(Signature, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
      });
      Signature.prototype.toBytes = function toBytes() {
        return this.Rencoded().concat(this.Sencoded());
      };
      Signature.prototype.toHex = function toHex2() {
        return utils.encode(this.toBytes(), "hex").toUpperCase();
      };
      module2.exports = Signature;
    }, { "../utils": 364, "bn.js": 365 }], 363: [function(require2, module2, exports2) {
      module2.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
    }, {}], 364: [function(require2, module2, exports2) {
      var utils = exports2;
      var BN = require2("bn.js");
      var minAssert = require2("minimalistic-assert");
      var minUtils = require2("minimalistic-crypto-utils");
      utils.assert = minAssert;
      utils.toArray = minUtils.toArray;
      utils.zero2 = minUtils.zero2;
      utils.toHex = minUtils.toHex;
      utils.encode = minUtils.encode;
      function getNAF(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws = 1 << w + 1;
        var k = num.clone();
        for (var i = 0; i < naf.length; i++) {
          var z;
          var mod = k.andln(ws - 1);
          if (k.isOdd()) {
            if (mod > (ws >> 1) - 1)
              z = (ws >> 1) - mod;
            else
              z = mod;
            k.isubn(z);
          } else {
            z = 0;
          }
          naf[i] = z;
          k.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF;
      function getJSF(k1, k2) {
        var jsf = [[], []];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            var m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0) {
            u2 = 0;
          } else {
            var m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u2 = -m24;
            else
              u2 = m24;
          }
          jsf[1].push(u2);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1);
          k2.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF;
      function cachedProperty(obj, name, computer) {
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty2() {
          return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes) {
        return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes) {
        return new BN(bytes, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    }, { "bn.js": 365, "minimalistic-assert": 437, "minimalistic-crypto-utils": 438 }], 365: [function(require2, module2, exports2) {
      arguments[4][181][0].apply(exports2, arguments);
    }, { "buffer": 185, "dup": 181 }], 366: [function(require2, module2, exports2) {
      module2.exports = { "_from": "elliptic@^6.5.3", "_id": "elliptic@6.5.3", "_inBundle": false, "_integrity": "sha512-IMqzv5wNQf+E6aHeIqATs0tOLeOTwj1QKbRcS3jBbYkl5oLAserA8yJTT7/VyHUYG91PRmPyeQDObKLPpeS4dw==", "_location": "/elliptic", "_phantomChildren": {}, "_requested": { "type": "range", "registry": true, "raw": "elliptic@^6.5.3", "name": "elliptic", "escapedName": "elliptic", "rawSpec": "^6.5.3", "saveSpec": null, "fetchSpec": "^6.5.3" }, "_requiredBy": ["/browserify-sign", "/create-ecdh"], "_resolved": "https://registry.npmjs.org/elliptic/-/elliptic-6.5.3.tgz", "_shasum": "cb59eb2efdaf73a0bd78ccd7015a62ad6e0f93d6", "_spec": "elliptic@^6.5.3", "_where": "/mnt/d/dev/git/exceljs/node_modules/browserify-sign", "author": { "name": "Fedor Indutny", "email": "fedor@indutny.com" }, "bugs": { "url": "https://github.com/indutny/elliptic/issues" }, "bundleDependencies": false, "dependencies": { "bn.js": "^4.4.0", "brorand": "^1.0.1", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.0", "inherits": "^2.0.1", "minimalistic-assert": "^1.0.0", "minimalistic-crypto-utils": "^1.0.0" }, "deprecated": false, "description": "EC cryptography", "devDependencies": { "brfs": "^1.4.3", "coveralls": "^3.0.8", "grunt": "^1.0.4", "grunt-browserify": "^5.0.0", "grunt-cli": "^1.2.0", "grunt-contrib-connect": "^1.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^1.0.1", "grunt-mocha-istanbul": "^3.0.1", "grunt-saucelabs": "^9.0.1", "istanbul": "^0.4.2", "jscs": "^3.0.7", "jshint": "^2.10.3", "mocha": "^6.2.2" }, "files": ["lib"], "homepage": "https://github.com/indutny/elliptic", "keywords": ["EC", "Elliptic", "curve", "Cryptography"], "license": "MIT", "main": "lib/elliptic.js", "name": "elliptic", "repository": { "type": "git", "url": "git+ssh://git@github.com/indutny/elliptic.git" }, "scripts": { "jscs": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js", "jshint": "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js", "lint": "npm run jscs && npm run jshint", "test": "npm run lint && npm run unit", "unit": "istanbul test _mocha --reporter=spec test/index.js", "version": "grunt dist && git add dist/" }, "version": "6.5.3" };
    }, {}], 367: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var objectCreate = Object.create || objectCreatePolyfill;
      var objectKeys = Object.keys || objectKeysPolyfill;
      var bind2 = Function.prototype.bind || functionBindPolyfill;
      function EventEmitter() {
        if (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      }
      module2.exports = EventEmitter;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      var hasDefineProperty;
      try {
        var o = {};
        if (Object.defineProperty)
          Object.defineProperty(o, "x", { value: 0 });
        hasDefineProperty = o.x === 0;
      } catch (err) {
        hasDefineProperty = false;
      }
      if (hasDefineProperty) {
        Object.defineProperty(EventEmitter, "defaultMaxListeners", { enumerable: true, get: function get() {
          return defaultMaxListeners;
        }, set: function set(arg) {
          if (typeof arg !== "number" || arg < 0 || arg !== arg)
            throw new TypeError('"defaultMaxListeners" must be a positive number');
          defaultMaxListeners = arg;
        } });
      } else {
        EventEmitter.defaultMaxListeners = defaultMaxListeners;
      }
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || isNaN(n))
          throw new TypeError('"n" argument must be a positive number');
        this._maxListeners = n;
        return this;
      };
      function $getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return $getMaxListeners(this);
      };
      function emitNone(handler, isFn, self2) {
        if (isFn)
          handler.call(self2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            listeners[i].call(self2);
          }
        }
      }
      function emitOne(handler, isFn, self2, arg1) {
        if (isFn)
          handler.call(self2, arg1);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            listeners[i].call(self2, arg1);
          }
        }
      }
      function emitTwo(handler, isFn, self2, arg1, arg2) {
        if (isFn)
          handler.call(self2, arg1, arg2);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            listeners[i].call(self2, arg1, arg2);
          }
        }
      }
      function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
        if (isFn)
          handler.call(self2, arg1, arg2, arg3);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            listeners[i].call(self2, arg1, arg2, arg3);
          }
        }
      }
      function emitMany(handler, isFn, self2, args) {
        if (isFn)
          handler.apply(self2, args);
        else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i) {
            listeners[i].apply(self2, args);
          }
        }
      }
      EventEmitter.prototype.emit = function emit(type) {
        var er, handler, len, args, i, events;
        var doError = type === "error";
        events = this._events;
        if (events)
          doError = doError && events.error == null;
        else if (!doError)
          return false;
        if (doError) {
          if (arguments.length > 1)
            er = arguments[1];
          if (er instanceof Error) {
            throw er;
          } else {
            var err = new Error('Unhandled "error" event. (' + er + ")");
            err.context = er;
            throw err;
          }
        }
        handler = events[type];
        if (!handler)
          return false;
        var isFn = typeof handler === "function";
        len = arguments.length;
        switch (len) {
          case 1:
            emitNone(handler, isFn, this);
            break;
          case 2:
            emitOne(handler, isFn, this, arguments[1]);
            break;
          case 3:
            emitTwo(handler, isFn, this, arguments[1], arguments[2]);
            break;
          case 4:
            emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            args = new Array(len - 1);
            for (i = 1; i < len; i++) {
              args[i - 1] = arguments[i];
            }
            emitMany(handler, isFn, this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = target._events;
        if (!events) {
          events = target._events = objectCreate(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            events = target._events;
          }
          existing = events[type];
        }
        if (!existing) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else {
            if (prepend) {
              existing.unshift(listener);
            } else {
              existing.push(listener);
            }
          }
          if (!existing.warned) {
            m = $getMaxListeners(target);
            if (m && m > 0 && existing.length > m) {
              existing.warned = true;
              var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + ' "' + String(type) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
              w.name = "MaxListenersExceededWarning";
              w.emitter = target;
              w.type = type;
              w.count = existing.length;
              if ((typeof console === "undefined" ? "undefined" : _typeof2(console)) === "object" && console.warn) {
                console.warn("%s: %s", w.name, w.message);
              }
            }
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          switch (arguments.length) {
            case 0:
              return this.listener.call(this.target);
            case 1:
              return this.listener.call(this.target, arguments[0]);
            case 2:
              return this.listener.call(this.target, arguments[0], arguments[1]);
            case 3:
              return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
            default:
              var args = new Array(arguments.length);
              for (var i = 0; i < args.length; ++i) {
                args[i] = arguments[i];
              }
              this.listener.apply(this.target, args);
          }
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = bind2.call(onceWrapper, state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once(type, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        if (typeof listener !== "function")
          throw new TypeError('"listener" argument must be a function');
        events = this._events;
        if (!events)
          return this;
        list = events[type];
        if (!list)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else
            spliceOne(list, position);
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (!events)
          return this;
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = objectCreate(null);
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              this._events = objectCreate(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = objectKeys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = objectCreate(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (!events)
          return [];
        var evlistener = events[type];
        if (!evlistener)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
      function spliceOne(list, index2) {
        for (var i = index2, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
          list[i] = list[k];
        }
        list.pop();
      }
      function arrayClone(arr, n) {
        var copy2 = new Array(n);
        for (var i = 0; i < n; ++i) {
          copy2[i] = arr[i];
        }
        return copy2;
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function objectCreatePolyfill(proto) {
        var F = function F2() {
        };
        F.prototype = proto;
        return new F();
      }
      function objectKeysPolyfill(obj) {
        for (var k in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, k))
            ;
        }
        return k;
      }
      function functionBindPolyfill(context) {
        var fn = this;
        return function() {
          return fn.apply(context, arguments);
        };
      }
    }, {}], 368: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var MD5 = require2("md5.js");
      function EVP_BytesToKey(password, salt, keyBits, ivLen) {
        if (!Buffer.isBuffer(password))
          password = Buffer.from(password, "binary");
        if (salt) {
          if (!Buffer.isBuffer(salt))
            salt = Buffer.from(salt, "binary");
          if (salt.length !== 8)
            throw new RangeError("salt should be Buffer with 8 byte length");
        }
        var keyLen = keyBits / 8;
        var key = Buffer.alloc(keyLen);
        var iv = Buffer.alloc(ivLen || 0);
        var tmp = Buffer.alloc(0);
        while (keyLen > 0 || ivLen > 0) {
          var hash = new MD5();
          hash.update(tmp);
          hash.update(password);
          if (salt)
            hash.update(salt);
          tmp = hash.digest();
          var used = 0;
          if (keyLen > 0) {
            var keyStart = key.length - keyLen;
            used = Math.min(keyLen, tmp.length);
            tmp.copy(key, keyStart, 0, used);
            keyLen -= used;
          }
          if (used < tmp.length && ivLen > 0) {
            var ivStart = iv.length - ivLen;
            var length = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length);
            ivLen -= length;
          }
        }
        tmp.fill(0);
        return { key, iv };
      }
      module2.exports = EVP_BytesToKey;
    }, { "md5.js": 434, "safe-buffer": 494 }], 369: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      var format_1 = require2("@fast-csv/format");
      Object.defineProperty(exports2, "format", { enumerable: true, get: function get() {
        return format_1.format;
      } });
      Object.defineProperty(exports2, "write", { enumerable: true, get: function get() {
        return format_1.write;
      } });
      Object.defineProperty(exports2, "writeToStream", { enumerable: true, get: function get() {
        return format_1.writeToStream;
      } });
      Object.defineProperty(exports2, "writeToBuffer", { enumerable: true, get: function get() {
        return format_1.writeToBuffer;
      } });
      Object.defineProperty(exports2, "writeToString", { enumerable: true, get: function get() {
        return format_1.writeToString;
      } });
      Object.defineProperty(exports2, "writeToPath", { enumerable: true, get: function get() {
        return format_1.writeToPath;
      } });
      Object.defineProperty(exports2, "CsvFormatterStream", { enumerable: true, get: function get() {
        return format_1.CsvFormatterStream;
      } });
      Object.defineProperty(exports2, "FormatterOptions", { enumerable: true, get: function get() {
        return format_1.FormatterOptions;
      } });
      var parse_1 = require2("@fast-csv/parse");
      Object.defineProperty(exports2, "parse", { enumerable: true, get: function get() {
        return parse_1.parse;
      } });
      Object.defineProperty(exports2, "parseString", { enumerable: true, get: function get() {
        return parse_1.parseString;
      } });
      Object.defineProperty(exports2, "parseStream", { enumerable: true, get: function get() {
        return parse_1.parseStream;
      } });
      Object.defineProperty(exports2, "parseFile", { enumerable: true, get: function get() {
        return parse_1.parseFile;
      } });
      Object.defineProperty(exports2, "ParserOptions", { enumerable: true, get: function get() {
        return parse_1.ParserOptions;
      } });
      Object.defineProperty(exports2, "CsvParserStream", { enumerable: true, get: function get() {
        return parse_1.CsvParserStream;
      } });
    }, { "@fast-csv/format": 148, "@fast-csv/parse": 152 }], 370: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var Transform = require2("readable-stream").Transform;
      var inherits = require2("inherits");
      function throwIfNotStringOrBuffer(val, prefix) {
        if (!Buffer.isBuffer(val) && typeof val !== "string") {
          throw new TypeError(prefix + " must be a string or a buffer");
        }
      }
      function HashBase(blockSize) {
        Transform.call(this);
        this._block = Buffer.allocUnsafe(blockSize);
        this._blockSize = blockSize;
        this._blockOffset = 0;
        this._length = [0, 0, 0, 0];
        this._finalized = false;
      }
      inherits(HashBase, Transform);
      HashBase.prototype._transform = function(chunk, encoding, callback) {
        var error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      HashBase.prototype._flush = function(callback) {
        var error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      HashBase.prototype.update = function(data, encoding) {
        throwIfNotStringOrBuffer(data, "Data");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer.isBuffer(data))
          data = Buffer.from(data, encoding);
        var block = this._block;
        var offset = 0;
        while (this._blockOffset + data.length - offset >= this._blockSize) {
          for (var i = this._blockOffset; i < this._blockSize; ) {
            block[i++] = data[offset++];
          }
          this._update();
          this._blockOffset = 0;
        }
        while (offset < data.length) {
          block[this._blockOffset++] = data[offset++];
        }
        for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
          this._length[j] += carry;
          carry = this._length[j] / 4294967296 | 0;
          if (carry > 0)
            this._length[j] -= 4294967296 * carry;
        }
        return this;
      };
      HashBase.prototype._update = function() {
        throw new Error("_update is not implemented");
      };
      HashBase.prototype.digest = function(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        var digest = this._digest();
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._block.fill(0);
        this._blockOffset = 0;
        for (var i = 0; i < 4; ++i) {
          this._length[i] = 0;
        }
        return digest;
      };
      HashBase.prototype._digest = function() {
        throw new Error("_digest is not implemented");
      };
      module2.exports = HashBase;
    }, { "inherits": 387, "readable-stream": 491, "safe-buffer": 371 }], 371: [function(require2, module2, exports2) {
      arguments[4][214][0].apply(exports2, arguments);
    }, { "buffer": 216, "dup": 214 }], 372: [function(require2, module2, exports2) {
      var hash = exports2;
      hash.utils = require2("./hash/utils");
      hash.common = require2("./hash/common");
      hash.sha = require2("./hash/sha");
      hash.ripemd = require2("./hash/ripemd");
      hash.hmac = require2("./hash/hmac");
      hash.sha1 = hash.sha.sha1;
      hash.sha256 = hash.sha.sha256;
      hash.sha224 = hash.sha.sha224;
      hash.sha384 = hash.sha.sha384;
      hash.sha512 = hash.sha.sha512;
      hash.ripemd160 = hash.ripemd.ripemd160;
    }, { "./hash/common": 373, "./hash/hmac": 374, "./hash/ripemd": 375, "./hash/sha": 376, "./hash/utils": 383 }], 373: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var assert = require2("minimalistic-assert");
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      exports2.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        msg = utils.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils.join32(msg, 0, msg.length - r, this.endian);
          for (var i = 0; i < msg.length; i += this._delta32) {
            this._update(msg, i, i + this._delta32);
          }
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad() {
        var len = this.pendingTotal;
        var bytes = this._delta8;
        var k = bytes - (len + this.padLength) % bytes;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++) {
          res[i] = 0;
        }
        len <<= 3;
        if (this.endian === "big") {
          for (var t2 = 8; t2 < this.padLength; t2++) {
            res[i++] = 0;
          }
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = len >>> 24 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len & 255;
        } else {
          res[i++] = len & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 24 & 255;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          for (t2 = 8; t2 < this.padLength; t2++) {
            res[i++] = 0;
          }
        }
        return res;
      };
    }, { "./utils": 383, "minimalistic-assert": 437 }], 374: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var assert = require2("minimalistic-assert");
      function Hmac(hash, key, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash, key, enc);
        this.Hash = hash;
        this.blockSize = hash.blockSize / 8;
        this.outSize = hash.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils.toArray(key, enc));
      }
      module2.exports = Hmac;
      Hmac.prototype._init = function init(key) {
        if (key.length > this.blockSize)
          key = new this.Hash().update(key).digest();
        assert(key.length <= this.blockSize);
        for (var i = key.length; i < this.blockSize; i++) {
          key.push(0);
        }
        for (i = 0; i < key.length; i++) {
          key[i] ^= 54;
        }
        this.inner = new this.Hash().update(key);
        for (i = 0; i < key.length; i++) {
          key[i] ^= 106;
        }
        this.outer = new this.Hash().update(key);
      };
      Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
    }, { "./utils": 383, "minimalistic-assert": 437 }], 375: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var common = require2("./common");
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_3 = utils.sum32_3;
      var sum32_4 = utils.sum32_4;
      var BlockHash = common.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils.inherits(RIPEMD160, BlockHash);
      exports2.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
          var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
          A = E;
          E = D;
          D = rotl32(C, 10);
          C = B;
          B = T;
          T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
      };
      RIPEMD160.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "little");
        else
          return utils.split32(this.h, "little");
      };
      function f(j, x, y, z) {
        if (j <= 15)
          return x ^ y ^ z;
        else if (j <= 31)
          return x & y | ~x & z;
        else if (j <= 47)
          return (x | ~y) ^ z;
        else if (j <= 63)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      function K(j) {
        if (j <= 15)
          return 0;
        else if (j <= 31)
          return 1518500249;
        else if (j <= 47)
          return 1859775393;
        else if (j <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j) {
        if (j <= 15)
          return 1352829926;
        else if (j <= 31)
          return 1548603684;
        else if (j <= 47)
          return 1836072691;
        else if (j <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
      var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
      var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
      var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    }, { "./common": 373, "./utils": 383 }], 376: [function(require2, module2, exports2) {
      exports2.sha1 = require2("./sha/1");
      exports2.sha224 = require2("./sha/224");
      exports2.sha256 = require2("./sha/256");
      exports2.sha384 = require2("./sha/384");
      exports2.sha512 = require2("./sha/512");
    }, { "./sha/1": 377, "./sha/224": 378, "./sha/256": 379, "./sha/384": 380, "./sha/512": 381 }], 377: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var common = require2("../common");
      var shaCommon = require2("./common");
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_5 = utils.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common.BlockHash;
      var sha1_K = [1518500249, 1859775393, 2400959708, 3395469782];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.W = new Array(80);
      }
      utils.inherits(SHA1, BlockHash);
      module2.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++) {
          W[i] = msg[start + i];
        }
        for (; i < W.length; i++) {
          W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        }
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
          var s = ~~(i / 20);
          var t2 = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
          e = d;
          d = c;
          c = rotl32(b, 30);
          b = a;
          a = t2;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }, { "../common": 373, "../utils": 383, "./common": 382 }], 378: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var SHA256 = require2("./256");
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224();
        SHA256.call(this);
        this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
      }
      utils.inherits(SHA224, SHA256);
      module2.exports = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 7), "big");
        else
          return utils.split32(this.h.slice(0, 7), "big");
      };
    }, { "../utils": 383, "./256": 379 }], 379: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var common = require2("../common");
      var shaCommon = require2("./common");
      var assert = require2("minimalistic-assert");
      var sum32 = utils.sum32;
      var sum32_4 = utils.sum32_4;
      var sum32_5 = utils.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common.BlockHash;
      var sha256_K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
      function SHA256() {
        if (!(this instanceof SHA256))
          return new SHA256();
        BlockHash.call(this);
        this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils.inherits(SHA256, BlockHash);
      module2.exports = SHA256;
      SHA256.blockSize = 512;
      SHA256.outSize = 256;
      SHA256.hmacStrength = 192;
      SHA256.padLength = 64;
      SHA256.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++) {
          W[i] = msg[start + i];
        }
        for (; i < W.length; i++) {
          W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        }
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f = this.h[5];
        var g = this.h[6];
        var h3 = this.h[7];
        assert(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
          var T1 = sum32_5(h3, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
          var T2 = sum32(s0_256(a), maj32(a, b, c));
          h3 = g;
          g = f;
          f = e;
          e = sum32(d, T1);
          d = c;
          c = b;
          b = a;
          a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h3);
      };
      SHA256.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }, { "../common": 373, "../utils": 383, "./common": 382, "minimalistic-assert": 437 }], 380: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var SHA512 = require2("./512");
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA512.call(this);
        this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
      }
      utils.inherits(SHA384, SHA512);
      module2.exports = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 12), "big");
        else
          return utils.split32(this.h.slice(0, 12), "big");
      };
    }, { "../utils": 383, "./512": 381 }], 381: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var common = require2("../common");
      var assert = require2("minimalistic-assert");
      var rotr64_hi = utils.rotr64_hi;
      var rotr64_lo = utils.rotr64_lo;
      var shr64_hi = utils.shr64_hi;
      var shr64_lo = utils.shr64_lo;
      var sum64 = utils.sum64;
      var sum64_hi = utils.sum64_hi;
      var sum64_lo = utils.sum64_lo;
      var sum64_4_hi = utils.sum64_4_hi;
      var sum64_4_lo = utils.sum64_4_lo;
      var sum64_5_hi = utils.sum64_5_hi;
      var sum64_5_lo = utils.sum64_5_lo;
      var BlockHash = common.BlockHash;
      var sha512_K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512();
        BlockHash.call(this);
        this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils.inherits(SHA512, BlockHash);
      module2.exports = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++) {
          W[i] = msg[start + i];
        }
        for (; i < W.length; i += 2) {
          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
          var c1_hi = W[i - 14];
          var c1_lo = W[i - 13];
          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
          var c3_hi = W[i - 32];
          var c3_lo = W[i - 31];
          W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
          W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        }
      };
      SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i];
          var c3_lo = this.k[i + 1];
          var c4_hi = W[i];
          var c4_lo = W[i + 1];
          var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
    }, { "../common": 373, "../utils": 383, "minimalistic-assert": 437 }], 382: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var rotr32 = utils.rotr32;
      function ft_1(s, x, y, z) {
        if (s === 0)
          return ch32(x, y, z);
        if (s === 1 || s === 3)
          return p32(x, y, z);
        if (s === 2)
          return maj32(x, y, z);
      }
      exports2.ft_1 = ft_1;
      function ch32(x, y, z) {
        return x & y ^ ~x & z;
      }
      exports2.ch32 = ch32;
      function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
      }
      exports2.maj32 = maj32;
      function p32(x, y, z) {
        return x ^ y ^ z;
      }
      exports2.p32 = p32;
      function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
      }
      exports2.s0_256 = s0_256;
      function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
      }
      exports2.s1_256 = s1_256;
      function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
      }
      exports2.g0_256 = g0_256;
      function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
      }
      exports2.g1_256 = g1_256;
    }, { "../utils": 383 }], 383: [function(require2, module2, exports2) {
      var assert = require2("minimalistic-assert");
      var inherits = require2("inherits");
      exports2.inherits = inherits;
      function isSurrogatePair(msg, i) {
        if ((msg.charCodeAt(i) & 64512) !== 55296) {
          return false;
        }
        if (i < 0 || i + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i + 1) & 64512) === 56320;
      }
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p = 0;
            for (var i = 0; i < msg.length; i++) {
              var c = msg.charCodeAt(i);
              if (c < 128) {
                res[p++] = c;
              } else if (c < 2048) {
                res[p++] = c >> 6 | 192;
                res[p++] = c & 63 | 128;
              } else if (isSurrogatePair(msg, i)) {
                c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
                res[p++] = c >> 18 | 240;
                res[p++] = c >> 12 & 63 | 128;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              } else {
                res[p++] = c >> 12 | 224;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i = 0; i < msg.length; i += 2) {
              res.push(parseInt(msg[i] + msg[i + 1], 16));
            }
          }
        } else {
          for (i = 0; i < msg.length; i++) {
            res[i] = msg[i] | 0;
          }
        }
        return res;
      }
      exports2.toArray = toArray;
      function toHex2(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          res += zero2(msg[i].toString(16));
        }
        return res;
      }
      exports2.toHex = toHex2;
      function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
      }
      exports2.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          var w = msg[i];
          if (endian === "little")
            w = htonl(w);
          res += zero8(w.toString(16));
        }
        return res;
      }
      exports2.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports2.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports2.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
          var w;
          if (endian === "big")
            w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
          else
            w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
          res[i] = w >>> 0;
        }
        return res;
      }
      exports2.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
          var m = msg[i];
          if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 255;
            res[k + 2] = m >>> 8 & 255;
            res[k + 3] = m & 255;
          } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 255;
            res[k + 1] = m >>> 8 & 255;
            res[k] = m & 255;
          }
        }
        return res;
      }
      exports2.split32 = split32;
      function rotr32(w, b) {
        return w >>> b | w << 32 - b;
      }
      exports2.rotr32 = rotr32;
      function rotl32(w, b) {
        return w << b | w >>> 32 - b;
      }
      exports2.rotl32 = rotl32;
      function sum32(a, b) {
        return a + b >>> 0;
      }
      exports2.sum32 = sum32;
      function sum32_3(a, b, c) {
        return a + b + c >>> 0;
      }
      exports2.sum32_3 = sum32_3;
      function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
      }
      exports2.sum32_4 = sum32_4;
      function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
      }
      exports2.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
      }
      exports2.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      exports2.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      exports2.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
      }
      exports2.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      exports2.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
      }
      exports2.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      exports2.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
      }
      exports2.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports2.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports2.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports2.shr64_lo = shr64_lo;
    }, { "inherits": 387, "minimalistic-assert": 437 }], 384: [function(require2, module2, exports2) {
      var hash = require2("hash.js");
      var utils = require2("minimalistic-crypto-utils");
      var assert = require2("minimalistic-assert");
      function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
          return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils.toArray(options.pers, options.persEnc || "hex");
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._init(entropy, nonce, pers);
      }
      module2.exports = HmacDRBG;
      HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
          this.K[i] = 0;
          this.V[i] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
      };
      HmacDRBG.prototype._hmac = function hmac() {
        return new hash.hmac(this.hash, this.K);
      };
      HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([0]);
        if (seed)
          kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed)
          return;
        this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
      };
      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
        if (typeof entropyEnc !== "string") {
          addEnc = add;
          add = entropyEnc;
          entropyEnc = null;
        }
        entropy = utils.toArray(entropy, entropyEnc);
        add = utils.toArray(add, addEnc);
        assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
        this._update(entropy.concat(add || []));
        this._reseed = 1;
      };
      HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        if (typeof enc !== "string") {
          addEnc = add;
          add = enc;
          enc = null;
        }
        if (add) {
          add = utils.toArray(add, addEnc || "hex");
          this._update(add);
        }
        var temp = [];
        while (temp.length < len) {
          this.V = this._hmac().update(this.V).digest();
          temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add);
        this._reseed++;
        return utils.encode(res, enc);
      };
    }, { "hash.js": 372, "minimalistic-assert": 437, "minimalistic-crypto-utils": 438 }], 385: [function(require2, module2, exports2) {
      exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }, {}], 386: [function(require2, module2, exports2) {
      (function(global2) {
        var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
        var scheduleDrain;
        {
          if (Mutation) {
            var called = 0;
            var observer = new Mutation(nextTick2);
            var element = global2.document.createTextNode("");
            observer.observe(element, { characterData: true });
            scheduleDrain = function scheduleDrain2() {
              element.data = called = ++called % 2;
            };
          } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
            var channel = new global2.MessageChannel();
            channel.port1.onmessage = nextTick2;
            scheduleDrain = function scheduleDrain2() {
              channel.port2.postMessage(0);
            };
          } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
            scheduleDrain = function scheduleDrain2() {
              var scriptEl = global2.document.createElement("script");
              scriptEl.onreadystatechange = function() {
                nextTick2();
                scriptEl.onreadystatechange = null;
                scriptEl.parentNode.removeChild(scriptEl);
                scriptEl = null;
              };
              global2.document.documentElement.appendChild(scriptEl);
            };
          } else {
            scheduleDrain = function scheduleDrain2() {
              setTimeout(nextTick2, 0);
            };
          }
        }
        var draining;
        var queue = [];
        function nextTick2() {
          draining = true;
          var i, oldQueue;
          var len = queue.length;
          while (len) {
            oldQueue = queue;
            queue = [];
            i = -1;
            while (++i < len) {
              oldQueue[i]();
            }
            len = queue.length;
          }
          draining = false;
        }
        module2.exports = immediate;
        function immediate(task) {
          if (queue.push(task) === 1 && !draining) {
            scheduleDrain();
          }
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 387: [function(require2, module2, exports2) {
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
          }
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function TempCtor2() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }, {}], 388: [function(require2, module2, exports2) {
      module2.exports = function(obj) {
        return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
      };
      function isBuffer(obj) {
        return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      }
      function isSlowBuffer(obj) {
        return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
      }
    }, {}], 389: [function(require2, module2, exports2) {
      var toString2 = {}.toString;
      module2.exports = Array.isArray || function(arr) {
        return toString2.call(arr) == "[object Array]";
      };
    }, {}], 390: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var support = require2("./support");
      var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      exports2.encode = function(input) {
        var output = [];
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0, len = input.length, remainingBytes = len;
        var isArray = utils.getTypeOf(input) !== "string";
        while (i < input.length) {
          remainingBytes = len - i;
          if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
          } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
          }
          enc1 = chr1 >> 2;
          enc2 = (chr1 & 3) << 4 | chr2 >> 4;
          enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
          enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
          output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
        }
        return output.join("");
      };
      exports2.decode = function(input) {
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0, resultIndex = 0;
        var dataUrlPrefix = "data:";
        if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
          throw new Error("Invalid base64 input, it looks like a data url.");
        }
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        var totalLength = input.length * 3 / 4;
        if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
          totalLength--;
        }
        if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
          totalLength--;
        }
        if (totalLength % 1 !== 0) {
          throw new Error("Invalid base64 input, bad content length.");
        }
        var output;
        if (support.uint8array) {
          output = new Uint8Array(totalLength | 0);
        } else {
          output = new Array(totalLength | 0);
        }
        while (i < input.length) {
          enc1 = _keyStr.indexOf(input.charAt(i++));
          enc2 = _keyStr.indexOf(input.charAt(i++));
          enc3 = _keyStr.indexOf(input.charAt(i++));
          enc4 = _keyStr.indexOf(input.charAt(i++));
          chr1 = enc1 << 2 | enc2 >> 4;
          chr2 = (enc2 & 15) << 4 | enc3 >> 2;
          chr3 = (enc3 & 3) << 6 | enc4;
          output[resultIndex++] = chr1;
          if (enc3 !== 64) {
            output[resultIndex++] = chr2;
          }
          if (enc4 !== 64) {
            output[resultIndex++] = chr3;
          }
        }
        return output;
      };
    }, { "./support": 419, "./utils": 421 }], 391: [function(require2, module2, exports2) {
      var external = require2("./external");
      var DataWorker = require2("./stream/DataWorker");
      var DataLengthProbe = require2("./stream/DataLengthProbe");
      var Crc32Probe = require2("./stream/Crc32Probe");
      var DataLengthProbe = require2("./stream/DataLengthProbe");
      function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
        this.compressedSize = compressedSize;
        this.uncompressedSize = uncompressedSize;
        this.crc32 = crc32;
        this.compression = compression;
        this.compressedContent = data;
      }
      CompressedObject.prototype = {
        /**
        * Create a worker to get the uncompressed content.
        * @return {GenericWorker} the worker.
        */
        getContentWorker: function getContentWorker() {
          var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
          var that = this;
          worker.on("end", function() {
            if (this.streamInfo["data_length"] !== that.uncompressedSize) {
              throw new Error("Bug : uncompressed data size mismatch");
            }
          });
          return worker;
        },
        /**
        * Create a worker to get the compressed content.
        * @return {GenericWorker} the worker.
        */
        getCompressedWorker: function getCompressedWorker() {
          return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        }
      };
      CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
        return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
      };
      module2.exports = CompressedObject;
    }, { "./external": 395, "./stream/Crc32Probe": 414, "./stream/DataLengthProbe": 415, "./stream/DataWorker": 416 }], 392: [function(require2, module2, exports2) {
      var GenericWorker = require2("./stream/GenericWorker");
      exports2.STORE = { magic: "\0\0", compressWorker: function compressWorker(compressionOptions) {
        return new GenericWorker("STORE compression");
      }, uncompressWorker: function uncompressWorker() {
        return new GenericWorker("STORE decompression");
      } };
      exports2.DEFLATE = require2("./flate");
    }, { "./flate": 396, "./stream/GenericWorker": 417 }], 393: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      function makeTable() {
        var c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          table[n] = c;
        }
        return table;
      }
      var crcTable = makeTable();
      function crc32(crc, buf, len, pos) {
        var t2 = crcTable, end = pos + len;
        crc = crc ^ -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      }
      function crc32str(crc, str, len, pos) {
        var t2 = crcTable, end = pos + len;
        crc = crc ^ -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t2[(crc ^ str.charCodeAt(i)) & 255];
        }
        return crc ^ -1;
      }
      module2.exports = function crc32wrapper(input, crc) {
        if (typeof input === "undefined" || !input.length) {
          return 0;
        }
        var isArray = utils.getTypeOf(input) !== "string";
        if (isArray) {
          return crc32(crc | 0, input, input.length, 0);
        } else {
          return crc32str(crc | 0, input, input.length, 0);
        }
      };
    }, { "./utils": 421 }], 394: [function(require2, module2, exports2) {
      exports2.base64 = false;
      exports2.binary = false;
      exports2.dir = false;
      exports2.createFolders = true;
      exports2.date = null;
      exports2.compression = null;
      exports2.compressionOptions = null;
      exports2.comment = null;
      exports2.unixPermissions = null;
      exports2.dosPermissions = null;
    }, {}], 395: [function(require2, module2, exports2) {
      var ES6Promise = null;
      if (typeof Promise !== "undefined") {
        ES6Promise = Promise;
      } else {
        ES6Promise = require2("lie");
      }
      module2.exports = { Promise: ES6Promise };
    }, { "lie": 425 }], 396: [function(require2, module2, exports2) {
      var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
      var pako = require2("pako");
      var utils = require2("./utils");
      var GenericWorker = require2("./stream/GenericWorker");
      var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
      exports2.magic = "\b\0";
      function FlateWorker(action, options) {
        GenericWorker.call(this, "FlateWorker/" + action);
        this._pako = null;
        this._pakoAction = action;
        this._pakoOptions = options;
        this.meta = {};
      }
      utils.inherits(FlateWorker, GenericWorker);
      FlateWorker.prototype.processChunk = function(chunk) {
        this.meta = chunk.meta;
        if (this._pako === null) {
          this._createPako();
        }
        this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
      };
      FlateWorker.prototype.flush = function() {
        GenericWorker.prototype.flush.call(this);
        if (this._pako === null) {
          this._createPako();
        }
        this._pako.push([], true);
      };
      FlateWorker.prototype.cleanUp = function() {
        GenericWorker.prototype.cleanUp.call(this);
        this._pako = null;
      };
      FlateWorker.prototype._createPako = function() {
        this._pako = new pako[this._pakoAction]({
          raw: true,
          level: this._pakoOptions.level || -1
          // default compression
        });
        var self2 = this;
        this._pako.onData = function(data) {
          self2.push({ data, meta: self2.meta });
        };
      };
      exports2.compressWorker = function(compressionOptions) {
        return new FlateWorker("Deflate", compressionOptions);
      };
      exports2.uncompressWorker = function() {
        return new FlateWorker("Inflate", {});
      };
    }, { "./stream/GenericWorker": 417, "./utils": 421, "pako": 439 }], 397: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var GenericWorker = require2("../stream/GenericWorker");
      var utf8 = require2("../utf8");
      var crc32 = require2("../crc32");
      var signature = require2("../signature");
      var decToHex = function decToHex2(dec, bytes) {
        var hex = "", i;
        for (i = 0; i < bytes; i++) {
          hex += String.fromCharCode(dec & 255);
          dec = dec >>> 8;
        }
        return hex;
      };
      var generateUnixExternalFileAttr = function generateUnixExternalFileAttr2(unixPermissions, isDir) {
        var result = unixPermissions;
        if (!unixPermissions) {
          result = isDir ? 16893 : 33204;
        }
        return (result & 65535) << 16;
      };
      var generateDosExternalFileAttr = function generateDosExternalFileAttr2(dosPermissions, isDir) {
        return (dosPermissions || 0) & 63;
      };
      var generateZipParts = function generateZipParts2(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
        var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
        var dataInfo = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        if (!streamedContent || streamingEnded) {
          dataInfo.crc32 = streamInfo["crc32"];
          dataInfo.compressedSize = streamInfo["compressedSize"];
          dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
        }
        var bitflag = 0;
        if (streamedContent) {
          bitflag |= 8;
        }
        if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
          bitflag |= 2048;
        }
        var extFileAttr = 0;
        var versionMadeBy = 0;
        if (dir) {
          extFileAttr |= 16;
        }
        if (platform === "UNIX") {
          versionMadeBy = 798;
          extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
        } else {
          versionMadeBy = 20;
          extFileAttr |= generateDosExternalFileAttr(file.dosPermissions);
        }
        dosTime = date.getUTCHours();
        dosTime = dosTime << 6;
        dosTime = dosTime | date.getUTCMinutes();
        dosTime = dosTime << 5;
        dosTime = dosTime | date.getUTCSeconds() / 2;
        dosDate = date.getUTCFullYear() - 1980;
        dosDate = dosDate << 4;
        dosDate = dosDate | date.getUTCMonth() + 1;
        dosDate = dosDate << 5;
        dosDate = dosDate | date.getUTCDate();
        if (useUTF8ForFileName) {
          unicodePathExtraField = // Version
          decToHex(1, 1) + // NameCRC32
          decToHex(crc32(encodedFileName), 4) + // UnicodeName
          utfEncodedFileName;
          extraFields += // Info-ZIP Unicode Path Extra Field
          "up" + // size
          decToHex(unicodePathExtraField.length, 2) + // content
          unicodePathExtraField;
        }
        if (useUTF8ForComment) {
          unicodeCommentExtraField = // Version
          decToHex(1, 1) + // CommentCRC32
          decToHex(crc32(encodedComment), 4) + // UnicodeName
          utfEncodedComment;
          extraFields += // Info-ZIP Unicode Path Extra Field
          "uc" + // size
          decToHex(unicodeCommentExtraField.length, 2) + // content
          unicodeCommentExtraField;
        }
        var header = "";
        header += "\n\0";
        header += decToHex(bitflag, 2);
        header += compression.magic;
        header += decToHex(dosTime, 2);
        header += decToHex(dosDate, 2);
        header += decToHex(dataInfo.crc32, 4);
        header += decToHex(dataInfo.compressedSize, 4);
        header += decToHex(dataInfo.uncompressedSize, 4);
        header += decToHex(encodedFileName.length, 2);
        header += decToHex(extraFields.length, 2);
        var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
        var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
        decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
        header + // file comment length
        decToHex(encodedComment.length, 2) + // disk number start
        "\0\0\0\0" + // external file attributes
        decToHex(extFileAttr, 4) + // relative offset of local header
        decToHex(offset, 4) + // file name
        encodedFileName + // extra field
        extraFields + // file comment
        encodedComment;
        return { fileRecord, dirRecord };
      };
      var generateCentralDirectoryEnd = function generateCentralDirectoryEnd2(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
        var dirEnd = "";
        var encodedComment = utils.transformTo("string", encodeFileName(comment));
        dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
        "\0\0\0\0" + // total number of entries in the central directory on this disk
        decToHex(entriesCount, 2) + // total number of entries in the central directory
        decToHex(entriesCount, 2) + // size of the central directory   4 bytes
        decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
        decToHex(localDirLength, 4) + // .ZIP file comment length
        decToHex(encodedComment.length, 2) + // .ZIP file comment
        encodedComment;
        return dirEnd;
      };
      var generateDataDescriptors = function generateDataDescriptors2(streamInfo) {
        var descriptor = "";
        descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
        decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
        decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
        decToHex(streamInfo["uncompressedSize"], 4);
        return descriptor;
      };
      function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
        GenericWorker.call(this, "ZipFileWorker");
        this.bytesWritten = 0;
        this.zipComment = comment;
        this.zipPlatform = platform;
        this.encodeFileName = encodeFileName;
        this.streamFiles = streamFiles;
        this.accumulate = false;
        this.contentBuffer = [];
        this.dirRecords = [];
        this.currentSourceOffset = 0;
        this.entriesCount = 0;
        this.currentFile = null;
        this._sources = [];
      }
      utils.inherits(ZipFileWorker, GenericWorker);
      ZipFileWorker.prototype.push = function(chunk) {
        var currentFilePercent = chunk.meta.percent || 0;
        var entriesCount = this.entriesCount;
        var remainingFiles = this._sources.length;
        if (this.accumulate) {
          this.contentBuffer.push(chunk);
        } else {
          this.bytesWritten += chunk.data.length;
          GenericWorker.prototype.push.call(this, { data: chunk.data, meta: { currentFile: this.currentFile, percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100 } });
        }
      };
      ZipFileWorker.prototype.openedSource = function(streamInfo) {
        this.currentSourceOffset = this.bytesWritten;
        this.currentFile = streamInfo["file"].name;
        var streamedContent = this.streamFiles && !streamInfo["file"].dir;
        if (streamedContent) {
          var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: record.fileRecord, meta: { percent: 0 } });
        } else {
          this.accumulate = true;
        }
      };
      ZipFileWorker.prototype.closedSource = function(streamInfo) {
        this.accumulate = false;
        var streamedContent = this.streamFiles && !streamInfo["file"].dir;
        var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.dirRecords.push(record.dirRecord);
        if (streamedContent) {
          this.push({ data: generateDataDescriptors(streamInfo), meta: { percent: 100 } });
        } else {
          this.push({ data: record.fileRecord, meta: { percent: 0 } });
          while (this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
          }
        }
        this.currentFile = null;
      };
      ZipFileWorker.prototype.flush = function() {
        var localDirLength = this.bytesWritten;
        for (var i = 0; i < this.dirRecords.length; i++) {
          this.push({ data: this.dirRecords[i], meta: { percent: 100 } });
        }
        var centralDirLength = this.bytesWritten - localDirLength;
        var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
        this.push({ data: dirEnd, meta: { percent: 100 } });
      };
      ZipFileWorker.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift();
        this.openedSource(this.previous.streamInfo);
        if (this.isPaused) {
          this.previous.pause();
        } else {
          this.previous.resume();
        }
      };
      ZipFileWorker.prototype.registerPrevious = function(previous) {
        this._sources.push(previous);
        var self2 = this;
        previous.on("data", function(chunk) {
          self2.processChunk(chunk);
        });
        previous.on("end", function() {
          self2.closedSource(self2.previous.streamInfo);
          if (self2._sources.length) {
            self2.prepareNextSource();
          } else {
            self2.end();
          }
        });
        previous.on("error", function(e) {
          self2.error(e);
        });
        return this;
      };
      ZipFileWorker.prototype.resume = function() {
        if (!GenericWorker.prototype.resume.call(this)) {
          return false;
        }
        if (!this.previous && this._sources.length) {
          this.prepareNextSource();
          return true;
        }
        if (!this.previous && !this._sources.length && !this.generatedError) {
          this.end();
          return true;
        }
      };
      ZipFileWorker.prototype.error = function(e) {
        var sources = this._sources;
        if (!GenericWorker.prototype.error.call(this, e)) {
          return false;
        }
        for (var i = 0; i < sources.length; i++) {
          try {
            sources[i].error(e);
          } catch (e2) {
          }
        }
        return true;
      };
      ZipFileWorker.prototype.lock = function() {
        GenericWorker.prototype.lock.call(this);
        var sources = this._sources;
        for (var i = 0; i < sources.length; i++) {
          sources[i].lock();
        }
      };
      module2.exports = ZipFileWorker;
    }, { "../crc32": 393, "../signature": 412, "../stream/GenericWorker": 417, "../utf8": 420, "../utils": 421 }], 398: [function(require2, module2, exports2) {
      var compressions = require2("../compressions");
      var ZipFileWorker = require2("./ZipFileWorker");
      var getCompression = function getCompression2(fileCompression, zipCompression) {
        var compressionName = fileCompression || zipCompression;
        var compression = compressions[compressionName];
        if (!compression) {
          throw new Error(compressionName + " is not a valid compression method !");
        }
        return compression;
      };
      exports2.generateWorker = function(zip, options, comment) {
        var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
        var entriesCount = 0;
        try {
          zip.forEach(function(relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir, date = file.date;
            file._compressWorker(compression, compressionOptions).withStreamInfo("file", { name: relativePath, dir, date, comment: file.comment || "", unixPermissions: file.unixPermissions, dosPermissions: file.dosPermissions }).pipe(zipFileWorker);
          });
          zipFileWorker.entriesCount = entriesCount;
        } catch (e) {
          zipFileWorker.error(e);
        }
        return zipFileWorker;
      };
    }, { "../compressions": 392, "./ZipFileWorker": 397 }], 399: [function(require2, module2, exports2) {
      function JSZip() {
        if (!(this instanceof JSZip)) {
          return new JSZip();
        }
        if (arguments.length) {
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        }
        this.files = {};
        this.comment = null;
        this.root = "";
        this.clone = function() {
          var newObj = new JSZip();
          for (var i in this) {
            if (typeof this[i] !== "function") {
              newObj[i] = this[i];
            }
          }
          return newObj;
        };
      }
      JSZip.prototype = require2("./object");
      JSZip.prototype.loadAsync = require2("./load");
      JSZip.support = require2("./support");
      JSZip.defaults = require2("./defaults");
      JSZip.version = "3.5.0";
      JSZip.loadAsync = function(content, options) {
        return new JSZip().loadAsync(content, options);
      };
      JSZip.external = require2("./external");
      module2.exports = JSZip;
    }, { "./defaults": 394, "./external": 395, "./load": 400, "./object": 404, "./support": 419 }], 400: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var external = require2("./external");
      var utf8 = require2("./utf8");
      var utils = require2("./utils");
      var ZipEntries = require2("./zipEntries");
      var Crc32Probe = require2("./stream/Crc32Probe");
      var nodejsUtils = require2("./nodejsUtils");
      function checkEntryCRC32(zipEntry) {
        return new external.Promise(function(resolve, reject) {
          var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
          worker.on("error", function(e) {
            reject(e);
          }).on("end", function() {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
              reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
              resolve();
            }
          }).resume();
        });
      }
      module2.exports = function(data, options) {
        var zip = this;
        options = utils.extend(options || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: utf8.utf8decode });
        if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
          return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
        }
        return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
          var zipEntries = new ZipEntries(options);
          zipEntries.load(data2);
          return zipEntries;
        }).then(function checkCRC32(zipEntries) {
          var promises = [external.Promise.resolve(zipEntries)];
          var files = zipEntries.files;
          if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
              promises.push(checkEntryCRC32(files[i]));
            }
          }
          return external.Promise.all(promises);
        }).then(function addFiles(results) {
          var zipEntries = results.shift();
          var files = zipEntries.files;
          for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, { binary: true, optimizedBinaryString: true, date: input.date, dir: input.dir, comment: input.fileCommentStr.length ? input.fileCommentStr : null, unixPermissions: input.unixPermissions, dosPermissions: input.dosPermissions, createFolders: options.createFolders });
          }
          if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
          }
          return zip;
        });
      };
    }, { "./external": 395, "./nodejsUtils": 403, "./stream/Crc32Probe": 414, "./utf8": 420, "./utils": 421, "./zipEntries": 422 }], 401: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var GenericWorker = require2("../stream/GenericWorker");
      function NodejsStreamInputAdapter(filename, stream) {
        GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
        this._upstreamEnded = false;
        this._bindStream(stream);
      }
      utils.inherits(NodejsStreamInputAdapter, GenericWorker);
      NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
        var self2 = this;
        this._stream = stream;
        stream.pause();
        stream.on("data", function(chunk) {
          self2.push({ data: chunk, meta: { percent: 0 } });
        }).on("error", function(e) {
          if (self2.isPaused) {
            this.generatedError = e;
          } else {
            self2.error(e);
          }
        }).on("end", function() {
          if (self2.isPaused) {
            self2._upstreamEnded = true;
          } else {
            self2.end();
          }
        });
      };
      NodejsStreamInputAdapter.prototype.pause = function() {
        if (!GenericWorker.prototype.pause.call(this)) {
          return false;
        }
        this._stream.pause();
        return true;
      };
      NodejsStreamInputAdapter.prototype.resume = function() {
        if (!GenericWorker.prototype.resume.call(this)) {
          return false;
        }
        if (this._upstreamEnded) {
          this.end();
        } else {
          this._stream.resume();
        }
        return true;
      };
      module2.exports = NodejsStreamInputAdapter;
    }, { "../stream/GenericWorker": 417, "../utils": 421 }], 402: [function(require2, module2, exports2) {
      var Readable = require2("readable-stream").Readable;
      var utils = require2("../utils");
      utils.inherits(NodejsStreamOutputAdapter, Readable);
      function NodejsStreamOutputAdapter(helper2, options, updateCb) {
        Readable.call(this, options);
        this._helper = helper2;
        var self2 = this;
        helper2.on("data", function(data, meta) {
          if (!self2.push(data)) {
            self2._helper.pause();
          }
          if (updateCb) {
            updateCb(meta);
          }
        }).on("error", function(e) {
          self2.emit("error", e);
        }).on("end", function() {
          self2.push(null);
        });
      }
      NodejsStreamOutputAdapter.prototype._read = function() {
        this._helper.resume();
      };
      module2.exports = NodejsStreamOutputAdapter;
    }, { "../utils": 421, "readable-stream": 405 }], 403: [function(require2, module2, exports2) {
      (function(Buffer) {
        module2.exports = {
          /**
          * True if this is running in Nodejs, will be undefined in a browser.
          * In a browser, browserify won't include this file and the whole module
          * will be resolved an empty object.
          */
          isNode: typeof Buffer !== "undefined",
          /**
          * Create a new nodejs Buffer from an existing content.
          * @param {Object} data the data to pass to the constructor.
          * @param {String} encoding the encoding to use.
          * @return {Buffer} a new Buffer.
          */
          newBufferFrom: function newBufferFrom(data, encoding) {
            if (Buffer.from && Buffer.from !== Uint8Array.from) {
              return Buffer.from(data, encoding);
            } else {
              if (typeof data === "number") {
                throw new Error('The "data" argument must not be a number');
              }
              return new Buffer(data, encoding);
            }
          },
          /**
          * Create a new nodejs Buffer with the specified size.
          * @param {Integer} size the size of the buffer.
          * @return {Buffer} a new Buffer.
          */
          allocBuffer: function allocBuffer(size) {
            if (Buffer.alloc) {
              return Buffer.alloc(size);
            } else {
              var buf = new Buffer(size);
              buf.fill(0);
              return buf;
            }
          },
          /**
          * Find out if an object is a Buffer.
          * @param {Object} b the object to test.
          * @return {Boolean} true if the object is a Buffer, false otherwise.
          */
          isBuffer: function isBuffer(b) {
            return Buffer.isBuffer(b);
          },
          isStream: function isStream(obj) {
            return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
          }
        };
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 216 }], 404: [function(require2, module2, exports2) {
      var utf8 = require2("./utf8");
      var utils = require2("./utils");
      var GenericWorker = require2("./stream/GenericWorker");
      var StreamHelper = require2("./stream/StreamHelper");
      var defaults = require2("./defaults");
      var CompressedObject = require2("./compressedObject");
      var ZipObject = require2("./zipObject");
      var generate = require2("./generate");
      var nodejsUtils = require2("./nodejsUtils");
      var NodejsStreamInputAdapter = require2("./nodejs/NodejsStreamInputAdapter");
      var fileAdd = function fileAdd2(name, data, originalOptions) {
        var dataType = utils.getTypeOf(data), parent;
        var o = utils.extend(originalOptions || {}, defaults);
        o.date = o.date || /* @__PURE__ */ new Date();
        if (o.compression !== null) {
          o.compression = o.compression.toUpperCase();
        }
        if (typeof o.unixPermissions === "string") {
          o.unixPermissions = parseInt(o.unixPermissions, 8);
        }
        if (o.unixPermissions && o.unixPermissions & 16384) {
          o.dir = true;
        }
        if (o.dosPermissions && o.dosPermissions & 16) {
          o.dir = true;
        }
        if (o.dir) {
          name = forceTrailingSlash(name);
        }
        if (o.createFolders && (parent = parentFolder(name))) {
          folderAdd.call(this, parent, true);
        }
        var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
        if (!originalOptions || typeof originalOptions.binary === "undefined") {
          o.binary = !isUnicodeString;
        }
        var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
        if (isCompressedEmpty || o.dir || !data || data.length === 0) {
          o.base64 = false;
          o.binary = true;
          data = "";
          o.compression = "STORE";
          dataType = "string";
        }
        var zipObjectContent = null;
        if (data instanceof CompressedObject || data instanceof GenericWorker) {
          zipObjectContent = data;
        } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
          zipObjectContent = new NodejsStreamInputAdapter(name, data);
        } else {
          zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
        }
        var object = new ZipObject(name, zipObjectContent, o);
        this.files[name] = object;
      };
      var parentFolder = function parentFolder2(path) {
        if (path.slice(-1) === "/") {
          path = path.substring(0, path.length - 1);
        }
        var lastSlash = path.lastIndexOf("/");
        return lastSlash > 0 ? path.substring(0, lastSlash) : "";
      };
      var forceTrailingSlash = function forceTrailingSlash2(path) {
        if (path.slice(-1) !== "/") {
          path += "/";
        }
        return path;
      };
      var folderAdd = function folderAdd2(name, createFolders) {
        createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
        name = forceTrailingSlash(name);
        if (!this.files[name]) {
          fileAdd.call(this, name, null, { dir: true, createFolders });
        }
        return this.files[name];
      };
      function isRegExp(object) {
        return Object.prototype.toString.call(object) === "[object RegExp]";
      }
      var out = {
        /**
        * @see loadAsync
        */
        load: function load() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
        * Call a callback function for each entry at this folder level.
        * @param {Function} cb the callback function:
        * function (relativePath, file) {...}
        * It takes 2 arguments : the relative path and the file.
        */
        forEach: function forEach(cb) {
          var filename, relativePath, file;
          for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
              continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) {
              cb(relativePath, file);
            }
          }
        },
        /**
        * Filter nested files/folders with the specified function.
        * @param {Function} search the predicate to use :
        * function (relativePath, file) {...}
        * It takes 2 arguments : the relative path and the file.
        * @return {Array} An array of matching elements.
        */
        filter: function filter(search) {
          var result = [];
          this.forEach(function(relativePath, entry) {
            if (search(relativePath, entry)) {
              result.push(entry);
            }
          });
          return result;
        },
        /**
        * Add a file to the zip file, or search a file.
        * @param   {string|RegExp} name The name of the file to add (if data is defined),
        * the name of the file to find (if no data) or a regex to match files.
        * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
        * @param   {Object} o     File options
        * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
        * a file (when searching by string) or an array of files (when searching by regex).
        */
        file: function file(name, data, o) {
          if (arguments.length === 1) {
            if (isRegExp(name)) {
              var regexp = name;
              return this.filter(function(relativePath, file2) {
                return !file2.dir && regexp.test(relativePath);
              });
            } else {
              var obj = this.files[this.root + name];
              if (obj && !obj.dir) {
                return obj;
              } else {
                return null;
              }
            }
          } else {
            name = this.root + name;
            fileAdd.call(this, name, data, o);
          }
          return this;
        },
        /**
        * Add a directory to the zip file, or search.
        * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
        * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
        */
        folder: function folder(arg) {
          if (!arg) {
            return this;
          }
          if (isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
              return file.dir && arg.test(relativePath);
            });
          }
          var name = this.root + arg;
          var newFolder = folderAdd.call(this, name);
          var ret = this.clone();
          ret.root = newFolder.name;
          return ret;
        },
        /**
        * Delete a file, or a directory and all sub-files, from the zip
        * @param {string} name the name of the file to delete
        * @return {JSZip} this JSZip object
        */
        remove: function remove(name) {
          name = this.root + name;
          var file = this.files[name];
          if (!file) {
            if (name.slice(-1) !== "/") {
              name += "/";
            }
            file = this.files[name];
          }
          if (file && !file.dir) {
            delete this.files[name];
          } else {
            var kids = this.filter(function(relativePath, file2) {
              return file2.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
              delete this.files[kids[i].name];
            }
          }
          return this;
        },
        /**
        * Generate the complete zip file
        * @param {Object} options the options to generate the zip file :
        * - compression, "STORE" by default.
        * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
        * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
        */
        generate: function generate2(options) {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        },
        /**
        * Generate the complete zip file as an internal stream.
        * @param {Object} options the options to generate the zip file :
        * - compression, "STORE" by default.
        * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
        * @return {StreamHelper} the streamed zip file.
        */
        generateInternalStream: function generateInternalStream(options) {
          var worker, opts = {};
          try {
            opts = utils.extend(options || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: utf8.utf8encode });
            opts.type = opts.type.toLowerCase();
            opts.compression = opts.compression.toUpperCase();
            if (opts.type === "binarystring") {
              opts.type = "string";
            }
            if (!opts.type) {
              throw new Error("No output type specified.");
            }
            utils.checkSupport(opts.type);
            if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
              opts.platform = "UNIX";
            }
            if (opts.platform === "win32") {
              opts.platform = "DOS";
            }
            var comment = opts.comment || this.comment || "";
            worker = generate.generateWorker(this, opts, comment);
          } catch (e) {
            worker = new GenericWorker("error");
            worker.error(e);
          }
          return new StreamHelper(worker, opts.type || "string", opts.mimeType);
        },
        /**
        * Generate the complete zip file asynchronously.
        * @see generateInternalStream
        */
        generateAsync: function generateAsync(options, onUpdate) {
          return this.generateInternalStream(options).accumulate(onUpdate);
        },
        /**
        * Generate the complete zip file asynchronously.
        * @see generateInternalStream
        */
        generateNodeStream: function generateNodeStream(options, onUpdate) {
          options = options || {};
          if (!options.type) {
            options.type = "nodebuffer";
          }
          return this.generateInternalStream(options).toNodejsStream(onUpdate);
        }
      };
      module2.exports = out;
    }, { "./compressedObject": 391, "./defaults": 394, "./generate": 398, "./nodejs/NodejsStreamInputAdapter": 401, "./nodejsUtils": 403, "./stream/GenericWorker": 417, "./stream/StreamHelper": 418, "./utf8": 420, "./utils": 421, "./zipObject": 424 }], 405: [function(require2, module2, exports2) {
      module2.exports = require2("stream");
    }, { "stream": 506 }], 406: [function(require2, module2, exports2) {
      var DataReader = require2("./DataReader");
      var utils = require2("../utils");
      function ArrayReader(data) {
        DataReader.call(this, data);
        for (var i = 0; i < this.data.length; i++) {
          data[i] = data[i] & 255;
        }
      }
      utils.inherits(ArrayReader, DataReader);
      ArrayReader.prototype.byteAt = function(i) {
        return this.data[this.zero + i];
      };
      ArrayReader.prototype.lastIndexOfSignature = function(sig) {
        var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
        for (var i = this.length - 4; i >= 0; --i) {
          if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
          }
        }
        return -1;
      };
      ArrayReader.prototype.readAndCheckSignature = function(sig) {
        var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
        return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
      };
      ArrayReader.prototype.readData = function(size) {
        this.checkOffset(size);
        if (size === 0) {
          return [];
        }
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module2.exports = ArrayReader;
    }, { "../utils": 421, "./DataReader": 407 }], 407: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      function DataReader(data) {
        this.data = data;
        this.length = data.length;
        this.index = 0;
        this.zero = 0;
      }
      DataReader.prototype = {
        /**
        * Check that the offset will not go too far.
        * @param {string} offset the additional offset to check.
        * @throws {Error} an Error if the offset is out of bounds.
        */
        checkOffset: function checkOffset(offset) {
          this.checkIndex(this.index + offset);
        },
        /**
        * Check that the specified index will not be too far.
        * @param {string} newIndex the index to check.
        * @throws {Error} an Error if the index is out of bounds.
        */
        checkIndex: function checkIndex(newIndex) {
          if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
          }
        },
        /**
        * Change the index.
        * @param {number} newIndex The new index.
        * @throws {Error} if the new index is out of the data.
        */
        setIndex: function setIndex(newIndex) {
          this.checkIndex(newIndex);
          this.index = newIndex;
        },
        /**
        * Skip the next n bytes.
        * @param {number} n the number of bytes to skip.
        * @throws {Error} if the new index is out of the data.
        */
        skip: function skip(n) {
          this.setIndex(this.index + n);
        },
        /**
        * Get the byte at the specified index.
        * @param {number} i the index to use.
        * @return {number} a byte.
        */
        byteAt: function byteAt(i) {
        },
        /**
          * Get the next number with a given byte size.
          * @param {number} size the number of bytes to read.
          * @return {number} the corresponding number.
          */
        readInt: function readInt(size) {
          var result = 0, i;
          this.checkOffset(size);
          for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
          }
          this.index += size;
          return result;
        },
        /**
        * Get the next string with a given byte size.
        * @param {number} size the number of bytes to read.
        * @return {string} the corresponding string.
        */
        readString: function readString(size) {
          return utils.transformTo("string", this.readData(size));
        },
        /**
        * Get raw data without conversion, <size> bytes.
        * @param {number} size the number of bytes to read.
        * @return {Object} the raw data, implementation specific.
        */
        readData: function readData(size) {
        },
        /**
          * Find the last occurrence of a zip signature (4 bytes).
          * @param {string} sig the signature to find.
          * @return {number} the index of the last occurrence, -1 if not found.
          */
        lastIndexOfSignature: function lastIndexOfSignature(sig) {
        },
        /**
          * Read the signature (4 bytes) at the current position and compare it with sig.
          * @param {string} sig the expected signature
          * @return {boolean} true if the signature matches, false otherwise.
          */
        readAndCheckSignature: function readAndCheckSignature(sig) {
        },
        /**
          * Get the next date.
          * @return {Date} the date.
          */
        readDate: function readDate() {
          var dostime = this.readInt(4);
          return new Date(Date.UTC(
            (dostime >> 25 & 127) + 1980,
            // year
            (dostime >> 21 & 15) - 1,
            // month
            dostime >> 16 & 31,
            // day
            dostime >> 11 & 31,
            // hour
            dostime >> 5 & 63,
            // minute
            (dostime & 31) << 1
          ));
        }
      };
      module2.exports = DataReader;
    }, { "../utils": 421 }], 408: [function(require2, module2, exports2) {
      var Uint8ArrayReader = require2("./Uint8ArrayReader");
      var utils = require2("../utils");
      function NodeBufferReader(data) {
        Uint8ArrayReader.call(this, data);
      }
      utils.inherits(NodeBufferReader, Uint8ArrayReader);
      NodeBufferReader.prototype.readData = function(size) {
        this.checkOffset(size);
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module2.exports = NodeBufferReader;
    }, { "../utils": 421, "./Uint8ArrayReader": 410 }], 409: [function(require2, module2, exports2) {
      var DataReader = require2("./DataReader");
      var utils = require2("../utils");
      function StringReader(data) {
        DataReader.call(this, data);
      }
      utils.inherits(StringReader, DataReader);
      StringReader.prototype.byteAt = function(i) {
        return this.data.charCodeAt(this.zero + i);
      };
      StringReader.prototype.lastIndexOfSignature = function(sig) {
        return this.data.lastIndexOf(sig) - this.zero;
      };
      StringReader.prototype.readAndCheckSignature = function(sig) {
        var data = this.readData(4);
        return sig === data;
      };
      StringReader.prototype.readData = function(size) {
        this.checkOffset(size);
        var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module2.exports = StringReader;
    }, { "../utils": 421, "./DataReader": 407 }], 410: [function(require2, module2, exports2) {
      var ArrayReader = require2("./ArrayReader");
      var utils = require2("../utils");
      function Uint8ArrayReader(data) {
        ArrayReader.call(this, data);
      }
      utils.inherits(Uint8ArrayReader, ArrayReader);
      Uint8ArrayReader.prototype.readData = function(size) {
        this.checkOffset(size);
        if (size === 0) {
          return new Uint8Array(0);
        }
        var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
        this.index += size;
        return result;
      };
      module2.exports = Uint8ArrayReader;
    }, { "../utils": 421, "./ArrayReader": 406 }], 411: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var support = require2("../support");
      var ArrayReader = require2("./ArrayReader");
      var StringReader = require2("./StringReader");
      var NodeBufferReader = require2("./NodeBufferReader");
      var Uint8ArrayReader = require2("./Uint8ArrayReader");
      module2.exports = function(data) {
        var type = utils.getTypeOf(data);
        utils.checkSupport(type);
        if (type === "string" && !support.uint8array) {
          return new StringReader(data);
        }
        if (type === "nodebuffer") {
          return new NodeBufferReader(data);
        }
        if (support.uint8array) {
          return new Uint8ArrayReader(utils.transformTo("uint8array", data));
        }
        return new ArrayReader(utils.transformTo("array", data));
      };
    }, { "../support": 419, "../utils": 421, "./ArrayReader": 406, "./NodeBufferReader": 408, "./StringReader": 409, "./Uint8ArrayReader": 410 }], 412: [function(require2, module2, exports2) {
      exports2.LOCAL_FILE_HEADER = "PK";
      exports2.CENTRAL_FILE_HEADER = "PK";
      exports2.CENTRAL_DIRECTORY_END = "PK";
      exports2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
      exports2.ZIP64_CENTRAL_DIRECTORY_END = "PK";
      exports2.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 413: [function(require2, module2, exports2) {
      var GenericWorker = require2("./GenericWorker");
      var utils = require2("../utils");
      function ConvertWorker(destType) {
        GenericWorker.call(this, "ConvertWorker to " + destType);
        this.destType = destType;
      }
      utils.inherits(ConvertWorker, GenericWorker);
      ConvertWorker.prototype.processChunk = function(chunk) {
        this.push({ data: utils.transformTo(this.destType, chunk.data), meta: chunk.meta });
      };
      module2.exports = ConvertWorker;
    }, { "../utils": 421, "./GenericWorker": 417 }], 414: [function(require2, module2, exports2) {
      var GenericWorker = require2("./GenericWorker");
      var crc32 = require2("../crc32");
      var utils = require2("../utils");
      function Crc32Probe() {
        GenericWorker.call(this, "Crc32Probe");
        this.withStreamInfo("crc32", 0);
      }
      utils.inherits(Crc32Probe, GenericWorker);
      Crc32Probe.prototype.processChunk = function(chunk) {
        this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
        this.push(chunk);
      };
      module2.exports = Crc32Probe;
    }, { "../crc32": 393, "../utils": 421, "./GenericWorker": 417 }], 415: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var GenericWorker = require2("./GenericWorker");
      function DataLengthProbe(propName) {
        GenericWorker.call(this, "DataLengthProbe for " + propName);
        this.propName = propName;
        this.withStreamInfo(propName, 0);
      }
      utils.inherits(DataLengthProbe, GenericWorker);
      DataLengthProbe.prototype.processChunk = function(chunk) {
        if (chunk) {
          var length = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = length + chunk.data.length;
        }
        GenericWorker.prototype.processChunk.call(this, chunk);
      };
      module2.exports = DataLengthProbe;
    }, { "../utils": 421, "./GenericWorker": 417 }], 416: [function(require2, module2, exports2) {
      var utils = require2("../utils");
      var GenericWorker = require2("./GenericWorker");
      var DEFAULT_BLOCK_SIZE = 16 * 1024;
      function DataWorker(dataP) {
        GenericWorker.call(this, "DataWorker");
        var self2 = this;
        this.dataIsReady = false;
        this.index = 0;
        this.max = 0;
        this.data = null;
        this.type = "";
        this._tickScheduled = false;
        dataP.then(function(data) {
          self2.dataIsReady = true;
          self2.data = data;
          self2.max = data && data.length || 0;
          self2.type = utils.getTypeOf(data);
          if (!self2.isPaused) {
            self2._tickAndRepeat();
          }
        }, function(e) {
          self2.error(e);
        });
      }
      utils.inherits(DataWorker, GenericWorker);
      DataWorker.prototype.cleanUp = function() {
        GenericWorker.prototype.cleanUp.call(this);
        this.data = null;
      };
      DataWorker.prototype.resume = function() {
        if (!GenericWorker.prototype.resume.call(this)) {
          return false;
        }
        if (!this._tickScheduled && this.dataIsReady) {
          this._tickScheduled = true;
          utils.delay(this._tickAndRepeat, [], this);
        }
        return true;
      };
      DataWorker.prototype._tickAndRepeat = function() {
        this._tickScheduled = false;
        if (this.isPaused || this.isFinished) {
          return;
        }
        this._tick();
        if (!this.isFinished) {
          utils.delay(this._tickAndRepeat, [], this);
          this._tickScheduled = true;
        }
      };
      DataWorker.prototype._tick = function() {
        if (this.isPaused || this.isFinished) {
          return false;
        }
        var size = DEFAULT_BLOCK_SIZE;
        var data = null, nextIndex = Math.min(this.max, this.index + size);
        if (this.index >= this.max) {
          return this.end();
        } else {
          switch (this.type) {
            case "string":
              data = this.data.substring(this.index, nextIndex);
              break;
            case "uint8array":
              data = this.data.subarray(this.index, nextIndex);
              break;
            case "array":
            case "nodebuffer":
              data = this.data.slice(this.index, nextIndex);
              break;
          }
          this.index = nextIndex;
          return this.push({ data, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }
      };
      module2.exports = DataWorker;
    }, { "../utils": 421, "./GenericWorker": 417 }], 417: [function(require2, module2, exports2) {
      function GenericWorker(name) {
        this.name = name || "default";
        this.streamInfo = {};
        this.generatedError = null;
        this.extraStreamInfo = {};
        this.isPaused = true;
        this.isFinished = false;
        this.isLocked = false;
        this._listeners = { "data": [], "end": [], "error": [] };
        this.previous = null;
      }
      GenericWorker.prototype = {
        /**
        * Push a chunk to the next workers.
        * @param {Object} chunk the chunk to push
        */
        push: function push(chunk) {
          this.emit("data", chunk);
        },
        /**
        * End the stream.
        * @return {Boolean} true if this call ended the worker, false otherwise.
        */
        end: function end() {
          if (this.isFinished) {
            return false;
          }
          this.flush();
          try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
          } catch (e) {
            this.emit("error", e);
          }
          return true;
        },
        /**
        * End the stream with an error.
        * @param {Error} e the error which caused the premature end.
        * @return {Boolean} true if this call ended the worker with an error, false otherwise.
        */
        error: function error(e) {
          if (this.isFinished) {
            return false;
          }
          if (this.isPaused) {
            this.generatedError = e;
          } else {
            this.isFinished = true;
            this.emit("error", e);
            if (this.previous) {
              this.previous.error(e);
            }
            this.cleanUp();
          }
          return true;
        },
        /**
        * Add a callback on an event.
        * @param {String} name the name of the event (data, end, error)
        * @param {Function} listener the function to call when the event is triggered
        * @return {GenericWorker} the current object for chainability
        */
        on: function on(name, listener) {
          this._listeners[name].push(listener);
          return this;
        },
        /**
        * Clean any references when a worker is ending.
        */
        cleanUp: function cleanUp() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null;
          this._listeners = [];
        },
        /**
        * Trigger an event. This will call registered callback with the provided arg.
        * @param {String} name the name of the event (data, end, error)
        * @param {Object} arg the argument to call the callback with.
        */
        emit: function emit(name, arg) {
          if (this._listeners[name]) {
            for (var i = 0; i < this._listeners[name].length; i++) {
              this._listeners[name][i].call(this, arg);
            }
          }
        },
        /**
        * Chain a worker with an other.
        * @param {Worker} next the worker receiving events from the current one.
        * @return {worker} the next worker for chainability
        */
        pipe: function pipe(next) {
          return next.registerPrevious(this);
        },
        /**
        * Same as `pipe` in the other direction.
        * Using an API with `pipe(next)` is very easy.
        * Implementing the API with the point of view of the next one registering
        * a source is easier, see the ZipFileWorker.
        * @param {Worker} previous the previous worker, sending events to this one
        * @return {Worker} the current worker for chainability
        */
        registerPrevious: function registerPrevious(previous) {
          if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
          }
          this.streamInfo = previous.streamInfo;
          this.mergeStreamInfo();
          this.previous = previous;
          var self2 = this;
          previous.on("data", function(chunk) {
            self2.processChunk(chunk);
          });
          previous.on("end", function() {
            self2.end();
          });
          previous.on("error", function(e) {
            self2.error(e);
          });
          return this;
        },
        /**
        * Pause the stream so it doesn't send events anymore.
        * @return {Boolean} true if this call paused the worker, false otherwise.
        */
        pause: function pause() {
          if (this.isPaused || this.isFinished) {
            return false;
          }
          this.isPaused = true;
          if (this.previous) {
            this.previous.pause();
          }
          return true;
        },
        /**
        * Resume a paused stream.
        * @return {Boolean} true if this call resumed the worker, false otherwise.
        */
        resume: function resume() {
          if (!this.isPaused || this.isFinished) {
            return false;
          }
          this.isPaused = false;
          var withError = false;
          if (this.generatedError) {
            this.error(this.generatedError);
            withError = true;
          }
          if (this.previous) {
            this.previous.resume();
          }
          return !withError;
        },
        /**
        * Flush any remaining bytes as the stream is ending.
        */
        flush: function flush() {
        },
        /**
        * Process a chunk. This is usually the method overridden.
        * @param {Object} chunk the chunk to process.
        */
        processChunk: function processChunk(chunk) {
          this.push(chunk);
        },
        /**
        * Add a key/value to be added in the workers chain streamInfo once activated.
        * @param {String} key the key to use
        * @param {Object} value the associated value
        * @return {Worker} the current worker for chainability
        */
        withStreamInfo: function withStreamInfo(key, value) {
          this.extraStreamInfo[key] = value;
          this.mergeStreamInfo();
          return this;
        },
        /**
        * Merge this worker's streamInfo into the chain's streamInfo.
        */
        mergeStreamInfo: function mergeStreamInfo() {
          for (var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
              continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
          }
        },
        /**
        * Lock the stream to prevent further updates on the workers chain.
        * After calling this method, all calls to pipe will fail.
        */
        lock: function lock() {
          if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
          }
          this.isLocked = true;
          if (this.previous) {
            this.previous.lock();
          }
        },
        /**
        *
        * Pretty print the workers chain.
        */
        toString: function toString2() {
          var me = "Worker " + this.name;
          if (this.previous) {
            return this.previous + " -> " + me;
          } else {
            return me;
          }
        }
      };
      module2.exports = GenericWorker;
    }, {}], 418: [function(require2, module2, exports2) {
      (function(Buffer) {
        var utils = require2("../utils");
        var ConvertWorker = require2("./ConvertWorker");
        var GenericWorker = require2("./GenericWorker");
        var base64 = require2("../base64");
        var support = require2("../support");
        var external = require2("../external");
        var NodejsStreamOutputAdapter = null;
        if (support.nodestream) {
          try {
            NodejsStreamOutputAdapter = require2("../nodejs/NodejsStreamOutputAdapter");
          } catch (e) {
          }
        }
        function transformZipOutput(type, content, mimeType) {
          switch (type) {
            case "blob":
              return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
            case "base64":
              return base64.encode(content);
            default:
              return utils.transformTo(type, content);
          }
        }
        function concat(type, dataArray) {
          var i, index2 = 0, res = null, totalLength = 0;
          for (i = 0; i < dataArray.length; i++) {
            totalLength += dataArray[i].length;
          }
          switch (type) {
            case "string":
              return dataArray.join("");
            case "array":
              return Array.prototype.concat.apply([], dataArray);
            case "uint8array":
              res = new Uint8Array(totalLength);
              for (i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index2);
                index2 += dataArray[i].length;
              }
              return res;
            case "nodebuffer":
              return Buffer.concat(dataArray);
            default:
              throw new Error("concat : unsupported type '" + type + "'");
          }
        }
        function _accumulate(helper2, updateCallback) {
          return new external.Promise(function(resolve, reject) {
            var dataArray = [];
            var chunkType = helper2._internalType, resultType = helper2._outputType, mimeType = helper2._mimeType;
            helper2.on("data", function(data, meta) {
              dataArray.push(data);
              if (updateCallback) {
                updateCallback(meta);
              }
            }).on("error", function(err) {
              dataArray = [];
              reject(err);
            }).on("end", function() {
              try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
              } catch (e) {
                reject(e);
              }
              dataArray = [];
            }).resume();
          });
        }
        function StreamHelper(worker, outputType, mimeType) {
          var internalType = outputType;
          switch (outputType) {
            case "blob":
            case "arraybuffer":
              internalType = "uint8array";
              break;
            case "base64":
              internalType = "string";
              break;
          }
          try {
            this._internalType = internalType;
            this._outputType = outputType;
            this._mimeType = mimeType;
            utils.checkSupport(internalType);
            this._worker = worker.pipe(new ConvertWorker(internalType));
            worker.lock();
          } catch (e) {
            this._worker = new GenericWorker("error");
            this._worker.error(e);
          }
        }
        StreamHelper.prototype = {
          /**
          * Listen a StreamHelper, accumulate its content and concatenate it into a
          * complete block.
          * @param {Function} updateCb the update callback.
          * @return Promise the promise for the accumulation.
          */
          accumulate: function accumulate(updateCb) {
            return _accumulate(this, updateCb);
          },
          /**
          * Add a listener on an event triggered on a stream.
          * @param {String} evt the name of the event
          * @param {Function} fn the listener
          * @return {StreamHelper} the current helper.
          */
          on: function on(evt, fn) {
            var self2 = this;
            if (evt === "data") {
              this._worker.on(evt, function(chunk) {
                fn.call(self2, chunk.data, chunk.meta);
              });
            } else {
              this._worker.on(evt, function() {
                utils.delay(fn, arguments, self2);
              });
            }
            return this;
          },
          /**
          * Resume the flow of chunks.
          * @return {StreamHelper} the current helper.
          */
          resume: function resume() {
            utils.delay(this._worker.resume, [], this._worker);
            return this;
          },
          /**
          * Pause the flow of chunks.
          * @return {StreamHelper} the current helper.
          */
          pause: function pause() {
            this._worker.pause();
            return this;
          },
          /**
          * Return a nodejs stream for this helper.
          * @param {Function} updateCb the update callback.
          * @return {NodejsStreamOutputAdapter} the nodejs stream.
          */
          toNodejsStream: function toNodejsStream(updateCb) {
            utils.checkSupport("nodestream");
            if (this._outputType !== "nodebuffer") {
              throw new Error(this._outputType + " is not supported by this method");
            }
            return new NodejsStreamOutputAdapter(this, { objectMode: this._outputType !== "nodebuffer" }, updateCb);
          }
        };
        module2.exports = StreamHelper;
      }).call(this, require2("buffer").Buffer);
    }, { "../base64": 390, "../external": 395, "../nodejs/NodejsStreamOutputAdapter": 402, "../support": 419, "../utils": 421, "./ConvertWorker": 413, "./GenericWorker": 417, "buffer": 216 }], 419: [function(require2, module2, exports2) {
      (function(Buffer) {
        exports2.base64 = true;
        exports2.array = true;
        exports2.string = true;
        exports2.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
        exports2.nodebuffer = typeof Buffer !== "undefined";
        exports2.uint8array = typeof Uint8Array !== "undefined";
        if (typeof ArrayBuffer === "undefined") {
          exports2.blob = false;
        } else {
          var buffer = new ArrayBuffer(0);
          try {
            exports2.blob = new Blob([buffer], { type: "application/zip" }).size === 0;
          } catch (e) {
            try {
              var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
              var builder = new Builder();
              builder.append(buffer);
              exports2.blob = builder.getBlob("application/zip").size === 0;
            } catch (e2) {
              exports2.blob = false;
            }
          }
        }
        try {
          exports2.nodestream = !!require2("readable-stream").Readable;
        } catch (e) {
          exports2.nodestream = false;
        }
      }).call(this, require2("buffer").Buffer);
    }, { "buffer": 216, "readable-stream": 405 }], 420: [function(require2, module2, exports2) {
      var utils = require2("./utils");
      var support = require2("./support");
      var nodejsUtils = require2("./nodejsUtils");
      var GenericWorker = require2("./stream/GenericWorker");
      var _utf8len = new Array(256);
      for (var i = 0; i < 256; i++) {
        _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
      }
      _utf8len[254] = _utf8len[254] = 1;
      var string2buf = function string2buf2(str) {
        var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        if (support.uint8array) {
          buf = new Uint8Array(buf_len);
        } else {
          buf = new Array(buf_len);
        }
        for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          if (c < 128) {
            buf[i2++] = c;
          } else if (c < 2048) {
            buf[i2++] = 192 | c >>> 6;
            buf[i2++] = 128 | c & 63;
          } else if (c < 65536) {
            buf[i2++] = 224 | c >>> 12;
            buf[i2++] = 128 | c >>> 6 & 63;
            buf[i2++] = 128 | c & 63;
          } else {
            buf[i2++] = 240 | c >>> 18;
            buf[i2++] = 128 | c >>> 12 & 63;
            buf[i2++] = 128 | c >>> 6 & 63;
            buf[i2++] = 128 | c & 63;
          }
        }
        return buf;
      };
      var utf8border = function utf8border2(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
      };
      var buf2string = function buf2string2(buf) {
        var i2, out, c, c_len;
        var len = buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i2 = 0; i2 < len; ) {
          c = buf[i2++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue;
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i2 += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i2 < len) {
            c = c << 6 | buf[i2++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c < 65536) {
            utf16buf[out++] = c;
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023;
          }
        }
        if (utf16buf.length !== out) {
          if (utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
          } else {
            utf16buf.length = out;
          }
        }
        return utils.applyFromCharCode(utf16buf);
      };
      exports2.utf8encode = function utf8encode(str) {
        if (support.nodebuffer) {
          return nodejsUtils.newBufferFrom(str, "utf-8");
        }
        return string2buf(str);
      };
      exports2.utf8decode = function utf8decode(buf) {
        if (support.nodebuffer) {
          return utils.transformTo("nodebuffer", buf).toString("utf-8");
        }
        buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
        return buf2string(buf);
      };
      function Utf8DecodeWorker() {
        GenericWorker.call(this, "utf-8 decode");
        this.leftOver = null;
      }
      utils.inherits(Utf8DecodeWorker, GenericWorker);
      Utf8DecodeWorker.prototype.processChunk = function(chunk) {
        var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
        if (this.leftOver && this.leftOver.length) {
          if (support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
          } else {
            data = this.leftOver.concat(data);
          }
          this.leftOver = null;
        }
        var nextBoundary = utf8border(data);
        var usableData = data;
        if (nextBoundary !== data.length) {
          if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
          } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
          }
        }
        this.push({ data: exports2.utf8decode(usableData), meta: chunk.meta });
      };
      Utf8DecodeWorker.prototype.flush = function() {
        if (this.leftOver && this.leftOver.length) {
          this.push({ data: exports2.utf8decode(this.leftOver), meta: {} });
          this.leftOver = null;
        }
      };
      exports2.Utf8DecodeWorker = Utf8DecodeWorker;
      function Utf8EncodeWorker() {
        GenericWorker.call(this, "utf-8 encode");
      }
      utils.inherits(Utf8EncodeWorker, GenericWorker);
      Utf8EncodeWorker.prototype.processChunk = function(chunk) {
        this.push({ data: exports2.utf8encode(chunk.data), meta: chunk.meta });
      };
      exports2.Utf8EncodeWorker = Utf8EncodeWorker;
    }, { "./nodejsUtils": 403, "./stream/GenericWorker": 417, "./support": 419, "./utils": 421 }], 421: [function(require2, module2, exports2) {
      var support = require2("./support");
      var base64 = require2("./base64");
      var nodejsUtils = require2("./nodejsUtils");
      var setImmediate = require2("set-immediate-shim");
      var external = require2("./external");
      function string2binary(str) {
        var result = null;
        if (support.uint8array) {
          result = new Uint8Array(str.length);
        } else {
          result = new Array(str.length);
        }
        return stringToArrayLike(str, result);
      }
      exports2.newBlob = function(part, type) {
        exports2.checkSupport("blob");
        try {
          return new Blob([part], { type });
        } catch (e) {
          try {
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
          } catch (e2) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      function identity(input) {
        return input;
      }
      function stringToArrayLike(str, array) {
        for (var i = 0; i < str.length; ++i) {
          array[i] = str.charCodeAt(i) & 255;
        }
        return array;
      }
      var arrayToStringHelper = {
        /**
        * Transform an array of int into a string, chunk by chunk.
        * See the performances notes on arrayLikeToString.
        * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
        * @param {String} type the type of the array.
        * @param {Integer} chunk the chunk size.
        * @return {String} the resulting string.
        * @throws Error if the chunk is too big for the stack.
        */
        stringifyByChunk: function stringifyByChunk(array, type, chunk) {
          var result = [], k = 0, len = array.length;
          if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
          }
          while (k < len) {
            if (type === "array" || type === "nodebuffer") {
              result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            } else {
              result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
          }
          return result.join("");
        },
        /**
        * Call String.fromCharCode on every item in the array.
        * This is the naive implementation, which generate A LOT of intermediate string.
        * This should be used when everything else fail.
        * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
        * @return {String} the result.
        */
        stringifyByChar: function stringifyByChar(array) {
          var resultStr = "";
          for (var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
          }
          return resultStr;
        },
        applyCanBeUsed: {
          /**
          * true if the browser accepts to use String.fromCharCode on Uint8Array
          */
          uint8array: function() {
            try {
              return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
              return false;
            }
          }(),
          /**
          * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
          */
          nodebuffer: function() {
            try {
              return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
            } catch (e) {
              return false;
            }
          }()
        }
      };
      function arrayLikeToString(array) {
        var chunk = 65536, type = exports2.getTypeOf(array), canUseApply = true;
        if (type === "uint8array") {
          canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
        } else if (type === "nodebuffer") {
          canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
        }
        if (canUseApply) {
          while (chunk > 1) {
            try {
              return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
              chunk = Math.floor(chunk / 2);
            }
          }
        }
        return arrayToStringHelper.stringifyByChar(array);
      }
      exports2.applyFromCharCode = arrayLikeToString;
      function arrayLikeToArrayLike(arrayFrom, arrayTo) {
        for (var i = 0; i < arrayFrom.length; i++) {
          arrayTo[i] = arrayFrom[i];
        }
        return arrayTo;
      }
      var transform = {};
      transform["string"] = { "string": identity, "array": function array(input) {
        return stringToArrayLike(input, new Array(input.length));
      }, "arraybuffer": function arraybuffer(input) {
        return transform["string"]["uint8array"](input).buffer;
      }, "uint8array": function uint8array(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      }, "nodebuffer": function nodebuffer(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
      } };
      transform["array"] = { "string": arrayLikeToString, "array": identity, "arraybuffer": function arraybuffer(input) {
        return new Uint8Array(input).buffer;
      }, "uint8array": function uint8array(input) {
        return new Uint8Array(input);
      }, "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(input);
      } };
      transform["arraybuffer"] = { "string": function string(input) {
        return arrayLikeToString(new Uint8Array(input));
      }, "array": function array(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      }, "arraybuffer": identity, "uint8array": function uint8array(input) {
        return new Uint8Array(input);
      }, "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
      } };
      transform["uint8array"] = { "string": arrayLikeToString, "array": function array(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      }, "arraybuffer": function arraybuffer(input) {
        return input.buffer;
      }, "uint8array": identity, "nodebuffer": function nodebuffer(input) {
        return nodejsUtils.newBufferFrom(input);
      } };
      transform["nodebuffer"] = { "string": arrayLikeToString, "array": function array(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      }, "arraybuffer": function arraybuffer(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
      }, "uint8array": function uint8array(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      }, "nodebuffer": identity };
      exports2.transformTo = function(outputType, input) {
        if (!input) {
          input = "";
        }
        if (!outputType) {
          return input;
        }
        exports2.checkSupport(outputType);
        var inputType = exports2.getTypeOf(input);
        var result = transform[inputType][outputType](input);
        return result;
      };
      exports2.getTypeOf = function(input) {
        if (typeof input === "string") {
          return "string";
        }
        if (Object.prototype.toString.call(input) === "[object Array]") {
          return "array";
        }
        if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
          return "nodebuffer";
        }
        if (support.uint8array && input instanceof Uint8Array) {
          return "uint8array";
        }
        if (support.arraybuffer && input instanceof ArrayBuffer) {
          return "arraybuffer";
        }
      };
      exports2.checkSupport = function(type) {
        var supported = support[type.toLowerCase()];
        if (!supported) {
          throw new Error(type + " is not supported by this platform");
        }
      };
      exports2.MAX_VALUE_16BITS = 65535;
      exports2.MAX_VALUE_32BITS = -1;
      exports2.pretty = function(str) {
        var res = "", code, i;
        for (i = 0; i < (str || "").length; i++) {
          code = str.charCodeAt(i);
          res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
        }
        return res;
      };
      exports2.delay = function(callback, args, self2) {
        setImmediate(function() {
          callback.apply(self2 || null, args || []);
        });
      };
      exports2.inherits = function(ctor, superCtor) {
        var Obj = function Obj2() {
        };
        Obj.prototype = superCtor.prototype;
        ctor.prototype = new Obj();
      };
      exports2.extend = function() {
        var result = {}, i, attr;
        for (i = 0; i < arguments.length; i++) {
          for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
              result[attr] = arguments[i][attr];
            }
          }
        }
        return result;
      };
      exports2.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
        var promise = external.Promise.resolve(inputData).then(function(data) {
          var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
          if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function(resolve, reject) {
              var reader = new FileReader();
              reader.onload = function(e) {
                resolve(e.target.result);
              };
              reader.onerror = function(e) {
                reject(e.target.error);
              };
              reader.readAsArrayBuffer(data);
            });
          } else {
            return data;
          }
        });
        return promise.then(function(data) {
          var dataType = exports2.getTypeOf(data);
          if (!dataType) {
            return external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          }
          if (dataType === "arraybuffer") {
            data = exports2.transformTo("uint8array", data);
          } else if (dataType === "string") {
            if (isBase64) {
              data = base64.decode(data);
            } else if (isBinary) {
              if (isOptimizedBinaryString !== true) {
                data = string2binary(data);
              }
            }
          }
          return data;
        });
      };
    }, { "./base64": 390, "./external": 395, "./nodejsUtils": 403, "./support": 419, "set-immediate-shim": 497 }], 422: [function(require2, module2, exports2) {
      var readerFor = require2("./reader/readerFor");
      var utils = require2("./utils");
      var sig = require2("./signature");
      var ZipEntry = require2("./zipEntry");
      require2("./utf8");
      var support = require2("./support");
      function ZipEntries(loadOptions) {
        this.files = [];
        this.loadOptions = loadOptions;
      }
      ZipEntries.prototype = {
        /**
        * Check that the reader is on the specified signature.
        * @param {string} expectedSignature the expected signature.
        * @throws {Error} if it is an other signature.
        */
        checkSignature: function checkSignature(expectedSignature) {
          if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
          }
        },
        /**
        * Check if the given signature is at the given index.
        * @param {number} askedIndex the index to check.
        * @param {string} expectedSignature the signature to expect.
        * @return {boolean} true if the signature is here, false otherwise.
        */
        isSignature: function isSignature(askedIndex, expectedSignature) {
          var currentIndex = this.reader.index;
          this.reader.setIndex(askedIndex);
          var signature = this.reader.readString(4);
          var result = signature === expectedSignature;
          this.reader.setIndex(currentIndex);
          return result;
        },
        /**
        * Read the end of the central directory.
        */
        readBlockEndOfCentral: function readBlockEndOfCentral() {
          this.diskNumber = this.reader.readInt(2);
          this.diskWithCentralDirStart = this.reader.readInt(2);
          this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
          this.centralDirRecords = this.reader.readInt(2);
          this.centralDirSize = this.reader.readInt(4);
          this.centralDirOffset = this.reader.readInt(4);
          this.zipCommentLength = this.reader.readInt(2);
          var zipComment = this.reader.readData(this.zipCommentLength);
          var decodeParamType = support.uint8array ? "uint8array" : "array";
          var decodeContent = utils.transformTo(decodeParamType, zipComment);
          this.zipComment = this.loadOptions.decodeFileName(decodeContent);
        },
        /**
        * Read the end of the Zip 64 central directory.
        * Not merged with the method readEndOfCentral :
        * The end of central can coexist with its Zip64 brother,
        * I don't want to read the wrong number of bytes !
        */
        readBlockZip64EndOfCentral: function readBlockZip64EndOfCentral() {
          this.zip64EndOfCentralSize = this.reader.readInt(8);
          this.reader.skip(4);
          this.diskNumber = this.reader.readInt(4);
          this.diskWithCentralDirStart = this.reader.readInt(4);
          this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
          this.centralDirRecords = this.reader.readInt(8);
          this.centralDirSize = this.reader.readInt(8);
          this.centralDirOffset = this.reader.readInt(8);
          this.zip64ExtensibleData = {};
          var extraDataSize = this.zip64EndOfCentralSize - 44, index2 = 0, extraFieldId, extraFieldLength, extraFieldValue;
          while (index2 < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = { id: extraFieldId, length: extraFieldLength, value: extraFieldValue };
          }
        },
        /**
        * Read the end of the Zip 64 central directory locator.
        */
        readBlockZip64EndOfCentralLocator: function readBlockZip64EndOfCentralLocator() {
          this.diskWithZip64CentralDirStart = this.reader.readInt(4);
          this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
          this.disksCount = this.reader.readInt(4);
          if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
          }
        },
        /**
        * Read the local files, based on the offset read in the central part.
        */
        readLocalFiles: function readLocalFiles() {
          var i, file;
          for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
          }
        },
        /**
        * Read the central directory.
        */
        readCentralDir: function readCentralDir() {
          var file;
          this.reader.setIndex(this.centralDirOffset);
          while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({ zip64: this.zip64 }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
          }
          if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
              throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            }
          }
        },
        /**
        * Read the end of central directory.
        */
        readEndOfCentral: function readEndOfCentral() {
          var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
          if (offset < 0) {
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
            if (isGarbage) {
              throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
              throw new Error("Corrupted zip: can't find end of central directory");
            }
          }
          this.reader.setIndex(offset);
          var endOfCentralDirOffset = offset;
          this.checkSignature(sig.CENTRAL_DIRECTORY_END);
          this.readBlockEndOfCentral();
          if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
              this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
              if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
              }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
          }
          var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
          if (this.zip64) {
            expectedEndOfCentralDirOffset += 20;
            expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
          }
          var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
          if (extraBytes > 0) {
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER))
              ;
            else {
              this.reader.zero = extraBytes;
            }
          } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
          }
        },
        prepareReader: function prepareReader(data) {
          this.reader = readerFor(data);
        },
        /**
        * Read a zip file and create ZipEntries.
        * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
        */
        load: function load(data) {
          this.prepareReader(data);
          this.readEndOfCentral();
          this.readCentralDir();
          this.readLocalFiles();
        }
      };
      module2.exports = ZipEntries;
    }, { "./reader/readerFor": 411, "./signature": 412, "./support": 419, "./utf8": 420, "./utils": 421, "./zipEntry": 423 }], 423: [function(require2, module2, exports2) {
      var readerFor = require2("./reader/readerFor");
      var utils = require2("./utils");
      var CompressedObject = require2("./compressedObject");
      var crc32fn = require2("./crc32");
      var utf8 = require2("./utf8");
      var compressions = require2("./compressions");
      var support = require2("./support");
      var MADE_BY_DOS = 0;
      var MADE_BY_UNIX = 3;
      var findCompression = function findCompression2(compressionMethod) {
        for (var method in compressions) {
          if (!compressions.hasOwnProperty(method)) {
            continue;
          }
          if (compressions[method].magic === compressionMethod) {
            return compressions[method];
          }
        }
        return null;
      };
      function ZipEntry(options, loadOptions) {
        this.options = options;
        this.loadOptions = loadOptions;
      }
      ZipEntry.prototype = {
        /**
        * say if the file is encrypted.
        * @return {boolean} true if the file is encrypted, false otherwise.
        */
        isEncrypted: function isEncrypted() {
          return (this.bitFlag & 1) === 1;
        },
        /**
        * say if the file has utf-8 filename/comment.
        * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
        */
        useUTF8: function useUTF8() {
          return (this.bitFlag & 2048) === 2048;
        },
        /**
        * Read the local part of a zip file and add the info in this object.
        * @param {DataReader} reader the reader to use.
        */
        readLocalPart: function readLocalPart(reader) {
          var compression, localExtraFieldsLength;
          reader.skip(22);
          this.fileNameLength = reader.readInt(2);
          localExtraFieldsLength = reader.readInt(2);
          this.fileName = reader.readData(this.fileNameLength);
          reader.skip(localExtraFieldsLength);
          if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          }
          compression = findCompression(this.compressionMethod);
          if (compression === null) {
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
          }
          this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
        },
        /**
        * Read the central part of a zip file and add the info in this object.
        * @param {DataReader} reader the reader to use.
        */
        readCentralPart: function readCentralPart(reader) {
          this.versionMadeBy = reader.readInt(2);
          reader.skip(2);
          this.bitFlag = reader.readInt(2);
          this.compressionMethod = reader.readString(2);
          this.date = reader.readDate();
          this.crc32 = reader.readInt(4);
          this.compressedSize = reader.readInt(4);
          this.uncompressedSize = reader.readInt(4);
          var fileNameLength = reader.readInt(2);
          this.extraFieldsLength = reader.readInt(2);
          this.fileCommentLength = reader.readInt(2);
          this.diskNumberStart = reader.readInt(2);
          this.internalFileAttributes = reader.readInt(2);
          this.externalFileAttributes = reader.readInt(4);
          this.localHeaderOffset = reader.readInt(4);
          if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
          }
          reader.skip(fileNameLength);
          this.readExtraFields(reader);
          this.parseZIP64ExtraField(reader);
          this.fileComment = reader.readData(this.fileCommentLength);
        },
        /**
        * Parse the external file attributes and get the unix/dos permissions.
        */
        processAttributes: function processAttributes() {
          this.unixPermissions = null;
          this.dosPermissions = null;
          var madeBy = this.versionMadeBy >> 8;
          this.dir = this.externalFileAttributes & 16 ? true : false;
          if (madeBy === MADE_BY_DOS) {
            this.dosPermissions = this.externalFileAttributes & 63;
          }
          if (madeBy === MADE_BY_UNIX) {
            this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
          }
          if (!this.dir && this.fileNameStr.slice(-1) === "/") {
            this.dir = true;
          }
        },
        /**
        * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
        * @param {DataReader} reader the reader to use.
        */
        parseZIP64ExtraField: function parseZIP64ExtraField(reader) {
          if (!this.extraFields[1]) {
            return;
          }
          var extraReader = readerFor(this.extraFields[1].value);
          if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
          }
          if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
          }
          if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
          }
          if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
          }
        },
        /**
        * Read the central part of a zip file and add the info in this object.
        * @param {DataReader} reader the reader to use.
        */
        readExtraFields: function readExtraFields(reader) {
          var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
          if (!this.extraFields) {
            this.extraFields = {};
          }
          while (reader.index + 4 < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);
            this.extraFields[extraFieldId] = { id: extraFieldId, length: extraFieldLength, value: extraFieldValue };
          }
          reader.setIndex(end);
        },
        /**
        * Apply an UTF8 transformation if needed.
        */
        handleUTF8: function handleUTF8() {
          var decodeParamType = support.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
          } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
              this.fileNameStr = upath;
            } else {
              var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }
            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
              this.fileCommentStr = ucomment;
            } else {
              var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
          }
        },
        /**
        * Find the unicode path declared in the extra field, if any.
        * @return {String} the unicode path, null otherwise.
        */
        findExtraFieldUnicodePath: function findExtraFieldUnicodePath() {
          var upathField = this.extraFields[28789];
          if (upathField) {
            var extraReader = readerFor(upathField.value);
            if (extraReader.readInt(1) !== 1) {
              return null;
            }
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
              return null;
            }
            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
          }
          return null;
        },
        /**
        * Find the unicode comment declared in the extra field, if any.
        * @return {String} the unicode comment, null otherwise.
        */
        findExtraFieldUnicodeComment: function findExtraFieldUnicodeComment() {
          var ucommentField = this.extraFields[25461];
          if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);
            if (extraReader.readInt(1) !== 1) {
              return null;
            }
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
              return null;
            }
            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
          }
          return null;
        }
      };
      module2.exports = ZipEntry;
    }, { "./compressedObject": 391, "./compressions": 392, "./crc32": 393, "./reader/readerFor": 411, "./support": 419, "./utf8": 420, "./utils": 421 }], 424: [function(require2, module2, exports2) {
      var StreamHelper = require2("./stream/StreamHelper");
      var DataWorker = require2("./stream/DataWorker");
      var utf8 = require2("./utf8");
      var CompressedObject = require2("./compressedObject");
      var GenericWorker = require2("./stream/GenericWorker");
      var ZipObject = function ZipObject2(name, data, options) {
        this.name = name;
        this.dir = options.dir;
        this.date = options.date;
        this.comment = options.comment;
        this.unixPermissions = options.unixPermissions;
        this.dosPermissions = options.dosPermissions;
        this._data = data;
        this._dataBinary = options.binary;
        this.options = { compression: options.compression, compressionOptions: options.compressionOptions };
      };
      ZipObject.prototype = {
        /**
        * Create an internal stream for the content of this object.
        * @param {String} type the type of each chunk.
        * @return StreamHelper the stream.
        */
        internalStream: function internalStream(type) {
          var result = null, outputType = "string";
          try {
            if (!type) {
              throw new Error("No output type specified.");
            }
            outputType = type.toLowerCase();
            var askUnicodeString = outputType === "string" || outputType === "text";
            if (outputType === "binarystring" || outputType === "text") {
              outputType = "string";
            }
            result = this._decompressWorker();
            var isUnicodeString = !this._dataBinary;
            if (isUnicodeString && !askUnicodeString) {
              result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            if (!isUnicodeString && askUnicodeString) {
              result = result.pipe(new utf8.Utf8DecodeWorker());
            }
          } catch (e) {
            result = new GenericWorker("error");
            result.error(e);
          }
          return new StreamHelper(result, outputType, "");
        },
        /**
        * Prepare the content in the asked type.
        * @param {String} type the type of the result.
        * @param {Function} onUpdate a function to call on each internal update.
        * @return Promise the promise of the result.
        */
        async: function async(type, onUpdate) {
          return this.internalStream(type).accumulate(onUpdate);
        },
        /**
        * Prepare the content as a nodejs stream.
        * @param {String} type the type of each chunk.
        * @param {Function} onUpdate a function to call on each internal update.
        * @return Stream the stream.
        */
        nodeStream: function nodeStream(type, onUpdate) {
          return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
        },
        /**
        * Return a worker for the compressed content.
        * @private
        * @param {Object} compression the compression object to use.
        * @param {Object} compressionOptions the options to use when compressing.
        * @return Worker the worker.
        */
        _compressWorker: function _compressWorker(compression, compressionOptions) {
          if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
            return this._data.getCompressedWorker();
          } else {
            var result = this._decompressWorker();
            if (!this._dataBinary) {
              result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
          }
        },
        /**
        * Return a worker for the decompressed content.
        * @private
        * @return Worker the worker.
        */
        _decompressWorker: function _decompressWorker() {
          if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
          } else if (this._data instanceof GenericWorker) {
            return this._data;
          } else {
            return new DataWorker(this._data);
          }
        }
      };
      var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
      var removedFn = function removedFn2() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      };
      for (var i = 0; i < removedMethods.length; i++) {
        ZipObject.prototype[removedMethods[i]] = removedFn;
      }
      module2.exports = ZipObject;
    }, { "./compressedObject": 391, "./stream/DataWorker": 416, "./stream/GenericWorker": 417, "./stream/StreamHelper": 418, "./utf8": 420 }], 425: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var immediate = require2("immediate");
      function INTERNAL() {
      }
      var handlers = {};
      var REJECTED = ["REJECTED"];
      var FULFILLED = ["FULFILLED"];
      var PENDING = ["PENDING"];
      module2.exports = Promise2;
      function Promise2(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function");
        }
        this.state = PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (resolver !== INTERNAL) {
          safelyResolveThenable(this, resolver);
        }
      }
      Promise2.prototype["finally"] = function(callback) {
        if (typeof callback !== "function") {
          return this;
        }
        var p = this.constructor;
        return this.then(resolve2, reject2);
        function resolve2(value) {
          function yes() {
            return value;
          }
          return p.resolve(callback()).then(yes);
        }
        function reject2(reason) {
          function no() {
            throw reason;
          }
          return p.resolve(callback()).then(no);
        }
      };
      Promise2.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
      };
      Promise2.prototype.then = function(onFulfilled, onRejected) {
        if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
          return this;
        }
        var promise = new this.constructor(INTERNAL);
        if (this.state !== PENDING) {
          var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
          unwrap(promise, resolver, this.outcome);
        } else {
          this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }
        return promise;
      };
      function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;
        if (typeof onFulfilled === "function") {
          this.onFulfilled = onFulfilled;
          this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === "function") {
          this.onRejected = onRejected;
          this.callRejected = this.otherCallRejected;
        }
      }
      QueueItem.prototype.callFulfilled = function(value) {
        handlers.resolve(this.promise, value);
      };
      QueueItem.prototype.otherCallFulfilled = function(value) {
        unwrap(this.promise, this.onFulfilled, value);
      };
      QueueItem.prototype.callRejected = function(value) {
        handlers.reject(this.promise, value);
      };
      QueueItem.prototype.otherCallRejected = function(value) {
        unwrap(this.promise, this.onRejected, value);
      };
      function unwrap(promise, func, value) {
        immediate(function() {
          var returnValue;
          try {
            returnValue = func(value);
          } catch (e) {
            return handlers.reject(promise, e);
          }
          if (returnValue === promise) {
            handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
          } else {
            handlers.resolve(promise, returnValue);
          }
        });
      }
      handlers.resolve = function(self2, value) {
        var result = tryCatch(getThen, value);
        if (result.status === "error") {
          return handlers.reject(self2, result.value);
        }
        var thenable = result.value;
        if (thenable) {
          safelyResolveThenable(self2, thenable);
        } else {
          self2.state = FULFILLED;
          self2.outcome = value;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callFulfilled(value);
          }
        }
        return self2;
      };
      handlers.reject = function(self2, error) {
        self2.state = REJECTED;
        self2.outcome = error;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callRejected(error);
        }
        return self2;
      };
      function getThen(obj) {
        var then = obj && obj.then;
        if (obj && (_typeof2(obj) === "object" || typeof obj === "function") && typeof then === "function") {
          return function appyThen() {
            then.apply(obj, arguments);
          };
        }
      }
      function safelyResolveThenable(self2, thenable) {
        var called = false;
        function onError(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.reject(self2, value);
        }
        function onSuccess(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.resolve(self2, value);
        }
        function tryToUnwrap() {
          thenable(onSuccess, onError);
        }
        var result = tryCatch(tryToUnwrap);
        if (result.status === "error") {
          onError(result.value);
        }
      }
      function tryCatch(func, value) {
        var out = {};
        try {
          out.value = func(value);
          out.status = "success";
        } catch (e) {
          out.status = "error";
          out.value = e;
        }
        return out;
      }
      Promise2.resolve = resolve;
      function resolve(value) {
        if (value instanceof this) {
          return value;
        }
        return handlers.resolve(new this(INTERNAL), value);
      }
      Promise2.reject = reject;
      function reject(reason) {
        var promise = new this(INTERNAL);
        return handlers.reject(promise, reason);
      }
      Promise2.all = all;
      function all(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var values = new Array(len);
        var resolved = 0;
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          allResolver(iterable[i], i);
        }
        return promise;
        function allResolver(value, i2) {
          self2.resolve(value).then(resolveFromAll, function(error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });
          function resolveFromAll(outValue) {
            values[i2] = outValue;
            if (++resolved === len && !called) {
              called = true;
              handlers.resolve(promise, values);
            }
          }
        }
      }
      Promise2.race = race;
      function race(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          resolver(iterable[i]);
        }
        return promise;
        function resolver(value) {
          self2.resolve(value).then(function(response) {
            if (!called) {
              called = true;
              handlers.resolve(promise, response);
            }
          }, function(error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });
        }
      }
    }, { "immediate": 386 }], 426: [function(require2, module2, exports2) {
      (function(global2) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        var INFINITY = 1 / 0;
        var symbolTag = "[object Symbol]";
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var freeGlobal = (typeof global2 === "undefined" ? "undefined" : _typeof2(global2)) == "object" && global2 && global2.Object === Object && global2;
        var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof2(self)) == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var objectProto = Object.prototype;
        var objectToString = objectProto.toString;
        var _Symbol = root.Symbol;
        var symbolProto = _Symbol ? _Symbol.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function isObjectLike(value) {
          return !!value && _typeof2(value) == "object";
        }
        function isSymbol(value) {
          return _typeof2(value) == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
        }
        function toString2(value) {
          return value == null ? "" : baseToString(value);
        }
        function escapeRegExp(string) {
          string = toString2(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        module2.exports = escapeRegExp;
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 427: [function(require2, module2, exports2) {
      (function(global2) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        var LARGE_ARRAY_SIZE = 200;
        var FUNC_ERROR_TEXT = "Expected a function";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reEscapeChar = /\\(\\)?/g;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var freeGlobal = (typeof global2 === "undefined" ? "undefined" : _typeof2(global2)) == "object" && global2 && global2.Object === Object && global2;
        var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof2(self)) == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = (typeof exports2 === "undefined" ? "undefined" : _typeof2(exports2)) == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule = freeExports && (typeof module2 === "undefined" ? "undefined" : _typeof2(module2)) == "object" && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            return freeProcess && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index2 = -1, length = array ? array.length : 0;
          while (++index2 < length) {
            var value = array[index2];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index2 = -1, length = array ? array.length : 0;
          while (++index2 < length) {
            if (predicate(array[index2], index2, array)) {
              return true;
            }
          }
          return false;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? void 0 : object[key];
          };
        }
        function baseTimes(n, iteratee) {
          var index2 = -1, result = Array(n);
          while (++index2 < n) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function getValue(object, key) {
          return object == null ? void 0 : object[key];
        }
        function isHostObject(value) {
          var result = false;
          if (value != null && typeof value.toString != "function") {
            try {
              result = !!(value + "");
            } catch (e) {
            }
          }
          return result;
        }
        function mapToArray(map) {
          var index2 = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index2] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function setToArray(set) {
          var index2 = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index2] = value;
          });
          return result;
        }
        var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
        var coreJsData = root["__core-js_shared__"];
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var funcToString = funcProto.toString;
        var hasOwnProperty3 = objectProto.hasOwnProperty;
        var objectToString = objectProto.toString;
        var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var _Symbol = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
        var nativeKeys = overArg(Object.keys, Object);
        var DataView = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = _Symbol ? _Symbol.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
        function Hash(entries) {
          var index2 = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
        }
        function hashDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? void 0 : result;
          }
          return hasOwnProperty3.call(data, key) ? data[key] : void 0;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== void 0 : hasOwnProperty3.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index2, 1);
          }
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? void 0 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.__data__ = { "hash": new Hash(), "map": new (Map2 || ListCache)(), "string": new Hash() };
        }
        function mapCacheDelete(key) {
          return getMapData(this, key)["delete"](key);
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          getMapData(this, key).set(key, value);
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values) {
          var index2 = -1, length = values ? values.length : 0;
          this.__data__ = new MapCache();
          while (++index2 < length) {
            this.add(values[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          this.__data__ = new ListCache(entries);
        }
        function stackClear() {
          this.__data__ = new ListCache();
        }
        function stackDelete(key) {
          return this.__data__["delete"](key);
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var cache2 = this.__data__;
          if (cache2 instanceof ListCache) {
            var pairs = cache2.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              return this;
            }
            cache2 = this.__data__ = new MapCache(pairs);
          }
          cache2.set(key, value);
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
          var length = result.length, skipIndexes = !!length;
          for (var key in value) {
            if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee(value), collection2);
          });
          return accumulator;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseFor = createBaseFor();
        function baseForOwn(object, iteratee) {
          return object && baseFor(object, iteratee, keys);
        }
        function baseGet(object, path) {
          path = isKey(path, object) ? [path] : castPath(path);
          var index2 = 0, length = path.length;
          while (object != null && index2 < length) {
            object = object[toKey(path[index2++])];
          }
          return index2 && index2 == length ? object : void 0;
        }
        function baseGetTag(value) {
          return objectToString.call(value);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }
        function baseIsEqual(value, other, customizer, bitmask, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
          if (!objIsArr) {
            objTag = getTag(object);
            objTag = objTag == argsTag ? objectTag : objTag;
          }
          if (!othIsArr) {
            othTag = getTag(other);
            othTag = othTag == argsTag ? objectTag : othTag;
          }
          var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
          }
          if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index2 = matchData.length, length = index2, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index2--) {
            var data = matchData[index2];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index2 < length) {
            data = matchData[index2];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === void 0 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (_typeof2(value) == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty3.call(object, key) && key != "constructor") {
              result.push(key);
            }
          }
          return result;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
          };
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function castPath(value) {
          return isArray(value) ? value : stringToPath(value);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, baseIteratee(iteratee), accumulator);
          };
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
            while (fromRight ? index2-- : ++index2 < length) {
              if (iteratee(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var index2 = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var stacked = stack.get(array);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var index2 = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== void 0) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
                  return seen.add(othIndex);
                }
              })) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              result = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result;
        }
        function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= UNORDERED_COMPARE_FLAG;
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
              stack["delete"](object);
              return result;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
              return false;
            }
          }
          var stacked = stack.get(object);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result;
        }
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result = keys(object), length = result.length;
          while (length--) {
            var key = result[length], value = object[key];
            result[length] = [key, value, isStrictComparable(value)];
          }
          return result;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : void 0;
        }
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function getTag2(value) {
            var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result;
          };
        }
        function hasPath(object, path, hasFunc) {
          path = isKey(path, object) ? [path] : castPath(path);
          var result, index2 = -1, length = path.length;
          while (++index2 < length) {
            var key = toKey(path[index2]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result) {
            return result;
          }
          var length = object ? object.length : 0;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function isIndex(value, length) {
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = _typeof2(value);
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
        }
        function isKeyable(value) {
          var type = _typeof2(value);
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
          };
        }
        var stringToPath = memoize(function(string) {
          string = toString2(string);
          var result = [];
          if (reLeadingDot.test(string)) {
            result.push("");
          }
          string.replace(rePropName, function(match, number, quote, string2) {
            result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
          });
          return result;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty3.call(result, key)) {
            result[key].push(value);
          } else {
            result[key] = [value];
          }
        });
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver && typeof resolver != "function") {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function memoized2() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized2.cache;
            if (cache2.has(key)) {
              return cache2.get(key);
            }
            var result = func.apply(this, args);
            memoized2.cache = cache2.set(key, result);
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        function isArguments(value) {
          return isArrayLikeObject(value) && hasOwnProperty3.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
        }
        var isArray = Array.isArray;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isFunction(value) {
          var tag = isObject(value) ? objectToString.call(value) : "";
          return tag == funcTag || tag == genTag;
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = _typeof2(value);
          return !!value && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return !!value && _typeof2(value) == "object";
        }
        function isSymbol(value) {
          return _typeof2(value) == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function toString2(value) {
          return value == null ? "" : baseToString(value);
        }
        function get(object, path, defaultValue) {
          var result = object == null ? void 0 : baseGet(object, path);
          return result === void 0 ? defaultValue : result;
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function identity(value) {
          return value;
        }
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        module2.exports = groupBy;
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 428: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var boolTag = "[object Boolean]";
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
      }
      function isObjectLike(value) {
        return !!value && _typeof2(value) == "object";
      }
      module2.exports = isBoolean;
    }, {}], 429: [function(require2, module2, exports2) {
      (function(global2) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        var LARGE_ARRAY_SIZE = 200;
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var MAX_SAFE_INTEGER = 9007199254740991;
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var freeGlobal = (typeof global2 === "undefined" ? "undefined" : _typeof2(global2)) == "object" && global2 && global2.Object === Object && global2;
        var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof2(self)) == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = (typeof exports2 === "undefined" ? "undefined" : _typeof2(exports2)) == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule = freeExports && (typeof module2 === "undefined" ? "undefined" : _typeof2(module2)) == "object" && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function arrayFilter(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index2 < length) {
            var value = array[index2];
            if (predicate(value, index2, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayPush(array, values) {
          var index2 = -1, length = values.length, offset = array.length;
          while (++index2 < length) {
            array[offset + index2] = values[index2];
          }
          return array;
        }
        function arraySome(array, predicate) {
          var index2 = -1, length = array == null ? 0 : array.length;
          while (++index2 < length) {
            if (predicate(array[index2], index2, array)) {
              return true;
            }
          }
          return false;
        }
        function baseTimes(n, iteratee) {
          var index2 = -1, result = Array(n);
          while (++index2 < n) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function cacheHas(cache2, key) {
          return cache2.has(key);
        }
        function getValue(object, key) {
          return object == null ? void 0 : object[key];
        }
        function mapToArray(map) {
          var index2 = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index2] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function setToArray(set) {
          var index2 = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index2] = value;
          });
          return result;
        }
        var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
        var coreJsData = root["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty3 = objectProto.hasOwnProperty;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer = moduleExports ? root.Buffer : void 0, _Symbol = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
        var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
        var DataView = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = _Symbol ? _Symbol.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
        function Hash(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? void 0 : result;
          }
          return hasOwnProperty3.call(data, key) ? data[key] : void 0;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== void 0 : hasOwnProperty3.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? void 0 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = { "hash": new Hash(), "map": new (Map2 || ListCache)(), "string": new Hash() };
        }
        function mapCacheDelete(key) {
          var result = getMapData(this, key)["delete"](key);
          this.size -= result ? 1 : 0;
          return result;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size = data.size;
          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values) {
          var index2 = -1, length = values == null ? 0 : values.length;
          this.__data__ = new MapCache();
          while (++index2 < length) {
            this.add(values[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result = data["delete"](key);
          this.size = data.size;
          return result;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === void 0 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty3.call(object, key) && key != "constructor") {
              result.push(key);
            }
          }
          return result;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var stacked = stack.get(array);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
          stack.set(array, other);
          stack.set(other, array);
          while (++index2 < arrLength) {
            var arrValue = array[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
            }
            if (compared !== void 0) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
              return false;
            }
          }
          var stacked = stack.get(object);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result;
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : void 0;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = void 0;
            var unmasked = true;
          } catch (e) {
          }
          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function getTag2(value) {
            var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result;
          };
        }
        function isIndex(value, length) {
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
        }
        function isKeyable(value) {
          var type = _typeof2(value);
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array.isArray;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = _typeof2(value);
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && _typeof2(value) == "object";
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        module2.exports = isEqual;
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 430: [function(require2, module2, exports2) {
      (function(global2) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", nullTag = "[object Null]", proxyTag = "[object Proxy]", undefinedTag = "[object Undefined]";
        var freeGlobal = (typeof global2 === "undefined" ? "undefined" : _typeof2(global2)) == "object" && global2 && global2.Object === Object && global2;
        var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof2(self)) == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var objectProto = Object.prototype;
        var hasOwnProperty3 = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var _Symbol = root.Symbol, symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
        function baseGetTag(value) {
          if (value == null) {
            return value === void 0 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = void 0;
            var unmasked = true;
          } catch (e) {
          }
          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isObject(value) {
          var type = _typeof2(value);
          return value != null && (type == "object" || type == "function");
        }
        module2.exports = isFunction;
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 431: [function(require2, module2, exports2) {
      function isNil(value) {
        return value == null;
      }
      module2.exports = isNil;
    }, {}], 432: [function(require2, module2, exports2) {
      function isUndefined(value) {
        return value === void 0;
      }
      module2.exports = isUndefined;
    }, {}], 433: [function(require2, module2, exports2) {
      (function(global2) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        var LARGE_ARRAY_SIZE = 200;
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var INFINITY = 1 / 0;
        var funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var freeGlobal = (typeof global2 === "undefined" ? "undefined" : _typeof2(global2)) == "object" && global2 && global2.Object === Object && global2;
        var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof2(self)) == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        function arrayIncludes(array, value) {
          var length = array ? array.length : 0;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index2 = -1, length = array ? array.length : 0;
          while (++index2 < length) {
            if (comparator(value, array[index2])) {
              return true;
            }
          }
          return false;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length) {
            if (predicate(array[index2], index2, array)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          if (value !== value) {
            return baseFindIndex(array, baseIsNaN, fromIndex);
          }
          var index2 = fromIndex - 1, length = array.length;
          while (++index2 < length) {
            if (array[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function cacheHas(cache2, key) {
          return cache2.has(key);
        }
        function getValue(object, key) {
          return object == null ? void 0 : object[key];
        }
        function isHostObject(value) {
          var result = false;
          if (value != null && typeof value.toString != "function") {
            try {
              result = !!(value + "");
            } catch (e) {
            }
          }
          return result;
        }
        function setToArray(set) {
          var index2 = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index2] = value;
          });
          return result;
        }
        var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
        var coreJsData = root["__core-js_shared__"];
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var funcToString = funcProto.toString;
        var hasOwnProperty3 = objectProto.hasOwnProperty;
        var objectToString = objectProto.toString;
        var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var splice = arrayProto.splice;
        var Map2 = getNative(root, "Map"), Set2 = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
        function Hash(entries) {
          var index2 = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
        }
        function hashDelete(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? void 0 : result;
          }
          return hasOwnProperty3.call(data, key) ? data[key] : void 0;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== void 0 : hasOwnProperty3.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index2, 1);
          }
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? void 0 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index2 < length) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.__data__ = { "hash": new Hash(), "map": new (Map2 || ListCache)(), "string": new Hash() };
        }
        function mapCacheDelete(key) {
          return getMapData(this, key)["delete"](key);
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          getMapData(this, key).set(key, value);
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values) {
          var index2 = -1, length = values ? values.length : 0;
          this.__data__ = new MapCache();
          while (++index2 < length) {
            this.add(values[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseUniq(array, iteratee, comparator) {
          var index2 = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
          if (comparator) {
            isCommon = false;
            includes = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set = iteratee ? null : createSet(array);
            if (set) {
              return setToArray(set);
            }
            isCommon = false;
            includes = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee ? [] : result;
          }
          outer:
            while (++index2 < length) {
              var value = array[index2], computed = iteratee ? iteratee(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee) {
                  seen.push(computed);
                }
                result.push(value);
              } else if (!includes(seen, computed, comparator)) {
                if (seen !== result) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
          return result;
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
          return new Set2(values);
        };
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : void 0;
        }
        function isKeyable(value) {
          var type = _typeof2(value);
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        function isFunction(value) {
          var tag = isObject(value) ? objectToString.call(value) : "";
          return tag == funcTag || tag == genTag;
        }
        function isObject(value) {
          var type = _typeof2(value);
          return !!value && (type == "object" || type == "function");
        }
        function noop() {
        }
        module2.exports = uniq;
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 434: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var HashBase = require2("hash-base");
      var Buffer = require2("safe-buffer").Buffer;
      var ARRAY16 = new Array(16);
      function MD5() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
      }
      inherits(MD5, HashBase);
      MD5.prototype._update = function() {
        var M = ARRAY16;
        for (var i = 0; i < 16; ++i) {
          M[i] = this._block.readInt32LE(i * 4);
        }
        var a = this._a;
        var b = this._b;
        var c = this._c;
        var d = this._d;
        a = fnF(a, b, c, d, M[0], 3614090360, 7);
        d = fnF(d, a, b, c, M[1], 3905402710, 12);
        c = fnF(c, d, a, b, M[2], 606105819, 17);
        b = fnF(b, c, d, a, M[3], 3250441966, 22);
        a = fnF(a, b, c, d, M[4], 4118548399, 7);
        d = fnF(d, a, b, c, M[5], 1200080426, 12);
        c = fnF(c, d, a, b, M[6], 2821735955, 17);
        b = fnF(b, c, d, a, M[7], 4249261313, 22);
        a = fnF(a, b, c, d, M[8], 1770035416, 7);
        d = fnF(d, a, b, c, M[9], 2336552879, 12);
        c = fnF(c, d, a, b, M[10], 4294925233, 17);
        b = fnF(b, c, d, a, M[11], 2304563134, 22);
        a = fnF(a, b, c, d, M[12], 1804603682, 7);
        d = fnF(d, a, b, c, M[13], 4254626195, 12);
        c = fnF(c, d, a, b, M[14], 2792965006, 17);
        b = fnF(b, c, d, a, M[15], 1236535329, 22);
        a = fnG(a, b, c, d, M[1], 4129170786, 5);
        d = fnG(d, a, b, c, M[6], 3225465664, 9);
        c = fnG(c, d, a, b, M[11], 643717713, 14);
        b = fnG(b, c, d, a, M[0], 3921069994, 20);
        a = fnG(a, b, c, d, M[5], 3593408605, 5);
        d = fnG(d, a, b, c, M[10], 38016083, 9);
        c = fnG(c, d, a, b, M[15], 3634488961, 14);
        b = fnG(b, c, d, a, M[4], 3889429448, 20);
        a = fnG(a, b, c, d, M[9], 568446438, 5);
        d = fnG(d, a, b, c, M[14], 3275163606, 9);
        c = fnG(c, d, a, b, M[3], 4107603335, 14);
        b = fnG(b, c, d, a, M[8], 1163531501, 20);
        a = fnG(a, b, c, d, M[13], 2850285829, 5);
        d = fnG(d, a, b, c, M[2], 4243563512, 9);
        c = fnG(c, d, a, b, M[7], 1735328473, 14);
        b = fnG(b, c, d, a, M[12], 2368359562, 20);
        a = fnH(a, b, c, d, M[5], 4294588738, 4);
        d = fnH(d, a, b, c, M[8], 2272392833, 11);
        c = fnH(c, d, a, b, M[11], 1839030562, 16);
        b = fnH(b, c, d, a, M[14], 4259657740, 23);
        a = fnH(a, b, c, d, M[1], 2763975236, 4);
        d = fnH(d, a, b, c, M[4], 1272893353, 11);
        c = fnH(c, d, a, b, M[7], 4139469664, 16);
        b = fnH(b, c, d, a, M[10], 3200236656, 23);
        a = fnH(a, b, c, d, M[13], 681279174, 4);
        d = fnH(d, a, b, c, M[0], 3936430074, 11);
        c = fnH(c, d, a, b, M[3], 3572445317, 16);
        b = fnH(b, c, d, a, M[6], 76029189, 23);
        a = fnH(a, b, c, d, M[9], 3654602809, 4);
        d = fnH(d, a, b, c, M[12], 3873151461, 11);
        c = fnH(c, d, a, b, M[15], 530742520, 16);
        b = fnH(b, c, d, a, M[2], 3299628645, 23);
        a = fnI(a, b, c, d, M[0], 4096336452, 6);
        d = fnI(d, a, b, c, M[7], 1126891415, 10);
        c = fnI(c, d, a, b, M[14], 2878612391, 15);
        b = fnI(b, c, d, a, M[5], 4237533241, 21);
        a = fnI(a, b, c, d, M[12], 1700485571, 6);
        d = fnI(d, a, b, c, M[3], 2399980690, 10);
        c = fnI(c, d, a, b, M[10], 4293915773, 15);
        b = fnI(b, c, d, a, M[1], 2240044497, 21);
        a = fnI(a, b, c, d, M[8], 1873313359, 6);
        d = fnI(d, a, b, c, M[15], 4264355552, 10);
        c = fnI(c, d, a, b, M[6], 2734768916, 15);
        b = fnI(b, c, d, a, M[13], 1309151649, 21);
        a = fnI(a, b, c, d, M[4], 4149444226, 6);
        d = fnI(d, a, b, c, M[11], 3174756917, 10);
        c = fnI(c, d, a, b, M[2], 718787259, 15);
        b = fnI(b, c, d, a, M[9], 3951481745, 21);
        this._a = this._a + a | 0;
        this._b = this._b + b | 0;
        this._c = this._c + c | 0;
        this._d = this._d + d | 0;
      };
      MD5.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer = Buffer.allocUnsafe(16);
        buffer.writeInt32LE(this._a, 0);
        buffer.writeInt32LE(this._b, 4);
        buffer.writeInt32LE(this._c, 8);
        buffer.writeInt32LE(this._d, 12);
        return buffer;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fnF(a, b, c, d, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
      }
      function fnG(a, b, c, d, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
      }
      function fnH(a, b, c, d, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
      }
      function fnI(a, b, c, d, m, k, s) {
        return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
      }
      module2.exports = MD5;
    }, { "hash-base": 370, "inherits": 387, "safe-buffer": 494 }], 435: [function(require2, module2, exports2) {
      var bn = require2("bn.js");
      var brorand = require2("brorand");
      function MillerRabin(rand) {
        this.rand = rand || new brorand.Rand();
      }
      module2.exports = MillerRabin;
      MillerRabin.create = function create(rand) {
        return new MillerRabin(rand);
      };
      MillerRabin.prototype._randbelow = function _randbelow(n) {
        var len = n.bitLength();
        var min_bytes = Math.ceil(len / 8);
        do {
          var a = new bn(this.rand.generate(min_bytes));
        } while (a.cmp(n) >= 0);
        return a;
      };
      MillerRabin.prototype._randrange = function _randrange(start, stop) {
        var size = stop.sub(start);
        return start.add(this._randbelow(size));
      };
      MillerRabin.prototype.test = function test(n, k, cb) {
        var len = n.bitLength();
        var red = bn.mont(n);
        var rone = new bn(1).toRed(red);
        if (!k)
          k = Math.max(1, len / 48 | 0);
        var n1 = n.subn(1);
        for (var s = 0; !n1.testn(s); s++) {
        }
        var d = n.shrn(s);
        var rn1 = n1.toRed(red);
        var prime = true;
        for (; k > 0; k--) {
          var a = this._randrange(new bn(2), n1);
          if (cb)
            cb(a);
          var x = a.toRed(red).redPow(d);
          if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
            continue;
          for (var i = 1; i < s; i++) {
            x = x.redSqr();
            if (x.cmp(rone) === 0)
              return false;
            if (x.cmp(rn1) === 0)
              break;
          }
          if (i === s)
            return false;
        }
        return prime;
      };
      MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
        var len = n.bitLength();
        var red = bn.mont(n);
        var rone = new bn(1).toRed(red);
        if (!k)
          k = Math.max(1, len / 48 | 0);
        var n1 = n.subn(1);
        for (var s = 0; !n1.testn(s); s++) {
        }
        var d = n.shrn(s);
        var rn1 = n1.toRed(red);
        for (; k > 0; k--) {
          var a = this._randrange(new bn(2), n1);
          var g = n.gcd(a);
          if (g.cmpn(1) !== 0)
            return g;
          var x = a.toRed(red).redPow(d);
          if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
            continue;
          for (var i = 1; i < s; i++) {
            x = x.redSqr();
            if (x.cmp(rone) === 0)
              return x.fromRed().subn(1).gcd(n);
            if (x.cmp(rn1) === 0)
              break;
          }
          if (i === s) {
            x = x.redSqr();
            return x.fromRed().subn(1).gcd(n);
          }
        }
        return false;
      };
    }, { "bn.js": 436, "brorand": 184 }], 436: [function(require2, module2, exports2) {
      arguments[4][181][0].apply(exports2, arguments);
    }, { "buffer": 185, "dup": 181 }], 437: [function(require2, module2, exports2) {
      module2.exports = assert;
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert.equal = function assertEqual(l, r, msg) {
        if (l != r)
          throw new Error(msg || "Assertion failed: " + l + " != " + r);
      };
    }, {}], 438: [function(require2, module2, exports2) {
      var utils = exports2;
      function toArray(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i = 0; i < msg.length; i++) {
            res[i] = msg[i] | 0;
          }
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i = 0; i < msg.length; i += 2) {
            res.push(parseInt(msg[i] + msg[i + 1], 16));
          }
        } else {
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            var hi = c >> 8;
            var lo = c & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex2(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          res += zero2(msg[i].toString(16));
        }
        return res;
      }
      utils.toHex = toHex2;
      utils.encode = function encode(arr, enc) {
        if (enc === "hex")
          return toHex2(arr);
        else
          return arr;
      };
    }, {}], 439: [function(require2, module2, exports2) {
      var assign = require2("./lib/utils/common").assign;
      var deflate = require2("./lib/deflate");
      var inflate = require2("./lib/inflate");
      var constants = require2("./lib/zlib/constants");
      var pako = {};
      assign(pako, deflate, inflate, constants);
      module2.exports = pako;
    }, { "./lib/deflate": 440, "./lib/inflate": 441, "./lib/utils/common": 442, "./lib/zlib/constants": 445 }], 440: [function(require2, module2, exports2) {
      var zlib_deflate = require2("./zlib/deflate");
      var utils = require2("./utils/common");
      var strings = require2("./utils/strings");
      var msg = require2("./zlib/messages");
      var ZStream = require2("./zlib/zstream");
      var toString2 = Object.prototype.toString;
      var Z_NO_FLUSH = 0;
      var Z_FINISH = 4;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_SYNC_FLUSH = 2;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_DEFLATED = 8;
      function Deflate(options) {
        if (!(this instanceof Deflate))
          return new Deflate(options);
        this.options = utils.assign({ level: Z_DEFAULT_COMPRESSION, method: Z_DEFLATED, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: Z_DEFAULT_STRATEGY, to: "" }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
          var dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
          } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
          } else {
            dict = opt.dictionary;
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          this._dict_set = true;
        }
      }
      Deflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        if (this.ended) {
          return false;
        }
        _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data);
        } else if (toString2.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_deflate.deflate(strm, _mode);
          if (status !== Z_STREAM_END && status !== Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
        if (_mode === Z_FINISH) {
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (_mode === Z_SYNC_FLUSH) {
          this.onEnd(Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function deflate(input, options) {
        var deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg || msg[deflator.err];
        }
        return deflator.result;
      }
      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
      }
      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
      }
      exports2.Deflate = Deflate;
      exports2.deflate = deflate;
      exports2.deflateRaw = deflateRaw;
      exports2.gzip = gzip;
    }, { "./utils/common": 442, "./utils/strings": 443, "./zlib/deflate": 447, "./zlib/messages": 452, "./zlib/zstream": 454 }], 441: [function(require2, module2, exports2) {
      var zlib_inflate = require2("./zlib/inflate");
      var utils = require2("./utils/common");
      var strings = require2("./utils/strings");
      var c = require2("./zlib/constants");
      var msg = require2("./zlib/messages");
      var ZStream = require2("./zlib/zstream");
      var GZheader = require2("./zlib/gzheader");
      var toString2 = Object.prototype.toString;
      function Inflate(options) {
        if (!(this instanceof Inflate))
          return new Inflate(options);
        this.options = utils.assign({ chunkSize: 16384, windowBits: 0, to: "" }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15;
          }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
          opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
          }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
        if (status !== c.Z_OK) {
          throw new Error(msg[status]);
        }
        this.header = new GZheader();
        zlib_inflate.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
          if (typeof opt.dictionary === "string") {
            opt.dictionary = strings.string2buf(opt.dictionary);
          } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
            opt.dictionary = new Uint8Array(opt.dictionary);
          }
          if (opt.raw) {
            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== c.Z_OK) {
              throw new Error(msg[status]);
            }
          }
        }
      }
      Inflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var dictionary = this.options.dictionary;
        var status, _mode;
        var next_out_utf8, tail, utf8str;
        var allowBufError = false;
        if (this.ended) {
          return false;
        }
        _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.binstring2buf(data);
        } else if (toString2.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
          if (status === c.Z_NEED_DICT && dictionary) {
            status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
          }
          if (status === c.Z_BUF_ERROR && allowBufError === true) {
            status = c.Z_OK;
            allowBufError = false;
          }
          if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                tail = strm.next_out - next_out_utf8;
                utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail) {
                  utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                }
                this.onData(utf8str);
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
              }
            }
          }
          if (strm.avail_in === 0 && strm.avail_out === 0) {
            allowBufError = true;
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
        if (status === c.Z_STREAM_END) {
          _mode = c.Z_FINISH;
        }
        if (_mode === c.Z_FINISH) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === c.Z_OK;
        }
        if (_mode === c.Z_SYNC_FLUSH) {
          this.onEnd(c.Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === c.Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function inflate(input, options) {
        var inflator = new Inflate(options);
        inflator.push(input, true);
        if (inflator.err) {
          throw inflator.msg || msg[inflator.err];
        }
        return inflator.result;
      }
      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
      }
      exports2.Inflate = Inflate;
      exports2.inflate = inflate;
      exports2.inflateRaw = inflateRaw;
      exports2.ungzip = inflate;
    }, { "./utils/common": 442, "./utils/strings": 443, "./zlib/constants": 445, "./zlib/gzheader": 448, "./zlib/inflate": 450, "./zlib/messages": 452, "./zlib/zstream": 454 }], 442: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
      function _has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      exports2.assign = function(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue;
          }
          if (_typeof2(source) !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (var p in source) {
            if (_has(source, p)) {
              obj[p] = source[p];
            }
          }
        }
        return obj;
      };
      exports2.shrinkBuf = function(buf, size) {
        if (buf.length === size) {
          return buf;
        }
        if (buf.subarray) {
          return buf.subarray(0, size);
        }
        buf.length = size;
        return buf;
      };
      var fnTyped = {
        arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return;
          }
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function flattenChunks(chunks) {
          var i, l, len, pos, chunk, result;
          len = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length;
          }
          result = new Uint8Array(len);
          pos = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
          }
          return result;
        }
      };
      var fnUntyped = {
        arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function flattenChunks(chunks) {
          return [].concat.apply([], chunks);
        }
      };
      exports2.setTyped = function(on) {
        if (on) {
          exports2.Buf8 = Uint8Array;
          exports2.Buf16 = Uint16Array;
          exports2.Buf32 = Int32Array;
          exports2.assign(exports2, fnTyped);
        } else {
          exports2.Buf8 = Array;
          exports2.Buf16 = Array;
          exports2.Buf32 = Array;
          exports2.assign(exports2, fnUntyped);
        }
      };
      exports2.setTyped(TYPED_OK);
    }, {}], 443: [function(require2, module2, exports2) {
      var utils = require2("./common");
      var STR_APPLY_OK = true;
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (__) {
        STR_APPLY_OK = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      var _utf8len = new utils.Buf8(256);
      for (var q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
      }
      _utf8len[254] = _utf8len[254] = 1;
      exports2.string2buf = function(str) {
        var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new utils.Buf8(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          if (c < 128) {
            buf[i++] = c;
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63;
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          }
        }
        return buf;
      };
      function buf2binstring(buf, len) {
        if (len < 65534) {
          if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
          }
        }
        var result = "";
        for (var i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i]);
        }
        return result;
      }
      exports2.buf2binstring = function(buf) {
        return buf2binstring(buf, buf.length);
      };
      exports2.binstring2buf = function(str) {
        var buf = new utils.Buf8(str.length);
        for (var i = 0, len = buf.length; i < len; i++) {
          buf[i] = str.charCodeAt(i);
        }
        return buf;
      };
      exports2.buf2string = function(buf, max) {
        var i, out, c, c_len;
        var len = max || buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len; ) {
          c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue;
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c < 65536) {
            utf16buf[out++] = c;
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023;
          }
        }
        return buf2binstring(utf16buf, out);
      };
      exports2.utf8border = function(buf, max) {
        var pos;
        max = max || buf.length;
        if (max > buf.length) {
          max = buf.length;
        }
        pos = max - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max;
        }
        if (pos === 0) {
          return max;
        }
        return pos + _utf8len[buf[pos]] > max ? pos : max;
      };
    }, { "./common": 442 }], 444: [function(require2, module2, exports2) {
      function adler32(adler, buf, len, pos) {
        var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
          n = len > 2e3 ? 2e3 : len;
          len -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      }
      module2.exports = adler32;
    }, {}], 445: [function(require2, module2, exports2) {
      module2.exports = {
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,
        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,
        /* The deflate compression method */
        Z_DEFLATED: 8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
      };
    }, {}], 446: [function(require2, module2, exports2) {
      function makeTable() {
        var c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          table[n] = c;
        }
        return table;
      }
      var crcTable = makeTable();
      function crc32(crc, buf, len, pos) {
        var t2 = crcTable, end = pos + len;
        crc ^= -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t2[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      }
      module2.exports = crc32;
    }, {}], 447: [function(require2, module2, exports2) {
      var utils = require2("../utils/common");
      var trees = require2("./trees");
      var adler32 = require2("./adler32");
      var crc32 = require2("./crc32");
      var msg = require2("./messages");
      var Z_NO_FLUSH = 0;
      var Z_PARTIAL_FLUSH = 1;
      var Z_FULL_FLUSH = 3;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_BUF_ERROR = -5;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_FILTERED = 1;
      var Z_HUFFMAN_ONLY = 2;
      var Z_RLE = 3;
      var Z_FIXED = 4;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_UNKNOWN = 2;
      var Z_DEFLATED = 8;
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;
      function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
      }
      function rank(f) {
        return (f << 1) - (f > 4 ? 9 : 0);
      }
      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      function flush_pending(strm) {
        var s = strm.state;
        var len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }
        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      }
      function flush_block_only(s, last) {
        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      }
      function put_byte(s, b) {
        s.pending_buf[s.pending++] = b;
      }
      function putShortMSB(s, b) {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
      }
      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }
        strm.avail_in -= len;
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
      }
      function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;
        var scan = s.strstart;
        var match;
        var len;
        var best_len = s.prev_length;
        var nice_match = s.nice_match;
        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        var _win = s.window;
        var wmask = s.w_mask;
        var prev = s.prev;
        var strend = s.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      }
      function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
            while (s.insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
      }
      function deflate_stored(s, flush) {
        var max_block_size = 65535;
        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5;
        }
        for (; ; ) {
          if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.strstart += s.lookahead;
          s.lookahead = 0;
          var max_start = s.block_start + max_block_size;
          if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.strstart > s.block_start) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_NEED_MORE;
      }
      function deflate_fast(s, flush) {
        var hash_head;
        var bflush;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
            }
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_slow(s, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1;
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_rle(s, flush) {
        var bflush;
        var prev;
        var scan, strend;
        var _win = s.window;
        for (; ; ) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_huff(s, flush) {
        var bflush;
        for (; ; ) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s.match_length = 0;
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configuration_table;
      configuration_table = [
        /*      good lazy nice chain */
        new Config(0, 0, 0, 0, deflate_stored),
        /* 0 store only */
        new Config(4, 4, 8, 4, deflate_fast),
        /* 1 max speed, no lazy matches */
        new Config(4, 5, 16, 8, deflate_fast),
        /* 2 */
        new Config(4, 6, 32, 32, deflate_fast),
        /* 3 */
        new Config(4, 4, 16, 16, deflate_slow),
        /* 4 lazy matches */
        new Config(8, 16, 32, 32, deflate_slow),
        /* 5 */
        new Config(8, 16, 128, 128, deflate_slow),
        /* 6 */
        new Config(8, 32, 128, 256, deflate_slow),
        /* 7 */
        new Config(32, 128, 258, 1024, deflate_slow),
        /* 8 */
        new Config(32, 258, 258, 4096, deflate_slow)
        /* 9 max compression */
      ];
      function lm_init(s) {
        s.window_size = 2 * s.w_size;
        zero(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      }
      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
        zero(this.dyn_ltree);
        zero(this.dyn_dtree);
        zero(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        this.heap = new utils.Buf16(2 * L_CODES + 1);
        zero(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new utils.Buf16(2 * L_CODES + 1);
        zero(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }
      function deflateResetKeep(strm) {
        var s;
        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap;
        }
        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK;
      }
      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state);
        }
        return ret;
      }
      function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
      }
      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        var wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        var s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);
        s.d_buf = 1 * s.lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
      }
      function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      }
      function deflate(strm, flush) {
        var old_flush, s;
        var beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        s = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        s.strm = strm;
        old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE;
            } else {
              put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
              put_byte(s, s.gzhead.time & 255);
              put_byte(s, s.gzhead.time >> 8 & 255);
              put_byte(s, s.gzhead.time >> 16 & 255);
              put_byte(s, s.gzhead.time >> 24 & 255);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, s.gzhead.os & 255);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 255);
                put_byte(s, s.gzhead.extra.length >> 8 & 255);
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE;
            }
          } else {
            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0;
            } else if (s.level < 6) {
              level_flags = 1;
            } else if (s.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
              header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535);
            }
            strm.adler = 1;
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            beg = s.pending;
            while (s.gzindex < (s.gzhead.extra.length & 65535)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break;
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 255);
              s.gzindex++;
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE;
            }
          } else {
            s.status = NAME_STATE;
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE;
            }
          } else {
            s.status = COMMENT_STATE;
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.status = HCRC_STATE;
            }
          } else {
            s.status = HCRC_STATE;
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              strm.adler = 0;
              s.status = BUSY_STATE;
            }
          } else {
            s.status = BUSY_STATE;
          }
        }
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR);
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
            }
            return Z_OK;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              trees._tr_align(s);
            } else if (flush !== Z_BLOCK) {
              trees._tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END;
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
      }
      function deflateEnd(strm) {
        var status;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
      }
      function deflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var s;
        var str, n;
        var wrap;
        var avail;
        var next;
        var input;
        var tmpDict;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        s = strm.state;
        wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          tmpDict = new utils.Buf8(s.w_size);
          utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        avail = strm.avail_in;
        next = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          str = s.strstart;
          n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
          } while (--n);
          s.strstart = str;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
      }
      exports2.deflateInit = deflateInit;
      exports2.deflateInit2 = deflateInit2;
      exports2.deflateReset = deflateReset;
      exports2.deflateResetKeep = deflateResetKeep;
      exports2.deflateSetHeader = deflateSetHeader;
      exports2.deflate = deflate;
      exports2.deflateEnd = deflateEnd;
      exports2.deflateSetDictionary = deflateSetDictionary;
      exports2.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 442, "./adler32": 444, "./crc32": 446, "./messages": 452, "./trees": 453 }], 448: [function(require2, module2, exports2) {
      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
      }
      module2.exports = GZheader;
    }, {}], 449: [function(require2, module2, exports2) {
      var BAD = 30;
      var TYPE = 12;
      module2.exports = function inflate_fast(strm, start) {
        var state;
        var _in;
        var last;
        var _out;
        var beg;
        var end;
        var dmax;
        var wsize;
        var whave;
        var wnext;
        var s_window;
        var hold;
        var bits;
        var lcode;
        var dcode;
        var lmask;
        var dmask;
        var here;
        var op;
        var len;
        var dist;
        var from;
        var from_source;
        var input, output;
        state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top:
          do {
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = lcode[hold & lmask];
            dolen:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                  output[_out++] = here & 65535;
                } else if (op & 16) {
                  len = here & 65535;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist:
                    for (; ; ) {
                      op = here >>> 24;
                      hold >>>= op;
                      bits -= op;
                      op = here >>> 16 & 255;
                      if (op & 16) {
                        dist = here & 65535;
                        op &= 15;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                          op = dist - op;
                          if (op > whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break top;
                            }
                          }
                          from = 0;
                          from_source = s_window;
                          if (wnext === 0) {
                            from += wsize - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          } else if (wnext < op) {
                            from += wsize + wnext - op;
                            op -= wnext;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = 0;
                              if (wnext < len) {
                                op = wnext;
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                          } else {
                            from += wnext - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                          while (len > 2) {
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            len -= 3;
                          }
                          if (len) {
                            output[_out++] = from_source[from++];
                            if (len > 1) {
                              output[_out++] = from_source[from++];
                            }
                          }
                        } else {
                          from = _out - dist;
                          do {
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            len -= 3;
                          } while (len > 2);
                          if (len) {
                            output[_out++] = output[from++];
                            if (len > 1) {
                              output[_out++] = output[from++];
                            }
                          }
                        }
                      } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + /*here.val*/
                        (hold & (1 << op) - 1)];
                        continue dodist;
                      } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break top;
                      }
                      break;
                    }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 65535) + /*here.val*/
                  (hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      };
    }, {}], 450: [function(require2, module2, exports2) {
      var utils = require2("../utils/common");
      var adler32 = require2("./adler32");
      var crc32 = require2("./crc32");
      var inflate_fast = require2("./inffast");
      var inflate_table = require2("./inftrees");
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_TREES = 6;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_NEED_DICT = 2;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_MEM_ERROR = -4;
      var Z_BUF_ERROR = -5;
      var Z_DEFLATED = 8;
      var HEAD = 1;
      var FLAGS = 2;
      var TIME = 3;
      var OS = 4;
      var EXLEN = 5;
      var EXTRA = 6;
      var NAME = 7;
      var COMMENT = 8;
      var HCRC = 9;
      var DICTID = 10;
      var DICT = 11;
      var TYPE = 12;
      var TYPEDO = 13;
      var STORED = 14;
      var COPY_ = 15;
      var COPY = 16;
      var TABLE = 17;
      var LENLENS = 18;
      var CODELENS = 19;
      var LEN_ = 20;
      var LEN = 21;
      var LENEXT = 22;
      var DIST = 23;
      var DISTEXT = 24;
      var MATCH = 25;
      var LIT = 26;
      var CHECK = 27;
      var LENGTH = 28;
      var DONE = 29;
      var BAD = 30;
      var MEM = 31;
      var SYNC = 32;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;
      function zswap32(q) {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
      }
      function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new utils.Buf16(320);
        this.work = new utils.Buf16(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
      }
      function inflateResetKeep(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK;
      }
      function inflateReset(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      }
      function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      }
      function inflateInit2(strm, windowBits) {
        var ret;
        var state;
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        state = new InflateState();
        strm.state = state;
        state.window = null;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null;
        }
        return ret;
      }
      function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS);
      }
      var virgin = true;
      var lenfix, distfix;
      function fixedtables(state) {
        if (virgin) {
          var sym;
          lenfix = new utils.Buf32(512);
          distfix = new utils.Buf32(32);
          sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
          virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      }
      function updatewindow(strm, src, end, copy2) {
        var dist;
        var state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new utils.Buf8(state.wsize);
        }
        if (copy2 >= state.wsize) {
          utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy2) {
            dist = copy2;
          }
          utils.arraySet(state.window, src, end - copy2, dist, state.wnext);
          copy2 -= dist;
          if (copy2) {
            utils.arraySet(state.window, src, end - copy2, copy2, 0);
            state.wnext = copy2;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      }
      function inflate(strm, flush) {
        var state;
        var input, output;
        var next;
        var put;
        var have, left;
        var hold;
        var bits;
        var _in, _out;
        var copy2;
        var from;
        var from_source;
        var here = 0;
        var here_bits, here_op, here_val;
        var last_bits, last_op, last_val;
        var len;
        var ret;
        var hbuf = new utils.Buf8(4);
        var opts;
        var n;
        var order = (
          /* permutation of code lengths */
          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
        );
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave:
          for (; ; ) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                  state.mode = TYPEDO;
                  break;
                }
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                  state.check = 0;
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                  hold = 0;
                  bits = 0;
                  state.mode = FLAGS;
                  break;
                }
                state.flags = 0;
                if (state.head) {
                  state.head.done = false;
                }
                if (!(state.wrap & 1) || /* check if zlib header allowed */
                (((hold & 255) << /*BITS(8)*/
                8) + (hold >> 8)) % 31) {
                  strm.msg = "incorrect header check";
                  state.mode = BAD;
                  break;
                }
                if ((hold & 15) !== /*BITS(4)*/
                Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + /*BITS(4)*/
                8;
                if (state.wbits === 0) {
                  state.wbits = len;
                } else if (len > state.wbits) {
                  strm.msg = "invalid window size";
                  state.mode = BAD;
                  break;
                }
                state.dmax = 1 << len;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
              case FLAGS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                if (state.flags & 57344) {
                  strm.msg = "unknown header flags set";
                  state.mode = BAD;
                  break;
                }
                if (state.head) {
                  state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
              case TIME:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.time = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  hbuf[2] = hold >>> 16 & 255;
                  hbuf[3] = hold >>> 24 & 255;
                  state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
              case OS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.xflags = hold & 255;
                  state.head.os = hold >> 8;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
              case EXLEN:
                if (state.flags & 1024) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length = hold;
                  if (state.head) {
                    state.head.extra_len = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                } else if (state.head) {
                  state.head.extra = null;
                }
                state.mode = EXTRA;
              case EXTRA:
                if (state.flags & 1024) {
                  copy2 = state.length;
                  if (copy2 > have) {
                    copy2 = have;
                  }
                  if (copy2) {
                    if (state.head) {
                      len = state.head.extra_len - state.length;
                      if (!state.head.extra) {
                        state.head.extra = new Array(state.head.extra_len);
                      }
                      utils.arraySet(
                        state.head.extra,
                        input,
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        copy2,
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        len
                      );
                    }
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy2, next);
                    }
                    have -= copy2;
                    next += copy2;
                    state.length -= copy2;
                  }
                  if (state.length) {
                    break inf_leave;
                  }
                }
                state.length = 0;
                state.mode = NAME;
              case NAME:
                if (state.flags & 2048) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy2 = 0;
                  do {
                    len = input[next + copy2++];
                    if (state.head && len && state.length < 65536) {
                      state.head.name += String.fromCharCode(len);
                    }
                  } while (len && copy2 < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy2, next);
                  }
                  have -= copy2;
                  next += copy2;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
              case COMMENT:
                if (state.flags & 4096) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy2 = 0;
                  do {
                    len = input[next + copy2++];
                    if (state.head && len && state.length < 65536) {
                      state.head.comment += String.fromCharCode(len);
                    }
                  } while (len && copy2 < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy2, next);
                  }
                  have -= copy2;
                  next += copy2;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.comment = null;
                }
                state.mode = HCRC;
              case HCRC:
                if (state.flags & 512) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.check & 65535)) {
                    strm.msg = "header crc mismatch";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                if (state.head) {
                  state.head.hcrc = state.flags >> 9 & 1;
                  state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
              case DICTID:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
              case DICT:
                if (state.havedict === 0) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  return Z_NEED_DICT;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                  break inf_leave;
                }
              case TYPEDO:
                if (state.last) {
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  state.mode = CHECK;
                  break;
                }
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;
                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      hold >>>= 2;
                      bits -= 2;
                      break inf_leave;
                    }
                    break;
                  case 2:
                    state.mode = TABLE;
                    break;
                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                  strm.msg = "invalid stored block lengths";
                  state.mode = BAD;
                  break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case COPY_:
                state.mode = COPY;
              case COPY:
                copy2 = state.length;
                if (copy2) {
                  if (copy2 > have) {
                    copy2 = have;
                  }
                  if (copy2 > left) {
                    copy2 = left;
                  }
                  if (copy2 === 0) {
                    break inf_leave;
                  }
                  utils.arraySet(output, input, next, copy2, put);
                  have -= copy2;
                  next += copy2;
                  left -= copy2;
                  put += copy2;
                  state.length -= copy2;
                  break;
                }
                state.mode = TYPE;
                break;
              case TABLE:
                while (bits < 14) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.nlen = (hold & 31) + /*BITS(5)*/
                257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + /*BITS(5)*/
                1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + /*BITS(4)*/
                4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                  strm.msg = "too many length or distance symbols";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = LENLENS;
              case LENLENS:
                while (state.have < state.ncode) {
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.lens[order[state.have++]] = hold & 7;
                  hold >>>= 3;
                  bits -= 3;
                }
                while (state.have < 19) {
                  state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = { bits: state.lenbits };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid code lengths set";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = CODELENS;
              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_val < 16) {
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.lens[state.have++] = here_val;
                  } else {
                    if (here_val === 16) {
                      n = here_bits + 2;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      if (state.have === 0) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      len = state.lens[state.have - 1];
                      copy2 = 3 + (hold & 3);
                      hold >>>= 2;
                      bits -= 2;
                    } else if (here_val === 17) {
                      n = here_bits + 3;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy2 = 3 + (hold & 7);
                      hold >>>= 3;
                      bits -= 3;
                    } else {
                      n = here_bits + 7;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy2 = 11 + (hold & 127);
                      hold >>>= 7;
                      bits -= 7;
                    }
                    if (state.have + copy2 > state.nlen + state.ndist) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    while (copy2--) {
                      state.lens[state.have++] = len;
                    }
                  }
                }
                if (state.mode === BAD) {
                  break;
                }
                if (state.lens[256] === 0) {
                  strm.msg = "invalid code -- missing end-of-block";
                  state.mode = BAD;
                  break;
                }
                state.lenbits = 9;
                opts = { bits: state.lenbits };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid literal/lengths set";
                  state.mode = BAD;
                  break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = { bits: state.distbits };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid distances set";
                  state.mode = BAD;
                  break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case LEN_:
                state.mode = LEN;
              case LEN:
                if (have >= 6 && left >= 258) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  inflate_fast(strm, _out);
                  put = strm.next_out;
                  output = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  if (state.mode === TYPE) {
                    state.back = -1;
                  }
                  break;
                }
                state.back = 0;
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/
                    last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                  state.mode = LIT;
                  break;
                }
                if (here_op & 32) {
                  state.back = -1;
                  state.mode = TYPE;
                  break;
                }
                if (here_op & 64) {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
              case LENEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
              case DIST:
                for (; ; ) {
                  here = state.distcode[hold & (1 << state.distbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> /*BITS(last.bits + last.op)*/
                    last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
              case DISTEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.offset += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
                state.mode = MATCH;
              case MATCH:
                if (left === 0) {
                  break inf_leave;
                }
                copy2 = _out - left;
                if (state.offset > copy2) {
                  copy2 = state.offset - copy2;
                  if (copy2 > state.whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break;
                    }
                  }
                  if (copy2 > state.wnext) {
                    copy2 -= state.wnext;
                    from = state.wsize - copy2;
                  } else {
                    from = state.wnext - copy2;
                  }
                  if (copy2 > state.length) {
                    copy2 = state.length;
                  }
                  from_source = state.window;
                } else {
                  from_source = output;
                  from = put - state.offset;
                  copy2 = state.length;
                }
                if (copy2 > left) {
                  copy2 = left;
                }
                left -= copy2;
                state.length -= copy2;
                do {
                  output[put++] = from_source[from++];
                } while (--copy2);
                if (state.length === 0) {
                  state.mode = LEN;
                }
                break;
              case LIT:
                if (left === 0) {
                  break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
              case CHECK:
                if (state.wrap) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold |= input[next++] << bits;
                    bits += 8;
                  }
                  _out -= left;
                  strm.total_out += _out;
                  state.total += _out;
                  if (_out) {
                    strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                    state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                  }
                  _out = left;
                  if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = "incorrect data check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = LENGTH;
              case LENGTH:
                if (state.wrap && state.flags) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.total & 4294967295)) {
                    strm.msg = "incorrect length check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = DONE;
              case DONE:
                ret = Z_STREAM_END;
                break inf_leave;
              case BAD:
                ret = Z_DATA_ERROR;
                break inf_leave;
              case MEM:
                return Z_MEM_ERROR;
              case SYNC:
              default:
                return Z_STREAM_ERROR;
            }
          }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
            ;
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR;
        }
        return ret;
      }
      function inflateEnd(strm) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        var state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK;
      }
      function inflateGetHeader(strm, head) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR;
        }
        state.head = head;
        head.done = false;
        return Z_OK;
      }
      function inflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var state;
        var dictid;
        var ret;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR;
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR;
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
        state.havedict = 1;
        return Z_OK;
      }
      exports2.inflateReset = inflateReset;
      exports2.inflateReset2 = inflateReset2;
      exports2.inflateResetKeep = inflateResetKeep;
      exports2.inflateInit = inflateInit;
      exports2.inflateInit2 = inflateInit2;
      exports2.inflate = inflate;
      exports2.inflateEnd = inflateEnd;
      exports2.inflateGetHeader = inflateGetHeader;
      exports2.inflateSetDictionary = inflateSetDictionary;
      exports2.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 442, "./adler32": 444, "./crc32": 446, "./inffast": 449, "./inftrees": 451 }], 451: [function(require2, module2, exports2) {
      var utils = require2("../utils/common");
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = [
        /* Length codes 257..285 base */
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ];
      var lext = [
        /* Length codes 257..285 extra */
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ];
      var dbase = [
        /* Distance codes 0..29 base */
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ];
      var dext = [
        /* Distance codes 0..29 extra */
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ];
      module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits;
        var len = 0;
        var sym = 0;
        var min = 0, max = 0;
        var root = 0;
        var curr = 0;
        var drop = 0;
        var left = 0;
        var used = 0;
        var huff = 0;
        var incr;
        var fill;
        var low;
        var mask;
        var next;
        var base = null;
        var base_index = 0;
        var end;
        var count = new utils.Buf16(MAXBITS + 1);
        var offs = new utils.Buf16(MAXBITS + 1);
        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max = MAXBITS; max >= 1; max--) {
          if (count[max] !== 0) {
            break;
          }
        }
        if (root > max) {
          root = max;
        }
        if (max === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
        }
        for (min = 1; min < max; min++) {
          if (count[min] !== 0) {
            break;
          }
        }
        if (root < min) {
          root = min;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type === CODES || max !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type === CODES) {
          base = extra = work;
          end = 19;
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256;
        } else {
          base = dbase;
          extra = dext;
          end = -1;
        }
        huff = 0;
        sym = 0;
        len = min;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        for (; ; ) {
          here_bits = len - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len - drop;
          fill = 1 << curr;
          min = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max) {
              break;
            }
            len = lens[lens_index + work[sym]];
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root;
            }
            next += min;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
      };
    }, { "../utils/common": 442 }], 452: [function(require2, module2, exports2) {
      module2.exports = {
        2: "need dictionary",
        /* Z_NEED_DICT       2  */
        1: "stream end",
        /* Z_STREAM_END      1  */
        0: "",
        /* Z_OK              0  */
        "-1": "file error",
        /* Z_ERRNO         (-1) */
        "-2": "stream error",
        /* Z_STREAM_ERROR  (-2) */
        "-3": "data error",
        /* Z_DATA_ERROR    (-3) */
        "-4": "insufficient memory",
        /* Z_MEM_ERROR     (-4) */
        "-5": "buffer error",
        /* Z_BUF_ERROR     (-5) */
        "-6": "incompatible version"
        /* Z_VERSION_ERROR (-6) */
      };
    }, {}], 453: [function(require2, module2, exports2) {
      var utils = require2("../utils/common");
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;
      function zero(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = (
        /* extra bits for each length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
      );
      var extra_dbits = (
        /* extra bits for each distance code */
        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
      );
      var extra_blbits = (
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
      );
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero(base_length);
      var base_dist = new Array(D_CODES);
      zero(base_dist);
      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;
      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }
      function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      }
      function put_short(s, w) {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
      }
      function send_bits(s, value, length) {
        if (s.bi_valid > Buf_size - length) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length - Buf_size;
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length;
        }
      }
      function send_code(s, c, tree) {
        send_bits(
          s,
          tree[c * 2],
          tree[c * 2 + 1]
          /*.Len*/
        );
      }
      function bi_reverse(code, len) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      }
      function bi_flush(s) {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      }
      function gen_bitlen(s, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h3;
        var n, m;
        var bits;
        var xbits;
        var f;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h3 = s.heap_max + 1; h3 < HEAP_SIZE; h3++) {
          n = s.heap[h3];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue;
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h3];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n--;
          }
        }
      }
      function gen_codes(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS + 1);
        var code = 0;
        var bits;
        var n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for (n = 0; n <= max_code; n++) {
          var len = tree[n * 2 + 1];
          if (len === 0) {
            continue;
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
      }
      function tr_static_init() {
        var n;
        var bits;
        var length;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS + 1);
        length = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length++] = code;
          }
        }
        _length_code[length - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist++] = code;
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
      }
      function init_block(s) {
        var n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
      }
      function bi_windup(s) {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      }
      function copy_block(s, buf, len, header) {
        bi_windup(s);
        if (header) {
          put_short(s, len);
          put_short(s, ~len);
        }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len;
      }
      function smaller(tree, n, m, depth) {
        var _n2 = n * 2;
        var _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
      }
      function pqdownheap(s, tree, k) {
        var v = s.heap[k];
        var j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          if (smaller(tree, v, s.heap[j], s.depth)) {
            break;
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1;
        }
        s.heap[k] = v;
      }
      function compress_block(s, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s.last_lit !== 0) {
          do {
            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code(s, lc, ltree);
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);
              }
            }
          } while (lx < s.last_lit);
        }
        send_code(s, END_BLOCK, ltree);
      }
      function build_tree(s, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m;
        var max_code = -1;
        var node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1] = 0;
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        node = elems;
        do {
          n = s.heap[
            1
            /*SMALLEST*/
          ];
          s.heap[
            1
            /*SMALLEST*/
          ] = s.heap[s.heap_len--];
          pqdownheap(
            s,
            tree,
            1
            /*SMALLEST*/
          );
          m = s.heap[
            1
            /*SMALLEST*/
          ];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[
            1
            /*SMALLEST*/
          ] = node++;
          pqdownheap(
            s,
            tree,
            1
            /*SMALLEST*/
          );
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[
          1
          /*SMALLEST*/
        ];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
      }
      function scan_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function send_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function build_bl_tree(s) {
        var max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      }
      function send_all_trees(s, lcodes, dcodes, blcodes) {
        var rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
      }
      function detect_data_type(s) {
        var black_mask = 4093624447;
        var n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY;
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      }
      var static_init_done = false;
      function _tr_init(s) {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
      }
      function _tr_stored_block(s, buf, stored_len, last) {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true);
      }
      function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      }
      function _tr_flush_block(s, buf, stored_len, last) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s);
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
          bi_windup(s);
        }
      }
      function _tr_tally(s, dist, lc) {
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
        s.last_lit++;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++;
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.last_lit === s.lit_bufsize - 1;
      }
      exports2._tr_init = _tr_init;
      exports2._tr_stored_block = _tr_stored_block;
      exports2._tr_flush_block = _tr_flush_block;
      exports2._tr_tally = _tr_tally;
      exports2._tr_align = _tr_align;
    }, { "../utils/common": 442 }], 454: [function(require2, module2, exports2) {
      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
      module2.exports = ZStream;
    }, {}], 455: [function(require2, module2, exports2) {
      module2.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
    }, {}], 456: [function(require2, module2, exports2) {
      var asn1 = require2("asn1.js");
      exports2.certificate = require2("./certificate");
      var RSAPrivateKey = asn1.define("RSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
      });
      exports2.RSAPrivateKey = RSAPrivateKey;
      var RSAPublicKey = asn1.define("RSAPublicKey", function() {
        this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
      });
      exports2.RSAPublicKey = RSAPublicKey;
      var PublicKey = asn1.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
      });
      exports2.PublicKey = PublicKey;
      var AlgorithmIdentifier = asn1.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
      });
      var PrivateKeyInfo = asn1.define("PrivateKeyInfo", function() {
        this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPrivateKey").octstr());
      });
      exports2.PrivateKey = PrivateKeyInfo;
      var EncryptedPrivateKeyInfo = asn1.define("EncryptedPrivateKeyInfo", function() {
        this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
      });
      exports2.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
      var DSAPrivateKey = asn1.define("DSAPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
      });
      exports2.DSAPrivateKey = DSAPrivateKey;
      exports2.DSAparam = asn1.define("DSAparam", function() {
        this.int();
      });
      var ECPrivateKey = asn1.define("ECPrivateKey", function() {
        this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
      });
      exports2.ECPrivateKey = ECPrivateKey;
      var ECParameters = asn1.define("ECParameters", function() {
        this.choice({ namedCurve: this.objid() });
      });
      exports2.signature = asn1.define("signature", function() {
        this.seq().obj(this.key("r").int(), this.key("s").int());
      });
    }, { "./certificate": 457, "asn1.js": 167 }], 457: [function(require2, module2, exports2) {
      var asn = require2("asn1.js");
      var Time = asn.define("Time", function() {
        this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
      });
      var AttributeTypeValue = asn.define("AttributeTypeValue", function() {
        this.seq().obj(this.key("type").objid(), this.key("value").any());
      });
      var AlgorithmIdentifier = asn.define("AlgorithmIdentifier", function() {
        this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
      });
      var SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
        this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
      });
      var RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
        this.setof(AttributeTypeValue);
      });
      var RDNSequence = asn.define("RDNSequence", function() {
        this.seqof(RelativeDistinguishedName);
      });
      var Name = asn.define("Name", function() {
        this.choice({ rdnSequence: this.use(RDNSequence) });
      });
      var Validity = asn.define("Validity", function() {
        this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
      });
      var Extension = asn.define("Extension", function() {
        this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
      });
      var TBSCertificate = asn.define("TBSCertificate", function() {
        this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
      });
      var X509Certificate = asn.define("X509Certificate", function() {
        this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
      });
      module2.exports = X509Certificate;
    }, { "asn1.js": 167 }], 458: [function(require2, module2, exports2) {
      var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
      var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
      var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
      var evp = require2("evp_bytestokey");
      var ciphers = require2("browserify-aes");
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = function(okey, password) {
        var key = okey.toString();
        var match = key.match(findProc);
        var decrypted;
        if (!match) {
          var match2 = key.match(fullRegex);
          decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ""), "base64");
        } else {
          var suite = "aes" + match[1];
          var iv = Buffer.from(match[2], "hex");
          var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ""), "base64");
          var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
          var out = [];
          var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
          out.push(cipher.update(cipherText));
          out.push(cipher.final());
          decrypted = Buffer.concat(out);
        }
        var tag = key.match(startRegex)[1];
        return { tag, data: decrypted };
      };
    }, { "browserify-aes": 188, "evp_bytestokey": 368, "safe-buffer": 494 }], 459: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var asn1 = require2("./asn1");
      var aesid = require2("./aesid.json");
      var fixProc = require2("./fixProc");
      var ciphers = require2("browserify-aes");
      var compat = require2("pbkdf2");
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = parseKeys;
      function parseKeys(buffer) {
        var password;
        if (_typeof2(buffer) === "object" && !Buffer.isBuffer(buffer)) {
          password = buffer.passphrase;
          buffer = buffer.key;
        }
        if (typeof buffer === "string") {
          buffer = Buffer.from(buffer);
        }
        var stripped = fixProc(buffer, password);
        var type = stripped.tag;
        var data = stripped.data;
        var subtype, ndata;
        switch (type) {
          case "CERTIFICATE":
            ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
          case "PUBLIC KEY":
            if (!ndata) {
              ndata = asn1.PublicKey.decode(data, "der");
            }
            subtype = ndata.algorithm.algorithm.join(".");
            switch (subtype) {
              case "1.2.840.113549.1.1.1":
                return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
              case "1.2.840.10045.2.1":
                ndata.subjectPrivateKey = ndata.subjectPublicKey;
                return { type: "ec", data: ndata };
              case "1.2.840.10040.4.1":
                ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der");
                return { type: "dsa", data: ndata.algorithm.params };
              default:
                throw new Error("unknown key id " + subtype);
            }
          case "ENCRYPTED PRIVATE KEY":
            data = asn1.EncryptedPrivateKey.decode(data, "der");
            data = decrypt(data, password);
          case "PRIVATE KEY":
            ndata = asn1.PrivateKey.decode(data, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch (subtype) {
              case "1.2.840.113549.1.1.1":
                return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
              case "1.2.840.10045.2.1":
                return { curve: ndata.algorithm.curve, privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey };
              case "1.2.840.10040.4.1":
                ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der");
                return { type: "dsa", params: ndata.algorithm.params };
              default:
                throw new Error("unknown key id " + subtype);
            }
          case "RSA PUBLIC KEY":
            return asn1.RSAPublicKey.decode(data, "der");
          case "RSA PRIVATE KEY":
            return asn1.RSAPrivateKey.decode(data, "der");
          case "DSA PRIVATE KEY":
            return { type: "dsa", params: asn1.DSAPrivateKey.decode(data, "der") };
          case "EC PRIVATE KEY":
            data = asn1.ECPrivateKey.decode(data, "der");
            return { curve: data.parameters.value, privateKey: data.privateKey };
          default:
            throw new Error("unknown key type " + type);
        }
      }
      parseKeys.signature = asn1.signature;
      function decrypt(data, password) {
        var salt = data.algorithm.decrypt.kde.kdeparams.salt;
        var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
        var algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
        var iv = data.algorithm.decrypt.cipher.iv;
        var cipherText = data.subjectPrivateKey;
        var keylen = parseInt(algo.split("-")[1], 10) / 8;
        var key = compat.pbkdf2Sync(password, salt, iters, keylen, "sha1");
        var cipher = ciphers.createDecipheriv(algo, key, iv);
        var out = [];
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        return Buffer.concat(out);
      }
    }, { "./aesid.json": 455, "./asn1": 456, "./fixProc": 458, "browserify-aes": 188, "pbkdf2": 460, "safe-buffer": 494 }], 460: [function(require2, module2, exports2) {
      exports2.pbkdf2 = require2("./lib/async");
      exports2.pbkdf2Sync = require2("./lib/sync");
    }, { "./lib/async": 461, "./lib/sync": 464 }], 461: [function(require2, module2, exports2) {
      (function(process, global2) {
        var Buffer = require2("safe-buffer").Buffer;
        var checkParameters = require2("./precondition");
        var defaultEncoding = require2("./default-encoding");
        var sync = require2("./sync");
        var toBuffer = require2("./to-buffer");
        var ZERO_BUF;
        var subtle = global2.crypto && global2.crypto.subtle;
        var toBrowser = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" };
        var checks = [];
        function checkNative(algo) {
          if (global2.process && !global2.process.browser) {
            return Promise.resolve(false);
          }
          if (!subtle || !subtle.importKey || !subtle.deriveBits) {
            return Promise.resolve(false);
          }
          if (checks[algo] !== void 0) {
            return checks[algo];
          }
          ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
          var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function() {
            return true;
          }).catch(function() {
            return false;
          });
          checks[algo] = prom;
          return prom;
        }
        function browserPbkdf2(password, salt, iterations, length, algo) {
          return subtle.importKey("raw", password, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(key) {
            return subtle.deriveBits({ name: "PBKDF2", salt, iterations, hash: { name: algo } }, key, length << 3);
          }).then(function(res) {
            return Buffer.from(res);
          });
        }
        function resolvePromise(promise, callback) {
          promise.then(function(out) {
            process.nextTick(function() {
              callback(null, out);
            });
          }, function(e) {
            process.nextTick(function() {
              callback(e);
            });
          });
        }
        module2.exports = function(password, salt, iterations, keylen, digest, callback) {
          if (typeof digest === "function") {
            callback = digest;
            digest = void 0;
          }
          digest = digest || "sha1";
          var algo = toBrowser[digest.toLowerCase()];
          if (!algo || typeof global2.Promise !== "function") {
            return process.nextTick(function() {
              var out;
              try {
                out = sync(password, salt, iterations, keylen, digest);
              } catch (e) {
                return callback(e);
              }
              callback(null, out);
            });
          }
          checkParameters(iterations, keylen);
          password = toBuffer(password, defaultEncoding, "Password");
          salt = toBuffer(salt, defaultEncoding, "Salt");
          if (typeof callback !== "function")
            throw new Error("No callback provided to pbkdf2");
          resolvePromise(checkNative(algo).then(function(resp) {
            if (resp)
              return browserPbkdf2(password, salt, iterations, keylen, algo);
            return sync(password, salt, iterations, keylen, digest);
          }), callback);
        };
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "./default-encoding": 462, "./precondition": 463, "./sync": 464, "./to-buffer": 465, "_process": 467, "safe-buffer": 494 }], 462: [function(require2, module2, exports2) {
      (function(process) {
        var defaultEncoding;
        if (process.browser) {
          defaultEncoding = "utf-8";
        } else if (process.version) {
          var pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10);
          defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
        } else {
          defaultEncoding = "utf-8";
        }
        module2.exports = defaultEncoding;
      }).call(this, require2("_process"));
    }, { "_process": 467 }], 463: [function(require2, module2, exports2) {
      var MAX_ALLOC = Math.pow(2, 30) - 1;
      module2.exports = function(iterations, keylen) {
        if (typeof iterations !== "number") {
          throw new TypeError("Iterations not a number");
        }
        if (iterations < 0) {
          throw new TypeError("Bad iterations");
        }
        if (typeof keylen !== "number") {
          throw new TypeError("Key length not a number");
        }
        if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
          throw new TypeError("Bad key length");
        }
      };
    }, {}], 464: [function(require2, module2, exports2) {
      var md5 = require2("create-hash/md5");
      var RIPEMD160 = require2("ripemd160");
      var sha = require2("sha.js");
      var Buffer = require2("safe-buffer").Buffer;
      var checkParameters = require2("./precondition");
      var defaultEncoding = require2("./default-encoding");
      var toBuffer = require2("./to-buffer");
      var ZEROS = Buffer.alloc(128);
      var sizes = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
      function Hmac(alg, key, saltLen) {
        var hash = getDigest(alg);
        var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key.length > blocksize) {
          key = hash(key);
        } else if (key.length < blocksize) {
          key = Buffer.concat([key, ZEROS], blocksize);
        }
        var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        for (var i = 0; i < blocksize; i++) {
          ipad[i] = key[i] ^ 54;
          opad[i] = key[i] ^ 92;
        }
        var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.hash = hash;
        this.size = sizes[alg];
      }
      Hmac.prototype.run = function(data, ipad) {
        data.copy(ipad, this.blocksize);
        var h3 = this.hash(ipad);
        h3.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
      };
      function getDigest(alg) {
        function shaFunc(data) {
          return sha(alg).update(data).digest();
        }
        function rmd160Func(data) {
          return new RIPEMD160().update(data).digest();
        }
        if (alg === "rmd160" || alg === "ripemd160")
          return rmd160Func;
        if (alg === "md5")
          return md5;
        return shaFunc;
      }
      function pbkdf2(password, salt, iterations, keylen, digest) {
        checkParameters(iterations, keylen);
        password = toBuffer(password, defaultEncoding, "Password");
        salt = toBuffer(salt, defaultEncoding, "Salt");
        digest = digest || "sha1";
        var hmac = new Hmac(digest, password, salt.length);
        var DK = Buffer.allocUnsafe(keylen);
        var block1 = Buffer.allocUnsafe(salt.length + 4);
        salt.copy(block1, 0, 0, salt.length);
        var destPos = 0;
        var hLen = sizes[digest];
        var l = Math.ceil(keylen / hLen);
        for (var i = 1; i <= l; i++) {
          block1.writeUInt32BE(i, salt.length);
          var T = hmac.run(block1, hmac.ipad1);
          var U = T;
          for (var j = 1; j < iterations; j++) {
            U = hmac.run(U, hmac.ipad2);
            for (var k = 0; k < hLen; k++) {
              T[k] ^= U[k];
            }
          }
          T.copy(DK, destPos);
          destPos += hLen;
        }
        return DK;
      }
      module2.exports = pbkdf2;
    }, { "./default-encoding": 462, "./precondition": 463, "./to-buffer": 465, "create-hash/md5": 332, "ripemd160": 493, "safe-buffer": 494, "sha.js": 499 }], 465: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = function(thing, encoding, name) {
        if (Buffer.isBuffer(thing)) {
          return thing;
        } else if (typeof thing === "string") {
          return Buffer.from(thing, encoding);
        } else if (ArrayBuffer.isView(thing)) {
          return Buffer.from(thing.buffer);
        } else {
          throw new TypeError(name + " must be a string, a Buffer, a typed array or a DataView");
        }
      };
    }, { "safe-buffer": 494 }], 466: [function(require2, module2, exports2) {
      (function(process) {
        if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
          module2.exports = { nextTick: nextTick2 };
        } else {
          module2.exports = process;
        }
        function nextTick2(fn, arg1, arg2, arg3) {
          if (typeof fn !== "function") {
            throw new TypeError('"callback" argument must be a function');
          }
          var len = arguments.length;
          var args, i;
          switch (len) {
            case 0:
            case 1:
              return process.nextTick(fn);
            case 2:
              return process.nextTick(function afterTickOne() {
                fn.call(null, arg1);
              });
            case 3:
              return process.nextTick(function afterTickTwo() {
                fn.call(null, arg1, arg2);
              });
            case 4:
              return process.nextTick(function afterTickThree() {
                fn.call(null, arg1, arg2, arg3);
              });
            default:
              args = new Array(len - 1);
              i = 0;
              while (i < args.length) {
                args[i++] = arguments[i];
              }
              return process.nextTick(function afterTick() {
                fn.apply(null, args);
              });
          }
        }
      }).call(this, require2("_process"));
    }, { "_process": 467 }], 467: [function(require2, module2, exports2) {
      var process = module2.exports = {};
      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error("setTimeout has not been defined");
      }
      function defaultClearTimeout() {
        throw new Error("clearTimeout has not been defined");
      }
      (function() {
        try {
          if (typeof setTimeout === "function") {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === "function") {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          return setTimeout(fun, 0);
        }
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e2) {
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (e2) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function(fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item2(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };
      function Item2(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item2.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      process.title = "browser";
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = "";
      process.versions = {};
      function noop() {
      }
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function(name) {
        return [];
      };
      process.binding = function(name) {
        throw new Error("process.binding is not supported");
      };
      process.cwd = function() {
        return "/";
      };
      process.chdir = function(dir) {
        throw new Error("process.chdir is not supported");
      };
      process.umask = function() {
        return 0;
      };
    }, {}], 468: [function(require2, module2, exports2) {
      exports2.publicEncrypt = require2("./publicEncrypt");
      exports2.privateDecrypt = require2("./privateDecrypt");
      exports2.privateEncrypt = function privateEncrypt(key, buf) {
        return exports2.publicEncrypt(key, buf, true);
      };
      exports2.publicDecrypt = function publicDecrypt(key, buf) {
        return exports2.privateDecrypt(key, buf, true);
      };
    }, { "./privateDecrypt": 471, "./publicEncrypt": 472 }], 469: [function(require2, module2, exports2) {
      var createHash = require2("create-hash");
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = function(seed, len) {
        var t2 = Buffer.alloc(0);
        var i = 0;
        var c;
        while (t2.length < len) {
          c = i2ops(i++);
          t2 = Buffer.concat([t2, createHash("sha1").update(seed).update(c).digest()]);
        }
        return t2.slice(0, len);
      };
      function i2ops(c) {
        var out = Buffer.allocUnsafe(4);
        out.writeUInt32BE(c, 0);
        return out;
      }
    }, { "create-hash": 331, "safe-buffer": 494 }], 470: [function(require2, module2, exports2) {
      arguments[4][181][0].apply(exports2, arguments);
    }, { "buffer": 185, "dup": 181 }], 471: [function(require2, module2, exports2) {
      var parseKeys = require2("parse-asn1");
      var mgf = require2("./mgf");
      var xor = require2("./xor");
      var BN = require2("bn.js");
      var crt = require2("browserify-rsa");
      var createHash = require2("create-hash");
      var withPublic = require2("./withPublic");
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = function privateDecrypt(privateKey, enc, reverse) {
        var padding;
        if (privateKey.padding) {
          padding = privateKey.padding;
        } else if (reverse) {
          padding = 1;
        } else {
          padding = 4;
        }
        var key = parseKeys(privateKey);
        var k = key.modulus.byteLength();
        if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
          throw new Error("decryption error");
        }
        var msg;
        if (reverse) {
          msg = withPublic(new BN(enc), key);
        } else {
          msg = crt(enc, key);
        }
        var zBuffer = Buffer.alloc(k - msg.length);
        msg = Buffer.concat([zBuffer, msg], k);
        if (padding === 4) {
          return oaep(key, msg);
        } else if (padding === 1) {
          return pkcs1(key, msg, reverse);
        } else if (padding === 3) {
          return msg;
        } else {
          throw new Error("unknown padding");
        }
      };
      function oaep(key, msg) {
        var k = key.modulus.byteLength();
        var iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
        var hLen = iHash.length;
        if (msg[0] !== 0) {
          throw new Error("decryption error");
        }
        var maskedSeed = msg.slice(1, hLen + 1);
        var maskedDb = msg.slice(hLen + 1);
        var seed = xor(maskedSeed, mgf(maskedDb, hLen));
        var db = xor(maskedDb, mgf(seed, k - hLen - 1));
        if (compare(iHash, db.slice(0, hLen))) {
          throw new Error("decryption error");
        }
        var i = hLen;
        while (db[i] === 0) {
          i++;
        }
        if (db[i++] !== 1) {
          throw new Error("decryption error");
        }
        return db.slice(i);
      }
      function pkcs1(key, msg, reverse) {
        var p1 = msg.slice(0, 2);
        var i = 2;
        var status = 0;
        while (msg[i++] !== 0) {
          if (i >= msg.length) {
            status++;
            break;
          }
        }
        var ps = msg.slice(2, i - 1);
        if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
          status++;
        }
        if (ps.length < 8) {
          status++;
        }
        if (status) {
          throw new Error("decryption error");
        }
        return msg.slice(i);
      }
      function compare(a, b) {
        a = Buffer.from(a);
        b = Buffer.from(b);
        var dif = 0;
        var len = a.length;
        if (a.length !== b.length) {
          dif++;
          len = Math.min(a.length, b.length);
        }
        var i = -1;
        while (++i < len) {
          dif += a[i] ^ b[i];
        }
        return dif;
      }
    }, { "./mgf": 469, "./withPublic": 473, "./xor": 474, "bn.js": 470, "browserify-rsa": 206, "create-hash": 331, "parse-asn1": 459, "safe-buffer": 494 }], 472: [function(require2, module2, exports2) {
      var parseKeys = require2("parse-asn1");
      var randomBytes = require2("randombytes");
      var createHash = require2("create-hash");
      var mgf = require2("./mgf");
      var xor = require2("./xor");
      var BN = require2("bn.js");
      var withPublic = require2("./withPublic");
      var crt = require2("browserify-rsa");
      var Buffer = require2("safe-buffer").Buffer;
      module2.exports = function publicEncrypt(publicKey, msg, reverse) {
        var padding;
        if (publicKey.padding) {
          padding = publicKey.padding;
        } else if (reverse) {
          padding = 1;
        } else {
          padding = 4;
        }
        var key = parseKeys(publicKey);
        var paddedMsg;
        if (padding === 4) {
          paddedMsg = oaep(key, msg);
        } else if (padding === 1) {
          paddedMsg = pkcs1(key, msg, reverse);
        } else if (padding === 3) {
          paddedMsg = new BN(msg);
          if (paddedMsg.cmp(key.modulus) >= 0) {
            throw new Error("data too long for modulus");
          }
        } else {
          throw new Error("unknown padding");
        }
        if (reverse) {
          return crt(paddedMsg, key);
        } else {
          return withPublic(paddedMsg, key);
        }
      };
      function oaep(key, msg) {
        var k = key.modulus.byteLength();
        var mLen = msg.length;
        var iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
        var hLen = iHash.length;
        var hLen2 = 2 * hLen;
        if (mLen > k - hLen2 - 2) {
          throw new Error("message too long");
        }
        var ps = Buffer.alloc(k - mLen - hLen2 - 2);
        var dblen = k - hLen - 1;
        var seed = randomBytes(hLen);
        var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen));
        var maskedSeed = xor(seed, mgf(maskedDb, hLen));
        return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k));
      }
      function pkcs1(key, msg, reverse) {
        var mLen = msg.length;
        var k = key.modulus.byteLength();
        if (mLen > k - 11) {
          throw new Error("message too long");
        }
        var ps;
        if (reverse) {
          ps = Buffer.alloc(k - mLen - 3, 255);
        } else {
          ps = nonZero(k - mLen - 3);
        }
        return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k));
      }
      function nonZero(len) {
        var out = Buffer.allocUnsafe(len);
        var i = 0;
        var cache2 = randomBytes(len * 2);
        var cur = 0;
        var num;
        while (i < len) {
          if (cur === cache2.length) {
            cache2 = randomBytes(len * 2);
            cur = 0;
          }
          num = cache2[cur++];
          if (num) {
            out[i++] = num;
          }
        }
        return out;
      }
    }, { "./mgf": 469, "./withPublic": 473, "./xor": 474, "bn.js": 470, "browserify-rsa": 206, "create-hash": 331, "parse-asn1": 459, "randombytes": 475, "safe-buffer": 494 }], 473: [function(require2, module2, exports2) {
      var BN = require2("bn.js");
      var Buffer = require2("safe-buffer").Buffer;
      function withPublic(paddedMsg, key) {
        return Buffer.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
      }
      module2.exports = withPublic;
    }, { "bn.js": 470, "safe-buffer": 494 }], 474: [function(require2, module2, exports2) {
      module2.exports = function xor(a, b) {
        var len = a.length;
        var i = -1;
        while (++i < len) {
          a[i] ^= b[i];
        }
        return a;
      };
    }, {}], 475: [function(require2, module2, exports2) {
      (function(process, global2) {
        var MAX_BYTES = 65536;
        var MAX_UINT32 = 4294967295;
        function oldBrowser() {
          throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
        }
        var Buffer = require2("safe-buffer").Buffer;
        var crypto2 = global2.crypto || global2.msCrypto;
        if (crypto2 && crypto2.getRandomValues) {
          module2.exports = randomBytes;
        } else {
          module2.exports = oldBrowser;
        }
        function randomBytes(size, cb) {
          if (size > MAX_UINT32)
            throw new RangeError("requested too many random bytes");
          var bytes = Buffer.allocUnsafe(size);
          if (size > 0) {
            if (size > MAX_BYTES) {
              for (var generated = 0; generated < size; generated += MAX_BYTES) {
                crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
              }
            } else {
              crypto2.getRandomValues(bytes);
            }
          }
          if (typeof cb === "function") {
            return process.nextTick(function() {
              cb(null, bytes);
            });
          }
          return bytes;
        }
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "_process": 467, "safe-buffer": 494 }], 476: [function(require2, module2, exports2) {
      (function(process, global2) {
        function oldBrowser() {
          throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
        }
        var safeBuffer = require2("safe-buffer");
        var randombytes = require2("randombytes");
        var Buffer = safeBuffer.Buffer;
        var kBufferMaxLength = safeBuffer.kMaxLength;
        var crypto2 = global2.crypto || global2.msCrypto;
        var kMaxUint32 = Math.pow(2, 32) - 1;
        function assertOffset(offset, length) {
          if (typeof offset !== "number" || offset !== offset) {
            throw new TypeError("offset must be a number");
          }
          if (offset > kMaxUint32 || offset < 0) {
            throw new TypeError("offset must be a uint32");
          }
          if (offset > kBufferMaxLength || offset > length) {
            throw new RangeError("offset out of range");
          }
        }
        function assertSize(size, offset, length) {
          if (typeof size !== "number" || size !== size) {
            throw new TypeError("size must be a number");
          }
          if (size > kMaxUint32 || size < 0) {
            throw new TypeError("size must be a uint32");
          }
          if (size + offset > length || size > kBufferMaxLength) {
            throw new RangeError("buffer too small");
          }
        }
        if (crypto2 && crypto2.getRandomValues || !process.browser) {
          exports2.randomFill = randomFill;
          exports2.randomFillSync = randomFillSync;
        } else {
          exports2.randomFill = oldBrowser;
          exports2.randomFillSync = oldBrowser;
        }
        function randomFill(buf, offset, size, cb) {
          if (!Buffer.isBuffer(buf) && !(buf instanceof global2.Uint8Array)) {
            throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
          }
          if (typeof offset === "function") {
            cb = offset;
            offset = 0;
            size = buf.length;
          } else if (typeof size === "function") {
            cb = size;
            size = buf.length - offset;
          } else if (typeof cb !== "function") {
            throw new TypeError('"cb" argument must be a function');
          }
          assertOffset(offset, buf.length);
          assertSize(size, offset, buf.length);
          return actualFill(buf, offset, size, cb);
        }
        function actualFill(buf, offset, size, cb) {
          if (process.browser) {
            var ourBuf = buf.buffer;
            var uint = new Uint8Array(ourBuf, offset, size);
            crypto2.getRandomValues(uint);
            if (cb) {
              process.nextTick(function() {
                cb(null, buf);
              });
              return;
            }
            return buf;
          }
          if (cb) {
            randombytes(size, function(err, bytes2) {
              if (err) {
                return cb(err);
              }
              bytes2.copy(buf, offset);
              cb(null, buf);
            });
            return;
          }
          var bytes = randombytes(size);
          bytes.copy(buf, offset);
          return buf;
        }
        function randomFillSync(buf, offset, size) {
          if (typeof offset === "undefined") {
            offset = 0;
          }
          if (!Buffer.isBuffer(buf) && !(buf instanceof global2.Uint8Array)) {
            throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
          }
          assertOffset(offset, buf.length);
          if (size === void 0)
            size = buf.length - offset;
          assertSize(size, offset, buf.length);
          return actualFill(buf, offset, size);
        }
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "_process": 467, "randombytes": 475, "safe-buffer": 494 }], 477: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      var codes = {};
      function createErrorType(code, message, Base) {
        if (!Base) {
          Base = Error;
        }
        function getMessage(arg1, arg2, arg3) {
          if (typeof message === "string") {
            return message;
          } else {
            return message(arg1, arg2, arg3);
          }
        }
        var NodeError = /* @__PURE__ */ function(_Base) {
          _inheritsLoose(NodeError2, _Base);
          function NodeError2(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
          }
          return NodeError2;
        }(Base);
        NodeError.prototype.name = Base.name;
        NodeError.prototype.code = code;
        codes[code] = NodeError;
      }
      function oneOf(expected, thing) {
        if (Array.isArray(expected)) {
          var len = expected.length;
          expected = expected.map(function(i) {
            return String(i);
          });
          if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
          } else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
          } else {
            return "of ".concat(thing, " ").concat(expected[0]);
          }
        } else {
          return "of ".concat(thing, " ").concat(String(expected));
        }
      }
      function startsWith(str, search, pos) {
        return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
      }
      function endsWith(str, search, this_len) {
        if (this_len === void 0 || this_len > str.length) {
          this_len = str.length;
        }
        return str.substring(this_len - search.length, this_len) === search;
      }
      function includes(str, search, start) {
        if (typeof start !== "number") {
          start = 0;
        }
        if (start + search.length > str.length) {
          return false;
        } else {
          return str.indexOf(search, start) !== -1;
        }
      }
      createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
        return 'The value "' + value + '" is invalid for option "' + name + '"';
      }, TypeError);
      createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
        var determiner;
        if (typeof expected === "string" && startsWith(expected, "not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        var msg;
        if (endsWith(name, " argument")) {
          msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        } else {
          var type = includes(name, ".") ? "property" : "argument";
          msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
        }
        msg += ". Received type ".concat(_typeof2(actual));
        return msg;
      }, TypeError);
      createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
      createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
        return "The " + name + " method is not implemented";
      });
      createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
      createErrorType("ERR_STREAM_DESTROYED", function(name) {
        return "Cannot call " + name + " after a stream was destroyed";
      });
      createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
      createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
      createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
      createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
      createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
        return "Unknown encoding: " + arg;
      }, TypeError);
      createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
      module2.exports.codes = codes;
    }, {}], 478: [function(require2, module2, exports2) {
      (function(process) {
        var objectKeys = Object.keys || function(obj) {
          var keys2 = [];
          for (var key in obj) {
            keys2.push(key);
          }
          return keys2;
        };
        module2.exports = Duplex;
        var Readable = require2("./_stream_readable");
        var Writable = require2("./_stream_writable");
        require2("inherits")(Duplex, Readable);
        {
          var keys = objectKeys(Writable.prototype);
          for (var v = 0; v < keys.length; v++) {
            var method = keys[v];
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method];
          }
        }
        function Duplex(options) {
          if (!(this instanceof Duplex))
            return new Duplex(options);
          Readable.call(this, options);
          Writable.call(this, options);
          this.allowHalfOpen = true;
          if (options) {
            if (options.readable === false)
              this.readable = false;
            if (options.writable === false)
              this.writable = false;
            if (options.allowHalfOpen === false) {
              this.allowHalfOpen = false;
              this.once("end", onend);
            }
          }
        }
        Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState.highWaterMark;
          }
        });
        Object.defineProperty(Duplex.prototype, "writableBuffer", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState && this._writableState.getBuffer();
          }
        });
        Object.defineProperty(Duplex.prototype, "writableLength", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState.length;
          }
        });
        function onend() {
          if (this._writableState.ended)
            return;
          process.nextTick(onEndNT, this);
        }
        function onEndNT(self2) {
          self2.end();
        }
        Object.defineProperty(Duplex.prototype, "destroyed", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            if (this._readableState === void 0 || this._writableState === void 0) {
              return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
          },
          set: function set(value) {
            if (this._readableState === void 0 || this._writableState === void 0) {
              return;
            }
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        });
      }).call(this, require2("_process"));
    }, { "./_stream_readable": 480, "./_stream_writable": 482, "_process": 467, "inherits": 387 }], 479: [function(require2, module2, exports2) {
      module2.exports = PassThrough;
      var Transform = require2("./_stream_transform");
      require2("inherits")(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }, { "./_stream_transform": 481, "inherits": 387 }], 480: [function(require2, module2, exports2) {
      (function(process, global2) {
        module2.exports = Readable;
        var Duplex;
        Readable.ReadableState = ReadableState;
        require2("events").EventEmitter;
        var EElistenerCount = function EElistenerCount2(emitter, type) {
          return emitter.listeners(type).length;
        };
        var Stream = require2("./internal/streams/stream");
        var Buffer = require2("buffer").Buffer;
        var OurUint8Array = global2.Uint8Array || function() {
        };
        function _uint8ArrayToBuffer(chunk) {
          return Buffer.from(chunk);
        }
        function _isUint8Array(obj) {
          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        var debugUtil = require2("util");
        var debug;
        if (debugUtil && debugUtil.debuglog) {
          debug = debugUtil.debuglog("stream");
        } else {
          debug = function debug2() {
          };
        }
        var BufferList = require2("./internal/streams/buffer_list");
        var destroyImpl = require2("./internal/streams/destroy");
        var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
        var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
        var StringDecoder;
        var createReadableStreamAsyncIterator;
        var from;
        require2("inherits")(Readable, Stream);
        var errorOrDestroy = destroyImpl.errorOrDestroy;
        var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
        function prependListener(emitter, event, fn) {
          if (typeof emitter.prependListener === "function")
            return emitter.prependListener(event, fn);
          if (!emitter._events || !emitter._events[event])
            emitter.on(event, fn);
          else if (Array.isArray(emitter._events[event]))
            emitter._events[event].unshift(fn);
          else
            emitter._events[event] = [fn, emitter._events[event]];
        }
        function ReadableState(options, stream, isDuplex) {
          Duplex = Duplex || require2("./_stream_duplex");
          options = options || {};
          if (typeof isDuplex !== "boolean")
            isDuplex = stream instanceof Duplex;
          this.objectMode = !!options.objectMode;
          if (isDuplex)
            this.objectMode = this.objectMode || !!options.readableObjectMode;
          this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
          this.buffer = new BufferList();
          this.length = 0;
          this.pipes = null;
          this.pipesCount = 0;
          this.flowing = null;
          this.ended = false;
          this.endEmitted = false;
          this.reading = false;
          this.sync = true;
          this.needReadable = false;
          this.emittedReadable = false;
          this.readableListening = false;
          this.resumeScheduled = false;
          this.paused = true;
          this.emitClose = options.emitClose !== false;
          this.autoDestroy = !!options.autoDestroy;
          this.destroyed = false;
          this.defaultEncoding = options.defaultEncoding || "utf8";
          this.awaitDrain = 0;
          this.readingMore = false;
          this.decoder = null;
          this.encoding = null;
          if (options.encoding) {
            if (!StringDecoder)
              StringDecoder = require2("string_decoder/").StringDecoder;
            this.decoder = new StringDecoder(options.encoding);
            this.encoding = options.encoding;
          }
        }
        function Readable(options) {
          Duplex = Duplex || require2("./_stream_duplex");
          if (!(this instanceof Readable))
            return new Readable(options);
          var isDuplex = this instanceof Duplex;
          this._readableState = new ReadableState(options, this, isDuplex);
          this.readable = true;
          if (options) {
            if (typeof options.read === "function")
              this._read = options.read;
            if (typeof options.destroy === "function")
              this._destroy = options.destroy;
          }
          Stream.call(this);
        }
        Object.defineProperty(Readable.prototype, "destroyed", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            if (this._readableState === void 0) {
              return false;
            }
            return this._readableState.destroyed;
          },
          set: function set(value) {
            if (!this._readableState) {
              return;
            }
            this._readableState.destroyed = value;
          }
        });
        Readable.prototype.destroy = destroyImpl.destroy;
        Readable.prototype._undestroy = destroyImpl.undestroy;
        Readable.prototype._destroy = function(err, cb) {
          cb(err);
        };
        Readable.prototype.push = function(chunk, encoding) {
          var state = this._readableState;
          var skipChunkCheck;
          if (!state.objectMode) {
            if (typeof chunk === "string") {
              encoding = encoding || state.defaultEncoding;
              if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
              }
              skipChunkCheck = true;
            }
          } else {
            skipChunkCheck = true;
          }
          return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
        };
        Readable.prototype.unshift = function(chunk) {
          return readableAddChunk(this, chunk, null, true, false);
        };
        function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
          debug("readableAddChunk", chunk);
          var state = stream._readableState;
          if (chunk === null) {
            state.reading = false;
            onEofChunk(stream, state);
          } else {
            var er;
            if (!skipChunkCheck)
              er = chunkInvalid(state, chunk);
            if (er) {
              errorOrDestroy(stream, er);
            } else if (state.objectMode || chunk && chunk.length > 0) {
              if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
              }
              if (addToFront) {
                if (state.endEmitted)
                  errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else
                  addChunk(stream, state, chunk, true);
              } else if (state.ended) {
                errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
              } else if (state.destroyed) {
                return false;
              } else {
                state.reading = false;
                if (state.decoder && !encoding) {
                  chunk = state.decoder.write(chunk);
                  if (state.objectMode || chunk.length !== 0)
                    addChunk(stream, state, chunk, false);
                  else
                    maybeReadMore(stream, state);
                } else {
                  addChunk(stream, state, chunk, false);
                }
              }
            } else if (!addToFront) {
              state.reading = false;
              maybeReadMore(stream, state);
            }
          }
          return !state.ended && (state.length < state.highWaterMark || state.length === 0);
        }
        function addChunk(stream, state, chunk, addToFront) {
          if (state.flowing && state.length === 0 && !state.sync) {
            state.awaitDrain = 0;
            stream.emit("data", chunk);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
        function chunkInvalid(state, chunk) {
          var er;
          if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
            er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
          }
          return er;
        }
        Readable.prototype.isPaused = function() {
          return this._readableState.flowing === false;
        };
        Readable.prototype.setEncoding = function(enc) {
          if (!StringDecoder)
            StringDecoder = require2("string_decoder/").StringDecoder;
          var decoder = new StringDecoder(enc);
          this._readableState.decoder = decoder;
          this._readableState.encoding = this._readableState.decoder.encoding;
          var p = this._readableState.buffer.head;
          var content = "";
          while (p !== null) {
            content += decoder.write(p.data);
            p = p.next;
          }
          this._readableState.buffer.clear();
          if (content !== "")
            this._readableState.buffer.push(content);
          this._readableState.length = content.length;
          return this;
        };
        var MAX_HWM = 1073741824;
        function computeNewHighWaterMark(n) {
          if (n >= MAX_HWM) {
            n = MAX_HWM;
          } else {
            n--;
            n |= n >>> 1;
            n |= n >>> 2;
            n |= n >>> 4;
            n |= n >>> 8;
            n |= n >>> 16;
            n++;
          }
          return n;
        }
        function howMuchToRead(n, state) {
          if (n <= 0 || state.length === 0 && state.ended)
            return 0;
          if (state.objectMode)
            return 1;
          if (n !== n) {
            if (state.flowing && state.length)
              return state.buffer.head.data.length;
            else
              return state.length;
          }
          if (n > state.highWaterMark)
            state.highWaterMark = computeNewHighWaterMark(n);
          if (n <= state.length)
            return n;
          if (!state.ended) {
            state.needReadable = true;
            return 0;
          }
          return state.length;
        }
        Readable.prototype.read = function(n) {
          debug("read", n);
          n = parseInt(n, 10);
          var state = this._readableState;
          var nOrig = n;
          if (n !== 0)
            state.emittedReadable = false;
          if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
            debug("read: emitReadable", state.length, state.ended);
            if (state.length === 0 && state.ended)
              endReadable(this);
            else
              emitReadable(this);
            return null;
          }
          n = howMuchToRead(n, state);
          if (n === 0 && state.ended) {
            if (state.length === 0)
              endReadable(this);
            return null;
          }
          var doRead = state.needReadable;
          debug("need readable", doRead);
          if (state.length === 0 || state.length - n < state.highWaterMark) {
            doRead = true;
            debug("length less than watermark", doRead);
          }
          if (state.ended || state.reading) {
            doRead = false;
            debug("reading or ended", doRead);
          } else if (doRead) {
            debug("do read");
            state.reading = true;
            state.sync = true;
            if (state.length === 0)
              state.needReadable = true;
            this._read(state.highWaterMark);
            state.sync = false;
            if (!state.reading)
              n = howMuchToRead(nOrig, state);
          }
          var ret;
          if (n > 0)
            ret = fromList(n, state);
          else
            ret = null;
          if (ret === null) {
            state.needReadable = state.length <= state.highWaterMark;
            n = 0;
          } else {
            state.length -= n;
            state.awaitDrain = 0;
          }
          if (state.length === 0) {
            if (!state.ended)
              state.needReadable = true;
            if (nOrig !== n && state.ended)
              endReadable(this);
          }
          if (ret !== null)
            this.emit("data", ret);
          return ret;
        };
        function onEofChunk(stream, state) {
          debug("onEofChunk");
          if (state.ended)
            return;
          if (state.decoder) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) {
              state.buffer.push(chunk);
              state.length += state.objectMode ? 1 : chunk.length;
            }
          }
          state.ended = true;
          if (state.sync) {
            emitReadable(stream);
          } else {
            state.needReadable = false;
            if (!state.emittedReadable) {
              state.emittedReadable = true;
              emitReadable_(stream);
            }
          }
        }
        function emitReadable(stream) {
          var state = stream._readableState;
          debug("emitReadable", state.needReadable, state.emittedReadable);
          state.needReadable = false;
          if (!state.emittedReadable) {
            debug("emitReadable", state.flowing);
            state.emittedReadable = true;
            process.nextTick(emitReadable_, stream);
          }
        }
        function emitReadable_(stream) {
          var state = stream._readableState;
          debug("emitReadable_", state.destroyed, state.length, state.ended);
          if (!state.destroyed && (state.length || state.ended)) {
            stream.emit("readable");
            state.emittedReadable = false;
          }
          state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
          flow(stream);
        }
        function maybeReadMore(stream, state) {
          if (!state.readingMore) {
            state.readingMore = true;
            process.nextTick(maybeReadMore_, stream, state);
          }
        }
        function maybeReadMore_(stream, state) {
          while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
            var len = state.length;
            debug("maybeReadMore read 0");
            stream.read(0);
            if (len === state.length)
              break;
          }
          state.readingMore = false;
        }
        Readable.prototype._read = function(n) {
          errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
        };
        Readable.prototype.pipe = function(dest, pipeOpts) {
          var src = this;
          var state = this._readableState;
          switch (state.pipesCount) {
            case 0:
              state.pipes = dest;
              break;
            case 1:
              state.pipes = [state.pipes, dest];
              break;
            default:
              state.pipes.push(dest);
              break;
          }
          state.pipesCount += 1;
          debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
          var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
          var endFn = doEnd ? onend : unpipe;
          if (state.endEmitted)
            process.nextTick(endFn);
          else
            src.once("end", endFn);
          dest.on("unpipe", onunpipe);
          function onunpipe(readable, unpipeInfo) {
            debug("onunpipe");
            if (readable === src) {
              if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
              }
            }
          }
          function onend() {
            debug("onend");
            dest.end();
          }
          var ondrain = pipeOnDrain(src);
          dest.on("drain", ondrain);
          var cleanedUp = false;
          function cleanup() {
            debug("cleanup");
            dest.removeListener("close", onclose);
            dest.removeListener("finish", onfinish);
            dest.removeListener("drain", ondrain);
            dest.removeListener("error", onerror);
            dest.removeListener("unpipe", onunpipe);
            src.removeListener("end", onend);
            src.removeListener("end", unpipe);
            src.removeListener("data", ondata);
            cleanedUp = true;
            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
              ondrain();
          }
          src.on("data", ondata);
          function ondata(chunk) {
            debug("ondata");
            var ret = dest.write(chunk);
            debug("dest.write", ret);
            if (ret === false) {
              if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
              }
              src.pause();
            }
          }
          function onerror(er) {
            debug("onerror", er);
            unpipe();
            dest.removeListener("error", onerror);
            if (EElistenerCount(dest, "error") === 0)
              errorOrDestroy(dest, er);
          }
          prependListener(dest, "error", onerror);
          function onclose() {
            dest.removeListener("finish", onfinish);
            unpipe();
          }
          dest.once("close", onclose);
          function onfinish() {
            debug("onfinish");
            dest.removeListener("close", onclose);
            unpipe();
          }
          dest.once("finish", onfinish);
          function unpipe() {
            debug("unpipe");
            src.unpipe(dest);
          }
          dest.emit("pipe", src);
          if (!state.flowing) {
            debug("pipe resume");
            src.resume();
          }
          return dest;
        };
        function pipeOnDrain(src) {
          return function pipeOnDrainFunctionResult() {
            var state = src._readableState;
            debug("pipeOnDrain", state.awaitDrain);
            if (state.awaitDrain)
              state.awaitDrain--;
            if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
              state.flowing = true;
              flow(src);
            }
          };
        }
        Readable.prototype.unpipe = function(dest) {
          var state = this._readableState;
          var unpipeInfo = { hasUnpiped: false };
          if (state.pipesCount === 0)
            return this;
          if (state.pipesCount === 1) {
            if (dest && dest !== state.pipes)
              return this;
            if (!dest)
              dest = state.pipes;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            if (dest)
              dest.emit("unpipe", this, unpipeInfo);
            return this;
          }
          if (!dest) {
            var dests = state.pipes;
            var len = state.pipesCount;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            for (var i = 0; i < len; i++) {
              dests[i].emit("unpipe", this, { hasUnpiped: false });
            }
            return this;
          }
          var index2 = indexOf(state.pipes, dest);
          if (index2 === -1)
            return this;
          state.pipes.splice(index2, 1);
          state.pipesCount -= 1;
          if (state.pipesCount === 1)
            state.pipes = state.pipes[0];
          dest.emit("unpipe", this, unpipeInfo);
          return this;
        };
        Readable.prototype.on = function(ev, fn) {
          var res = Stream.prototype.on.call(this, ev, fn);
          var state = this._readableState;
          if (ev === "data") {
            state.readableListening = this.listenerCount("readable") > 0;
            if (state.flowing !== false)
              this.resume();
          } else if (ev === "readable") {
            if (!state.endEmitted && !state.readableListening) {
              state.readableListening = state.needReadable = true;
              state.flowing = false;
              state.emittedReadable = false;
              debug("on readable", state.length, state.reading);
              if (state.length) {
                emitReadable(this);
              } else if (!state.reading) {
                process.nextTick(nReadingNextTick, this);
              }
            }
          }
          return res;
        };
        Readable.prototype.addListener = Readable.prototype.on;
        Readable.prototype.removeListener = function(ev, fn) {
          var res = Stream.prototype.removeListener.call(this, ev, fn);
          if (ev === "readable") {
            process.nextTick(updateReadableListening, this);
          }
          return res;
        };
        Readable.prototype.removeAllListeners = function(ev) {
          var res = Stream.prototype.removeAllListeners.apply(this, arguments);
          if (ev === "readable" || ev === void 0) {
            process.nextTick(updateReadableListening, this);
          }
          return res;
        };
        function updateReadableListening(self2) {
          var state = self2._readableState;
          state.readableListening = self2.listenerCount("readable") > 0;
          if (state.resumeScheduled && !state.paused) {
            state.flowing = true;
          } else if (self2.listenerCount("data") > 0) {
            self2.resume();
          }
        }
        function nReadingNextTick(self2) {
          debug("readable nexttick read 0");
          self2.read(0);
        }
        Readable.prototype.resume = function() {
          var state = this._readableState;
          if (!state.flowing) {
            debug("resume");
            state.flowing = !state.readableListening;
            resume(this, state);
          }
          state.paused = false;
          return this;
        };
        function resume(stream, state) {
          if (!state.resumeScheduled) {
            state.resumeScheduled = true;
            process.nextTick(resume_, stream, state);
          }
        }
        function resume_(stream, state) {
          debug("resume", state.reading);
          if (!state.reading) {
            stream.read(0);
          }
          state.resumeScheduled = false;
          stream.emit("resume");
          flow(stream);
          if (state.flowing && !state.reading)
            stream.read(0);
        }
        Readable.prototype.pause = function() {
          debug("call pause flowing=%j", this._readableState.flowing);
          if (this._readableState.flowing !== false) {
            debug("pause");
            this._readableState.flowing = false;
            this.emit("pause");
          }
          this._readableState.paused = true;
          return this;
        };
        function flow(stream) {
          var state = stream._readableState;
          debug("flow", state.flowing);
          while (state.flowing && stream.read() !== null) {
          }
        }
        Readable.prototype.wrap = function(stream) {
          var _this = this;
          var state = this._readableState;
          var paused = false;
          stream.on("end", function() {
            debug("wrapped end");
            if (state.decoder && !state.ended) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length)
                _this.push(chunk);
            }
            _this.push(null);
          });
          stream.on("data", function(chunk) {
            debug("wrapped data");
            if (state.decoder)
              chunk = state.decoder.write(chunk);
            if (state.objectMode && (chunk === null || chunk === void 0))
              return;
            else if (!state.objectMode && (!chunk || !chunk.length))
              return;
            var ret = _this.push(chunk);
            if (!ret) {
              paused = true;
              stream.pause();
            }
          });
          for (var i in stream) {
            if (this[i] === void 0 && typeof stream[i] === "function") {
              this[i] = function methodWrap(method) {
                return function methodWrapReturnFunction() {
                  return stream[method].apply(stream, arguments);
                };
              }(i);
            }
          }
          for (var n = 0; n < kProxyEvents.length; n++) {
            stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
          }
          this._read = function(n2) {
            debug("wrapped _read", n2);
            if (paused) {
              paused = false;
              stream.resume();
            }
          };
          return this;
        };
        if (typeof Symbol === "function") {
          Readable.prototype[Symbol.asyncIterator] = function() {
            if (createReadableStreamAsyncIterator === void 0) {
              createReadableStreamAsyncIterator = require2("./internal/streams/async_iterator");
            }
            return createReadableStreamAsyncIterator(this);
          };
        }
        Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._readableState.highWaterMark;
          }
        });
        Object.defineProperty(Readable.prototype, "readableBuffer", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._readableState && this._readableState.buffer;
          }
        });
        Object.defineProperty(Readable.prototype, "readableFlowing", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._readableState.flowing;
          },
          set: function set(state) {
            if (this._readableState) {
              this._readableState.flowing = state;
            }
          }
        });
        Readable._fromList = fromList;
        Object.defineProperty(Readable.prototype, "readableLength", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._readableState.length;
          }
        });
        function fromList(n, state) {
          if (state.length === 0)
            return null;
          var ret;
          if (state.objectMode)
            ret = state.buffer.shift();
          else if (!n || n >= state.length) {
            if (state.decoder)
              ret = state.buffer.join("");
            else if (state.buffer.length === 1)
              ret = state.buffer.first();
            else
              ret = state.buffer.concat(state.length);
            state.buffer.clear();
          } else {
            ret = state.buffer.consume(n, state.decoder);
          }
          return ret;
        }
        function endReadable(stream) {
          var state = stream._readableState;
          debug("endReadable", state.endEmitted);
          if (!state.endEmitted) {
            state.ended = true;
            process.nextTick(endReadableNT, state, stream);
          }
        }
        function endReadableNT(state, stream) {
          debug("endReadableNT", state.endEmitted, state.length);
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
            if (state.autoDestroy) {
              var wState = stream._writableState;
              if (!wState || wState.autoDestroy && wState.finished) {
                stream.destroy();
              }
            }
          }
        }
        if (typeof Symbol === "function") {
          Readable.from = function(iterable, opts) {
            if (from === void 0) {
              from = require2("./internal/streams/from");
            }
            return from(Readable, iterable, opts);
          };
        }
        function indexOf(xs, x) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (xs[i] === x)
              return i;
          }
          return -1;
        }
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "../errors": 477, "./_stream_duplex": 478, "./internal/streams/async_iterator": 483, "./internal/streams/buffer_list": 484, "./internal/streams/destroy": 485, "./internal/streams/from": 487, "./internal/streams/state": 489, "./internal/streams/stream": 490, "_process": 467, "buffer": 216, "events": 367, "inherits": 387, "string_decoder/": 520, "util": 185 }], 481: [function(require2, module2, exports2) {
      module2.exports = Transform;
      var _require$codes = require2("../errors").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
      var Duplex = require2("./_stream_duplex");
      require2("inherits")(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (cb === null) {
          return this.emit("error", new ERR_MULTIPLE_CALLBACK());
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = { afterTransform: afterTransform.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function" && !this._readableState.destroyed) {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new ERR_TRANSFORM_WITH_LENGTH_0();
        if (stream._transformState.transforming)
          throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
        return stream.push(null);
      }
    }, { "../errors": 477, "./_stream_duplex": 478, "inherits": 387 }], 482: [function(require2, module2, exports2) {
      (function(process, global2) {
        module2.exports = Writable;
        function CorkedRequest(state) {
          var _this = this;
          this.next = null;
          this.entry = null;
          this.finish = function() {
            onCorkedFinish(_this, state);
          };
        }
        var Duplex;
        Writable.WritableState = WritableState;
        var internalUtil = { deprecate: require2("util-deprecate") };
        var Stream = require2("./internal/streams/stream");
        var Buffer = require2("buffer").Buffer;
        var OurUint8Array = global2.Uint8Array || function() {
        };
        function _uint8ArrayToBuffer(chunk) {
          return Buffer.from(chunk);
        }
        function _isUint8Array(obj) {
          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        var destroyImpl = require2("./internal/streams/destroy");
        var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
        var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
        var errorOrDestroy = destroyImpl.errorOrDestroy;
        require2("inherits")(Writable, Stream);
        function nop() {
        }
        function WritableState(options, stream, isDuplex) {
          Duplex = Duplex || require2("./_stream_duplex");
          options = options || {};
          if (typeof isDuplex !== "boolean")
            isDuplex = stream instanceof Duplex;
          this.objectMode = !!options.objectMode;
          if (isDuplex)
            this.objectMode = this.objectMode || !!options.writableObjectMode;
          this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
          this.finalCalled = false;
          this.needDrain = false;
          this.ending = false;
          this.ended = false;
          this.finished = false;
          this.destroyed = false;
          var noDecode = options.decodeStrings === false;
          this.decodeStrings = !noDecode;
          this.defaultEncoding = options.defaultEncoding || "utf8";
          this.length = 0;
          this.writing = false;
          this.corked = 0;
          this.sync = true;
          this.bufferProcessing = false;
          this.onwrite = function(er) {
            onwrite(stream, er);
          };
          this.writecb = null;
          this.writelen = 0;
          this.bufferedRequest = null;
          this.lastBufferedRequest = null;
          this.pendingcb = 0;
          this.prefinished = false;
          this.errorEmitted = false;
          this.emitClose = options.emitClose !== false;
          this.autoDestroy = !!options.autoDestroy;
          this.bufferedRequestCount = 0;
          this.corkedRequestsFree = new CorkedRequest(this);
        }
        WritableState.prototype.getBuffer = function getBuffer() {
          var current = this.bufferedRequest;
          var out = [];
          while (current) {
            out.push(current);
            current = current.next;
          }
          return out;
        };
        (function() {
          try {
            Object.defineProperty(WritableState.prototype, "buffer", { get: internalUtil.deprecate(function writableStateBufferGetter() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
          } catch (_) {
          }
        })();
        var realHasInstance;
        if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
          realHasInstance = Function.prototype[Symbol.hasInstance];
          Object.defineProperty(Writable, Symbol.hasInstance, { value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          } });
        } else {
          realHasInstance = function realHasInstance2(object) {
            return object instanceof this;
          };
        }
        function Writable(options) {
          Duplex = Duplex || require2("./_stream_duplex");
          var isDuplex = this instanceof Duplex;
          if (!isDuplex && !realHasInstance.call(Writable, this))
            return new Writable(options);
          this._writableState = new WritableState(options, this, isDuplex);
          this.writable = true;
          if (options) {
            if (typeof options.write === "function")
              this._write = options.write;
            if (typeof options.writev === "function")
              this._writev = options.writev;
            if (typeof options.destroy === "function")
              this._destroy = options.destroy;
            if (typeof options.final === "function")
              this._final = options.final;
          }
          Stream.call(this);
        }
        Writable.prototype.pipe = function() {
          errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
        };
        function writeAfterEnd(stream, cb) {
          var er = new ERR_STREAM_WRITE_AFTER_END();
          errorOrDestroy(stream, er);
          process.nextTick(cb, er);
        }
        function validChunk(stream, state, chunk, cb) {
          var er;
          if (chunk === null) {
            er = new ERR_STREAM_NULL_VALUES();
          } else if (typeof chunk !== "string" && !state.objectMode) {
            er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
          }
          if (er) {
            errorOrDestroy(stream, er);
            process.nextTick(cb, er);
            return false;
          }
          return true;
        }
        Writable.prototype.write = function(chunk, encoding, cb) {
          var state = this._writableState;
          var ret = false;
          var isBuf = !state.objectMode && _isUint8Array(chunk);
          if (isBuf && !Buffer.isBuffer(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (typeof encoding === "function") {
            cb = encoding;
            encoding = null;
          }
          if (isBuf)
            encoding = "buffer";
          else if (!encoding)
            encoding = state.defaultEncoding;
          if (typeof cb !== "function")
            cb = nop;
          if (state.ending)
            writeAfterEnd(this, cb);
          else if (isBuf || validChunk(this, state, chunk, cb)) {
            state.pendingcb++;
            ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
          }
          return ret;
        };
        Writable.prototype.cork = function() {
          this._writableState.corked++;
        };
        Writable.prototype.uncork = function() {
          var state = this._writableState;
          if (state.corked) {
            state.corked--;
            if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
              clearBuffer(this, state);
          }
        };
        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
          if (typeof encoding === "string")
            encoding = encoding.toLowerCase();
          if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
            throw new ERR_UNKNOWN_ENCODING(encoding);
          this._writableState.defaultEncoding = encoding;
          return this;
        };
        Object.defineProperty(Writable.prototype, "writableBuffer", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState && this._writableState.getBuffer();
          }
        });
        function decodeChunk(state, chunk, encoding) {
          if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
            chunk = Buffer.from(chunk, encoding);
          }
          return chunk;
        }
        Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState.highWaterMark;
          }
        });
        function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
          if (!isBuf) {
            var newChunk = decodeChunk(state, chunk, encoding);
            if (chunk !== newChunk) {
              isBuf = true;
              encoding = "buffer";
              chunk = newChunk;
            }
          }
          var len = state.objectMode ? 1 : chunk.length;
          state.length += len;
          var ret = state.length < state.highWaterMark;
          if (!ret)
            state.needDrain = true;
          if (state.writing || state.corked) {
            var last = state.lastBufferedRequest;
            state.lastBufferedRequest = { chunk, encoding, isBuf, callback: cb, next: null };
            if (last) {
              last.next = state.lastBufferedRequest;
            } else {
              state.bufferedRequest = state.lastBufferedRequest;
            }
            state.bufferedRequestCount += 1;
          } else {
            doWrite(stream, state, false, len, chunk, encoding, cb);
          }
          return ret;
        }
        function doWrite(stream, state, writev, len, chunk, encoding, cb) {
          state.writelen = len;
          state.writecb = cb;
          state.writing = true;
          state.sync = true;
          if (state.destroyed)
            state.onwrite(new ERR_STREAM_DESTROYED("write"));
          else if (writev)
            stream._writev(chunk, state.onwrite);
          else
            stream._write(chunk, encoding, state.onwrite);
          state.sync = false;
        }
        function onwriteError(stream, state, sync, er, cb) {
          --state.pendingcb;
          if (sync) {
            process.nextTick(cb, er);
            process.nextTick(finishMaybe, stream, state);
            stream._writableState.errorEmitted = true;
            errorOrDestroy(stream, er);
          } else {
            cb(er);
            stream._writableState.errorEmitted = true;
            errorOrDestroy(stream, er);
            finishMaybe(stream, state);
          }
        }
        function onwriteStateUpdate(state) {
          state.writing = false;
          state.writecb = null;
          state.length -= state.writelen;
          state.writelen = 0;
        }
        function onwrite(stream, er) {
          var state = stream._writableState;
          var sync = state.sync;
          var cb = state.writecb;
          if (typeof cb !== "function")
            throw new ERR_MULTIPLE_CALLBACK();
          onwriteStateUpdate(state);
          if (er)
            onwriteError(stream, state, sync, er, cb);
          else {
            var finished = needFinish(state) || stream.destroyed;
            if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
              clearBuffer(stream, state);
            }
            if (sync) {
              process.nextTick(afterWrite, stream, state, finished, cb);
            } else {
              afterWrite(stream, state, finished, cb);
            }
          }
        }
        function afterWrite(stream, state, finished, cb) {
          if (!finished)
            onwriteDrain(stream, state);
          state.pendingcb--;
          cb();
          finishMaybe(stream, state);
        }
        function onwriteDrain(stream, state) {
          if (state.length === 0 && state.needDrain) {
            state.needDrain = false;
            stream.emit("drain");
          }
        }
        function clearBuffer(stream, state) {
          state.bufferProcessing = true;
          var entry = state.bufferedRequest;
          if (stream._writev && entry && entry.next) {
            var l = state.bufferedRequestCount;
            var buffer = new Array(l);
            var holder = state.corkedRequestsFree;
            holder.entry = entry;
            var count = 0;
            var allBuffers = true;
            while (entry) {
              buffer[count] = entry;
              if (!entry.isBuf)
                allBuffers = false;
              entry = entry.next;
              count += 1;
            }
            buffer.allBuffers = allBuffers;
            doWrite(stream, state, true, state.length, buffer, "", holder.finish);
            state.pendingcb++;
            state.lastBufferedRequest = null;
            if (holder.next) {
              state.corkedRequestsFree = holder.next;
              holder.next = null;
            } else {
              state.corkedRequestsFree = new CorkedRequest(state);
            }
            state.bufferedRequestCount = 0;
          } else {
            while (entry) {
              var chunk = entry.chunk;
              var encoding = entry.encoding;
              var cb = entry.callback;
              var len = state.objectMode ? 1 : chunk.length;
              doWrite(stream, state, false, len, chunk, encoding, cb);
              entry = entry.next;
              state.bufferedRequestCount--;
              if (state.writing) {
                break;
              }
            }
            if (entry === null)
              state.lastBufferedRequest = null;
          }
          state.bufferedRequest = entry;
          state.bufferProcessing = false;
        }
        Writable.prototype._write = function(chunk, encoding, cb) {
          cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
        };
        Writable.prototype._writev = null;
        Writable.prototype.end = function(chunk, encoding, cb) {
          var state = this._writableState;
          if (typeof chunk === "function") {
            cb = chunk;
            chunk = null;
            encoding = null;
          } else if (typeof encoding === "function") {
            cb = encoding;
            encoding = null;
          }
          if (chunk !== null && chunk !== void 0)
            this.write(chunk, encoding);
          if (state.corked) {
            state.corked = 1;
            this.uncork();
          }
          if (!state.ending)
            endWritable(this, state, cb);
          return this;
        };
        Object.defineProperty(Writable.prototype, "writableLength", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState.length;
          }
        });
        function needFinish(state) {
          return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
        }
        function callFinal(stream, state) {
          stream._final(function(err) {
            state.pendingcb--;
            if (err) {
              errorOrDestroy(stream, err);
            }
            state.prefinished = true;
            stream.emit("prefinish");
            finishMaybe(stream, state);
          });
        }
        function prefinish(stream, state) {
          if (!state.prefinished && !state.finalCalled) {
            if (typeof stream._final === "function" && !state.destroyed) {
              state.pendingcb++;
              state.finalCalled = true;
              process.nextTick(callFinal, stream, state);
            } else {
              state.prefinished = true;
              stream.emit("prefinish");
            }
          }
        }
        function finishMaybe(stream, state) {
          var need = needFinish(state);
          if (need) {
            prefinish(stream, state);
            if (state.pendingcb === 0) {
              state.finished = true;
              stream.emit("finish");
              if (state.autoDestroy) {
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) {
                  stream.destroy();
                }
              }
            }
          }
          return need;
        }
        function endWritable(stream, state, cb) {
          state.ending = true;
          finishMaybe(stream, state);
          if (cb) {
            if (state.finished)
              process.nextTick(cb);
            else
              stream.once("finish", cb);
          }
          state.ended = true;
          stream.writable = false;
        }
        function onCorkedFinish(corkReq, state, err) {
          var entry = corkReq.entry;
          corkReq.entry = null;
          while (entry) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(err);
            entry = entry.next;
          }
          state.corkedRequestsFree.next = corkReq;
        }
        Object.defineProperty(Writable.prototype, "destroyed", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            if (this._writableState === void 0) {
              return false;
            }
            return this._writableState.destroyed;
          },
          set: function set(value) {
            if (!this._writableState) {
              return;
            }
            this._writableState.destroyed = value;
          }
        });
        Writable.prototype.destroy = destroyImpl.destroy;
        Writable.prototype._undestroy = destroyImpl.undestroy;
        Writable.prototype._destroy = function(err, cb) {
          cb(err);
        };
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "../errors": 477, "./_stream_duplex": 478, "./internal/streams/destroy": 485, "./internal/streams/state": 489, "./internal/streams/stream": 490, "_process": 467, "buffer": 216, "inherits": 387, "util-deprecate": 522 }], 483: [function(require2, module2, exports2) {
      (function(process) {
        var _Object$setPrototypeO;
        function _defineProperty2(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var finished = require2("./end-of-stream");
        var kLastResolve = Symbol("lastResolve");
        var kLastReject = Symbol("lastReject");
        var kError = Symbol("error");
        var kEnded = Symbol("ended");
        var kLastPromise = Symbol("lastPromise");
        var kHandlePromise = Symbol("handlePromise");
        var kStream = Symbol("stream");
        function createIterResult(value, done) {
          return { value, done };
        }
        function readAndResolve(iter) {
          var resolve = iter[kLastResolve];
          if (resolve !== null) {
            var data = iter[kStream].read();
            if (data !== null) {
              iter[kLastPromise] = null;
              iter[kLastResolve] = null;
              iter[kLastReject] = null;
              resolve(createIterResult(data, false));
            }
          }
        }
        function onReadable(iter) {
          process.nextTick(readAndResolve, iter);
        }
        function wrapForNext(lastPromise, iter) {
          return function(resolve, reject) {
            lastPromise.then(function() {
              if (iter[kEnded]) {
                resolve(createIterResult(void 0, true));
                return;
              }
              iter[kHandlePromise](resolve, reject);
            }, reject);
          };
        }
        var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
        });
        var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = { get stream() {
          return this[kStream];
        }, next: function next() {
          var _this = this;
          var error = this[kError];
          if (error !== null) {
            return Promise.reject(error);
          }
          if (this[kEnded]) {
            return Promise.resolve(createIterResult(void 0, true));
          }
          if (this[kStream].destroyed) {
            return new Promise(function(resolve, reject) {
              process.nextTick(function() {
                if (_this[kError]) {
                  reject(_this[kError]);
                } else {
                  resolve(createIterResult(void 0, true));
                }
              });
            });
          }
          var lastPromise = this[kLastPromise];
          var promise;
          if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
          } else {
            var data = this[kStream].read();
            if (data !== null) {
              return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
          }
          this[kLastPromise] = promise;
          return promise;
        } }, _defineProperty2(_Object$setPrototypeO, Symbol.asyncIterator, function() {
          return this;
        }), _defineProperty2(_Object$setPrototypeO, "return", function _return() {
          var _this2 = this;
          return new Promise(function(resolve, reject) {
            _this2[kStream].destroy(null, function(err) {
              if (err) {
                reject(err);
                return;
              }
              resolve(createIterResult(void 0, true));
            });
          });
        }), _Object$setPrototypeO), AsyncIteratorPrototype);
        var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
          var _Object$create;
          var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty2(_Object$create, kStream, { value: stream, writable: true }), _defineProperty2(_Object$create, kLastResolve, { value: null, writable: true }), _defineProperty2(_Object$create, kLastReject, { value: null, writable: true }), _defineProperty2(_Object$create, kError, { value: null, writable: true }), _defineProperty2(_Object$create, kEnded, { value: stream._readableState.endEmitted, writable: true }), _defineProperty2(_Object$create, kHandlePromise, { value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(data, false));
            } else {
              iterator[kLastResolve] = resolve;
              iterator[kLastReject] = reject;
            }
          }, writable: true }), _Object$create));
          iterator[kLastPromise] = null;
          finished(stream, function(err) {
            if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              var reject = iterator[kLastReject];
              if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
              }
              iterator[kError] = err;
              return;
            }
            var resolve = iterator[kLastResolve];
            if (resolve !== null) {
              iterator[kLastPromise] = null;
              iterator[kLastResolve] = null;
              iterator[kLastReject] = null;
              resolve(createIterResult(void 0, true));
            }
            iterator[kEnded] = true;
          });
          stream.on("readable", onReadable.bind(null, iterator));
          return iterator;
        };
        module2.exports = createReadableStreamAsyncIterator;
      }).call(this, require2("_process"));
    }, { "./end-of-stream": 486, "_process": 467 }], 484: [function(require2, module2, exports2) {
      function ownKeys2(object, enumerableOnly) {
        var keys = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys.push.apply(keys, symbols);
        }
        return keys;
      }
      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};
          if (i % 2) {
            ownKeys2(Object(source), true).forEach(function(key) {
              _defineProperty2(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys2(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _defineProperty2(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      var _require = require2("buffer"), Buffer = _require.Buffer;
      var _require2 = require2("util"), inspect = _require2.inspect;
      var custom = inspect && inspect.custom || "inspect";
      function copyBuffer(src, target, offset) {
        Buffer.prototype.copy.call(src, target, offset);
      }
      module2.exports = /* @__PURE__ */ function() {
        function BufferList() {
          _classCallCheck2(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        _createClass2(BufferList, [{ key: "push", value: function push(v) {
          var entry = { data: v, next: null };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        } }, { key: "unshift", value: function unshift(v) {
          var entry = { data: v, next: this.head };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        } }, { key: "shift", value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        } }, { key: "clear", value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        } }, { key: "join", value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        } }, {
          key: "concat",
          value: function concat(n) {
            if (this.length === 0)
              return Buffer.alloc(0);
            var ret = Buffer.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }
          // Consumes a specified amount of bytes or characters from the buffered data.
        }, { key: "consume", value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        } }, {
          key: "first",
          value: function first() {
            return this.head.data;
          }
          // Consumes a specified amount of characters from the buffered data.
        }, {
          key: "_getString",
          value: function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Consumes a specified amount of bytes from the buffered data.
        }, {
          key: "_getBuffer",
          value: function _getBuffer(n) {
            var ret = Buffer.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }
          // Make sure the linked list only shows the minimal necessary information.
        }, { key: custom, value: function value(_, options) {
          return inspect(this, _objectSpread2({}, options, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        } }]);
        return BufferList;
      }();
    }, { "buffer": 216, "util": 185 }], 485: [function(require2, module2, exports2) {
      (function(process) {
        function destroy(err, cb) {
          var _this = this;
          var readableDestroyed = this._readableState && this._readableState.destroyed;
          var writableDestroyed = this._writableState && this._writableState.destroyed;
          if (readableDestroyed || writableDestroyed) {
            if (cb) {
              cb(err);
            } else if (err) {
              if (!this._writableState) {
                process.nextTick(emitErrorNT, this, err);
              } else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err);
              }
            }
            return this;
          }
          if (this._readableState) {
            this._readableState.destroyed = true;
          }
          if (this._writableState) {
            this._writableState.destroyed = true;
          }
          this._destroy(err || null, function(err2) {
            if (!cb && err2) {
              if (!_this._writableState) {
                process.nextTick(emitErrorAndCloseNT, _this, err2);
              } else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err2);
              } else {
                process.nextTick(emitCloseNT, _this);
              }
            } else if (cb) {
              process.nextTick(emitCloseNT, _this);
              cb(err2);
            } else {
              process.nextTick(emitCloseNT, _this);
            }
          });
          return this;
        }
        function emitErrorAndCloseNT(self2, err) {
          emitErrorNT(self2, err);
          emitCloseNT(self2);
        }
        function emitCloseNT(self2) {
          if (self2._writableState && !self2._writableState.emitClose)
            return;
          if (self2._readableState && !self2._readableState.emitClose)
            return;
          self2.emit("close");
        }
        function undestroy() {
          if (this._readableState) {
            this._readableState.destroyed = false;
            this._readableState.reading = false;
            this._readableState.ended = false;
            this._readableState.endEmitted = false;
          }
          if (this._writableState) {
            this._writableState.destroyed = false;
            this._writableState.ended = false;
            this._writableState.ending = false;
            this._writableState.finalCalled = false;
            this._writableState.prefinished = false;
            this._writableState.finished = false;
            this._writableState.errorEmitted = false;
          }
        }
        function emitErrorNT(self2, err) {
          self2.emit("error", err);
        }
        function errorOrDestroy(stream, err) {
          var rState = stream._readableState;
          var wState = stream._writableState;
          if (rState && rState.autoDestroy || wState && wState.autoDestroy)
            stream.destroy(err);
          else
            stream.emit("error", err);
        }
        module2.exports = { destroy, undestroy, errorOrDestroy };
      }).call(this, require2("_process"));
    }, { "_process": 467 }], 486: [function(require2, module2, exports2) {
      var ERR_STREAM_PREMATURE_CLOSE = require2("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function once(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          callback.apply(this, args);
        };
      }
      function noop() {
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function eos(stream, opts, callback) {
        if (typeof opts === "function")
          return eos(stream, null, opts);
        if (!opts)
          opts = {};
        callback = once(callback || noop);
        var readable = opts.readable || opts.readable !== false && stream.readable;
        var writable = opts.writable || opts.writable !== false && stream.writable;
        var onlegacyfinish = function onlegacyfinish2() {
          if (!stream.writable)
            onfinish();
        };
        var writableEnded = stream._writableState && stream._writableState.finished;
        var onfinish = function onfinish2() {
          writable = false;
          writableEnded = true;
          if (!readable)
            callback.call(stream);
        };
        var readableEnded = stream._readableState && stream._readableState.endEmitted;
        var onend = function onend2() {
          readable = false;
          readableEnded = true;
          if (!writable)
            callback.call(stream);
        };
        var onerror = function onerror2(err) {
          callback.call(stream, err);
        };
        var onclose = function onclose2() {
          var err;
          if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
          if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
              err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
          }
        };
        var onrequest = function onrequest2() {
          stream.req.on("finish", onfinish);
        };
        if (isRequest(stream)) {
          stream.on("complete", onfinish);
          stream.on("abort", onclose);
          if (stream.req)
            onrequest();
          else
            stream.on("request", onrequest);
        } else if (writable && !stream._writableState) {
          stream.on("end", onlegacyfinish);
          stream.on("close", onlegacyfinish);
        }
        stream.on("end", onend);
        stream.on("finish", onfinish);
        if (opts.error !== false)
          stream.on("error", onerror);
        stream.on("close", onclose);
        return function() {
          stream.removeListener("complete", onfinish);
          stream.removeListener("abort", onclose);
          stream.removeListener("request", onrequest);
          if (stream.req)
            stream.req.removeListener("finish", onfinish);
          stream.removeListener("end", onlegacyfinish);
          stream.removeListener("close", onlegacyfinish);
          stream.removeListener("finish", onfinish);
          stream.removeListener("end", onend);
          stream.removeListener("error", onerror);
          stream.removeListener("close", onclose);
        };
      }
      module2.exports = eos;
    }, { "../../../errors": 477 }], 487: [function(require2, module2, exports2) {
      module2.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}], 488: [function(require2, module2, exports2) {
      var eos;
      function once(callback) {
        var called = false;
        return function() {
          if (called)
            return;
          called = true;
          callback.apply(void 0, arguments);
        };
      }
      var _require$codes = require2("../../../errors").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
      function noop(err) {
        if (err)
          throw err;
      }
      function isRequest(stream) {
        return stream.setHeader && typeof stream.abort === "function";
      }
      function destroyer(stream, reading, writing, callback) {
        callback = once(callback);
        var closed = false;
        stream.on("close", function() {
          closed = true;
        });
        if (eos === void 0)
          eos = require2("./end-of-stream");
        eos(stream, { readable: reading, writable: writing }, function(err) {
          if (err)
            return callback(err);
          closed = true;
          callback();
        });
        var destroyed = false;
        return function(err) {
          if (closed)
            return;
          if (destroyed)
            return;
          destroyed = true;
          if (isRequest(stream))
            return stream.abort();
          if (typeof stream.destroy === "function")
            return stream.destroy();
          callback(err || new ERR_STREAM_DESTROYED("pipe"));
        };
      }
      function call(fn) {
        fn();
      }
      function pipe(from, to) {
        return from.pipe(to);
      }
      function popCallback(streams) {
        if (!streams.length)
          return noop;
        if (typeof streams[streams.length - 1] !== "function")
          return noop;
        return streams.pop();
      }
      function pipeline() {
        for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
          streams[_key] = arguments[_key];
        }
        var callback = popCallback(streams);
        if (Array.isArray(streams[0]))
          streams = streams[0];
        if (streams.length < 2) {
          throw new ERR_MISSING_ARGS("streams");
        }
        var error;
        var destroys = streams.map(function(stream, i) {
          var reading = i < streams.length - 1;
          var writing = i > 0;
          return destroyer(stream, reading, writing, function(err) {
            if (!error)
              error = err;
            if (err)
              destroys.forEach(call);
            if (reading)
              return;
            destroys.forEach(call);
            callback(error);
          });
        });
        return streams.reduce(pipe);
      }
      module2.exports = pipeline;
    }, { "../../../errors": 477, "./end-of-stream": 486 }], 489: [function(require2, module2, exports2) {
      var ERR_INVALID_OPT_VALUE = require2("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      function highWaterMarkFrom(options, isDuplex, duplexKey) {
        return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
      }
      function getHighWaterMark(state, options, duplexKey, isDuplex) {
        var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
        if (hwm != null) {
          if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : "highWaterMark";
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
          }
          return Math.floor(hwm);
        }
        return state.objectMode ? 16 : 16 * 1024;
      }
      module2.exports = { getHighWaterMark };
    }, { "../../../errors": 477 }], 490: [function(require2, module2, exports2) {
      module2.exports = require2("events").EventEmitter;
    }, { "events": 367 }], 491: [function(require2, module2, exports2) {
      exports2 = module2.exports = require2("./lib/_stream_readable.js");
      exports2.Stream = exports2;
      exports2.Readable = exports2;
      exports2.Writable = require2("./lib/_stream_writable.js");
      exports2.Duplex = require2("./lib/_stream_duplex.js");
      exports2.Transform = require2("./lib/_stream_transform.js");
      exports2.PassThrough = require2("./lib/_stream_passthrough.js");
      exports2.finished = require2("./lib/internal/streams/end-of-stream.js");
      exports2.pipeline = require2("./lib/internal/streams/pipeline.js");
    }, { "./lib/_stream_duplex.js": 478, "./lib/_stream_passthrough.js": 479, "./lib/_stream_readable.js": 480, "./lib/_stream_transform.js": 481, "./lib/_stream_writable.js": 482, "./lib/internal/streams/end-of-stream.js": 486, "./lib/internal/streams/pipeline.js": 488 }], 492: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      var runtime2 = function(exports3) {
        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var undefined$1;
        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
        function define(obj, key, value) {
          Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          return obj[key];
        }
        try {
          define({}, "");
        } catch (err) {
          define = function define2(obj, key, value) {
            return obj[key] = value;
          };
        }
        function wrap(innerFn, outerFn, self2, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context = new Context(tryLocsList || []);
          generator._invoke = makeInvokeMethod(innerFn, self2, context);
          return generator;
        }
        exports3.wrap = wrap;
        function tryCatch(fn, obj, arg) {
          try {
            return { type: "normal", arg: fn.call(obj, arg) };
          } catch (err) {
            return { type: "throw", arg: err };
          }
        }
        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";
        var ContinueSentinel = {};
        function Generator() {
        }
        function GeneratorFunction() {
        }
        function GeneratorFunctionPrototype() {
        }
        var IteratorPrototype = {};
        IteratorPrototype[iteratorSymbol] = function() {
          return this;
        };
        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
          IteratorPrototype = NativeIteratorPrototype;
        }
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
        GeneratorFunctionPrototype.constructor = GeneratorFunction;
        GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method) {
            define(prototype, method, function(arg) {
              return this._invoke(method, arg);
            });
          });
        }
        exports3.isGeneratorFunction = function(genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
        };
        exports3.mark = function(genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            define(genFun, toStringTagSymbol, "GeneratorFunction");
          }
          genFun.prototype = Object.create(Gp);
          return genFun;
        };
        exports3.awrap = function(arg) {
          return { __await: arg };
        };
        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value = result.value;
              if (value && _typeof2(value) === "object" && hasOwn.call(value, "__await")) {
                return PromiseImpl.resolve(value.__await).then(function(value2) {
                  invoke("next", value2, resolve, reject);
                }, function(err) {
                  invoke("throw", err, resolve, reject);
                });
              }
              return PromiseImpl.resolve(value).then(function(unwrapped) {
                result.value = unwrapped;
                resolve(result);
              }, function(error) {
                return invoke("throw", error, resolve, reject);
              });
            }
          }
          var previousPromise;
          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = // If enqueue has been called before, then we want to wait until
            // all previous Promises have been resolved before calling invoke,
            // so that results are always delivered in the correct order. If
            // enqueue has not been called before, then it is important to
            // call invoke immediately, without waiting on a callback to fire,
            // so that the async generator function has the opportunity to do
            // any necessary setup in a predictable way. This predictability
            // is why the Promise constructor synchronously invokes its
            // executor callback, and why async functions synchronously
            // execute code before the first await. Since we implement simple
            // async functions in terms of async generators, it is especially
            // important to get this right, even though it requires care.
            previousPromise ? previousPromise.then(
              callInvokeWithMethodAndArg,
              // Avoid propagating failures to Promises returned by later
              // invocations of the iterator.
              callInvokeWithMethodAndArg
            ) : callInvokeWithMethodAndArg();
          }
          this._invoke = enqueue;
        }
        defineIteratorMethods(AsyncIterator.prototype);
        AsyncIterator.prototype[asyncIteratorSymbol] = function() {
          return this;
        };
        exports3.AsyncIterator = AsyncIterator;
        exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
          if (PromiseImpl === void 0)
            PromiseImpl = Promise;
          var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
          return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
        };
        function makeInvokeMethod(innerFn, self2, context) {
          var state = GenStateSuspendedStart;
          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error("Generator is already running");
            }
            if (state === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              }
              return doneResult();
            }
            context.method = method;
            context.arg = arg;
            while (true) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel)
                    continue;
                  return delegateResult;
                }
              }
              if (context.method === "next") {
                context.sent = context._sent = context.arg;
              } else if (context.method === "throw") {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted;
                  throw context.arg;
                }
                context.dispatchException(context.arg);
              } else if (context.method === "return") {
                context.abrupt("return", context.arg);
              }
              state = GenStateExecuting;
              var record = tryCatch(innerFn, self2, context);
              if (record.type === "normal") {
                state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                if (record.arg === ContinueSentinel) {
                  continue;
                }
                return { value: record.arg, done: context.done };
              } else if (record.type === "throw") {
                state = GenStateCompleted;
                context.method = "throw";
                context.arg = record.arg;
              }
            }
          };
        }
        function maybeInvokeDelegate(delegate, context) {
          var method = delegate.iterator[context.method];
          if (method === undefined$1) {
            context.delegate = null;
            if (context.method === "throw") {
              if (delegate.iterator["return"]) {
                context.method = "return";
                context.arg = undefined$1;
                maybeInvokeDelegate(delegate, context);
                if (context.method === "throw") {
                  return ContinueSentinel;
                }
              }
              context.method = "throw";
              context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return ContinueSentinel;
          }
          var record = tryCatch(method, delegate.iterator, context.arg);
          if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
          }
          var info = record.arg;
          if (!info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
          }
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
            if (context.method !== "return") {
              context.method = "next";
              context.arg = undefined$1;
            }
          } else {
            return info;
          }
          context.delegate = null;
          return ContinueSentinel;
        }
        defineIteratorMethods(Gp);
        define(Gp, toStringTagSymbol, "Generator");
        Gp[iteratorSymbol] = function() {
          return this;
        };
        Gp.toString = function() {
          return "[object Generator]";
        };
        function pushTryEntry(locs) {
          var entry = { tryLoc: locs[0] };
          if (1 in locs) {
            entry.catchLoc = locs[1];
          }
          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }
          this.tryEntries.push(entry);
        }
        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }
        function Context(tryLocsList) {
          this.tryEntries = [{ tryLoc: "root" }];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }
        exports3.keys = function(object) {
          var keys = [];
          for (var key in object) {
            keys.push(key);
          }
          keys.reverse();
          return function next() {
            while (keys.length) {
              var key2 = keys.pop();
              if (key2 in object) {
                next.value = key2;
                next.done = false;
                return next;
              }
            }
            next.done = true;
            return next;
          };
        };
        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }
            if (typeof iterable.next === "function") {
              return iterable;
            }
            if (!isNaN(iterable.length)) {
              var i = -1, next = function next2() {
                while (++i < iterable.length) {
                  if (hasOwn.call(iterable, i)) {
                    next2.value = iterable[i];
                    next2.done = false;
                    return next2;
                  }
                }
                next2.value = undefined$1;
                next2.done = true;
                return next2;
              };
              return next.next = next;
            }
          }
          return { next: doneResult };
        }
        exports3.values = values;
        function doneResult() {
          return { value: undefined$1, done: true };
        }
        Context.prototype = { constructor: Context, reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        }, stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        }, dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined$1;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        }, abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        }, complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        }, finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        }, "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        }, delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = { iterator: values(iterable), resultName, nextLoc };
          if (this.method === "next") {
            this.arg = undefined$1;
          }
          return ContinueSentinel;
        } };
        return exports3;
      }(
        // If this script is executing as a CommonJS module, use module.exports
        // as the regeneratorRuntime namespace. Otherwise create a new empty
        // object. Either way, the resulting object will be used to initialize
        // the regeneratorRuntime variable at the top of this file.
        (typeof module2 === "undefined" ? "undefined" : _typeof2(module2)) === "object" ? module2.exports : {}
      );
      try {
        regeneratorRuntime = runtime2;
      } catch (accidentalStrictMode) {
        Function("r", "regeneratorRuntime = r")(runtime2);
      }
    }, {}], 493: [function(require2, module2, exports2) {
      var Buffer = require2("buffer").Buffer;
      var inherits = require2("inherits");
      var HashBase = require2("hash-base");
      var ARRAY16 = new Array(16);
      var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
      var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
      var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
      var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
      var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
      var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
      function RIPEMD160() {
        HashBase.call(this, 64);
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
      }
      inherits(RIPEMD160, HashBase);
      RIPEMD160.prototype._update = function() {
        var words = ARRAY16;
        for (var j = 0; j < 16; ++j) {
          words[j] = this._block.readInt32LE(j * 4);
        }
        var al = this._a | 0;
        var bl = this._b | 0;
        var cl = this._c | 0;
        var dl = this._d | 0;
        var el = this._e | 0;
        var ar = this._a | 0;
        var br = this._b | 0;
        var cr = this._c | 0;
        var dr = this._d | 0;
        var er = this._e | 0;
        for (var i = 0; i < 80; i += 1) {
          var tl;
          var tr;
          if (i < 16) {
            tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
            tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
          } else if (i < 32) {
            tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
            tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
          } else if (i < 48) {
            tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
            tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
          } else if (i < 64) {
            tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
            tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
          } else {
            tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
            tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
          }
          al = el;
          el = dl;
          dl = rotl(cl, 10);
          cl = bl;
          bl = tl;
          ar = er;
          er = dr;
          dr = rotl(cr, 10);
          cr = br;
          br = tr;
        }
        var t2 = this._b + cl + dr | 0;
        this._b = this._c + dl + er | 0;
        this._c = this._d + el + ar | 0;
        this._d = this._e + al + br | 0;
        this._e = this._a + bl + cr | 0;
        this._a = t2;
      };
      RIPEMD160.prototype._digest = function() {
        this._block[this._blockOffset++] = 128;
        if (this._blockOffset > 56) {
          this._block.fill(0, this._blockOffset, 64);
          this._update();
          this._blockOffset = 0;
        }
        this._block.fill(0, this._blockOffset, 56);
        this._block.writeUInt32LE(this._length[0], 56);
        this._block.writeUInt32LE(this._length[1], 60);
        this._update();
        var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
        buffer.writeInt32LE(this._a, 0);
        buffer.writeInt32LE(this._b, 4);
        buffer.writeInt32LE(this._c, 8);
        buffer.writeInt32LE(this._d, 12);
        buffer.writeInt32LE(this._e, 16);
        return buffer;
      };
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      function fn1(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
      }
      function fn2(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
      }
      function fn3(a, b, c, d, e, m, k, s) {
        return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
      }
      function fn4(a, b, c, d, e, m, k, s) {
        return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
      }
      function fn5(a, b, c, d, e, m, k, s) {
        return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
      }
      module2.exports = RIPEMD160;
    }, { "buffer": 216, "hash-base": 370, "inherits": 387 }], 494: [function(require2, module2, exports2) {
      var buffer = require2("buffer");
      var Buffer = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key in src) {
          dst[key] = src[key];
        }
      }
      if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
        module2.exports = buffer;
      } else {
        copyProps(buffer, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer(arg, encodingOrOffset, length);
      }
      copyProps(Buffer, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    }, { "buffer": 216 }], 495: [function(require2, module2, exports2) {
      (function(process) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        var buffer = require2("buffer");
        var Buffer = buffer.Buffer;
        var safer = {};
        var key;
        for (key in buffer) {
          if (!buffer.hasOwnProperty(key))
            continue;
          if (key === "SlowBuffer" || key === "Buffer")
            continue;
          safer[key] = buffer[key];
        }
        var Safer = safer.Buffer = {};
        for (key in Buffer) {
          if (!Buffer.hasOwnProperty(key))
            continue;
          if (key === "allocUnsafe" || key === "allocUnsafeSlow")
            continue;
          Safer[key] = Buffer[key];
        }
        safer.Buffer.prototype = Buffer.prototype;
        if (!Safer.from || Safer.from === Uint8Array.from) {
          Safer.from = function(value, encodingOrOffset, length) {
            if (typeof value === "number") {
              throw new TypeError('The "value" argument must not be of type number. Received type ' + _typeof2(value));
            }
            if (value && typeof value.length === "undefined") {
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + _typeof2(value));
            }
            return Buffer(value, encodingOrOffset, length);
          };
        }
        if (!Safer.alloc) {
          Safer.alloc = function(size, fill, encoding) {
            if (typeof size !== "number") {
              throw new TypeError('The "size" argument must be of type number. Received type ' + _typeof2(size));
            }
            if (size < 0 || size >= 2 * (1 << 30)) {
              throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
            var buf = Buffer(size);
            if (!fill || fill.length === 0) {
              buf.fill(0);
            } else if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
            return buf;
          };
        }
        if (!safer.kStringMaxLength) {
          try {
            safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
          } catch (e) {
          }
        }
        if (!safer.constants) {
          safer.constants = { MAX_LENGTH: safer.kMaxLength };
          if (safer.kStringMaxLength) {
            safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
          }
        }
        module2.exports = safer;
      }).call(this, require2("_process"));
    }, { "_process": 467, "buffer": 216 }], 496: [function(require2, module2, exports2) {
      function _createForOfIteratorHelper2(o, allowArrayLike) {
        var it;
        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it)
              o = it;
            var i = 0;
            var F = function F2() {
            };
            return { s: F, n: function n() {
              if (i >= o.length)
                return { done: true };
              return { done: false, value: o[i++] };
            }, e: function e(_e) {
              throw _e;
            }, f: F };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var normalCompletion = true, didErr = false, err;
        return { s: function s() {
          it = o[Symbol.iterator]();
        }, n: function n() {
          var step = it.next();
          normalCompletion = step.done;
          return step;
        }, e: function e(_e2) {
          didErr = true;
          err = _e2;
        }, f: function f() {
          try {
            if (!normalCompletion && it.return != null)
              it.return();
          } finally {
            if (didErr)
              throw err;
          }
        } };
      }
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties2(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass2(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties2(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties2(Constructor, staticProps);
        return Constructor;
      }
      function _toConsumableArray2(arr) {
        return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
      }
      function _nonIterableSpread2() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray2(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray2(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray2(o, minLen);
      }
      function _iterableToArray2(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
          return Array.from(iter);
      }
      function _arrayWithoutHoles2(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray2(arr);
      }
      function _arrayLikeToArray2(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      Object.defineProperty(exports2, "__esModule", { value: true });
      var ed5 = require2("xmlchars/xml/1.0/ed5");
      var ed2 = require2("xmlchars/xml/1.1/ed2");
      var NSed3 = require2("xmlchars/xmlns/1.0/ed3");
      var isS = ed5.isS;
      var isChar10 = ed5.isChar;
      var isNameStartChar = ed5.isNameStartChar;
      var isNameChar = ed5.isNameChar;
      var S_LIST = ed5.S_LIST;
      var NAME_RE = ed5.NAME_RE;
      var isChar11 = ed2.isChar;
      var isNCNameStartChar = NSed3.isNCNameStartChar;
      var isNCNameChar = NSed3.isNCNameChar;
      var NC_NAME_RE = NSed3.NC_NAME_RE;
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        __proto__: null,
        xml: XML_NAMESPACE,
        xmlns: XMLNS_NAMESPACE
      };
      var XML_ENTITIES = {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        __proto__: null,
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      };
      var EOC = -1;
      var NL_LIKE = -2;
      var S_BEGIN = 0;
      var S_BEGIN_WHITESPACE = 1;
      var S_DOCTYPE = 2;
      var S_DOCTYPE_QUOTE = 3;
      var S_DTD = 4;
      var S_DTD_QUOTED = 5;
      var S_DTD_OPEN_WAKA = 6;
      var S_DTD_OPEN_WAKA_BANG = 7;
      var S_DTD_COMMENT = 8;
      var S_DTD_COMMENT_ENDING = 9;
      var S_DTD_COMMENT_ENDED = 10;
      var S_DTD_PI = 11;
      var S_DTD_PI_ENDING = 12;
      var S_TEXT = 13;
      var S_ENTITY = 14;
      var S_OPEN_WAKA = 15;
      var S_OPEN_WAKA_BANG = 16;
      var S_COMMENT = 17;
      var S_COMMENT_ENDING = 18;
      var S_COMMENT_ENDED = 19;
      var S_CDATA = 20;
      var S_CDATA_ENDING = 21;
      var S_CDATA_ENDING_2 = 22;
      var S_PI_FIRST_CHAR = 23;
      var S_PI_REST = 24;
      var S_PI_BODY = 25;
      var S_PI_ENDING = 26;
      var S_XML_DECL_NAME_START = 27;
      var S_XML_DECL_NAME = 28;
      var S_XML_DECL_EQ = 29;
      var S_XML_DECL_VALUE_START = 30;
      var S_XML_DECL_VALUE = 31;
      var S_XML_DECL_SEPARATOR = 32;
      var S_XML_DECL_ENDING = 33;
      var S_OPEN_TAG = 34;
      var S_OPEN_TAG_SLASH = 35;
      var S_ATTRIB = 36;
      var S_ATTRIB_NAME = 37;
      var S_ATTRIB_NAME_SAW_WHITE = 38;
      var S_ATTRIB_VALUE = 39;
      var S_ATTRIB_VALUE_QUOTED = 40;
      var S_ATTRIB_VALUE_CLOSED = 41;
      var S_ATTRIB_VALUE_UNQUOTED = 42;
      var S_CLOSE_TAG = 43;
      var S_CLOSE_TAG_SAW_WHITE = 44;
      var TAB = 9;
      var NL = 10;
      var CR = 13;
      var SPACE = 32;
      var BANG = 33;
      var DQUOTE = 34;
      var AMP = 38;
      var SQUOTE = 39;
      var MINUS = 45;
      var FORWARD_SLASH = 47;
      var SEMICOLON = 59;
      var LESS = 60;
      var EQUAL = 61;
      var GREATER = 62;
      var QUESTION = 63;
      var OPEN_BRACKET = 91;
      var CLOSE_BRACKET = 93;
      var NEL = 133;
      var LS = 8232;
      var isQuote = function isQuote2(c) {
        return c === DQUOTE || c === SQUOTE;
      };
      var QUOTES = [DQUOTE, SQUOTE];
      var DOCTYPE_TERMINATOR = [].concat(QUOTES, [OPEN_BRACKET, GREATER]);
      var DTD_TERMINATOR = [].concat(QUOTES, [LESS, CLOSE_BRACKET]);
      var XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION].concat(_toConsumableArray2(S_LIST));
      var ATTRIB_VALUE_UNQUOTED_TERMINATOR = [].concat(_toConsumableArray2(S_LIST), [GREATER, AMP, LESS]);
      function nsPairCheck(parser, prefix, uri) {
        switch (prefix) {
          case "xml":
            if (uri !== XML_NAMESPACE) {
              parser.fail("xml prefix must be bound to ".concat(XML_NAMESPACE, "."));
            }
            break;
          case "xmlns":
            if (uri !== XMLNS_NAMESPACE) {
              parser.fail("xmlns prefix must be bound to ".concat(XMLNS_NAMESPACE, "."));
            }
            break;
        }
        switch (uri) {
          case XMLNS_NAMESPACE:
            parser.fail(prefix === "" ? "the default namespace may not be set to ".concat(uri, ".") : 'may not assign a prefix (even "xmlns") to the URI '.concat(XMLNS_NAMESPACE, "."));
            break;
          case XML_NAMESPACE:
            switch (prefix) {
              case "xml":
                break;
              case "":
                parser.fail("the default namespace may not be set to ".concat(uri, "."));
                break;
              default:
                parser.fail("may not assign the xml namespace to another prefix.");
            }
            break;
        }
      }
      function nsMappingCheck(parser, mapping) {
        for (var _i = 0, _Object$keys = Object.keys(mapping); _i < _Object$keys.length; _i++) {
          var local = _Object$keys[_i];
          nsPairCheck(parser, local, mapping[local]);
        }
      }
      var isNCName = function isNCName2(name) {
        return NC_NAME_RE.test(name);
      };
      var isName = function isName2(name) {
        return NAME_RE.test(name);
      };
      var FORBIDDEN_START = 0;
      var FORBIDDEN_BRACKET = 1;
      var FORBIDDEN_BRACKET_BRACKET = 2;
      exports2.EVENTS = ["xmldecl", "text", "processinginstruction", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "cdata", "error", "end", "ready"];
      var EVENT_NAME_TO_HANDLER_NAME = { xmldecl: "xmldeclHandler", text: "textHandler", processinginstruction: "piHandler", doctype: "doctypeHandler", comment: "commentHandler", opentagstart: "openTagStartHandler", attribute: "attributeHandler", opentag: "openTagHandler", closetag: "closeTagHandler", cdata: "cdataHandler", error: "errorHandler", end: "endHandler", ready: "readyHandler" };
      var SaxesParser = /* @__PURE__ */ function() {
        function SaxesParser2(opt) {
          _classCallCheck2(this, SaxesParser2);
          this.opt = opt !== null && opt !== void 0 ? opt : {};
          this.fragmentOpt = !!this.opt.fragment;
          var xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;
          this.trackPosition = this.opt.position !== false;
          this.fileName = this.opt.fileName;
          if (xmlnsOpt) {
            this.nameStartCheck = isNCNameStartChar;
            this.nameCheck = isNCNameChar;
            this.isName = isNCName;
            this.processAttribs = this.processAttribsNS;
            this.pushAttrib = this.pushAttribNS;
            this.ns = Object.assign({ __proto__: null }, rootNS);
            var additional = this.opt.additionalNamespaces;
            if (additional != null) {
              nsMappingCheck(this, additional);
              Object.assign(this.ns, additional);
            }
          } else {
            this.nameStartCheck = isNameStartChar;
            this.nameCheck = isNameChar;
            this.isName = isName;
            this.processAttribs = this.processAttribsPlain;
            this.pushAttrib = this.pushAttribPlain;
          }
          this.stateTable = [
            /* eslint-disable @typescript-eslint/unbound-method */
            this.sBegin,
            this.sBeginWhitespace,
            this.sDoctype,
            this.sDoctypeQuote,
            this.sDTD,
            this.sDTDQuoted,
            this.sDTDOpenWaka,
            this.sDTDOpenWakaBang,
            this.sDTDComment,
            this.sDTDCommentEnding,
            this.sDTDCommentEnded,
            this.sDTDPI,
            this.sDTDPIEnding,
            this.sText,
            this.sEntity,
            this.sOpenWaka,
            this.sOpenWakaBang,
            this.sComment,
            this.sCommentEnding,
            this.sCommentEnded,
            this.sCData,
            this.sCDataEnding,
            this.sCDataEnding2,
            this.sPIFirstChar,
            this.sPIRest,
            this.sPIBody,
            this.sPIEnding,
            this.sXMLDeclNameStart,
            this.sXMLDeclName,
            this.sXMLDeclEq,
            this.sXMLDeclValueStart,
            this.sXMLDeclValue,
            this.sXMLDeclSeparator,
            this.sXMLDeclEnding,
            this.sOpenTag,
            this.sOpenTagSlash,
            this.sAttrib,
            this.sAttribName,
            this.sAttribNameSawWhite,
            this.sAttribValue,
            this.sAttribValueQuoted,
            this.sAttribValueClosed,
            this.sAttribValueUnquoted,
            this.sCloseTag,
            this.sCloseTagSawWhite
          ];
          this._init();
        }
        _createClass2(SaxesParser2, [{
          key: "_init",
          value: function _init() {
            var _a;
            this.openWakaBang = "";
            this.text = "";
            this.name = "";
            this.piTarget = "";
            this.entity = "";
            this.q = null;
            this.tags = [];
            this.tag = null;
            this.topNS = null;
            this.chunk = "";
            this.chunkPosition = 0;
            this.i = 0;
            this.prevI = 0;
            this.carriedFromPrevious = void 0;
            this.forbiddenState = FORBIDDEN_START;
            this.attribList = [];
            var fragmentOpt = this.fragmentOpt;
            this.state = fragmentOpt ? S_TEXT : S_BEGIN;
            this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt;
            this.xmlDeclPossible = !fragmentOpt;
            this.xmlDeclExpects = ["version"];
            this.entityReturnState = void 0;
            var defaultXMLVersion = this.opt.defaultXMLVersion;
            if (defaultXMLVersion === void 0) {
              if (this.opt.forceXMLVersion === true) {
                throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
              }
              defaultXMLVersion = "1.0";
            }
            this.setXMLVersion(defaultXMLVersion);
            this.positionAtNewLine = 0;
            this.doctype = false;
            this._closed = false;
            this.xmlDecl = { version: void 0, encoding: void 0, standalone: void 0 };
            this.line = 1;
            this.column = 0;
            this.ENTITIES = Object.create(XML_ENTITIES);
            (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);
          }
          /**
          * The stream position the parser is currently looking at. This field is
          * zero-based.
          *
          * This field is not based on counting Unicode characters but is to be
          * interpreted as a plain index into a JavaScript string.
          */
        }, {
          key: "on",
          /**
          * Set an event listener on an event. The parser supports one handler per
          * event type. If you try to set an event handler over an existing handler,
          * the old handler is silently overwritten.
          *
          * @param name The event to listen to.
          *
          * @param handler The handler to set.
          */
          value: function on(name, handler) {
            this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;
          }
          /**
          * Unset an event handler.
          *
          * @parma name The event to stop listening to.
          */
        }, {
          key: "off",
          value: function off(name) {
            this[EVENT_NAME_TO_HANDLER_NAME[name]] = void 0;
          }
          /**
          * Make an error object. The error object will have a message that contains
          * the ``fileName`` option passed at the creation of the parser. If position
          * tracking was turned on, it will also have line and column number
          * information.
          *
          * @param message The message describing the error to report.
          *
          * @returns An error object with a properly formatted message.
          */
        }, {
          key: "makeError",
          value: function makeError(message) {
            var _a;
            var msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : "";
            if (this.trackPosition) {
              if (msg.length > 0) {
                msg += ":";
              }
              msg += "".concat(this.line, ":").concat(this.column);
            }
            if (msg.length > 0) {
              msg += ": ";
            }
            return new Error(msg + message);
          }
          /**
          * Report a parsing error. This method is made public so that client code may
          * check for issues that are outside the scope of this project and can report
          * errors.
          *
          * @param message The error to report.
          *
          * @returns this
          */
        }, {
          key: "fail",
          value: function fail(message) {
            var err = this.makeError(message);
            var handler = this.errorHandler;
            if (handler === void 0) {
              throw err;
            } else {
              handler(err);
            }
            return this;
          }
          /**
          * Write a XML data to the parser.
          *
          * @param chunk The XML data to write.
          *
          * @returns this
          */
        }, {
          key: "write",
          value: function write(chunk) {
            if (this.closed) {
              return this.fail("cannot write after close; assign an onready handler.");
            }
            var end = false;
            if (chunk === null) {
              end = true;
              chunk = "";
            } else if (_typeof2(chunk) === "object") {
              chunk = chunk.toString();
            }
            if (this.carriedFromPrevious !== void 0) {
              chunk = "".concat(this.carriedFromPrevious).concat(chunk);
              this.carriedFromPrevious = void 0;
            }
            var limit = chunk.length;
            var lastCode = chunk.charCodeAt(limit - 1);
            if (!end && // A trailing CR or surrogate must be carried over to the next
            // chunk.
            (lastCode === CR || lastCode >= 55296 && lastCode <= 56319)) {
              this.carriedFromPrevious = chunk[limit - 1];
              limit--;
              chunk = chunk.slice(0, limit);
            }
            var stateTable = this.stateTable;
            this.chunk = chunk;
            this.i = 0;
            while (this.i < limit) {
              stateTable[this.state].call(this);
            }
            this.chunkPosition += limit;
            return end ? this.end() : this;
          }
          /**
          * Close the current stream. Perform final well-formedness checks and reset
          * the parser tstate.
          *
          * @returns this
          */
        }, {
          key: "close",
          value: function close() {
            return this.write(null);
          }
          /**
          * Get a single code point out of the current chunk. This updates the current
          * position if we do position tracking.
          *
          * This is the algorithm to use for XML 1.0.
          *
          * @returns The character read.
          */
        }, {
          key: "getCode10",
          value: function getCode10() {
            var chunk = this.chunk, i = this.i;
            this.prevI = i;
            this.i = i + 1;
            if (i >= chunk.length) {
              return EOC;
            }
            var code = chunk.charCodeAt(i);
            this.column++;
            if (code < 55296) {
              if (code >= SPACE || code === TAB) {
                return code;
              }
              switch (code) {
                case NL:
                  this.line++;
                  this.column = 0;
                  this.positionAtNewLine = this.position;
                  return NL;
                case CR:
                  if (chunk.charCodeAt(i + 1) === NL) {
                    this.i = i + 2;
                  }
                  this.line++;
                  this.column = 0;
                  this.positionAtNewLine = this.position;
                  return NL_LIKE;
                default:
                  this.fail("disallowed character.");
                  return code;
              }
            }
            if (code > 56319) {
              if (!(code >= 57344 && code <= 65533)) {
                this.fail("disallowed character.");
              }
              return code;
            }
            var final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
            this.i = i + 2;
            if (final > 1114111) {
              this.fail("disallowed character.");
            }
            return final;
          }
          /**
          * Get a single code point out of the current chunk. This updates the current
          * position if we do position tracking.
          *
          * This is the algorithm to use for XML 1.1.
          *
          * @returns {number} The character read.
          */
        }, {
          key: "getCode11",
          value: function getCode11() {
            var chunk = this.chunk, i = this.i;
            this.prevI = i;
            this.i = i + 1;
            if (i >= chunk.length) {
              return EOC;
            }
            var code = chunk.charCodeAt(i);
            this.column++;
            if (code < 55296) {
              if (code > 31 && code < 127 || code > 159 && code !== LS || code === TAB) {
                return code;
              }
              switch (code) {
                case NL:
                  this.line++;
                  this.column = 0;
                  this.positionAtNewLine = this.position;
                  return NL;
                case CR: {
                  var next = chunk.charCodeAt(i + 1);
                  if (next === NL || next === NEL) {
                    this.i = i + 2;
                  }
                }
                case NEL:
                case LS:
                  this.line++;
                  this.column = 0;
                  this.positionAtNewLine = this.position;
                  return NL_LIKE;
                default:
                  this.fail("disallowed character.");
                  return code;
              }
            }
            if (code > 56319) {
              if (!(code >= 57344 && code <= 65533)) {
                this.fail("disallowed character.");
              }
              return code;
            }
            var final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
            this.i = i + 2;
            if (final > 1114111) {
              this.fail("disallowed character.");
            }
            return final;
          }
          /**
          * Like ``getCode`` but with the return value normalized so that ``NL`` is
          * returned for ``NL_LIKE``.
          */
        }, { key: "getCodeNorm", value: function getCodeNorm() {
          var c = this.getCode();
          return c === NL_LIKE ? NL : c;
        } }, {
          key: "unget",
          value: function unget() {
            this.i = this.prevI;
            this.column--;
          }
          /**
          * Capture characters into a buffer until encountering one of a set of
          * characters.
          *
          * @param chars An array of codepoints. Encountering a character in the array
          * ends the capture. (``chars`` may safely contain ``NL``.)
          *
          * @return The character code that made the capture end, or ``EOC`` if we hit
          * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
          * instead.
          */
        }, {
          key: "captureTo",
          value: function captureTo(chars) {
            var start = this.i;
            var chunk = this.chunk;
            while (true) {
              var c = this.getCode();
              var isNLLike = c === NL_LIKE;
              var final = isNLLike ? NL : c;
              if (final === EOC || chars.includes(final)) {
                this.text += chunk.slice(start, this.prevI);
                return final;
              }
              if (isNLLike) {
                this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                start = this.i;
              }
            }
          }
          /**
          * Capture characters into a buffer until encountering a character.
          *
          * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT
          * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.
          *
          * @return ``true`` if we ran into the character. Otherwise, we ran into the
          * end of the current chunk.
          */
        }, {
          key: "captureToChar",
          value: function captureToChar(char) {
            var start = this.i;
            var chunk = this.chunk;
            while (true) {
              var c = this.getCode();
              switch (c) {
                case NL_LIKE:
                  this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                  start = this.i;
                  c = NL;
                  break;
                case EOC:
                  this.text += chunk.slice(start);
                  return false;
              }
              if (c === char) {
                this.text += chunk.slice(start, this.prevI);
                return true;
              }
            }
          }
          /**
          * Capture characters that satisfy ``isNameChar`` into the ``name`` field of
          * this parser.
          *
          * @return The character code that made the test fail, or ``EOC`` if we hit
          * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
          * instead.
          */
        }, {
          key: "captureNameChars",
          value: function captureNameChars() {
            var chunk = this.chunk, start = this.i;
            while (true) {
              var c = this.getCode();
              if (c === EOC) {
                this.name += chunk.slice(start);
                return EOC;
              }
              if (!isNameChar(c)) {
                this.name += chunk.slice(start, this.prevI);
                return c === NL_LIKE ? NL : c;
              }
            }
          }
          /**
          * Skip white spaces.
          *
          * @return The character that ended the skip, or ``EOC`` if we hit
          * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
          * instead.
          */
        }, { key: "skipSpaces", value: function skipSpaces() {
          while (true) {
            var c = this.getCodeNorm();
            if (c === EOC || !isS(c)) {
              return c;
            }
          }
        } }, {
          key: "setXMLVersion",
          value: function setXMLVersion(version) {
            this.currentXMLVersion = version;
            if (version === "1.0") {
              this.isChar = isChar10;
              this.getCode = this.getCode10;
            } else {
              this.isChar = isChar11;
              this.getCode = this.getCode11;
            }
          }
          // STATE ENGINE METHODS
          // This needs to be a state separate from S_BEGIN_WHITESPACE because we want
          // to be sure never to come back to this state later.
        }, { key: "sBegin", value: function sBegin() {
          if (this.chunk.charCodeAt(0) === 65279) {
            this.i++;
            this.column++;
          }
          this.state = S_BEGIN_WHITESPACE;
        } }, { key: "sBeginWhitespace", value: function sBeginWhitespace() {
          var iBefore = this.i;
          var c = this.skipSpaces();
          if (this.prevI !== iBefore) {
            this.xmlDeclPossible = false;
          }
          switch (c) {
            case LESS:
              this.state = S_OPEN_WAKA;
              if (this.text.length !== 0) {
                throw new Error("no-empty text at start");
              }
              break;
            case EOC:
              break;
            default:
              this.unget();
              this.state = S_TEXT;
              this.xmlDeclPossible = false;
          }
        } }, { key: "sDoctype", value: function sDoctype() {
          var _a;
          var c = this.captureTo(DOCTYPE_TERMINATOR);
          switch (c) {
            case GREATER: {
              (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
              this.text = "";
              this.state = S_TEXT;
              this.doctype = true;
              break;
            }
            case EOC:
              break;
            default:
              this.text += String.fromCodePoint(c);
              if (c === OPEN_BRACKET) {
                this.state = S_DTD;
              } else if (isQuote(c)) {
                this.state = S_DOCTYPE_QUOTE;
                this.q = c;
              }
          }
        } }, { key: "sDoctypeQuote", value: function sDoctypeQuote() {
          var q = this.q;
          if (this.captureToChar(q)) {
            this.text += String.fromCodePoint(q);
            this.q = null;
            this.state = S_DOCTYPE;
          }
        } }, { key: "sDTD", value: function sDTD() {
          var c = this.captureTo(DTD_TERMINATOR);
          if (c === EOC) {
            return;
          }
          this.text += String.fromCodePoint(c);
          if (c === CLOSE_BRACKET) {
            this.state = S_DOCTYPE;
          } else if (c === LESS) {
            this.state = S_DTD_OPEN_WAKA;
          } else if (isQuote(c)) {
            this.state = S_DTD_QUOTED;
            this.q = c;
          }
        } }, { key: "sDTDQuoted", value: function sDTDQuoted() {
          var q = this.q;
          if (this.captureToChar(q)) {
            this.text += String.fromCodePoint(q);
            this.state = S_DTD;
            this.q = null;
          }
        } }, { key: "sDTDOpenWaka", value: function sDTDOpenWaka() {
          var c = this.getCodeNorm();
          this.text += String.fromCodePoint(c);
          switch (c) {
            case BANG:
              this.state = S_DTD_OPEN_WAKA_BANG;
              this.openWakaBang = "";
              break;
            case QUESTION:
              this.state = S_DTD_PI;
              break;
            default:
              this.state = S_DTD;
          }
        } }, { key: "sDTDOpenWakaBang", value: function sDTDOpenWakaBang() {
          var char = String.fromCodePoint(this.getCodeNorm());
          var owb = this.openWakaBang += char;
          this.text += char;
          if (owb !== "-") {
            this.state = owb === "--" ? S_DTD_COMMENT : S_DTD;
            this.openWakaBang = "";
          }
        } }, { key: "sDTDComment", value: function sDTDComment() {
          if (this.captureToChar(MINUS)) {
            this.text += "-";
            this.state = S_DTD_COMMENT_ENDING;
          }
        } }, { key: "sDTDCommentEnding", value: function sDTDCommentEnding() {
          var c = this.getCodeNorm();
          this.text += String.fromCodePoint(c);
          this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;
        } }, { key: "sDTDCommentEnded", value: function sDTDCommentEnded() {
          var c = this.getCodeNorm();
          this.text += String.fromCodePoint(c);
          if (c === GREATER) {
            this.state = S_DTD;
          } else {
            this.fail("malformed comment.");
            this.state = S_DTD_COMMENT;
          }
        } }, { key: "sDTDPI", value: function sDTDPI() {
          if (this.captureToChar(QUESTION)) {
            this.text += "?";
            this.state = S_DTD_PI_ENDING;
          }
        } }, { key: "sDTDPIEnding", value: function sDTDPIEnding() {
          var c = this.getCodeNorm();
          this.text += String.fromCodePoint(c);
          if (c === GREATER) {
            this.state = S_DTD;
          }
        } }, { key: "sText", value: function sText() {
          if (this.tags.length !== 0) {
            this.handleTextInRoot();
          } else {
            this.handleTextOutsideRoot();
          }
        } }, { key: "sEntity", value: function sEntity() {
          var start = this.i;
          var chunk = this.chunk;
          loop:
            while (true) {
              switch (this.getCode()) {
                case NL_LIKE:
                  this.entity += "".concat(chunk.slice(start, this.prevI), "\n");
                  start = this.i;
                  break;
                case SEMICOLON: {
                  var entityReturnState = this.entityReturnState;
                  var entity = this.entity + chunk.slice(start, this.prevI);
                  this.state = entityReturnState;
                  var parsed = void 0;
                  if (entity === "") {
                    this.fail("empty entity name.");
                    parsed = "&;";
                  } else {
                    parsed = this.parseEntity(entity);
                    this.entity = "";
                  }
                  if (entityReturnState !== S_TEXT || this.textHandler !== void 0) {
                    this.text += parsed;
                  }
                  break loop;
                }
                case EOC:
                  this.entity += chunk.slice(start);
                  break loop;
              }
            }
        } }, { key: "sOpenWaka", value: function sOpenWaka() {
          var c = this.getCode();
          if (isNameStartChar(c)) {
            this.state = S_OPEN_TAG;
            this.unget();
            this.xmlDeclPossible = false;
          } else {
            switch (c) {
              case FORWARD_SLASH:
                this.state = S_CLOSE_TAG;
                this.xmlDeclPossible = false;
                break;
              case BANG:
                this.state = S_OPEN_WAKA_BANG;
                this.openWakaBang = "";
                this.xmlDeclPossible = false;
                break;
              case QUESTION:
                this.state = S_PI_FIRST_CHAR;
                break;
              default:
                this.fail("disallowed character in tag name");
                this.state = S_TEXT;
                this.xmlDeclPossible = false;
            }
          }
        } }, { key: "sOpenWakaBang", value: function sOpenWakaBang() {
          this.openWakaBang += String.fromCodePoint(this.getCodeNorm());
          switch (this.openWakaBang) {
            case "[CDATA[":
              if (!this.sawRoot && !this.reportedTextBeforeRoot) {
                this.fail("text data outside of root node.");
                this.reportedTextBeforeRoot = true;
              }
              if (this.closedRoot && !this.reportedTextAfterRoot) {
                this.fail("text data outside of root node.");
                this.reportedTextAfterRoot = true;
              }
              this.state = S_CDATA;
              this.openWakaBang = "";
              break;
            case "--":
              this.state = S_COMMENT;
              this.openWakaBang = "";
              break;
            case "DOCTYPE":
              this.state = S_DOCTYPE;
              if (this.doctype || this.sawRoot) {
                this.fail("inappropriately located doctype declaration.");
              }
              this.openWakaBang = "";
              break;
            default:
              if (this.openWakaBang.length >= 7) {
                this.fail("incorrect syntax.");
              }
          }
        } }, { key: "sComment", value: function sComment() {
          if (this.captureToChar(MINUS)) {
            this.state = S_COMMENT_ENDING;
          }
        } }, { key: "sCommentEnding", value: function sCommentEnding() {
          var _a;
          var c = this.getCodeNorm();
          if (c === MINUS) {
            this.state = S_COMMENT_ENDED;
            (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
            this.text = "";
          } else {
            this.text += "-".concat(String.fromCodePoint(c));
            this.state = S_COMMENT;
          }
        } }, { key: "sCommentEnded", value: function sCommentEnded() {
          var c = this.getCodeNorm();
          if (c !== GREATER) {
            this.fail("malformed comment.");
            this.text += "--".concat(String.fromCodePoint(c));
            this.state = S_COMMENT;
          } else {
            this.state = S_TEXT;
          }
        } }, { key: "sCData", value: function sCData() {
          if (this.captureToChar(CLOSE_BRACKET)) {
            this.state = S_CDATA_ENDING;
          }
        } }, { key: "sCDataEnding", value: function sCDataEnding() {
          var c = this.getCodeNorm();
          if (c === CLOSE_BRACKET) {
            this.state = S_CDATA_ENDING_2;
          } else {
            this.text += "]".concat(String.fromCodePoint(c));
            this.state = S_CDATA;
          }
        } }, {
          key: "sCDataEnding2",
          value: function sCDataEnding2() {
            var _a;
            var c = this.getCodeNorm();
            switch (c) {
              case GREATER: {
                (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
                this.text = "";
                this.state = S_TEXT;
                break;
              }
              case CLOSE_BRACKET:
                this.text += "]";
                break;
              default:
                this.text += "]]".concat(String.fromCodePoint(c));
                this.state = S_CDATA;
            }
          }
          // We need this separate state to check the first character fo the pi target
          // with this.nameStartCheck which allows less characters than this.nameCheck.
        }, { key: "sPIFirstChar", value: function sPIFirstChar() {
          var c = this.getCodeNorm();
          if (this.nameStartCheck(c)) {
            this.piTarget += String.fromCodePoint(c);
            this.state = S_PI_REST;
          } else if (c === QUESTION || isS(c)) {
            this.fail("processing instruction without a target.");
            this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;
          } else {
            this.fail("disallowed character in processing instruction name.");
            this.piTarget += String.fromCodePoint(c);
            this.state = S_PI_REST;
          }
        } }, { key: "sPIRest", value: function sPIRest() {
          var chunk = this.chunk, start = this.i;
          while (true) {
            var c = this.getCodeNorm();
            if (c === EOC) {
              this.piTarget += chunk.slice(start);
              return;
            }
            if (!this.nameCheck(c)) {
              this.piTarget += chunk.slice(start, this.prevI);
              var isQuestion = c === QUESTION;
              if (isQuestion || isS(c)) {
                if (this.piTarget === "xml") {
                  if (!this.xmlDeclPossible) {
                    this.fail("an XML declaration must be at the start of the document.");
                  }
                  this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;
                } else {
                  this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;
                }
              } else {
                this.fail("disallowed character in processing instruction name.");
                this.piTarget += String.fromCodePoint(c);
              }
              break;
            }
          }
        } }, { key: "sPIBody", value: function sPIBody() {
          if (this.text.length === 0) {
            var c = this.getCodeNorm();
            if (c === QUESTION) {
              this.state = S_PI_ENDING;
            } else if (!isS(c)) {
              this.text = String.fromCodePoint(c);
            }
          } else if (this.captureToChar(QUESTION)) {
            this.state = S_PI_ENDING;
          }
        } }, { key: "sPIEnding", value: function sPIEnding() {
          var _a;
          var c = this.getCodeNorm();
          if (c === GREATER) {
            var piTarget = this.piTarget;
            if (piTarget.toLowerCase() === "xml") {
              this.fail("the XML declaration must appear at the start of the document.");
            }
            (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, { target: piTarget, body: this.text });
            this.piTarget = this.text = "";
            this.state = S_TEXT;
          } else if (c === QUESTION) {
            this.text += "?";
          } else {
            this.text += "?".concat(String.fromCodePoint(c));
            this.state = S_PI_BODY;
          }
          this.xmlDeclPossible = false;
        } }, { key: "sXMLDeclNameStart", value: function sXMLDeclNameStart() {
          var c = this.skipSpaces();
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            return;
          }
          if (c !== EOC) {
            this.state = S_XML_DECL_NAME;
            this.name = String.fromCodePoint(c);
          }
        } }, { key: "sXMLDeclName", value: function sXMLDeclName() {
          var c = this.captureTo(XML_DECL_NAME_TERMINATOR);
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.name += this.text;
            this.text = "";
            this.fail("XML declaration is incomplete.");
            return;
          }
          if (!(isS(c) || c === EQUAL)) {
            return;
          }
          this.name += this.text;
          this.text = "";
          if (!this.xmlDeclExpects.includes(this.name)) {
            switch (this.name.length) {
              case 0:
                this.fail("did not expect any more name/value pairs.");
                break;
              case 1:
                this.fail("expected the name ".concat(this.xmlDeclExpects[0], "."));
                break;
              default:
                this.fail("expected one of ".concat(this.xmlDeclExpects.join(", ")));
            }
          }
          this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;
        } }, { key: "sXMLDeclEq", value: function sXMLDeclEq() {
          var c = this.getCodeNorm();
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.fail("XML declaration is incomplete.");
            return;
          }
          if (isS(c)) {
            return;
          }
          if (c !== EQUAL) {
            this.fail("value required.");
          }
          this.state = S_XML_DECL_VALUE_START;
        } }, { key: "sXMLDeclValueStart", value: function sXMLDeclValueStart() {
          var c = this.getCodeNorm();
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.fail("XML declaration is incomplete.");
            return;
          }
          if (isS(c)) {
            return;
          }
          if (!isQuote(c)) {
            this.fail("value must be quoted.");
            this.q = SPACE;
          } else {
            this.q = c;
          }
          this.state = S_XML_DECL_VALUE;
        } }, { key: "sXMLDeclValue", value: function sXMLDeclValue() {
          var c = this.captureTo([this.q, QUESTION]);
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            this.text = "";
            this.fail("XML declaration is incomplete.");
            return;
          }
          if (c === EOC) {
            return;
          }
          var value = this.text;
          this.text = "";
          switch (this.name) {
            case "version": {
              this.xmlDeclExpects = ["encoding", "standalone"];
              var version = value;
              this.xmlDecl.version = version;
              if (!/^1\.[0-9]+$/.test(version)) {
                this.fail("version number must match /^1\\.[0-9]+$/.");
              } else if (!this.opt.forceXMLVersion) {
                this.setXMLVersion(version);
              }
              break;
            }
            case "encoding":
              if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {
                this.fail("encoding value must match 	/^[A-Za-z0-9][A-Za-z0-9._-]*$/.");
              }
              this.xmlDeclExpects = ["standalone"];
              this.xmlDecl.encoding = value;
              break;
            case "standalone":
              if (value !== "yes" && value !== "no") {
                this.fail('standalone value must match "yes" or "no".');
              }
              this.xmlDeclExpects = [];
              this.xmlDecl.standalone = value;
              break;
          }
          this.name = "";
          this.state = S_XML_DECL_SEPARATOR;
        } }, { key: "sXMLDeclSeparator", value: function sXMLDeclSeparator() {
          var c = this.getCodeNorm();
          if (c === QUESTION) {
            this.state = S_XML_DECL_ENDING;
            return;
          }
          if (!isS(c)) {
            this.fail("whitespace required.");
            this.unget();
          }
          this.state = S_XML_DECL_NAME_START;
        } }, { key: "sXMLDeclEnding", value: function sXMLDeclEnding() {
          var _a;
          var c = this.getCodeNorm();
          if (c === GREATER) {
            if (this.piTarget !== "xml") {
              this.fail("processing instructions are not allowed before root.");
            } else if (this.name !== "version" && this.xmlDeclExpects.includes("version")) {
              this.fail("XML declaration must contain a version.");
            }
            (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);
            this.name = "";
            this.piTarget = this.text = "";
            this.state = S_TEXT;
          } else {
            this.fail("The character ? is disallowed anywhere in XML declarations.");
          }
          this.xmlDeclPossible = false;
        } }, { key: "sOpenTag", value: function sOpenTag() {
          var _a;
          var c = this.captureNameChars();
          if (c === EOC) {
            return;
          }
          var tag = this.tag = { name: this.name, attributes: /* @__PURE__ */ Object.create(null) };
          this.name = "";
          if (this.xmlnsOpt) {
            this.topNS = tag.ns = /* @__PURE__ */ Object.create(null);
          }
          (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
          this.sawRoot = true;
          if (!this.fragmentOpt && this.closedRoot) {
            this.fail("documents may contain only one root.");
          }
          switch (c) {
            case GREATER:
              this.openTag();
              break;
            case FORWARD_SLASH:
              this.state = S_OPEN_TAG_SLASH;
              break;
            default:
              if (!isS(c)) {
                this.fail("disallowed character in tag name.");
              }
              this.state = S_ATTRIB;
          }
        } }, { key: "sOpenTagSlash", value: function sOpenTagSlash() {
          if (this.getCode() === GREATER) {
            this.openSelfClosingTag();
          } else {
            this.fail("forward-slash in opening tag not followed by >.");
            this.state = S_ATTRIB;
          }
        } }, { key: "sAttrib", value: function sAttrib() {
          var c = this.skipSpaces();
          if (c === EOC) {
            return;
          }
          if (isNameStartChar(c)) {
            this.unget();
            this.state = S_ATTRIB_NAME;
          } else if (c === GREATER) {
            this.openTag();
          } else if (c === FORWARD_SLASH) {
            this.state = S_OPEN_TAG_SLASH;
          } else {
            this.fail("disallowed character in attribute name.");
          }
        } }, { key: "sAttribName", value: function sAttribName() {
          var c = this.captureNameChars();
          if (c === EQUAL) {
            this.state = S_ATTRIB_VALUE;
          } else if (isS(c)) {
            this.state = S_ATTRIB_NAME_SAW_WHITE;
          } else if (c === GREATER) {
            this.fail("attribute without value.");
            this.pushAttrib(this.name, this.name);
            this.name = this.text = "";
            this.openTag();
          } else if (c !== EOC) {
            this.fail("disallowed character in attribute name.");
          }
        } }, { key: "sAttribNameSawWhite", value: function sAttribNameSawWhite() {
          var c = this.skipSpaces();
          switch (c) {
            case EOC:
              return;
            case EQUAL:
              this.state = S_ATTRIB_VALUE;
              break;
            default:
              this.fail("attribute without value.");
              this.text = "";
              this.name = "";
              if (c === GREATER) {
                this.openTag();
              } else if (isNameStartChar(c)) {
                this.unget();
                this.state = S_ATTRIB_NAME;
              } else {
                this.fail("disallowed character in attribute name.");
                this.state = S_ATTRIB;
              }
          }
        } }, { key: "sAttribValue", value: function sAttribValue() {
          var c = this.getCodeNorm();
          if (isQuote(c)) {
            this.q = c;
            this.state = S_ATTRIB_VALUE_QUOTED;
          } else if (!isS(c)) {
            this.fail("unquoted attribute value.");
            this.state = S_ATTRIB_VALUE_UNQUOTED;
            this.unget();
          }
        } }, { key: "sAttribValueQuoted", value: function sAttribValueQuoted() {
          var q = this.q, chunk = this.chunk;
          var start = this.i;
          while (true) {
            switch (this.getCode()) {
              case q:
                this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));
                this.name = this.text = "";
                this.q = null;
                this.state = S_ATTRIB_VALUE_CLOSED;
                return;
              case AMP:
                this.text += chunk.slice(start, this.prevI);
                this.state = S_ENTITY;
                this.entityReturnState = S_ATTRIB_VALUE_QUOTED;
                return;
              case NL:
              case NL_LIKE:
              case TAB:
                this.text += "".concat(chunk.slice(start, this.prevI), " ");
                start = this.i;
                break;
              case LESS:
                this.text += chunk.slice(start, this.prevI);
                this.fail("disallowed character.");
                return;
              case EOC:
                this.text += chunk.slice(start);
                return;
            }
          }
        } }, { key: "sAttribValueClosed", value: function sAttribValueClosed() {
          var c = this.getCodeNorm();
          if (isS(c)) {
            this.state = S_ATTRIB;
          } else if (c === GREATER) {
            this.openTag();
          } else if (c === FORWARD_SLASH) {
            this.state = S_OPEN_TAG_SLASH;
          } else if (isNameStartChar(c)) {
            this.fail("no whitespace between attributes.");
            this.unget();
            this.state = S_ATTRIB_NAME;
          } else {
            this.fail("disallowed character in attribute name.");
          }
        } }, { key: "sAttribValueUnquoted", value: function sAttribValueUnquoted() {
          var c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);
          switch (c) {
            case AMP:
              this.state = S_ENTITY;
              this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;
              break;
            case LESS:
              this.fail("disallowed character.");
              break;
            case EOC:
              break;
            default:
              if (this.text.includes("]]>")) {
                this.fail('the string "]]>" is disallowed in char data.');
              }
              this.pushAttrib(this.name, this.text);
              this.name = this.text = "";
              if (c === GREATER) {
                this.openTag();
              } else {
                this.state = S_ATTRIB;
              }
          }
        } }, { key: "sCloseTag", value: function sCloseTag() {
          var c = this.captureNameChars();
          if (c === GREATER) {
            this.closeTag();
          } else if (isS(c)) {
            this.state = S_CLOSE_TAG_SAW_WHITE;
          } else if (c !== EOC) {
            this.fail("disallowed character in closing tag.");
          }
        } }, {
          key: "sCloseTagSawWhite",
          value: function sCloseTagSawWhite() {
            switch (this.skipSpaces()) {
              case GREATER:
                this.closeTag();
                break;
              case EOC:
                break;
              default:
                this.fail("disallowed character in closing tag.");
            }
          }
          // END OF STATE ENGINE METHODS
        }, { key: "handleTextInRoot", value: function handleTextInRoot() {
          var start = this.i, forbiddenState = this.forbiddenState;
          var chunk = this.chunk, handler = this.textHandler;
          scanLoop:
            while (true) {
              switch (this.getCode()) {
                case LESS: {
                  this.state = S_OPEN_WAKA;
                  if (handler !== void 0) {
                    var text = this.text;
                    var slice = chunk.slice(start, this.prevI);
                    if (text.length !== 0) {
                      handler(text + slice);
                      this.text = "";
                    } else if (slice.length !== 0) {
                      handler(slice);
                    }
                  }
                  forbiddenState = FORBIDDEN_START;
                  break scanLoop;
                }
                case AMP:
                  this.state = S_ENTITY;
                  this.entityReturnState = S_TEXT;
                  if (handler !== void 0) {
                    this.text += chunk.slice(start, this.prevI);
                  }
                  forbiddenState = FORBIDDEN_START;
                  break scanLoop;
                case CLOSE_BRACKET:
                  switch (forbiddenState) {
                    case FORBIDDEN_START:
                      forbiddenState = FORBIDDEN_BRACKET;
                      break;
                    case FORBIDDEN_BRACKET:
                      forbiddenState = FORBIDDEN_BRACKET_BRACKET;
                      break;
                    case FORBIDDEN_BRACKET_BRACKET:
                      break;
                    default:
                      throw new Error("impossible state");
                  }
                  break;
                case GREATER:
                  if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {
                    this.fail('the string "]]>" is disallowed in char data.');
                  }
                  forbiddenState = FORBIDDEN_START;
                  break;
                case NL_LIKE:
                  if (handler !== void 0) {
                    this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                  }
                  start = this.i;
                  forbiddenState = FORBIDDEN_START;
                  break;
                case EOC:
                  if (handler !== void 0) {
                    this.text += chunk.slice(start);
                  }
                  break scanLoop;
                default:
                  forbiddenState = FORBIDDEN_START;
              }
            }
          this.forbiddenState = forbiddenState;
        } }, { key: "handleTextOutsideRoot", value: function handleTextOutsideRoot() {
          var start = this.i;
          var chunk = this.chunk, handler = this.textHandler;
          var nonSpace = false;
          outRootLoop:
            while (true) {
              var code = this.getCode();
              switch (code) {
                case LESS: {
                  this.state = S_OPEN_WAKA;
                  if (handler !== void 0) {
                    var text = this.text;
                    var slice = chunk.slice(start, this.prevI);
                    if (text.length !== 0) {
                      handler(text + slice);
                      this.text = "";
                    } else if (slice.length !== 0) {
                      handler(slice);
                    }
                  }
                  break outRootLoop;
                }
                case AMP:
                  this.state = S_ENTITY;
                  this.entityReturnState = S_TEXT;
                  if (handler !== void 0) {
                    this.text += chunk.slice(start, this.prevI);
                  }
                  nonSpace = true;
                  break outRootLoop;
                case NL_LIKE:
                  if (handler !== void 0) {
                    this.text += "".concat(chunk.slice(start, this.prevI), "\n");
                  }
                  start = this.i;
                  break;
                case EOC:
                  if (handler !== void 0) {
                    this.text += chunk.slice(start);
                  }
                  break outRootLoop;
                default:
                  if (!isS(code)) {
                    nonSpace = true;
                  }
              }
            }
          if (!nonSpace) {
            return;
          }
          if (!this.sawRoot && !this.reportedTextBeforeRoot) {
            this.fail("text data outside of root node.");
            this.reportedTextBeforeRoot = true;
          }
          if (this.closedRoot && !this.reportedTextAfterRoot) {
            this.fail("text data outside of root node.");
            this.reportedTextAfterRoot = true;
          }
        } }, { key: "pushAttribNS", value: function pushAttribNS(name, value) {
          var _a;
          var _this$qname = this.qname(name), prefix = _this$qname.prefix, local = _this$qname.local;
          var attr = { name, prefix, local, value };
          this.attribList.push(attr);
          (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
          if (prefix === "xmlns") {
            var trimmed = value.trim();
            if (this.currentXMLVersion === "1.0" && trimmed === "") {
              this.fail("invalid attempt to undefine prefix in XML 1.0");
            }
            this.topNS[local] = trimmed;
            nsPairCheck(this, local, trimmed);
          } else if (name === "xmlns") {
            var _trimmed = value.trim();
            this.topNS[""] = _trimmed;
            nsPairCheck(this, "", _trimmed);
          }
        } }, {
          key: "pushAttribPlain",
          value: function pushAttribPlain(name, value) {
            var _a;
            var attr = { name, value };
            this.attribList.push(attr);
            (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
          }
          /**
          * End parsing. This performs final well-formedness checks and resets the
          * parser to a clean state.
          *
          * @returns this
          */
        }, {
          key: "end",
          value: function end() {
            var _a, _b;
            if (!this.sawRoot) {
              this.fail("document must contain a root element.");
            }
            var tags = this.tags;
            while (tags.length > 0) {
              var tag = tags.pop();
              this.fail("unclosed tag: ".concat(tag.name));
            }
            if (this.state !== S_BEGIN && this.state !== S_TEXT) {
              this.fail("unexpected end.");
            }
            var text = this.text;
            if (text.length !== 0) {
              (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);
              this.text = "";
            }
            this._closed = true;
            (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);
            this._init();
            return this;
          }
          /**
          * Resolve a namespace prefix.
          *
          * @param prefix The prefix to resolve.
          *
          * @returns The namespace URI or ``undefined`` if the prefix is not defined.
          */
        }, {
          key: "resolve",
          value: function resolve(prefix) {
            var _a, _b;
            var uri = this.topNS[prefix];
            if (uri !== void 0) {
              return uri;
            }
            var tags = this.tags;
            for (var index2 = tags.length - 1; index2 >= 0; index2--) {
              uri = tags[index2].ns[prefix];
              if (uri !== void 0) {
                return uri;
              }
            }
            uri = this.ns[prefix];
            if (uri !== void 0) {
              return uri;
            }
            return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);
          }
          /**
          * Parse a qname into its prefix and local name parts.
          *
          * @param name The name to parse
          *
          * @returns
          */
        }, { key: "qname", value: function qname(name) {
          var colon = name.indexOf(":");
          if (colon === -1) {
            return { prefix: "", local: name };
          }
          var local = name.slice(colon + 1);
          var prefix = name.slice(0, colon);
          if (prefix === "" || local === "" || local.includes(":")) {
            this.fail("malformed name: ".concat(name, "."));
          }
          return { prefix, local };
        } }, { key: "processAttribsNS", value: function processAttribsNS() {
          var _a;
          var attribList = this.attribList;
          var tag = this.tag;
          {
            var _this$qname2 = this.qname(tag.name), prefix = _this$qname2.prefix, local = _this$qname2.local;
            tag.prefix = prefix;
            tag.local = local;
            var uri = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : "";
            if (prefix !== "") {
              if (prefix === "xmlns") {
                this.fail('tags may not have "xmlns" as prefix.');
              }
              if (uri === "") {
                this.fail("unbound namespace prefix: ".concat(JSON.stringify(prefix), "."));
                tag.uri = prefix;
              }
            }
          }
          if (attribList.length === 0) {
            return;
          }
          var attributes = tag.attributes;
          var seen = /* @__PURE__ */ new Set();
          var _iterator = _createForOfIteratorHelper2(attribList), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var attr = _step.value;
              var name = attr.name, _prefix = attr.prefix, _local = attr.local;
              var _uri = void 0;
              var eqname = void 0;
              if (_prefix === "") {
                _uri = name === "xmlns" ? XMLNS_NAMESPACE : "";
                eqname = name;
              } else {
                _uri = this.resolve(_prefix);
                if (_uri === void 0) {
                  this.fail("unbound namespace prefix: ".concat(JSON.stringify(_prefix), "."));
                  _uri = _prefix;
                }
                eqname = "{".concat(_uri, "}").concat(_local);
              }
              if (seen.has(eqname)) {
                this.fail("duplicate attribute: ".concat(eqname, "."));
              }
              seen.add(eqname);
              attr.uri = _uri;
              attributes[name] = attr;
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          this.attribList = [];
        } }, {
          key: "processAttribsPlain",
          value: function processAttribsPlain() {
            var attribList = this.attribList;
            var attributes = this.tag.attributes;
            var _iterator2 = _createForOfIteratorHelper2(attribList), _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                var _step2$value = _step2.value, name = _step2$value.name, value = _step2$value.value;
                if (attributes[name] !== void 0) {
                  this.fail("duplicate attribute: ".concat(name, "."));
                }
                attributes[name] = value;
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
            this.attribList = [];
          }
          /**
          * Handle a complete open tag. This parser code calls this once it has seen
          * the whole tag. This method checks for well-formeness and then emits
          * ``onopentag``.
          */
        }, {
          key: "openTag",
          value: function openTag() {
            var _a;
            this.processAttribs();
            var tags = this.tags;
            var tag = this.tag;
            tag.isSelfClosing = false;
            (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
            tags.push(tag);
            this.state = S_TEXT;
            this.name = "";
          }
          /**
          * Handle a complete self-closing tag. This parser code calls this once it has
          * seen the whole tag. This method checks for well-formeness and then emits
          * ``onopentag`` and ``onclosetag``.
          */
        }, {
          key: "openSelfClosingTag",
          value: function openSelfClosingTag() {
            var _a, _b, _c;
            this.processAttribs();
            var tags = this.tags;
            var tag = this.tag;
            tag.isSelfClosing = true;
            (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
            (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);
            var top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;
            if (top === null) {
              this.closedRoot = true;
            }
            this.state = S_TEXT;
            this.name = "";
          }
          /**
          * Handle a complete close tag. This parser code calls this once it has seen
          * the whole tag. This method checks for well-formeness and then emits
          * ``onclosetag``.
          */
        }, {
          key: "closeTag",
          value: function closeTag() {
            var tags = this.tags, name = this.name;
            this.state = S_TEXT;
            this.name = "";
            if (name === "") {
              this.fail("weird empty close tag.");
              this.text += "</>";
              return;
            }
            var handler = this.closeTagHandler;
            var l = tags.length;
            while (l-- > 0) {
              var tag = this.tag = tags.pop();
              this.topNS = tag.ns;
              handler === null || handler === void 0 ? void 0 : handler(tag);
              if (tag.name === name) {
                break;
              }
              this.fail("unexpected close tag.");
            }
            if (l === 0) {
              this.closedRoot = true;
            } else if (l < 0) {
              this.fail("unmatched closing tag: ".concat(name, "."));
              this.text += "</".concat(name, ">");
            }
          }
          /**
          * Resolves an entity. Makes any necessary well-formedness checks.
          *
          * @param entity The entity to resolve.
          *
          * @returns The parsed entity.
          */
        }, { key: "parseEntity", value: function parseEntity(entity) {
          if (entity[0] !== "#") {
            var defined = this.ENTITIES[entity];
            if (defined !== void 0) {
              return defined;
            }
            this.fail(this.isName(entity) ? "undefined entity." : "disallowed character in entity name.");
            return "&".concat(entity, ";");
          }
          var num = NaN;
          if (entity[1] === "x" && /^#x[0-9a-f]+$/i.test(entity)) {
            num = parseInt(entity.slice(2), 16);
          } else if (/^#[0-9]+$/.test(entity)) {
            num = parseInt(entity.slice(1), 10);
          }
          if (!this.isChar(num)) {
            this.fail("malformed character entity.");
            return "&".concat(entity, ";");
          }
          return String.fromCodePoint(num);
        } }, { key: "closed", get: function get() {
          return this._closed;
        } }, {
          key: "position",
          get: function get() {
            return this.chunkPosition + this.i;
          }
          /**
          * The column number of the next character to be read by the parser.  *
          * This field is zero-based. (The first column in a line is 0.)
          *
          * This field reports the index at which the next character would be in the
          * line if the line were represented as a JavaScript string.  Note that this
          * *can* be different to a count based on the number of *Unicode characters*
          * due to how JavaScript handles astral plane characters.
          *
          * See [[column]] for a number that corresponds to a count of Unicode
          * characters.
          */
        }, { key: "columnIndex", get: function get() {
          return this.position - this.positionAtNewLine;
        } }]);
        return SaxesParser2;
      }();
      exports2.SaxesParser = SaxesParser;
    }, { "xmlchars/xml/1.0/ed5": 541, "xmlchars/xml/1.1/ed2": 542, "xmlchars/xmlns/1.0/ed3": 543 }], 497: [function(require2, module2, exports2) {
      (function(setImmediate) {
        module2.exports = typeof setImmediate === "function" ? setImmediate : function setImmediate2() {
          var args = [].slice.apply(arguments);
          args.splice(1, 0, 0);
          setTimeout.apply(null, args);
        };
      }).call(this, require2("timers").setImmediate);
    }, { "timers": 521 }], 498: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      function Hash(blockSize, finalSize) {
        this._block = Buffer.alloc(blockSize);
        this._finalSize = finalSize;
        this._blockSize = blockSize;
        this._len = 0;
      }
      Hash.prototype.update = function(data, enc) {
        if (typeof data === "string") {
          enc = enc || "utf8";
          data = Buffer.from(data, enc);
        }
        var block = this._block;
        var blockSize = this._blockSize;
        var length = data.length;
        var accum = this._len;
        for (var offset = 0; offset < length; ) {
          var assigned = accum % blockSize;
          var remainder = Math.min(length - offset, blockSize - assigned);
          for (var i = 0; i < remainder; i++) {
            block[assigned + i] = data[offset + i];
          }
          accum += remainder;
          offset += remainder;
          if (accum % blockSize === 0) {
            this._update(block);
          }
        }
        this._len += length;
        return this;
      };
      Hash.prototype.digest = function(enc) {
        var rem = this._len % this._blockSize;
        this._block[rem] = 128;
        this._block.fill(0, rem + 1);
        if (rem >= this._finalSize) {
          this._update(this._block);
          this._block.fill(0);
        }
        var bits = this._len * 8;
        if (bits <= 4294967295) {
          this._block.writeUInt32BE(bits, this._blockSize - 4);
        } else {
          var lowBits = (bits & 4294967295) >>> 0;
          var highBits = (bits - lowBits) / 4294967296;
          this._block.writeUInt32BE(highBits, this._blockSize - 8);
          this._block.writeUInt32BE(lowBits, this._blockSize - 4);
        }
        this._update(this._block);
        var hash = this._hash();
        return enc ? hash.toString(enc) : hash;
      };
      Hash.prototype._update = function() {
        throw new Error("_update must be implemented by subclass");
      };
      module2.exports = Hash;
    }, { "safe-buffer": 494 }], 499: [function(require2, module2, exports2) {
      var _exports = module2.exports = function SHA(algorithm) {
        algorithm = algorithm.toLowerCase();
        var Algorithm = _exports[algorithm];
        if (!Algorithm)
          throw new Error(algorithm + " is not supported (we accept pull requests)");
        return new Algorithm();
      };
      _exports.sha = require2("./sha");
      _exports.sha1 = require2("./sha1");
      _exports.sha224 = require2("./sha224");
      _exports.sha256 = require2("./sha256");
      _exports.sha384 = require2("./sha384");
      _exports.sha512 = require2("./sha512");
    }, { "./sha": 500, "./sha1": 501, "./sha224": 502, "./sha256": 503, "./sha384": 504, "./sha512": 505 }], 500: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
      var W = new Array(80);
      function Sha() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha, Hash);
      Sha.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0)
          return b & c | ~b & d;
        if (s === 2)
          return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i) {
          W2[i] = M.readInt32BE(i * 4);
        }
        for (; i < 80; ++i) {
          W2[i] = W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16];
        }
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t2 = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t2;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha.prototype._hash = function() {
        var H = Buffer.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      module2.exports = Sha;
    }, { "./hash": 498, "inherits": 387, "safe-buffer": 494 }], 501: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
      var W = new Array(80);
      function Sha1() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha1, Hash);
      Sha1.prototype.init = function() {
        this._a = 1732584193;
        this._b = 4023233417;
        this._c = 2562383102;
        this._d = 271733878;
        this._e = 3285377520;
        return this;
      };
      function rotl1(num) {
        return num << 1 | num >>> 31;
      }
      function rotl5(num) {
        return num << 5 | num >>> 27;
      }
      function rotl30(num) {
        return num << 30 | num >>> 2;
      }
      function ft(s, b, c, d) {
        if (s === 0)
          return b & c | ~b & d;
        if (s === 2)
          return b & c | b & d | c & d;
        return b ^ c ^ d;
      }
      Sha1.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        for (var i = 0; i < 16; ++i) {
          W2[i] = M.readInt32BE(i * 4);
        }
        for (; i < 80; ++i) {
          W2[i] = rotl1(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16]);
        }
        for (var j = 0; j < 80; ++j) {
          var s = ~~(j / 20);
          var t2 = rotl5(a) + ft(s, b, c, d) + e + W2[j] + K[s] | 0;
          e = d;
          d = c;
          c = rotl30(b);
          b = a;
          a = t2;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
      };
      Sha1.prototype._hash = function() {
        var H = Buffer.allocUnsafe(20);
        H.writeInt32BE(this._a | 0, 0);
        H.writeInt32BE(this._b | 0, 4);
        H.writeInt32BE(this._c | 0, 8);
        H.writeInt32BE(this._d | 0, 12);
        H.writeInt32BE(this._e | 0, 16);
        return H;
      };
      module2.exports = Sha1;
    }, { "./hash": 498, "inherits": 387, "safe-buffer": 494 }], 502: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Sha256 = require2("./sha256");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var W = new Array(64);
      function Sha224() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha224, Sha256);
      Sha224.prototype.init = function() {
        this._a = 3238371032;
        this._b = 914150663;
        this._c = 812702999;
        this._d = 4144912697;
        this._e = 4290775857;
        this._f = 1750603025;
        this._g = 1694076839;
        this._h = 3204075428;
        return this;
      };
      Sha224.prototype._hash = function() {
        var H = Buffer.allocUnsafe(28);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        return H;
      };
      module2.exports = Sha224;
    }, { "./hash": 498, "./sha256": 503, "inherits": 387, "safe-buffer": 494 }], 503: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
      var W = new Array(64);
      function Sha256() {
        this.init();
        this._w = W;
        Hash.call(this, 64, 56);
      }
      inherits(Sha256, Hash);
      Sha256.prototype.init = function() {
        this._a = 1779033703;
        this._b = 3144134277;
        this._c = 1013904242;
        this._d = 2773480762;
        this._e = 1359893119;
        this._f = 2600822924;
        this._g = 528734635;
        this._h = 1541459225;
        return this;
      };
      function ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x) {
        return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
      }
      function sigma1(x) {
        return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
      }
      function gamma0(x) {
        return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
      }
      function gamma1(x) {
        return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
      }
      Sha256.prototype._update = function(M) {
        var W2 = this._w;
        var a = this._a | 0;
        var b = this._b | 0;
        var c = this._c | 0;
        var d = this._d | 0;
        var e = this._e | 0;
        var f = this._f | 0;
        var g = this._g | 0;
        var h3 = this._h | 0;
        for (var i = 0; i < 16; ++i) {
          W2[i] = M.readInt32BE(i * 4);
        }
        for (; i < 64; ++i) {
          W2[i] = gamma1(W2[i - 2]) + W2[i - 7] + gamma0(W2[i - 15]) + W2[i - 16] | 0;
        }
        for (var j = 0; j < 64; ++j) {
          var T1 = h3 + sigma1(e) + ch(e, f, g) + K[j] + W2[j] | 0;
          var T2 = sigma0(a) + maj(a, b, c) | 0;
          h3 = g;
          g = f;
          f = e;
          e = d + T1 | 0;
          d = c;
          c = b;
          b = a;
          a = T1 + T2 | 0;
        }
        this._a = a + this._a | 0;
        this._b = b + this._b | 0;
        this._c = c + this._c | 0;
        this._d = d + this._d | 0;
        this._e = e + this._e | 0;
        this._f = f + this._f | 0;
        this._g = g + this._g | 0;
        this._h = h3 + this._h | 0;
      };
      Sha256.prototype._hash = function() {
        var H = Buffer.allocUnsafe(32);
        H.writeInt32BE(this._a, 0);
        H.writeInt32BE(this._b, 4);
        H.writeInt32BE(this._c, 8);
        H.writeInt32BE(this._d, 12);
        H.writeInt32BE(this._e, 16);
        H.writeInt32BE(this._f, 20);
        H.writeInt32BE(this._g, 24);
        H.writeInt32BE(this._h, 28);
        return H;
      };
      module2.exports = Sha256;
    }, { "./hash": 498, "inherits": 387, "safe-buffer": 494 }], 504: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var SHA512 = require2("./sha512");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var W = new Array(160);
      function Sha384() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits(Sha384, SHA512);
      Sha384.prototype.init = function() {
        this._ah = 3418070365;
        this._bh = 1654270250;
        this._ch = 2438529370;
        this._dh = 355462360;
        this._eh = 1731405415;
        this._fh = 2394180231;
        this._gh = 3675008525;
        this._hh = 1203062813;
        this._al = 3238371032;
        this._bl = 914150663;
        this._cl = 812702999;
        this._dl = 4144912697;
        this._el = 4290775857;
        this._fl = 1750603025;
        this._gl = 1694076839;
        this._hl = 3204075428;
        return this;
      };
      Sha384.prototype._hash = function() {
        var H = Buffer.allocUnsafe(48);
        function writeInt64BE(h3, l, offset) {
          H.writeInt32BE(h3, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        return H;
      };
      module2.exports = Sha384;
    }, { "./hash": 498, "./sha512": 505, "inherits": 387, "safe-buffer": 494 }], 505: [function(require2, module2, exports2) {
      var inherits = require2("inherits");
      var Hash = require2("./hash");
      var Buffer = require2("safe-buffer").Buffer;
      var K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
      var W = new Array(160);
      function Sha512() {
        this.init();
        this._w = W;
        Hash.call(this, 128, 112);
      }
      inherits(Sha512, Hash);
      Sha512.prototype.init = function() {
        this._ah = 1779033703;
        this._bh = 3144134277;
        this._ch = 1013904242;
        this._dh = 2773480762;
        this._eh = 1359893119;
        this._fh = 2600822924;
        this._gh = 528734635;
        this._hh = 1541459225;
        this._al = 4089235720;
        this._bl = 2227873595;
        this._cl = 4271175723;
        this._dl = 1595750129;
        this._el = 2917565137;
        this._fl = 725511199;
        this._gl = 4215389547;
        this._hl = 327033209;
        return this;
      };
      function Ch(x, y, z) {
        return z ^ x & (y ^ z);
      }
      function maj(x, y, z) {
        return x & y | z & (x | y);
      }
      function sigma0(x, xl) {
        return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
      }
      function sigma1(x, xl) {
        return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
      }
      function Gamma0(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
      }
      function Gamma0l(x, xl) {
        return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
      }
      function Gamma1(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
      }
      function Gamma1l(x, xl) {
        return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
      }
      function getCarry(a, b) {
        return a >>> 0 < b >>> 0 ? 1 : 0;
      }
      Sha512.prototype._update = function(M) {
        var W2 = this._w;
        var ah = this._ah | 0;
        var bh = this._bh | 0;
        var ch = this._ch | 0;
        var dh = this._dh | 0;
        var eh = this._eh | 0;
        var fh = this._fh | 0;
        var gh = this._gh | 0;
        var hh = this._hh | 0;
        var al = this._al | 0;
        var bl = this._bl | 0;
        var cl = this._cl | 0;
        var dl = this._dl | 0;
        var el = this._el | 0;
        var fl = this._fl | 0;
        var gl = this._gl | 0;
        var hl = this._hl | 0;
        for (var i = 0; i < 32; i += 2) {
          W2[i] = M.readInt32BE(i * 4);
          W2[i + 1] = M.readInt32BE(i * 4 + 4);
        }
        for (; i < 160; i += 2) {
          var xh = W2[i - 15 * 2];
          var xl = W2[i - 15 * 2 + 1];
          var gamma0 = Gamma0(xh, xl);
          var gamma0l = Gamma0l(xl, xh);
          xh = W2[i - 2 * 2];
          xl = W2[i - 2 * 2 + 1];
          var gamma1 = Gamma1(xh, xl);
          var gamma1l = Gamma1l(xl, xh);
          var Wi7h = W2[i - 7 * 2];
          var Wi7l = W2[i - 7 * 2 + 1];
          var Wi16h = W2[i - 16 * 2];
          var Wi16l = W2[i - 16 * 2 + 1];
          var Wil = gamma0l + Wi7l | 0;
          var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
          Wil = Wil + gamma1l | 0;
          Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
          Wil = Wil + Wi16l | 0;
          Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
          W2[i] = Wih;
          W2[i + 1] = Wil;
        }
        for (var j = 0; j < 160; j += 2) {
          Wih = W2[j];
          Wil = W2[j + 1];
          var majh = maj(ah, bh, ch);
          var majl = maj(al, bl, cl);
          var sigma0h = sigma0(ah, al);
          var sigma0l = sigma0(al, ah);
          var sigma1h = sigma1(eh, el);
          var sigma1l = sigma1(el, eh);
          var Kih = K[j];
          var Kil = K[j + 1];
          var chh = Ch(eh, fh, gh);
          var chl = Ch(el, fl, gl);
          var t1l = hl + sigma1l | 0;
          var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
          t1l = t1l + chl | 0;
          t1h = t1h + chh + getCarry(t1l, chl) | 0;
          t1l = t1l + Kil | 0;
          t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
          t1l = t1l + Wil | 0;
          t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
          var t2l = sigma0l + majl | 0;
          var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          el = dl + t1l | 0;
          eh = dh + t1h + getCarry(el, dl) | 0;
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          al = t1l + t2l | 0;
          ah = t1h + t2h + getCarry(al, t1l) | 0;
        }
        this._al = this._al + al | 0;
        this._bl = this._bl + bl | 0;
        this._cl = this._cl + cl | 0;
        this._dl = this._dl + dl | 0;
        this._el = this._el + el | 0;
        this._fl = this._fl + fl | 0;
        this._gl = this._gl + gl | 0;
        this._hl = this._hl + hl | 0;
        this._ah = this._ah + ah + getCarry(this._al, al) | 0;
        this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
        this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
        this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
        this._eh = this._eh + eh + getCarry(this._el, el) | 0;
        this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
        this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
        this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
      };
      Sha512.prototype._hash = function() {
        var H = Buffer.allocUnsafe(64);
        function writeInt64BE(h3, l, offset) {
          H.writeInt32BE(h3, offset);
          H.writeInt32BE(l, offset + 4);
        }
        writeInt64BE(this._ah, this._al, 0);
        writeInt64BE(this._bh, this._bl, 8);
        writeInt64BE(this._ch, this._cl, 16);
        writeInt64BE(this._dh, this._dl, 24);
        writeInt64BE(this._eh, this._el, 32);
        writeInt64BE(this._fh, this._fl, 40);
        writeInt64BE(this._gh, this._gl, 48);
        writeInt64BE(this._hh, this._hl, 56);
        return H;
      };
      module2.exports = Sha512;
    }, { "./hash": 498, "inherits": 387, "safe-buffer": 494 }], 506: [function(require2, module2, exports2) {
      module2.exports = Stream;
      var EE = require2("events").EventEmitter;
      var inherits = require2("inherits");
      inherits(Stream, EE);
      Stream.Readable = require2("readable-stream/readable.js");
      Stream.Writable = require2("readable-stream/writable.js");
      Stream.Duplex = require2("readable-stream/duplex.js");
      Stream.Transform = require2("readable-stream/transform.js");
      Stream.PassThrough = require2("readable-stream/passthrough.js");
      Stream.Stream = Stream;
      function Stream() {
        EE.call(this);
      }
      Stream.prototype.pipe = function(dest, options) {
        var source = this;
        function ondata(chunk) {
          if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
              source.pause();
            }
          }
        }
        source.on("data", ondata);
        function ondrain() {
          if (source.readable && source.resume) {
            source.resume();
          }
        }
        dest.on("drain", ondrain);
        if (!dest._isStdio && (!options || options.end !== false)) {
          source.on("end", onend);
          source.on("close", onclose);
        }
        var didOnEnd = false;
        function onend() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          dest.end();
        }
        function onclose() {
          if (didOnEnd)
            return;
          didOnEnd = true;
          if (typeof dest.destroy === "function")
            dest.destroy();
        }
        function onerror(er) {
          cleanup();
          if (EE.listenerCount(this, "error") === 0) {
            throw er;
          }
        }
        source.on("error", onerror);
        dest.on("error", onerror);
        function cleanup() {
          source.removeListener("data", ondata);
          dest.removeListener("drain", ondrain);
          source.removeListener("end", onend);
          source.removeListener("close", onclose);
          source.removeListener("error", onerror);
          dest.removeListener("error", onerror);
          source.removeListener("end", cleanup);
          source.removeListener("close", cleanup);
          dest.removeListener("close", cleanup);
        }
        source.on("end", cleanup);
        source.on("close", cleanup);
        dest.on("close", cleanup);
        dest.emit("pipe", source);
        return dest;
      };
    }, { "events": 367, "inherits": 387, "readable-stream/duplex.js": 507, "readable-stream/passthrough.js": 516, "readable-stream/readable.js": 517, "readable-stream/transform.js": 518, "readable-stream/writable.js": 519 }], 507: [function(require2, module2, exports2) {
      module2.exports = require2("./lib/_stream_duplex.js");
    }, { "./lib/_stream_duplex.js": 508 }], 508: [function(require2, module2, exports2) {
      var pna = require2("process-nextick-args");
      var objectKeys = Object.keys || function(obj) {
        var keys2 = [];
        for (var key in obj) {
          keys2.push(key);
        }
        return keys2;
      };
      module2.exports = Duplex;
      var util = Object.create(require2("core-util-is"));
      util.inherits = require2("inherits");
      var Readable = require2("./_stream_readable");
      var Writable = require2("./_stream_writable");
      util.inherits(Duplex, Readable);
      {
        var keys = objectKeys(Writable.prototype);
        for (var v = 0; v < keys.length; v++) {
          var method = keys[v];
          if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
        }
      }
      function Duplex(options) {
        if (!(this instanceof Duplex))
          return new Duplex(options);
        Readable.call(this, options);
        Writable.call(this, options);
        if (options && options.readable === false)
          this.readable = false;
        if (options && options.writable === false)
          this.writable = false;
        this.allowHalfOpen = true;
        if (options && options.allowHalfOpen === false)
          this.allowHalfOpen = false;
        this.once("end", onend);
      }
      Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
        // making it explicit this property is not enumerable
        // because otherwise some prototype manipulation in
        // userland will fail
        enumerable: false,
        get: function get() {
          return this._writableState.highWaterMark;
        }
      });
      function onend() {
        if (this.allowHalfOpen || this._writableState.ended)
          return;
        pna.nextTick(onEndNT, this);
      }
      function onEndNT(self2) {
        self2.end();
      }
      Object.defineProperty(Duplex.prototype, "destroyed", { get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      }, set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      } });
      Duplex.prototype._destroy = function(err, cb) {
        this.push(null);
        this.end();
        pna.nextTick(cb, err);
      };
    }, { "./_stream_readable": 510, "./_stream_writable": 512, "core-util-is": 328, "inherits": 387, "process-nextick-args": 466 }], 509: [function(require2, module2, exports2) {
      module2.exports = PassThrough;
      var Transform = require2("./_stream_transform");
      var util = Object.create(require2("core-util-is"));
      util.inherits = require2("inherits");
      util.inherits(PassThrough, Transform);
      function PassThrough(options) {
        if (!(this instanceof PassThrough))
          return new PassThrough(options);
        Transform.call(this, options);
      }
      PassThrough.prototype._transform = function(chunk, encoding, cb) {
        cb(null, chunk);
      };
    }, { "./_stream_transform": 511, "core-util-is": 328, "inherits": 387 }], 510: [function(require2, module2, exports2) {
      (function(process, global2) {
        var pna = require2("process-nextick-args");
        module2.exports = Readable;
        var isArray = require2("isarray");
        var Duplex;
        Readable.ReadableState = ReadableState;
        require2("events").EventEmitter;
        var EElistenerCount = function EElistenerCount2(emitter, type) {
          return emitter.listeners(type).length;
        };
        var Stream = require2("./internal/streams/stream");
        var Buffer = require2("safe-buffer").Buffer;
        var OurUint8Array = global2.Uint8Array || function() {
        };
        function _uint8ArrayToBuffer(chunk) {
          return Buffer.from(chunk);
        }
        function _isUint8Array(obj) {
          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        var util = Object.create(require2("core-util-is"));
        util.inherits = require2("inherits");
        var debugUtil = require2("util");
        var debug = void 0;
        if (debugUtil && debugUtil.debuglog) {
          debug = debugUtil.debuglog("stream");
        } else {
          debug = function debug2() {
          };
        }
        var BufferList = require2("./internal/streams/BufferList");
        var destroyImpl = require2("./internal/streams/destroy");
        var StringDecoder;
        util.inherits(Readable, Stream);
        var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
        function prependListener(emitter, event, fn) {
          if (typeof emitter.prependListener === "function")
            return emitter.prependListener(event, fn);
          if (!emitter._events || !emitter._events[event])
            emitter.on(event, fn);
          else if (isArray(emitter._events[event]))
            emitter._events[event].unshift(fn);
          else
            emitter._events[event] = [fn, emitter._events[event]];
        }
        function ReadableState(options, stream) {
          Duplex = Duplex || require2("./_stream_duplex");
          options = options || {};
          var isDuplex = stream instanceof Duplex;
          this.objectMode = !!options.objectMode;
          if (isDuplex)
            this.objectMode = this.objectMode || !!options.readableObjectMode;
          var hwm = options.highWaterMark;
          var readableHwm = options.readableHighWaterMark;
          var defaultHwm = this.objectMode ? 16 : 16 * 1024;
          if (hwm || hwm === 0)
            this.highWaterMark = hwm;
          else if (isDuplex && (readableHwm || readableHwm === 0))
            this.highWaterMark = readableHwm;
          else
            this.highWaterMark = defaultHwm;
          this.highWaterMark = Math.floor(this.highWaterMark);
          this.buffer = new BufferList();
          this.length = 0;
          this.pipes = null;
          this.pipesCount = 0;
          this.flowing = null;
          this.ended = false;
          this.endEmitted = false;
          this.reading = false;
          this.sync = true;
          this.needReadable = false;
          this.emittedReadable = false;
          this.readableListening = false;
          this.resumeScheduled = false;
          this.destroyed = false;
          this.defaultEncoding = options.defaultEncoding || "utf8";
          this.awaitDrain = 0;
          this.readingMore = false;
          this.decoder = null;
          this.encoding = null;
          if (options.encoding) {
            if (!StringDecoder)
              StringDecoder = require2("string_decoder/").StringDecoder;
            this.decoder = new StringDecoder(options.encoding);
            this.encoding = options.encoding;
          }
        }
        function Readable(options) {
          Duplex = Duplex || require2("./_stream_duplex");
          if (!(this instanceof Readable))
            return new Readable(options);
          this._readableState = new ReadableState(options, this);
          this.readable = true;
          if (options) {
            if (typeof options.read === "function")
              this._read = options.read;
            if (typeof options.destroy === "function")
              this._destroy = options.destroy;
          }
          Stream.call(this);
        }
        Object.defineProperty(Readable.prototype, "destroyed", { get: function get() {
          if (this._readableState === void 0) {
            return false;
          }
          return this._readableState.destroyed;
        }, set: function set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        } });
        Readable.prototype.destroy = destroyImpl.destroy;
        Readable.prototype._undestroy = destroyImpl.undestroy;
        Readable.prototype._destroy = function(err, cb) {
          this.push(null);
          cb(err);
        };
        Readable.prototype.push = function(chunk, encoding) {
          var state = this._readableState;
          var skipChunkCheck;
          if (!state.objectMode) {
            if (typeof chunk === "string") {
              encoding = encoding || state.defaultEncoding;
              if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = "";
              }
              skipChunkCheck = true;
            }
          } else {
            skipChunkCheck = true;
          }
          return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
        };
        Readable.prototype.unshift = function(chunk) {
          return readableAddChunk(this, chunk, null, true, false);
        };
        function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
          var state = stream._readableState;
          if (chunk === null) {
            state.reading = false;
            onEofChunk(stream, state);
          } else {
            var er;
            if (!skipChunkCheck)
              er = chunkInvalid(state, chunk);
            if (er) {
              stream.emit("error", er);
            } else if (state.objectMode || chunk && chunk.length > 0) {
              if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
              }
              if (addToFront) {
                if (state.endEmitted)
                  stream.emit("error", new Error("stream.unshift() after end event"));
                else
                  addChunk(stream, state, chunk, true);
              } else if (state.ended) {
                stream.emit("error", new Error("stream.push() after EOF"));
              } else {
                state.reading = false;
                if (state.decoder && !encoding) {
                  chunk = state.decoder.write(chunk);
                  if (state.objectMode || chunk.length !== 0)
                    addChunk(stream, state, chunk, false);
                  else
                    maybeReadMore(stream, state);
                } else {
                  addChunk(stream, state, chunk, false);
                }
              }
            } else if (!addToFront) {
              state.reading = false;
            }
          }
          return needMoreData(state);
        }
        function addChunk(stream, state, chunk, addToFront) {
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit("data", chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
        function chunkInvalid(state, chunk) {
          var er;
          if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
            er = new TypeError("Invalid non-string/buffer chunk");
          }
          return er;
        }
        function needMoreData(state) {
          return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
        }
        Readable.prototype.isPaused = function() {
          return this._readableState.flowing === false;
        };
        Readable.prototype.setEncoding = function(enc) {
          if (!StringDecoder)
            StringDecoder = require2("string_decoder/").StringDecoder;
          this._readableState.decoder = new StringDecoder(enc);
          this._readableState.encoding = enc;
          return this;
        };
        var MAX_HWM = 8388608;
        function computeNewHighWaterMark(n) {
          if (n >= MAX_HWM) {
            n = MAX_HWM;
          } else {
            n--;
            n |= n >>> 1;
            n |= n >>> 2;
            n |= n >>> 4;
            n |= n >>> 8;
            n |= n >>> 16;
            n++;
          }
          return n;
        }
        function howMuchToRead(n, state) {
          if (n <= 0 || state.length === 0 && state.ended)
            return 0;
          if (state.objectMode)
            return 1;
          if (n !== n) {
            if (state.flowing && state.length)
              return state.buffer.head.data.length;
            else
              return state.length;
          }
          if (n > state.highWaterMark)
            state.highWaterMark = computeNewHighWaterMark(n);
          if (n <= state.length)
            return n;
          if (!state.ended) {
            state.needReadable = true;
            return 0;
          }
          return state.length;
        }
        Readable.prototype.read = function(n) {
          debug("read", n);
          n = parseInt(n, 10);
          var state = this._readableState;
          var nOrig = n;
          if (n !== 0)
            state.emittedReadable = false;
          if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
            debug("read: emitReadable", state.length, state.ended);
            if (state.length === 0 && state.ended)
              endReadable(this);
            else
              emitReadable(this);
            return null;
          }
          n = howMuchToRead(n, state);
          if (n === 0 && state.ended) {
            if (state.length === 0)
              endReadable(this);
            return null;
          }
          var doRead = state.needReadable;
          debug("need readable", doRead);
          if (state.length === 0 || state.length - n < state.highWaterMark) {
            doRead = true;
            debug("length less than watermark", doRead);
          }
          if (state.ended || state.reading) {
            doRead = false;
            debug("reading or ended", doRead);
          } else if (doRead) {
            debug("do read");
            state.reading = true;
            state.sync = true;
            if (state.length === 0)
              state.needReadable = true;
            this._read(state.highWaterMark);
            state.sync = false;
            if (!state.reading)
              n = howMuchToRead(nOrig, state);
          }
          var ret;
          if (n > 0)
            ret = fromList(n, state);
          else
            ret = null;
          if (ret === null) {
            state.needReadable = true;
            n = 0;
          } else {
            state.length -= n;
          }
          if (state.length === 0) {
            if (!state.ended)
              state.needReadable = true;
            if (nOrig !== n && state.ended)
              endReadable(this);
          }
          if (ret !== null)
            this.emit("data", ret);
          return ret;
        };
        function onEofChunk(stream, state) {
          if (state.ended)
            return;
          if (state.decoder) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) {
              state.buffer.push(chunk);
              state.length += state.objectMode ? 1 : chunk.length;
            }
          }
          state.ended = true;
          emitReadable(stream);
        }
        function emitReadable(stream) {
          var state = stream._readableState;
          state.needReadable = false;
          if (!state.emittedReadable) {
            debug("emitReadable", state.flowing);
            state.emittedReadable = true;
            if (state.sync)
              pna.nextTick(emitReadable_, stream);
            else
              emitReadable_(stream);
          }
        }
        function emitReadable_(stream) {
          debug("emit readable");
          stream.emit("readable");
          flow(stream);
        }
        function maybeReadMore(stream, state) {
          if (!state.readingMore) {
            state.readingMore = true;
            pna.nextTick(maybeReadMore_, stream, state);
          }
        }
        function maybeReadMore_(stream, state) {
          var len = state.length;
          while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
            debug("maybeReadMore read 0");
            stream.read(0);
            if (len === state.length)
              break;
            else
              len = state.length;
          }
          state.readingMore = false;
        }
        Readable.prototype._read = function(n) {
          this.emit("error", new Error("_read() is not implemented"));
        };
        Readable.prototype.pipe = function(dest, pipeOpts) {
          var src = this;
          var state = this._readableState;
          switch (state.pipesCount) {
            case 0:
              state.pipes = dest;
              break;
            case 1:
              state.pipes = [state.pipes, dest];
              break;
            default:
              state.pipes.push(dest);
              break;
          }
          state.pipesCount += 1;
          debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
          var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
          var endFn = doEnd ? onend : unpipe;
          if (state.endEmitted)
            pna.nextTick(endFn);
          else
            src.once("end", endFn);
          dest.on("unpipe", onunpipe);
          function onunpipe(readable, unpipeInfo) {
            debug("onunpipe");
            if (readable === src) {
              if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
              }
            }
          }
          function onend() {
            debug("onend");
            dest.end();
          }
          var ondrain = pipeOnDrain(src);
          dest.on("drain", ondrain);
          var cleanedUp = false;
          function cleanup() {
            debug("cleanup");
            dest.removeListener("close", onclose);
            dest.removeListener("finish", onfinish);
            dest.removeListener("drain", ondrain);
            dest.removeListener("error", onerror);
            dest.removeListener("unpipe", onunpipe);
            src.removeListener("end", onend);
            src.removeListener("end", unpipe);
            src.removeListener("data", ondata);
            cleanedUp = true;
            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
              ondrain();
          }
          var increasedAwaitDrain = false;
          src.on("data", ondata);
          function ondata(chunk) {
            debug("ondata");
            increasedAwaitDrain = false;
            var ret = dest.write(chunk);
            if (false === ret && !increasedAwaitDrain) {
              if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug("false write response, pause", src._readableState.awaitDrain);
                src._readableState.awaitDrain++;
                increasedAwaitDrain = true;
              }
              src.pause();
            }
          }
          function onerror(er) {
            debug("onerror", er);
            unpipe();
            dest.removeListener("error", onerror);
            if (EElistenerCount(dest, "error") === 0)
              dest.emit("error", er);
          }
          prependListener(dest, "error", onerror);
          function onclose() {
            dest.removeListener("finish", onfinish);
            unpipe();
          }
          dest.once("close", onclose);
          function onfinish() {
            debug("onfinish");
            dest.removeListener("close", onclose);
            unpipe();
          }
          dest.once("finish", onfinish);
          function unpipe() {
            debug("unpipe");
            src.unpipe(dest);
          }
          dest.emit("pipe", src);
          if (!state.flowing) {
            debug("pipe resume");
            src.resume();
          }
          return dest;
        };
        function pipeOnDrain(src) {
          return function() {
            var state = src._readableState;
            debug("pipeOnDrain", state.awaitDrain);
            if (state.awaitDrain)
              state.awaitDrain--;
            if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
              state.flowing = true;
              flow(src);
            }
          };
        }
        Readable.prototype.unpipe = function(dest) {
          var state = this._readableState;
          var unpipeInfo = { hasUnpiped: false };
          if (state.pipesCount === 0)
            return this;
          if (state.pipesCount === 1) {
            if (dest && dest !== state.pipes)
              return this;
            if (!dest)
              dest = state.pipes;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            if (dest)
              dest.emit("unpipe", this, unpipeInfo);
            return this;
          }
          if (!dest) {
            var dests = state.pipes;
            var len = state.pipesCount;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            for (var i = 0; i < len; i++) {
              dests[i].emit("unpipe", this, unpipeInfo);
            }
            return this;
          }
          var index2 = indexOf(state.pipes, dest);
          if (index2 === -1)
            return this;
          state.pipes.splice(index2, 1);
          state.pipesCount -= 1;
          if (state.pipesCount === 1)
            state.pipes = state.pipes[0];
          dest.emit("unpipe", this, unpipeInfo);
          return this;
        };
        Readable.prototype.on = function(ev, fn) {
          var res = Stream.prototype.on.call(this, ev, fn);
          if (ev === "data") {
            if (this._readableState.flowing !== false)
              this.resume();
          } else if (ev === "readable") {
            var state = this._readableState;
            if (!state.endEmitted && !state.readableListening) {
              state.readableListening = state.needReadable = true;
              state.emittedReadable = false;
              if (!state.reading) {
                pna.nextTick(nReadingNextTick, this);
              } else if (state.length) {
                emitReadable(this);
              }
            }
          }
          return res;
        };
        Readable.prototype.addListener = Readable.prototype.on;
        function nReadingNextTick(self2) {
          debug("readable nexttick read 0");
          self2.read(0);
        }
        Readable.prototype.resume = function() {
          var state = this._readableState;
          if (!state.flowing) {
            debug("resume");
            state.flowing = true;
            resume(this, state);
          }
          return this;
        };
        function resume(stream, state) {
          if (!state.resumeScheduled) {
            state.resumeScheduled = true;
            pna.nextTick(resume_, stream, state);
          }
        }
        function resume_(stream, state) {
          if (!state.reading) {
            debug("resume read 0");
            stream.read(0);
          }
          state.resumeScheduled = false;
          state.awaitDrain = 0;
          stream.emit("resume");
          flow(stream);
          if (state.flowing && !state.reading)
            stream.read(0);
        }
        Readable.prototype.pause = function() {
          debug("call pause flowing=%j", this._readableState.flowing);
          if (false !== this._readableState.flowing) {
            debug("pause");
            this._readableState.flowing = false;
            this.emit("pause");
          }
          return this;
        };
        function flow(stream) {
          var state = stream._readableState;
          debug("flow", state.flowing);
          while (state.flowing && stream.read() !== null) {
          }
        }
        Readable.prototype.wrap = function(stream) {
          var _this = this;
          var state = this._readableState;
          var paused = false;
          stream.on("end", function() {
            debug("wrapped end");
            if (state.decoder && !state.ended) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length)
                _this.push(chunk);
            }
            _this.push(null);
          });
          stream.on("data", function(chunk) {
            debug("wrapped data");
            if (state.decoder)
              chunk = state.decoder.write(chunk);
            if (state.objectMode && (chunk === null || chunk === void 0))
              return;
            else if (!state.objectMode && (!chunk || !chunk.length))
              return;
            var ret = _this.push(chunk);
            if (!ret) {
              paused = true;
              stream.pause();
            }
          });
          for (var i in stream) {
            if (this[i] === void 0 && typeof stream[i] === "function") {
              this[i] = function(method) {
                return function() {
                  return stream[method].apply(stream, arguments);
                };
              }(i);
            }
          }
          for (var n = 0; n < kProxyEvents.length; n++) {
            stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
          }
          this._read = function(n2) {
            debug("wrapped _read", n2);
            if (paused) {
              paused = false;
              stream.resume();
            }
          };
          return this;
        };
        Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._readableState.highWaterMark;
          }
        });
        Readable._fromList = fromList;
        function fromList(n, state) {
          if (state.length === 0)
            return null;
          var ret;
          if (state.objectMode)
            ret = state.buffer.shift();
          else if (!n || n >= state.length) {
            if (state.decoder)
              ret = state.buffer.join("");
            else if (state.buffer.length === 1)
              ret = state.buffer.head.data;
            else
              ret = state.buffer.concat(state.length);
            state.buffer.clear();
          } else {
            ret = fromListPartial(n, state.buffer, state.decoder);
          }
          return ret;
        }
        function fromListPartial(n, list, hasStrings) {
          var ret;
          if (n < list.head.data.length) {
            ret = list.head.data.slice(0, n);
            list.head.data = list.head.data.slice(n);
          } else if (n === list.head.data.length) {
            ret = list.shift();
          } else {
            ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
          }
          return ret;
        }
        function copyFromBufferString(n, list) {
          var p = list.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  list.head = p.next;
                else
                  list.head = list.tail = null;
              } else {
                list.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          list.length -= c;
          return ret;
        }
        function copyFromBuffer(n, list) {
          var ret = Buffer.allocUnsafe(n);
          var p = list.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  list.head = p.next;
                else
                  list.head = list.tail = null;
              } else {
                list.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          list.length -= c;
          return ret;
        }
        function endReadable(stream) {
          var state = stream._readableState;
          if (state.length > 0)
            throw new Error('"endReadable()" called on non-empty stream');
          if (!state.endEmitted) {
            state.ended = true;
            pna.nextTick(endReadableNT, state, stream);
          }
        }
        function endReadableNT(state, stream) {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        }
        function indexOf(xs, x) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (xs[i] === x)
              return i;
          }
          return -1;
        }
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "./_stream_duplex": 508, "./internal/streams/BufferList": 513, "./internal/streams/destroy": 514, "./internal/streams/stream": 515, "_process": 467, "core-util-is": 328, "events": 367, "inherits": 387, "isarray": 389, "process-nextick-args": 466, "safe-buffer": 494, "string_decoder/": 520, "util": 185 }], 511: [function(require2, module2, exports2) {
      module2.exports = Transform;
      var Duplex = require2("./_stream_duplex");
      var util = Object.create(require2("core-util-is"));
      util.inherits = require2("inherits");
      util.inherits(Transform, Duplex);
      function afterTransform(er, data) {
        var ts = this._transformState;
        ts.transforming = false;
        var cb = ts.writecb;
        if (!cb) {
          return this.emit("error", new Error("write callback called multiple times"));
        }
        ts.writechunk = null;
        ts.writecb = null;
        if (data != null)
          this.push(data);
        cb(er);
        var rs = this._readableState;
        rs.reading = false;
        if (rs.needReadable || rs.length < rs.highWaterMark) {
          this._read(rs.highWaterMark);
        }
      }
      function Transform(options) {
        if (!(this instanceof Transform))
          return new Transform(options);
        Duplex.call(this, options);
        this._transformState = { afterTransform: afterTransform.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null };
        this._readableState.needReadable = true;
        this._readableState.sync = false;
        if (options) {
          if (typeof options.transform === "function")
            this._transform = options.transform;
          if (typeof options.flush === "function")
            this._flush = options.flush;
        }
        this.on("prefinish", prefinish);
      }
      function prefinish() {
        var _this = this;
        if (typeof this._flush === "function") {
          this._flush(function(er, data) {
            done(_this, er, data);
          });
        } else {
          done(this, null, null);
        }
      }
      Transform.prototype.push = function(chunk, encoding) {
        this._transformState.needTransform = false;
        return Duplex.prototype.push.call(this, chunk, encoding);
      };
      Transform.prototype._transform = function(chunk, encoding, cb) {
        throw new Error("_transform() is not implemented");
      };
      Transform.prototype._write = function(chunk, encoding, cb) {
        var ts = this._transformState;
        ts.writecb = cb;
        ts.writechunk = chunk;
        ts.writeencoding = encoding;
        if (!ts.transforming) {
          var rs = this._readableState;
          if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
        }
      };
      Transform.prototype._read = function(n) {
        var ts = this._transformState;
        if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
          ts.transforming = true;
          this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
        } else {
          ts.needTransform = true;
        }
      };
      Transform.prototype._destroy = function(err, cb) {
        var _this2 = this;
        Duplex.prototype._destroy.call(this, err, function(err2) {
          cb(err2);
          _this2.emit("close");
        });
      };
      function done(stream, er, data) {
        if (er)
          return stream.emit("error", er);
        if (data != null)
          stream.push(data);
        if (stream._writableState.length)
          throw new Error("Calling transform done when ws.length != 0");
        if (stream._transformState.transforming)
          throw new Error("Calling transform done when still transforming");
        return stream.push(null);
      }
    }, { "./_stream_duplex": 508, "core-util-is": 328, "inherits": 387 }], 512: [function(require2, module2, exports2) {
      (function(process, global2, setImmediate) {
        var pna = require2("process-nextick-args");
        module2.exports = Writable;
        function CorkedRequest(state) {
          var _this = this;
          this.next = null;
          this.entry = null;
          this.finish = function() {
            onCorkedFinish(_this, state);
          };
        }
        var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
        var Duplex;
        Writable.WritableState = WritableState;
        var util = Object.create(require2("core-util-is"));
        util.inherits = require2("inherits");
        var internalUtil = { deprecate: require2("util-deprecate") };
        var Stream = require2("./internal/streams/stream");
        var Buffer = require2("safe-buffer").Buffer;
        var OurUint8Array = global2.Uint8Array || function() {
        };
        function _uint8ArrayToBuffer(chunk) {
          return Buffer.from(chunk);
        }
        function _isUint8Array(obj) {
          return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        var destroyImpl = require2("./internal/streams/destroy");
        util.inherits(Writable, Stream);
        function nop() {
        }
        function WritableState(options, stream) {
          Duplex = Duplex || require2("./_stream_duplex");
          options = options || {};
          var isDuplex = stream instanceof Duplex;
          this.objectMode = !!options.objectMode;
          if (isDuplex)
            this.objectMode = this.objectMode || !!options.writableObjectMode;
          var hwm = options.highWaterMark;
          var writableHwm = options.writableHighWaterMark;
          var defaultHwm = this.objectMode ? 16 : 16 * 1024;
          if (hwm || hwm === 0)
            this.highWaterMark = hwm;
          else if (isDuplex && (writableHwm || writableHwm === 0))
            this.highWaterMark = writableHwm;
          else
            this.highWaterMark = defaultHwm;
          this.highWaterMark = Math.floor(this.highWaterMark);
          this.finalCalled = false;
          this.needDrain = false;
          this.ending = false;
          this.ended = false;
          this.finished = false;
          this.destroyed = false;
          var noDecode = options.decodeStrings === false;
          this.decodeStrings = !noDecode;
          this.defaultEncoding = options.defaultEncoding || "utf8";
          this.length = 0;
          this.writing = false;
          this.corked = 0;
          this.sync = true;
          this.bufferProcessing = false;
          this.onwrite = function(er) {
            onwrite(stream, er);
          };
          this.writecb = null;
          this.writelen = 0;
          this.bufferedRequest = null;
          this.lastBufferedRequest = null;
          this.pendingcb = 0;
          this.prefinished = false;
          this.errorEmitted = false;
          this.bufferedRequestCount = 0;
          this.corkedRequestsFree = new CorkedRequest(this);
        }
        WritableState.prototype.getBuffer = function getBuffer() {
          var current = this.bufferedRequest;
          var out = [];
          while (current) {
            out.push(current);
            current = current.next;
          }
          return out;
        };
        (function() {
          try {
            Object.defineProperty(WritableState.prototype, "buffer", { get: internalUtil.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
          } catch (_) {
          }
        })();
        var realHasInstance;
        if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
          realHasInstance = Function.prototype[Symbol.hasInstance];
          Object.defineProperty(Writable, Symbol.hasInstance, { value: function value(object) {
            if (realHasInstance.call(this, object))
              return true;
            if (this !== Writable)
              return false;
            return object && object._writableState instanceof WritableState;
          } });
        } else {
          realHasInstance = function realHasInstance2(object) {
            return object instanceof this;
          };
        }
        function Writable(options) {
          Duplex = Duplex || require2("./_stream_duplex");
          if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
            return new Writable(options);
          }
          this._writableState = new WritableState(options, this);
          this.writable = true;
          if (options) {
            if (typeof options.write === "function")
              this._write = options.write;
            if (typeof options.writev === "function")
              this._writev = options.writev;
            if (typeof options.destroy === "function")
              this._destroy = options.destroy;
            if (typeof options.final === "function")
              this._final = options.final;
          }
          Stream.call(this);
        }
        Writable.prototype.pipe = function() {
          this.emit("error", new Error("Cannot pipe, not readable"));
        };
        function writeAfterEnd(stream, cb) {
          var er = new Error("write after end");
          stream.emit("error", er);
          pna.nextTick(cb, er);
        }
        function validChunk(stream, state, chunk, cb) {
          var valid = true;
          var er = false;
          if (chunk === null) {
            er = new TypeError("May not write null values to stream");
          } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
            er = new TypeError("Invalid non-string/buffer chunk");
          }
          if (er) {
            stream.emit("error", er);
            pna.nextTick(cb, er);
            valid = false;
          }
          return valid;
        }
        Writable.prototype.write = function(chunk, encoding, cb) {
          var state = this._writableState;
          var ret = false;
          var isBuf = !state.objectMode && _isUint8Array(chunk);
          if (isBuf && !Buffer.isBuffer(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (typeof encoding === "function") {
            cb = encoding;
            encoding = null;
          }
          if (isBuf)
            encoding = "buffer";
          else if (!encoding)
            encoding = state.defaultEncoding;
          if (typeof cb !== "function")
            cb = nop;
          if (state.ended)
            writeAfterEnd(this, cb);
          else if (isBuf || validChunk(this, state, chunk, cb)) {
            state.pendingcb++;
            ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
          }
          return ret;
        };
        Writable.prototype.cork = function() {
          var state = this._writableState;
          state.corked++;
        };
        Writable.prototype.uncork = function() {
          var state = this._writableState;
          if (state.corked) {
            state.corked--;
            if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
              clearBuffer(this, state);
          }
        };
        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
          if (typeof encoding === "string")
            encoding = encoding.toLowerCase();
          if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
            throw new TypeError("Unknown encoding: " + encoding);
          this._writableState.defaultEncoding = encoding;
          return this;
        };
        function decodeChunk(state, chunk, encoding) {
          if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
            chunk = Buffer.from(chunk, encoding);
          }
          return chunk;
        }
        Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function get() {
            return this._writableState.highWaterMark;
          }
        });
        function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
          if (!isBuf) {
            var newChunk = decodeChunk(state, chunk, encoding);
            if (chunk !== newChunk) {
              isBuf = true;
              encoding = "buffer";
              chunk = newChunk;
            }
          }
          var len = state.objectMode ? 1 : chunk.length;
          state.length += len;
          var ret = state.length < state.highWaterMark;
          if (!ret)
            state.needDrain = true;
          if (state.writing || state.corked) {
            var last = state.lastBufferedRequest;
            state.lastBufferedRequest = { chunk, encoding, isBuf, callback: cb, next: null };
            if (last) {
              last.next = state.lastBufferedRequest;
            } else {
              state.bufferedRequest = state.lastBufferedRequest;
            }
            state.bufferedRequestCount += 1;
          } else {
            doWrite(stream, state, false, len, chunk, encoding, cb);
          }
          return ret;
        }
        function doWrite(stream, state, writev, len, chunk, encoding, cb) {
          state.writelen = len;
          state.writecb = cb;
          state.writing = true;
          state.sync = true;
          if (writev)
            stream._writev(chunk, state.onwrite);
          else
            stream._write(chunk, encoding, state.onwrite);
          state.sync = false;
        }
        function onwriteError(stream, state, sync, er, cb) {
          --state.pendingcb;
          if (sync) {
            pna.nextTick(cb, er);
            pna.nextTick(finishMaybe, stream, state);
            stream._writableState.errorEmitted = true;
            stream.emit("error", er);
          } else {
            cb(er);
            stream._writableState.errorEmitted = true;
            stream.emit("error", er);
            finishMaybe(stream, state);
          }
        }
        function onwriteStateUpdate(state) {
          state.writing = false;
          state.writecb = null;
          state.length -= state.writelen;
          state.writelen = 0;
        }
        function onwrite(stream, er) {
          var state = stream._writableState;
          var sync = state.sync;
          var cb = state.writecb;
          onwriteStateUpdate(state);
          if (er)
            onwriteError(stream, state, sync, er, cb);
          else {
            var finished = needFinish(state);
            if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
              clearBuffer(stream, state);
            }
            if (sync) {
              asyncWrite(afterWrite, stream, state, finished, cb);
            } else {
              afterWrite(stream, state, finished, cb);
            }
          }
        }
        function afterWrite(stream, state, finished, cb) {
          if (!finished)
            onwriteDrain(stream, state);
          state.pendingcb--;
          cb();
          finishMaybe(stream, state);
        }
        function onwriteDrain(stream, state) {
          if (state.length === 0 && state.needDrain) {
            state.needDrain = false;
            stream.emit("drain");
          }
        }
        function clearBuffer(stream, state) {
          state.bufferProcessing = true;
          var entry = state.bufferedRequest;
          if (stream._writev && entry && entry.next) {
            var l = state.bufferedRequestCount;
            var buffer = new Array(l);
            var holder = state.corkedRequestsFree;
            holder.entry = entry;
            var count = 0;
            var allBuffers = true;
            while (entry) {
              buffer[count] = entry;
              if (!entry.isBuf)
                allBuffers = false;
              entry = entry.next;
              count += 1;
            }
            buffer.allBuffers = allBuffers;
            doWrite(stream, state, true, state.length, buffer, "", holder.finish);
            state.pendingcb++;
            state.lastBufferedRequest = null;
            if (holder.next) {
              state.corkedRequestsFree = holder.next;
              holder.next = null;
            } else {
              state.corkedRequestsFree = new CorkedRequest(state);
            }
            state.bufferedRequestCount = 0;
          } else {
            while (entry) {
              var chunk = entry.chunk;
              var encoding = entry.encoding;
              var cb = entry.callback;
              var len = state.objectMode ? 1 : chunk.length;
              doWrite(stream, state, false, len, chunk, encoding, cb);
              entry = entry.next;
              state.bufferedRequestCount--;
              if (state.writing) {
                break;
              }
            }
            if (entry === null)
              state.lastBufferedRequest = null;
          }
          state.bufferedRequest = entry;
          state.bufferProcessing = false;
        }
        Writable.prototype._write = function(chunk, encoding, cb) {
          cb(new Error("_write() is not implemented"));
        };
        Writable.prototype._writev = null;
        Writable.prototype.end = function(chunk, encoding, cb) {
          var state = this._writableState;
          if (typeof chunk === "function") {
            cb = chunk;
            chunk = null;
            encoding = null;
          } else if (typeof encoding === "function") {
            cb = encoding;
            encoding = null;
          }
          if (chunk !== null && chunk !== void 0)
            this.write(chunk, encoding);
          if (state.corked) {
            state.corked = 1;
            this.uncork();
          }
          if (!state.ending && !state.finished)
            endWritable(this, state, cb);
        };
        function needFinish(state) {
          return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
        }
        function callFinal(stream, state) {
          stream._final(function(err) {
            state.pendingcb--;
            if (err) {
              stream.emit("error", err);
            }
            state.prefinished = true;
            stream.emit("prefinish");
            finishMaybe(stream, state);
          });
        }
        function prefinish(stream, state) {
          if (!state.prefinished && !state.finalCalled) {
            if (typeof stream._final === "function") {
              state.pendingcb++;
              state.finalCalled = true;
              pna.nextTick(callFinal, stream, state);
            } else {
              state.prefinished = true;
              stream.emit("prefinish");
            }
          }
        }
        function finishMaybe(stream, state) {
          var need = needFinish(state);
          if (need) {
            prefinish(stream, state);
            if (state.pendingcb === 0) {
              state.finished = true;
              stream.emit("finish");
            }
          }
          return need;
        }
        function endWritable(stream, state, cb) {
          state.ending = true;
          finishMaybe(stream, state);
          if (cb) {
            if (state.finished)
              pna.nextTick(cb);
            else
              stream.once("finish", cb);
          }
          state.ended = true;
          stream.writable = false;
        }
        function onCorkedFinish(corkReq, state, err) {
          var entry = corkReq.entry;
          corkReq.entry = null;
          while (entry) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(err);
            entry = entry.next;
          }
          if (state.corkedRequestsFree) {
            state.corkedRequestsFree.next = corkReq;
          } else {
            state.corkedRequestsFree = corkReq;
          }
        }
        Object.defineProperty(Writable.prototype, "destroyed", { get: function get() {
          if (this._writableState === void 0) {
            return false;
          }
          return this._writableState.destroyed;
        }, set: function set(value) {
          if (!this._writableState) {
            return;
          }
          this._writableState.destroyed = value;
        } });
        Writable.prototype.destroy = destroyImpl.destroy;
        Writable.prototype._undestroy = destroyImpl.undestroy;
        Writable.prototype._destroy = function(err, cb) {
          this.end();
          cb(err);
        };
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("timers").setImmediate);
    }, { "./_stream_duplex": 508, "./internal/streams/destroy": 514, "./internal/streams/stream": 515, "_process": 467, "core-util-is": 328, "inherits": 387, "process-nextick-args": 466, "safe-buffer": 494, "timers": 521, "util-deprecate": 522 }], 513: [function(require2, module2, exports2) {
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      var Buffer = require2("safe-buffer").Buffer;
      var util = require2("util");
      function copyBuffer(src, target, offset) {
        src.copy(target, offset);
      }
      module2.exports = function() {
        function BufferList() {
          _classCallCheck2(this, BufferList);
          this.head = null;
          this.tail = null;
          this.length = 0;
        }
        BufferList.prototype.push = function push(v) {
          var entry = { data: v, next: null };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        };
        BufferList.prototype.unshift = function unshift(v) {
          var entry = { data: v, next: this.head };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        };
        BufferList.prototype.shift = function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        };
        BufferList.prototype.clear = function clear() {
          this.head = this.tail = null;
          this.length = 0;
        };
        BufferList.prototype.join = function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        };
        BufferList.prototype.concat = function concat(n) {
          if (this.length === 0)
            return Buffer.alloc(0);
          if (this.length === 1)
            return this.head.data;
          var ret = Buffer.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        };
        return BufferList;
      }();
      if (util && util.inspect && util.inspect.custom) {
        module2.exports.prototype[util.inspect.custom] = function() {
          var obj = util.inspect({ length: this.length });
          return this.constructor.name + " " + obj;
        };
      }
    }, { "safe-buffer": 494, "util": 185 }], 514: [function(require2, module2, exports2) {
      var pna = require2("process-nextick-args");
      function destroy(err, cb) {
        var _this = this;
        var readableDestroyed = this._readableState && this._readableState.destroyed;
        var writableDestroyed = this._writableState && this._writableState.destroyed;
        if (readableDestroyed || writableDestroyed) {
          if (cb) {
            cb(err);
          } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
            pna.nextTick(emitErrorNT, this, err);
          }
          return this;
        }
        if (this._readableState) {
          this._readableState.destroyed = true;
        }
        if (this._writableState) {
          this._writableState.destroyed = true;
        }
        this._destroy(err || null, function(err2) {
          if (!cb && err2) {
            pna.nextTick(emitErrorNT, _this, err2);
            if (_this._writableState) {
              _this._writableState.errorEmitted = true;
            }
          } else if (cb) {
            cb(err2);
          }
        });
        return this;
      }
      function undestroy() {
        if (this._readableState) {
          this._readableState.destroyed = false;
          this._readableState.reading = false;
          this._readableState.ended = false;
          this._readableState.endEmitted = false;
        }
        if (this._writableState) {
          this._writableState.destroyed = false;
          this._writableState.ended = false;
          this._writableState.ending = false;
          this._writableState.finished = false;
          this._writableState.errorEmitted = false;
        }
      }
      function emitErrorNT(self2, err) {
        self2.emit("error", err);
      }
      module2.exports = { destroy, undestroy };
    }, { "process-nextick-args": 466 }], 515: [function(require2, module2, exports2) {
      arguments[4][490][0].apply(exports2, arguments);
    }, { "dup": 490, "events": 367 }], 516: [function(require2, module2, exports2) {
      module2.exports = require2("./readable").PassThrough;
    }, { "./readable": 517 }], 517: [function(require2, module2, exports2) {
      exports2 = module2.exports = require2("./lib/_stream_readable.js");
      exports2.Stream = exports2;
      exports2.Readable = exports2;
      exports2.Writable = require2("./lib/_stream_writable.js");
      exports2.Duplex = require2("./lib/_stream_duplex.js");
      exports2.Transform = require2("./lib/_stream_transform.js");
      exports2.PassThrough = require2("./lib/_stream_passthrough.js");
    }, { "./lib/_stream_duplex.js": 508, "./lib/_stream_passthrough.js": 509, "./lib/_stream_readable.js": 510, "./lib/_stream_transform.js": 511, "./lib/_stream_writable.js": 512 }], 518: [function(require2, module2, exports2) {
      module2.exports = require2("./readable").Transform;
    }, { "./readable": 517 }], 519: [function(require2, module2, exports2) {
      module2.exports = require2("./lib/_stream_writable.js");
    }, { "./lib/_stream_writable.js": 512 }], 520: [function(require2, module2, exports2) {
      var Buffer = require2("safe-buffer").Buffer;
      var isEncoding = Buffer.isEncoding || function(encoding) {
        encoding = "" + encoding;
        switch (encoding && encoding.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      function _normalizeEncoding(enc) {
        if (!enc)
          return "utf8";
        var retried;
        while (true) {
          switch (enc) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return enc;
            default:
              if (retried)
                return;
              enc = ("" + enc).toLowerCase();
              retried = true;
          }
        }
      }
      function normalizeEncoding(enc) {
        var nenc = _normalizeEncoding(enc);
        if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
          throw new Error("Unknown encoding: " + enc);
        return nenc || enc;
      }
      exports2.StringDecoder = StringDecoder;
      function StringDecoder(encoding) {
        this.encoding = normalizeEncoding(encoding);
        var nb;
        switch (this.encoding) {
          case "utf16le":
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
          case "utf8":
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
          case "base64":
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
          default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
        }
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
      }
      StringDecoder.prototype.write = function(buf) {
        if (buf.length === 0)
          return "";
        var r;
        var i;
        if (this.lastNeed) {
          r = this.fillLast(buf);
          if (r === void 0)
            return "";
          i = this.lastNeed;
          this.lastNeed = 0;
        } else {
          i = 0;
        }
        if (i < buf.length)
          return r ? r + this.text(buf, i) : this.text(buf, i);
        return r || "";
      };
      StringDecoder.prototype.end = utf8End;
      StringDecoder.prototype.text = utf8Text;
      StringDecoder.prototype.fillLast = function(buf) {
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
        this.lastNeed -= buf.length;
      };
      function utf8CheckByte(byte) {
        if (byte <= 127)
          return 0;
        else if (byte >> 5 === 6)
          return 2;
        else if (byte >> 4 === 14)
          return 3;
        else if (byte >> 3 === 30)
          return 4;
        return byte >> 6 === 2 ? -1 : -2;
      }
      function utf8CheckIncomplete(self2, buf, i) {
        var j = buf.length - 1;
        if (j < i)
          return 0;
        var nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 1;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0)
            self2.lastNeed = nb - 2;
          return nb;
        }
        if (--j < i || nb === -2)
          return 0;
        nb = utf8CheckByte(buf[j]);
        if (nb >= 0) {
          if (nb > 0) {
            if (nb === 2)
              nb = 0;
            else
              self2.lastNeed = nb - 3;
          }
          return nb;
        }
        return 0;
      }
      function utf8CheckExtraBytes(self2, buf, p) {
        if ((buf[0] & 192) !== 128) {
          self2.lastNeed = 0;
          return "";
        }
        if (self2.lastNeed > 1 && buf.length > 1) {
          if ((buf[1] & 192) !== 128) {
            self2.lastNeed = 1;
            return "";
          }
          if (self2.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 192) !== 128) {
              self2.lastNeed = 2;
              return "";
            }
          }
        }
      }
      function utf8FillLast(buf) {
        var p = this.lastTotal - this.lastNeed;
        var r = utf8CheckExtraBytes(this, buf);
        if (r !== void 0)
          return r;
        if (this.lastNeed <= buf.length) {
          buf.copy(this.lastChar, p, 0, this.lastNeed);
          return this.lastChar.toString(this.encoding, 0, this.lastTotal);
        }
        buf.copy(this.lastChar, p, 0, buf.length);
        this.lastNeed -= buf.length;
      }
      function utf8Text(buf, i) {
        var total = utf8CheckIncomplete(this, buf, i);
        if (!this.lastNeed)
          return buf.toString("utf8", i);
        this.lastTotal = total;
        var end = buf.length - (total - this.lastNeed);
        buf.copy(this.lastChar, 0, end);
        return buf.toString("utf8", i, end);
      }
      function utf8End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + "";
        return r;
      }
      function utf16Text(buf, i) {
        if ((buf.length - i) % 2 === 0) {
          var r = buf.toString("utf16le", i);
          if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 55296 && c <= 56319) {
              this.lastNeed = 2;
              this.lastTotal = 4;
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
              return r.slice(0, -1);
            }
          }
          return r;
        }
        this.lastNeed = 1;
        this.lastTotal = 2;
        this.lastChar[0] = buf[buf.length - 1];
        return buf.toString("utf16le", i, buf.length - 1);
      }
      function utf16End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed) {
          var end = this.lastTotal - this.lastNeed;
          return r + this.lastChar.toString("utf16le", 0, end);
        }
        return r;
      }
      function base64Text(buf, i) {
        var n = (buf.length - i) % 3;
        if (n === 0)
          return buf.toString("base64", i);
        this.lastNeed = 3 - n;
        this.lastTotal = 3;
        if (n === 1) {
          this.lastChar[0] = buf[buf.length - 1];
        } else {
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
        }
        return buf.toString("base64", i, buf.length - n);
      }
      function base64End(buf) {
        var r = buf && buf.length ? this.write(buf) : "";
        if (this.lastNeed)
          return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
        return r;
      }
      function simpleWrite(buf) {
        return buf.toString(this.encoding);
      }
      function simpleEnd(buf) {
        return buf && buf.length ? this.write(buf) : "";
      }
    }, { "safe-buffer": 494 }], 521: [function(require2, module2, exports2) {
      (function(setImmediate, clearImmediate) {
        var nextTick2 = require2("process/browser.js").nextTick;
        var apply = Function.prototype.apply;
        var slice = Array.prototype.slice;
        var immediateIds = {};
        var nextImmediateId = 0;
        exports2.setTimeout = function() {
          return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
        };
        exports2.setInterval = function() {
          return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
        };
        exports2.clearTimeout = exports2.clearInterval = function(timeout) {
          timeout.close();
        };
        function Timeout(id, clearFn) {
          this._id = id;
          this._clearFn = clearFn;
        }
        Timeout.prototype.unref = Timeout.prototype.ref = function() {
        };
        Timeout.prototype.close = function() {
          this._clearFn.call(window, this._id);
        };
        exports2.enroll = function(item, msecs) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = msecs;
        };
        exports2.unenroll = function(item) {
          clearTimeout(item._idleTimeoutId);
          item._idleTimeout = -1;
        };
        exports2._unrefActive = exports2.active = function(item) {
          clearTimeout(item._idleTimeoutId);
          var msecs = item._idleTimeout;
          if (msecs >= 0) {
            item._idleTimeoutId = setTimeout(function onTimeout() {
              if (item._onTimeout)
                item._onTimeout();
            }, msecs);
          }
        };
        exports2.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
          var id = nextImmediateId++;
          var args = arguments.length < 2 ? false : slice.call(arguments, 1);
          immediateIds[id] = true;
          nextTick2(function onNextTick() {
            if (immediateIds[id]) {
              if (args) {
                fn.apply(null, args);
              } else {
                fn.call(null);
              }
              exports2.clearImmediate(id);
            }
          });
          return id;
        };
        exports2.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
          delete immediateIds[id];
        };
      }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
    }, { "process/browser.js": 467, "timers": 521 }], 522: [function(require2, module2, exports2) {
      (function(global2) {
        module2.exports = deprecate;
        function deprecate(fn, msg) {
          if (config("noDeprecation")) {
            return fn;
          }
          var warned = false;
          function deprecated() {
            if (!warned) {
              if (config("throwDeprecation")) {
                throw new Error(msg);
              } else if (config("traceDeprecation")) {
                console.trace(msg);
              } else {
                console.warn(msg);
              }
              warned = true;
            }
            return fn.apply(this, arguments);
          }
          return deprecated;
        }
        function config(name) {
          try {
            if (!global2.localStorage)
              return false;
          } catch (_) {
            return false;
          }
          var val = global2.localStorage[name];
          if (null == val)
            return false;
          return String(val).toLowerCase() === "true";
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 523: [function(require2, module2, exports2) {
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function TempCtor2() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
    }, {}], 524: [function(require2, module2, exports2) {
      function _typeof2(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof2 = function _typeof3(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof2 = function _typeof3(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof2(obj);
      }
      module2.exports = function isBuffer(arg) {
        return arg && _typeof2(arg) === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }, {}], 525: [function(require2, module2, exports2) {
      (function(process, global2) {
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        var formatRegExp = /%[sdj%]/g;
        exports2.format = function(f) {
          if (!isString(f)) {
            var objects = [];
            for (var i = 0; i < arguments.length; i++) {
              objects.push(inspect(arguments[i]));
            }
            return objects.join(" ");
          }
          var i = 1;
          var args = arguments;
          var len = args.length;
          var str = String(f).replace(formatRegExp, function(x2) {
            if (x2 === "%%")
              return "%";
            if (i >= len)
              return x2;
            switch (x2) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_) {
                  return "[Circular]";
                }
              default:
                return x2;
            }
          });
          for (var x = args[i]; i < len; x = args[++i]) {
            if (isNull(x) || !isObject(x)) {
              str += " " + x;
            } else {
              str += " " + inspect(x);
            }
          }
          return str;
        };
        exports2.deprecate = function(fn, msg) {
          if (isUndefined(global2.process)) {
            return function() {
              return exports2.deprecate(fn, msg).apply(this, arguments);
            };
          }
          if (process.noDeprecation === true) {
            return fn;
          }
          var warned = false;
          function deprecated() {
            if (!warned) {
              if (process.throwDeprecation) {
                throw new Error(msg);
              } else if (process.traceDeprecation) {
                console.trace(msg);
              } else {
                console.error(msg);
              }
              warned = true;
            }
            return fn.apply(this, arguments);
          }
          return deprecated;
        };
        var debugs = {};
        var debugEnviron;
        exports2.debuglog = function(set) {
          if (isUndefined(debugEnviron))
            debugEnviron = process.env.NODE_DEBUG || "";
          set = set.toUpperCase();
          if (!debugs[set]) {
            if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
              var pid = process.pid;
              debugs[set] = function() {
                var msg = exports2.format.apply(exports2, arguments);
                console.error("%s %d: %s", set, pid, msg);
              };
            } else {
              debugs[set] = function() {
              };
            }
          }
          return debugs[set];
        };
        function inspect(obj, opts) {
          var ctx = { seen: [], stylize: stylizeNoColor };
          if (arguments.length >= 3)
            ctx.depth = arguments[2];
          if (arguments.length >= 4)
            ctx.colors = arguments[3];
          if (isBoolean(opts)) {
            ctx.showHidden = opts;
          } else if (opts) {
            exports2._extend(ctx, opts);
          }
          if (isUndefined(ctx.showHidden))
            ctx.showHidden = false;
          if (isUndefined(ctx.depth))
            ctx.depth = 2;
          if (isUndefined(ctx.colors))
            ctx.colors = false;
          if (isUndefined(ctx.customInspect))
            ctx.customInspect = true;
          if (ctx.colors)
            ctx.stylize = stylizeWithColor;
          return formatValue(ctx, obj, ctx.depth);
        }
        exports2.inspect = inspect;
        inspect.colors = { "bold": [1, 22], "italic": [3, 23], "underline": [4, 24], "inverse": [7, 27], "white": [37, 39], "grey": [90, 39], "black": [30, 39], "blue": [34, 39], "cyan": [36, 39], "green": [32, 39], "magenta": [35, 39], "red": [31, 39], "yellow": [33, 39] };
        inspect.styles = {
          "special": "cyan",
          "number": "yellow",
          "boolean": "yellow",
          "undefined": "grey",
          "null": "bold",
          "string": "green",
          "date": "magenta",
          // "name": intentionally not styling
          "regexp": "red"
        };
        function stylizeWithColor(str, styleType) {
          var style = inspect.styles[styleType];
          if (style) {
            return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
          } else {
            return str;
          }
        }
        function stylizeNoColor(str, styleType) {
          return str;
        }
        function arrayToHash(array) {
          var hash = {};
          array.forEach(function(val, idx) {
            hash[val] = true;
          });
          return hash;
        }
        function formatValue(ctx, value, recurseTimes) {
          if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
          value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
            var ret = value.inspect(recurseTimes, ctx);
            if (!isString(ret)) {
              ret = formatValue(ctx, ret, recurseTimes);
            }
            return ret;
          }
          var primitive = formatPrimitive(ctx, value);
          if (primitive) {
            return primitive;
          }
          var keys = Object.keys(value);
          var visibleKeys = arrayToHash(keys);
          if (ctx.showHidden) {
            keys = Object.getOwnPropertyNames(value);
          }
          if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
            return formatError(value);
          }
          if (keys.length === 0) {
            if (isFunction(value)) {
              var name = value.name ? ": " + value.name : "";
              return ctx.stylize("[Function" + name + "]", "special");
            }
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
            }
            if (isDate(value)) {
              return ctx.stylize(Date.prototype.toString.call(value), "date");
            }
            if (isError(value)) {
              return formatError(value);
            }
          }
          var base = "", array = false, braces = ["{", "}"];
          if (isArray(value)) {
            array = true;
            braces = ["[", "]"];
          }
          if (isFunction(value)) {
            var n = value.name ? ": " + value.name : "";
            base = " [Function" + n + "]";
          }
          if (isRegExp(value)) {
            base = " " + RegExp.prototype.toString.call(value);
          }
          if (isDate(value)) {
            base = " " + Date.prototype.toUTCString.call(value);
          }
          if (isError(value)) {
            base = " " + formatError(value);
          }
          if (keys.length === 0 && (!array || value.length == 0)) {
            return braces[0] + base + braces[1];
          }
          if (recurseTimes < 0) {
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
            } else {
              return ctx.stylize("[Object]", "special");
            }
          }
          ctx.seen.push(value);
          var output;
          if (array) {
            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
          } else {
            output = keys.map(function(key) {
              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
            });
          }
          ctx.seen.pop();
          return reduceToSingleString(output, base, braces);
        }
        function formatPrimitive(ctx, value) {
          if (isUndefined(value))
            return ctx.stylize("undefined", "undefined");
          if (isString(value)) {
            var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return ctx.stylize(simple, "string");
          }
          if (isNumber(value))
            return ctx.stylize("" + value, "number");
          if (isBoolean(value))
            return ctx.stylize("" + value, "boolean");
          if (isNull(value))
            return ctx.stylize("null", "null");
        }
        function formatError(value) {
          return "[" + Error.prototype.toString.call(value) + "]";
        }
        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
          var output = [];
          for (var i = 0, l = value.length; i < l; ++i) {
            if (hasOwnProperty3(value, String(i))) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
            } else {
              output.push("");
            }
          }
          keys.forEach(function(key) {
            if (!key.match(/^\d+$/)) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
            }
          });
          return output;
        }
        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
          var name, str, desc;
          desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
          if (desc.get) {
            if (desc.set) {
              str = ctx.stylize("[Getter/Setter]", "special");
            } else {
              str = ctx.stylize("[Getter]", "special");
            }
          } else {
            if (desc.set) {
              str = ctx.stylize("[Setter]", "special");
            }
          }
          if (!hasOwnProperty3(visibleKeys, key)) {
            name = "[" + key + "]";
          }
          if (!str) {
            if (ctx.seen.indexOf(desc.value) < 0) {
              if (isNull(recurseTimes)) {
                str = formatValue(ctx, desc.value, null);
              } else {
                str = formatValue(ctx, desc.value, recurseTimes - 1);
              }
              if (str.indexOf("\n") > -1) {
                if (array) {
                  str = str.split("\n").map(function(line) {
                    return "  " + line;
                  }).join("\n").substr(2);
                } else {
                  str = "\n" + str.split("\n").map(function(line) {
                    return "   " + line;
                  }).join("\n");
                }
              }
            } else {
              str = ctx.stylize("[Circular]", "special");
            }
          }
          if (isUndefined(name)) {
            if (array && key.match(/^\d+$/)) {
              return str;
            }
            name = JSON.stringify("" + key);
            if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
              name = name.substr(1, name.length - 2);
              name = ctx.stylize(name, "name");
            } else {
              name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
              name = ctx.stylize(name, "string");
            }
          }
          return name + ": " + str;
        }
        function reduceToSingleString(output, base, braces) {
          var length = output.reduce(function(prev, cur) {
            if (cur.indexOf("\n") >= 0)
              ;
            return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
          }, 0);
          if (length > 60) {
            return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
          }
          return braces[0] + base + " " + output.join(", ") + " " + braces[1];
        }
        function isArray(ar) {
          return Array.isArray(ar);
        }
        exports2.isArray = isArray;
        function isBoolean(arg) {
          return typeof arg === "boolean";
        }
        exports2.isBoolean = isBoolean;
        function isNull(arg) {
          return arg === null;
        }
        exports2.isNull = isNull;
        function isNullOrUndefined(arg) {
          return arg == null;
        }
        exports2.isNullOrUndefined = isNullOrUndefined;
        function isNumber(arg) {
          return typeof arg === "number";
        }
        exports2.isNumber = isNumber;
        function isString(arg) {
          return typeof arg === "string";
        }
        exports2.isString = isString;
        function isSymbol(arg) {
          return _typeof2(arg) === "symbol";
        }
        exports2.isSymbol = isSymbol;
        function isUndefined(arg) {
          return arg === void 0;
        }
        exports2.isUndefined = isUndefined;
        function isRegExp(re) {
          return isObject(re) && objectToString(re) === "[object RegExp]";
        }
        exports2.isRegExp = isRegExp;
        function isObject(arg) {
          return _typeof2(arg) === "object" && arg !== null;
        }
        exports2.isObject = isObject;
        function isDate(d) {
          return isObject(d) && objectToString(d) === "[object Date]";
        }
        exports2.isDate = isDate;
        function isError(e) {
          return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
        }
        exports2.isError = isError;
        function isFunction(arg) {
          return typeof arg === "function";
        }
        exports2.isFunction = isFunction;
        function isPrimitive(arg) {
          return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || _typeof2(arg) === "symbol" || // ES6 symbol
          typeof arg === "undefined";
        }
        exports2.isPrimitive = isPrimitive;
        exports2.isBuffer = require2("./support/isBuffer");
        function objectToString(o) {
          return Object.prototype.toString.call(o);
        }
        function pad(n) {
          return n < 10 ? "0" + n.toString(10) : n.toString(10);
        }
        var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        function timestamp() {
          var d = /* @__PURE__ */ new Date();
          var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(":");
          return [d.getDate(), months[d.getMonth()], time].join(" ");
        }
        exports2.log = function() {
          console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
        };
        exports2.inherits = require2("inherits");
        exports2._extend = function(origin, add) {
          if (!add || !isObject(add))
            return origin;
          var keys = Object.keys(add);
          var i = keys.length;
          while (i--) {
            origin[keys[i]] = add[keys[i]];
          }
          return origin;
        };
        function hasOwnProperty3(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
      }).call(this, require2("_process"), typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "./support/isBuffer": 524, "_process": 467, "inherits": 523 }], 526: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      Object.defineProperty(exports2, "v1", { enumerable: true, get: function get() {
        return _v.default;
      } });
      Object.defineProperty(exports2, "v3", { enumerable: true, get: function get() {
        return _v2.default;
      } });
      Object.defineProperty(exports2, "v4", { enumerable: true, get: function get() {
        return _v3.default;
      } });
      Object.defineProperty(exports2, "v5", { enumerable: true, get: function get() {
        return _v4.default;
      } });
      Object.defineProperty(exports2, "NIL", { enumerable: true, get: function get() {
        return _nil.default;
      } });
      Object.defineProperty(exports2, "version", { enumerable: true, get: function get() {
        return _version.default;
      } });
      Object.defineProperty(exports2, "validate", { enumerable: true, get: function get() {
        return _validate.default;
      } });
      Object.defineProperty(exports2, "stringify", { enumerable: true, get: function get() {
        return _stringify.default;
      } });
      Object.defineProperty(exports2, "parse", { enumerable: true, get: function get() {
        return _parse.default;
      } });
      var _v = _interopRequireDefault(require2("./v1.js"));
      var _v2 = _interopRequireDefault(require2("./v3.js"));
      var _v3 = _interopRequireDefault(require2("./v4.js"));
      var _v4 = _interopRequireDefault(require2("./v5.js"));
      var _nil = _interopRequireDefault(require2("./nil.js"));
      var _version = _interopRequireDefault(require2("./version.js"));
      var _validate = _interopRequireDefault(require2("./validate.js"));
      var _stringify = _interopRequireDefault(require2("./stringify.js"));
      var _parse = _interopRequireDefault(require2("./parse.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
    }, { "./nil.js": 528, "./parse.js": 529, "./stringify.js": 533, "./v1.js": 534, "./v3.js": 535, "./v4.js": 537, "./v5.js": 538, "./validate.js": 539, "./version.js": 540 }], 527: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      function md5(bytes) {
        if (typeof bytes === "string") {
          var msg = unescape(encodeURIComponent(bytes));
          bytes = new Uint8Array(msg.length);
          for (var i = 0; i < msg.length; ++i) {
            bytes[i] = msg.charCodeAt(i);
          }
        }
        return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
      }
      function md5ToHexEncodedArray(input) {
        var output = [];
        var length32 = input.length * 32;
        var hexTab = "0123456789abcdef";
        for (var i = 0; i < length32; i += 8) {
          var x = input[i >> 5] >>> i % 32 & 255;
          var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
          output.push(hex);
        }
        return output;
      }
      function getOutputLength(inputLength8) {
        return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
      }
      function wordsToMd5(x, len) {
        x[len >> 5] |= 128 << len % 32;
        x[getOutputLength(len) - 1] = len;
        var a = 1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d = 271733878;
        for (var i = 0; i < x.length; i += 16) {
          var olda = a;
          var oldb = b;
          var oldc = c;
          var oldd = d;
          a = md5ff(a, b, c, d, x[i], 7, -680876936);
          d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
          c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
          b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
          a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
          d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
          c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
          b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
          a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
          d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
          c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
          b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
          a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
          d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
          c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
          b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
          a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
          d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
          c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
          b = md5gg(b, c, d, a, x[i], 20, -373897302);
          a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
          d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
          c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
          b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
          a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
          d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
          c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
          b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
          a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
          d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
          c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
          b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
          a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
          d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
          c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
          b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
          a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
          d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
          c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
          b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
          a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
          d = md5hh(d, a, b, c, x[i], 11, -358537222);
          c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
          b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
          a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
          d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
          c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
          b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
          a = md5ii(a, b, c, d, x[i], 6, -198630844);
          d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
          c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
          b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
          a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
          d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
          c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
          b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
          a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
          d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
          c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
          b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
          a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
          d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
          c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
          b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
          a = safeAdd(a, olda);
          b = safeAdd(b, oldb);
          c = safeAdd(c, oldc);
          d = safeAdd(d, oldd);
        }
        return [a, b, c, d];
      }
      function bytesToWords(input) {
        if (input.length === 0) {
          return [];
        }
        var length8 = input.length * 8;
        var output = new Uint32Array(getOutputLength(length8));
        for (var i = 0; i < length8; i += 8) {
          output[i >> 5] |= (input[i / 8] & 255) << i % 32;
        }
        return output;
      }
      function safeAdd(x, y) {
        var lsw = (x & 65535) + (y & 65535);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return msw << 16 | lsw & 65535;
      }
      function bitRotateLeft(num, cnt) {
        return num << cnt | num >>> 32 - cnt;
      }
      function md5cmn(q, a, b, x, s, t2) {
        return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t2)), s), b);
      }
      function md5ff(a, b, c, d, x, s, t2) {
        return md5cmn(b & c | ~b & d, a, b, x, s, t2);
      }
      function md5gg(a, b, c, d, x, s, t2) {
        return md5cmn(b & d | c & ~d, a, b, x, s, t2);
      }
      function md5hh(a, b, c, d, x, s, t2) {
        return md5cmn(b ^ c ^ d, a, b, x, s, t2);
      }
      function md5ii(a, b, c, d, x, s, t2) {
        return md5cmn(c ^ (b | ~d), a, b, x, s, t2);
      }
      var _default3 = md5;
      exports2.default = _default3;
    }, {}], 528: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _default3 = "00000000-0000-0000-0000-000000000000";
      exports2.default = _default3;
    }, {}], 529: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _validate = _interopRequireDefault(require2("./validate.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function parse(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Invalid UUID");
        }
        var v;
        var arr = new Uint8Array(16);
        arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
        arr[1] = v >>> 16 & 255;
        arr[2] = v >>> 8 & 255;
        arr[3] = v & 255;
        arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
        arr[5] = v & 255;
        arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
        arr[7] = v & 255;
        arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
        arr[9] = v & 255;
        arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
        arr[11] = v / 4294967296 & 255;
        arr[12] = v >>> 24 & 255;
        arr[13] = v >>> 16 & 255;
        arr[14] = v >>> 8 & 255;
        arr[15] = v & 255;
        return arr;
      }
      var _default3 = parse;
      exports2.default = _default3;
    }, { "./validate.js": 539 }], 530: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _default3 = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
      exports2.default = _default3;
    }, {}], 531: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = rng;
      var getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
      var rnds8 = new Uint8Array(16);
      function rng() {
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
        return getRandomValues(rnds8);
      }
    }, {}], 532: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      function f(s, x, y, z) {
        switch (s) {
          case 0:
            return x & y ^ ~x & z;
          case 1:
            return x ^ y ^ z;
          case 2:
            return x & y ^ x & z ^ y & z;
          case 3:
            return x ^ y ^ z;
        }
      }
      function ROTL(x, n) {
        return x << n | x >>> 32 - n;
      }
      function sha1(bytes) {
        var K = [1518500249, 1859775393, 2400959708, 3395469782];
        var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        if (typeof bytes === "string") {
          var msg = unescape(encodeURIComponent(bytes));
          bytes = [];
          for (var i = 0; i < msg.length; ++i) {
            bytes.push(msg.charCodeAt(i));
          }
        } else if (!Array.isArray(bytes)) {
          bytes = Array.prototype.slice.call(bytes);
        }
        bytes.push(128);
        var l = bytes.length / 4 + 2;
        var N = Math.ceil(l / 16);
        var M = new Array(N);
        for (var _i = 0; _i < N; ++_i) {
          var arr = new Uint32Array(16);
          for (var j = 0; j < 16; ++j) {
            arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
          }
          M[_i] = arr;
        }
        M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
        M[N - 1][14] = Math.floor(M[N - 1][14]);
        M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
        for (var _i2 = 0; _i2 < N; ++_i2) {
          var W = new Uint32Array(80);
          for (var t2 = 0; t2 < 16; ++t2) {
            W[t2] = M[_i2][t2];
          }
          for (var _t = 16; _t < 80; ++_t) {
            W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
          }
          var a = H[0];
          var b = H[1];
          var c = H[2];
          var d = H[3];
          var e = H[4];
          for (var _t2 = 0; _t2 < 80; ++_t2) {
            var s = Math.floor(_t2 / 20);
            var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
            e = d;
            d = c;
            c = ROTL(b, 30) >>> 0;
            b = a;
            a = T;
          }
          H[0] = H[0] + a >>> 0;
          H[1] = H[1] + b >>> 0;
          H[2] = H[2] + c >>> 0;
          H[3] = H[3] + d >>> 0;
          H[4] = H[4] + e >>> 0;
        }
        return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
      }
      var _default3 = sha1;
      exports2.default = _default3;
    }, {}], 533: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _validate = _interopRequireDefault(require2("./validate.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var byteToHex = [];
      for (var i = 0; i < 256; ++i) {
        byteToHex.push((i + 256).toString(16).substr(1));
      }
      function stringify(arr) {
        var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Stringified UUID is invalid");
        }
        return uuid;
      }
      var _default3 = stringify;
      exports2.default = _default3;
    }, { "./validate.js": 539 }], 534: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _rng = _interopRequireDefault(require2("./rng.js"));
      var _stringify = _interopRequireDefault(require2("./stringify.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var _nodeId;
      var _clockseq;
      var _lastMSecs = 0;
      var _lastNSecs = 0;
      function v1(options, buf, offset) {
        var i = buf && offset || 0;
        var b = buf || new Array(16);
        options = options || {};
        var node = options.node || _nodeId;
        var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
        if (node == null || clockseq == null) {
          var seedBytes = options.random || (options.rng || _rng.default)();
          if (node == null) {
            node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
          }
          if (clockseq == null) {
            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
          }
        }
        var msecs = options.msecs !== void 0 ? options.msecs : Date.now();
        var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
        var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
        if (dt < 0 && options.clockseq === void 0) {
          clockseq = clockseq + 1 & 16383;
        }
        if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
          nsecs = 0;
        }
        if (nsecs >= 1e4) {
          throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        }
        _lastMSecs = msecs;
        _lastNSecs = nsecs;
        _clockseq = clockseq;
        msecs += 122192928e5;
        var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
        b[i++] = tl >>> 24 & 255;
        b[i++] = tl >>> 16 & 255;
        b[i++] = tl >>> 8 & 255;
        b[i++] = tl & 255;
        var tmh = msecs / 4294967296 * 1e4 & 268435455;
        b[i++] = tmh >>> 8 & 255;
        b[i++] = tmh & 255;
        b[i++] = tmh >>> 24 & 15 | 16;
        b[i++] = tmh >>> 16 & 255;
        b[i++] = clockseq >>> 8 | 128;
        b[i++] = clockseq & 255;
        for (var n = 0; n < 6; ++n) {
          b[i + n] = node[n];
        }
        return buf || (0, _stringify.default)(b);
      }
      var _default3 = v1;
      exports2.default = _default3;
    }, { "./rng.js": 531, "./stringify.js": 533 }], 535: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _v = _interopRequireDefault(require2("./v35.js"));
      var _md = _interopRequireDefault(require2("./md5.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var v3 = (0, _v.default)("v3", 48, _md.default);
      var _default3 = v3;
      exports2.default = _default3;
    }, { "./md5.js": 527, "./v35.js": 536 }], 536: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = _default3;
      exports2.URL = exports2.DNS = void 0;
      var _stringify = _interopRequireDefault(require2("./stringify.js"));
      var _parse = _interopRequireDefault(require2("./parse.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function stringToBytes(str) {
        str = unescape(encodeURIComponent(str));
        var bytes = [];
        for (var i = 0; i < str.length; ++i) {
          bytes.push(str.charCodeAt(i));
        }
        return bytes;
      }
      var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
      exports2.DNS = DNS;
      var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
      exports2.URL = URL2;
      function _default3(name, version, hashfunc) {
        function generateUUID(value, namespace, buf, offset) {
          if (typeof value === "string") {
            value = stringToBytes(value);
          }
          if (typeof namespace === "string") {
            namespace = (0, _parse.default)(namespace);
          }
          if (namespace.length !== 16) {
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
          }
          var bytes = new Uint8Array(16 + value.length);
          bytes.set(namespace);
          bytes.set(value, namespace.length);
          bytes = hashfunc(bytes);
          bytes[6] = bytes[6] & 15 | version;
          bytes[8] = bytes[8] & 63 | 128;
          if (buf) {
            offset = offset || 0;
            for (var i = 0; i < 16; ++i) {
              buf[offset + i] = bytes[i];
            }
            return buf;
          }
          return (0, _stringify.default)(bytes);
        }
        try {
          generateUUID.name = name;
        } catch (err) {
        }
        generateUUID.DNS = DNS;
        generateUUID.URL = URL2;
        return generateUUID;
      }
    }, { "./parse.js": 529, "./stringify.js": 533 }], 537: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _rng = _interopRequireDefault(require2("./rng.js"));
      var _stringify = _interopRequireDefault(require2("./stringify.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function v4(options, buf, offset) {
        options = options || {};
        var rnds = options.random || (options.rng || _rng.default)();
        rnds[6] = rnds[6] & 15 | 64;
        rnds[8] = rnds[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (var i = 0; i < 16; ++i) {
            buf[offset + i] = rnds[i];
          }
          return buf;
        }
        return (0, _stringify.default)(rnds);
      }
      var _default3 = v4;
      exports2.default = _default3;
    }, { "./rng.js": 531, "./stringify.js": 533 }], 538: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _v = _interopRequireDefault(require2("./v35.js"));
      var _sha = _interopRequireDefault(require2("./sha1.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var v5 = (0, _v.default)("v5", 80, _sha.default);
      var _default3 = v5;
      exports2.default = _default3;
    }, { "./sha1.js": 532, "./v35.js": 536 }], 539: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _regex = _interopRequireDefault(require2("./regex.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function validate(uuid) {
        return typeof uuid === "string" && _regex.default.test(uuid);
      }
      var _default3 = validate;
      exports2.default = _default3;
    }, { "./regex.js": 530 }], 540: [function(require2, module2, exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = void 0;
      var _validate = _interopRequireDefault(require2("./validate.js"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function version(uuid) {
        if (!(0, _validate.default)(uuid)) {
          throw TypeError("Invalid UUID");
        }
        return parseInt(uuid.substr(14, 1), 16);
      }
      var _default3 = version;
      exports2.default = _default3;
    }, { "./validate.js": 539 }], 541: [function(require2, module2, exports2) {
      /**
      * Character classes and associated utilities for the 5th edition of XML 1.0.
      *
      * @author Louis-Dominique Dubeau
      * @license MIT
      * @copyright Louis-Dominique Dubeau
      */
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CHAR = "	\n\r ---";
      exports2.S = " 	\r\n";
      exports2.NAME_START_CHAR = ":A-Z_a-z-----------";
      exports2.NAME_CHAR = "-" + exports2.NAME_START_CHAR + ".0-9--";
      exports2.CHAR_RE = new RegExp("^[" + exports2.CHAR + "]$", "u");
      exports2.S_RE = new RegExp("^[" + exports2.S + "]+$", "u");
      exports2.NAME_START_CHAR_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "]$", "u");
      exports2.NAME_CHAR_RE = new RegExp("^[" + exports2.NAME_CHAR + "]$", "u");
      exports2.NAME_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "][" + exports2.NAME_CHAR + "]*$", "u");
      exports2.NMTOKEN_RE = new RegExp("^[" + exports2.NAME_CHAR + "]+$", "u");
      var TAB = 9;
      var NL = 10;
      var CR = 13;
      var SPACE = 32;
      exports2.S_LIST = [SPACE, NL, CR, TAB];
      function isChar(c) {
        return c >= SPACE && c <= 55295 || c === NL || c === CR || c === TAB || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
      }
      exports2.isChar = isChar;
      function isS(c) {
        return c === SPACE || c === NL || c === CR || c === TAB;
      }
      exports2.isS = isS;
      function isNameStartChar(c) {
        return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 58 || c === 95 || c === 8204 || c === 8205 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
      }
      exports2.isNameStartChar = isNameStartChar;
      function isNameChar(c) {
        return isNameStartChar(c) || c >= 48 && c <= 57 || c === 45 || c === 46 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
      }
      exports2.isNameChar = isNameChar;
    }, {}], 542: [function(require2, module2, exports2) {
      /**
      * Character classes and associated utilities for the 2nd edition of XML 1.1.
      *
      * @author Louis-Dominique Dubeau
      * @license MIT
      * @copyright Louis-Dominique Dubeau
      */
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.CHAR = "---";
      exports2.RESTRICTED_CHAR = "-\b\v\f---";
      exports2.S = " 	\r\n";
      exports2.NAME_START_CHAR = ":A-Z_a-z-----------";
      exports2.NAME_CHAR = "-" + exports2.NAME_START_CHAR + ".0-9--";
      exports2.CHAR_RE = new RegExp("^[" + exports2.CHAR + "]$", "u");
      exports2.RESTRICTED_CHAR_RE = new RegExp("^[" + exports2.RESTRICTED_CHAR + "]$", "u");
      exports2.S_RE = new RegExp("^[" + exports2.S + "]+$", "u");
      exports2.NAME_START_CHAR_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "]$", "u");
      exports2.NAME_CHAR_RE = new RegExp("^[" + exports2.NAME_CHAR + "]$", "u");
      exports2.NAME_RE = new RegExp("^[" + exports2.NAME_START_CHAR + "][" + exports2.NAME_CHAR + "]*$", "u");
      exports2.NMTOKEN_RE = new RegExp("^[" + exports2.NAME_CHAR + "]+$", "u");
      var TAB = 9;
      var NL = 10;
      var CR = 13;
      var SPACE = 32;
      exports2.S_LIST = [SPACE, NL, CR, TAB];
      function isChar(c) {
        return c >= 1 && c <= 55295 || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
      }
      exports2.isChar = isChar;
      function isRestrictedChar(c) {
        return c >= 1 && c <= 8 || c === 11 || c === 12 || c >= 14 && c <= 31 || c >= 127 && c <= 132 || c >= 134 && c <= 159;
      }
      exports2.isRestrictedChar = isRestrictedChar;
      function isCharAndNotRestricted(c) {
        return c === 9 || c === 10 || c === 13 || c > 31 && c < 127 || c === 133 || c > 159 && c <= 55295 || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
      }
      exports2.isCharAndNotRestricted = isCharAndNotRestricted;
      function isS(c) {
        return c === SPACE || c === NL || c === CR || c === TAB;
      }
      exports2.isS = isS;
      function isNameStartChar(c) {
        return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 58 || c === 95 || c === 8204 || c === 8205 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
      }
      exports2.isNameStartChar = isNameStartChar;
      function isNameChar(c) {
        return isNameStartChar(c) || c >= 48 && c <= 57 || c === 45 || c === 46 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
      }
      exports2.isNameChar = isNameChar;
    }, {}], 543: [function(require2, module2, exports2) {
      /**
      * Character class utilities for XML NS 1.0 edition 3.
      *
      * @author Louis-Dominique Dubeau
      * @license MIT
      * @copyright Louis-Dominique Dubeau
      */
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.NC_NAME_START_CHAR = "A-Z_a-z------------";
      exports2.NC_NAME_CHAR = "-" + exports2.NC_NAME_START_CHAR + ".0-9--";
      exports2.NC_NAME_START_CHAR_RE = new RegExp("^[" + exports2.NC_NAME_START_CHAR + "]$", "u");
      exports2.NC_NAME_CHAR_RE = new RegExp("^[" + exports2.NC_NAME_CHAR + "]$", "u");
      exports2.NC_NAME_RE = new RegExp("^[" + exports2.NC_NAME_START_CHAR + "][" + exports2.NC_NAME_CHAR + "]*$", "u");
      function isNCNameStartChar(c) {
        return c >= 65 && c <= 90 || c === 95 || c >= 97 && c <= 122 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
      }
      exports2.isNCNameStartChar = isNCNameStartChar;
      function isNCNameChar(c) {
        return isNCNameStartChar(c) || c === 45 || c === 46 || c >= 48 && c <= 57 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
      }
      exports2.isNCNameChar = isNCNameChar;
    }, {}] }, {}, [15])(15);
  });
})(exceljs);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function getUrl(src) {
  if (typeof src === "string") {
    return src;
  } else if (src instanceof Blob) {
    return URL.createObjectURL(src);
  } else if (src instanceof ArrayBuffer) {
    return URL.createObjectURL(new Blob([src]));
  } else if (src instanceof Response) {
    return URL.createObjectURL(src.blob());
  } else {
    return src;
  }
}
function download(_x, _x2) {
  return _download.apply(this, arguments);
}
function _download() {
  _download = _asyncToGenerator(/* @__PURE__ */ regenerator.mark(function _callee(filename, data) {
    return regenerator.wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            if (data) {
              _context.next = 2;
              break;
            }
            return _context.abrupt("return");
          case 2:
            if (data instanceof ArrayBuffer) {
              data = new Blob([data]);
            }
            downloadFile(filename, URL.createObjectURL(data));
          case 4:
          case "end":
            return _context.stop();
        }
    }, _callee);
  }));
  return _download.apply(this, arguments);
}
function downloadFile(filename, href) {
  var eleLink = document.createElement("a");
  eleLink.download = filename;
  eleLink.style.display = "none";
  eleLink.href = href;
  document.body.appendChild(eleLink);
  eleLink.click();
  document.body.removeChild(eleLink);
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928)
      R = RsRGB / 12.92;
    else
      R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G = GsRGB / 12.92;
    else
      G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B = BsRGB / 12.92;
    else
      B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h3 = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h3 + ", " + s + "%, " + v + "%)" : "hsva(" + h3 + ", " + s + "%, " + v + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h3 = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h3 + ", " + s + "%, " + l + "%)" : "hsla(" + h3 + ", " + s + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format) {
    var formatSet = !!format;
    format = format || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof(color) == "object") {
    var newColor = {};
    for (var i in color) {
      if (color.hasOwnProperty(i)) {
        if (i === "a") {
          newColor[i] = color[i];
        } else {
          newColor[i] = convertToPercentage(color[i]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h3, s, l = (max + min) / 2;
  if (max == min) {
    h3 = s = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h3 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h3 = (b - r) / d + 2;
        break;
      case b:
        h3 = (r - g) / d + 4;
        break;
    }
    h3 /= 6;
  }
  return {
    h: h3,
    s,
    l
  };
}
function hslToRgb(h3, s, l) {
  var r, g, b;
  h3 = bound01(h3, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  function hue2rgb(p2, q2, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6)
      return p2 + (q2 - p2) * 6 * t2;
    if (t2 < 1 / 2)
      return q2;
    if (t2 < 2 / 3)
      return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
    return p2;
  }
  if (s === 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h3 + 1 / 3);
    g = hue2rgb(p, q, h3);
    b = hue2rgb(p, q, h3 - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b), min = Math.min(r, g, b);
  var h3, s, v = max;
  var d = max - min;
  s = max === 0 ? 0 : d / max;
  if (max == min) {
    h3 = 0;
  } else {
    switch (max) {
      case r:
        h3 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h3 = (b - r) / d + 2;
        break;
      case b:
        h3 = (r - g) / d + 4;
        break;
    }
    h3 /= 6;
  }
  return {
    h: h3,
    s,
    v
  };
}
function hsvToRgb(h3, s, v) {
  h3 = bound01(h3, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h3), f = h3 - i, p = v * (1 - s), q = v * (1 - f * s), t2 = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t2, v][mod], g = [t2, v, v, q, p, p][mod], b = [p, p, t2, v, v, q][mod];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r, g, b, a) {
  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number) {
  if (isNaN(number) || number <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number;
  for (var i = 1; i < number; i++) {
    result.push(tinycolor({
      h: (hsl.h + i * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h3 = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h3 + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h3 + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h3 = hsv.h, s = hsv.s, v = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h3,
      s,
      v
    }));
    v = (v + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c2 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i = 0; i < colorList.length; i++) {
    readability = tinycolor.readability(baseColor, colorList[i]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o) {
  var flipped = {};
  for (var i in o) {
    if (o.hasOwnProperty(i)) {
      flipped[o[i]] = i;
    }
  }
  return flipped;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function bound01(n, max) {
  if (isOnePointZero(n))
    n = "100%";
  var processPercent = isPercentage(n);
  n = Math.min(max, Math.max(0, parseFloat(n)));
  if (processPercent) {
    n = parseInt(n * max, 10) / 100;
  }
  if (Math.abs(n - max) < 1e-6) {
    return 1;
  }
  return n % max / parseFloat(max);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n) {
  return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") != -1;
}
function pad2(c) {
  return c.length == 1 ? "0" + c : "" + c;
}
function convertToPercentage(n) {
  if (n <= 1) {
    n = n * 100 + "%";
  }
  return n;
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h3) {
  return parseIntFromHex(h3) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}
var lodashExports = {};
var lodash = {
  get exports() {
    return lodashExports;
  },
  set exports(v) {
    lodashExports = v;
  }
};
(function(module, exports) {
  (function() {
    var undefined$1;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [["ary", WRAP_ARY_FLAG], ["bind", WRAP_BIND_FLAG], ["bindKey", WRAP_BIND_KEY_FLAG], ["curry", WRAP_CURRY_FLAG], ["curryRight", WRAP_CURRY_RIGHT_FLAG], ["flip", WRAP_FLIP_FLAG], ["partial", WRAP_PARTIAL_FLAG], ["partialRight", WRAP_PARTIAL_RIGHT_FLAG], ["rearg", WRAP_REARG_FLAG]];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "c",
      "": "D",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "N",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "o",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "Y",
      "": "y",
      "": "y",
      "": "Ae",
      "": "ae",
      "": "Th",
      "": "th",
      "": "ss",
      // Latin Extended-A block.
      "": "A",
      "": "A",
      "": "A",
      "": "a",
      "": "a",
      "": "a",
      "": "C",
      "": "C",
      "": "C",
      "": "C",
      "": "c",
      "": "c",
      "": "c",
      "": "c",
      "": "D",
      "": "D",
      "": "d",
      "": "d",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "E",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "e",
      "": "G",
      "": "G",
      "": "G",
      "": "G",
      "": "g",
      "": "g",
      "": "g",
      "": "g",
      "": "H",
      "": "H",
      "": "h",
      "": "h",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "I",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "i",
      "": "J",
      "": "j",
      "": "K",
      "": "k",
      "": "k",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "L",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "l",
      "": "N",
      "": "N",
      "": "N",
      "": "N",
      "": "n",
      "": "n",
      "": "n",
      "": "n",
      "": "O",
      "": "O",
      "": "O",
      "": "o",
      "": "o",
      "": "o",
      "": "R",
      "": "R",
      "": "R",
      "": "r",
      "": "r",
      "": "r",
      "": "S",
      "": "S",
      "": "S",
      "": "S",
      "": "s",
      "": "s",
      "": "s",
      "": "s",
      "": "T",
      "": "T",
      "": "T",
      "": "t",
      "": "t",
      "": "t",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "U",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "u",
      "": "W",
      "": "w",
      "": "Y",
      "": "y",
      "": "Y",
      "": "Z",
      "": "Z",
      "": "Z",
      "": "z",
      "": "z",
      "": "z",
      "": "IJ",
      "": "ij",
      "": "Oe",
      "": "oe",
      "": "'n",
      "": "s"
    };
    var htmlEscapes = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
    var htmlUnescapes = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" };
    var stringEscapes = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator(array[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache2, key) {
      return cache2.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty3 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty3).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty3.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
        * Used to detect `data` property values to be HTML-escaped.
        *
        * @memberOf _.templateSettings
        * @type {RegExp}
        */
        "escape": reEscape,
        /**
        * Used to detect code to be evaluated.
        *
        * @memberOf _.templateSettings
        * @type {RegExp}
        */
        "evaluate": reEvaluate,
        /**
        * Used to detect `data` property values to inject.
        *
        * @memberOf _.templateSettings
        * @type {RegExp}
        */
        "interpolate": reInterpolate,
        /**
        * Used to reference the data object in the template text.
        *
        * @memberOf _.templateSettings
        * @type {string}
        */
        "variable": "",
        /**
        * Used to import variables into the compiled template.
        *
        * @memberOf _.templateSettings
        * @type {Object}
        */
        "imports": {
          /**
          * A reference to the `lodash` function.
          *
          * @memberOf _.templateSettings.imports
          * @type {Function}
          */
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array[index2];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty3.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty3.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? undefined$1 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = { "hash": new Hash(), "map": new (Map2 || ListCache)(), "string": new Hash() };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty3.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty3.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, { "configurable": true, "enumerable": true, "value": value, "writable": true });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value = array[index2], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$1 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty3.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache2 = caches[othIndex];
                if (!(cache2 ? cacheHas(cache2, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty3.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data = matchData[index2];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty3.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty3.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index2] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", { "configurable": true, "enumerable": false, "value": constant(string), "writable": true });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index2 = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index2 = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined$1;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString2(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString2(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined$1, args, holders, undefined$1, undefined$1, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function predicate2(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData2(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$1;
          }
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary2, arity];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString2(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData2(func);
        var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty3.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty3.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData2 = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty3.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty3.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty3.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function getTag2(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data = transforms[index2], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty3.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
      }
      function isIterateeCall(value, index2, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData2(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined$1 ? length : size2;
        while (++index2 < size2) {
          var rand = baseRandom(index2, lastIndex), value = array[rand];
          array[rand] = array[index2];
          array[index2] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size2);
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array, value, index2);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined$1 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value);
          if (index2 < length && eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined$1 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function interceptor2(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone3 = wrapperClone(parent2);
          clone3.__index__ = 0;
          clone3.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone3;
          } else {
            result2 = clone3;
          }
          var previous = clone3;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({ "func": thru, "args": [reverse], "thisArg": undefined$1 });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty3.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty3.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined$1 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind2 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip2(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function memoized2() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized2.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result2 = func.apply(this, args);
          memoized2.cache = cache2.set(key, result2) || cache2;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$1 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, { "leading": leading, "maxWait": wait, "trailing": trailing });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone2(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep2(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty3.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty3.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty3.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString2(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty3.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty3.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty3.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value === undefined$1) {
            index2 = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee2(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined$1) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString2(string).toLowerCase());
      }
      function deburr(string) {
        string = toString2(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString2(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        string = toString2(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString2(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString2(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString2(string), n);
      }
      function replace() {
        var args = arguments, string = toString2(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString2(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString2(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$1;
        }
        string = toString2(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty3.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty3.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString2(value).toLowerCase();
      }
      function toUpper(value) {
        return toString2(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString2(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString2(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString2(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString2(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind2(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString2(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum3(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at;
      lodash2.before = before;
      lodash2.bind = bind2;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce;
      lodash2.defaults = defaults;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip2;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys;
      lodash2.keysIn = keysIn;
      lodash2.map = map;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle2;
      lodash2.thru = thru;
      lodash2.toArray = toArray;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp;
      lodash2.clone = clone2;
      lodash2.cloneDeep = cloneDeep2;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith;
      lodash2.eq = eq;
      lodash2.escape = escape;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex;
      lodash2.findKey = findKey;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray;
      lodash2.isArrayBuffer = isArrayBuffer;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean;
      lodash2.isBuffer = isBuffer;
      lodash2.isDate = isDate;
      lodash2.isElement = isElement;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber;
      lodash2.isObject = isObject;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject;
      lodash2.isRegExp = isRegExp;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet;
      lodash2.isString = isString;
      lodash2.isSymbol = isSymbol;
      lodash2.isTypedArray = isTypedArray;
      lodash2.isUndefined = isUndefined;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop;
      lodash2.now = now;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace;
      lodash2.result = result;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum3;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString2;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty3.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({ "size": nativeMin(n, MAX_ARRAY_LENGTH), "type": methodName + (result2.__dir__ < 0 ? "Right" : "") });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({ "iteratee": getIteratee(iteratee2, 3), "type": type });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined$1) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function interceptor2(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty3.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{ "name": "wrapper", "func": undefined$1 }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _ = runInContext();
    if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(commonjsGlobal);
})(lodash, lodashExports);
function HexToRgb(str) {
  str = str.replace("#", "");
  var hxs = str.match(/../g);
  for (var i = 0; i < 3; i++)
    hxs[i] = parseInt(hxs[i], 16);
  return hxs;
}
function RgbToHex(a, b, c) {
  var hexs = [a.toString(16), b.toString(16), c.toString(16)];
  for (var i = 0; i < 3; i++)
    if (hexs[i].length == 1)
      hexs[i] = "0" + hexs[i];
  return "#" + hexs.join("");
}
function getDarkColor(color, level) {
  var rgbc = HexToRgb(color);
  for (var i = 0; i < 3; i++)
    rgbc[i] = Math.floor(rgbc[i] * (1 - level));
  return RgbToHex(rgbc[0], rgbc[1], rgbc[2]);
}
function getLightColor(color, level) {
  var rgbc = HexToRgb(color);
  for (var i = 0; i < 3; i++)
    rgbc[i] = Math.floor((255 - rgbc[i]) * level + rgbc[i]);
  return RgbToHex(rgbc[0], rgbc[1], rgbc[2]);
}
var dayjs_minExports = {};
var dayjs_min = {
  get exports() {
    return dayjs_minExports;
  },
  set exports(v) {
    dayjs_minExports = v;
  }
};
(function(module, exports) {
  !function(t2, e) {
    module.exports = e();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h3 = "quarter", c = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = {
      name: "en",
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
      ordinal: function ordinal(t3) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
        return "[" + t3 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      }
    }, m = function m2(t3, e2, n2) {
      var r2 = String(t3);
      return !r2 || r2.length >= e2 ? t3 : "" + Array(e2 + 1 - r2.length).join(n2) + t3;
    }, v = {
      s: m,
      z: function z(t3) {
        var e2 = -t3.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      },
      m: function t3(e2, n2) {
        if (e2.date() < n2.date())
          return -t3(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      },
      a: function a2(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      },
      p: function p2(t3) {
        return {
          M: f,
          y: c,
          w: o,
          d: a,
          D: d,
          h: u,
          m: s,
          s: i,
          ms: r,
          Q: h3
        }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      },
      u: function u2(t3) {
        return void 0 === t3;
      }
    }, g = "en", D = {};
    D[g] = M;
    var p = function p2(t3) {
      return t3 instanceof _;
    }, S = function t3(e2, n2, r2) {
      var i2;
      if (!e2)
        return g;
      if ("string" == typeof e2) {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1)
          return t3(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, w = function w2(t3, e2) {
      if (p(t3))
        return t3.clone();
      var n2 = "object" == typeof e2 ? e2 : {};
      return n2.date = t3, n2.args = arguments, new _(n2);
    }, O = v;
    O.l = S, O.i = p, O.w = function(t3, e2) {
      return w(t3, {
        locale: e2.$L,
        utc: e2.$u,
        x: e2.$x,
        $offset: e2.$offset
      });
    };
    var _ = function() {
      function M2(t3) {
        this.$L = S(t3.locale, null, true), this.parse(t3);
      }
      var m2 = M2.prototype;
      return m2.parse = function(t3) {
        this.$d = function(t4) {
          var e2 = t4.date, n2 = t4.utc;
          if (null === e2)
            return /* @__PURE__ */ new Date(NaN);
          if (O.u(e2))
            return /* @__PURE__ */ new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if ("string" == typeof e2 && !/Z$/i.test(e2)) {
            var r2 = e2.match($);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t3), this.$x = t3.x || {}, this.init();
      }, m2.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m2.$utils = function() {
        return O;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t3, e2) {
        var n2 = w(t3);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t3, e2) {
        return w(t3) < this.startOf(e2);
      }, m2.isBefore = function(t3, e2) {
        return this.endOf(e2) < w(t3);
      }, m2.$g = function(t3, e2, n2) {
        return O.u(t3) ? this[e2] : this.set(n2, t3);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t3, e2) {
        var n2 = this, r2 = !!O.u(e2) || e2, h4 = O.p(t3), l2 = function l3(t4, e3) {
          var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t4) : new Date(n2.$y, e3, t4), n2);
          return r2 ? i2 : i2.endOf(a);
        }, $2 = function $3(t4, e3) {
          return O.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (h4) {
          case c:
            return r2 ? l2(1, 0) : l2(31, 11);
          case f:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return $2(v2 + "Hours", 0);
          case u:
            return $2(v2 + "Minutes", 1);
          case s:
            return $2(v2 + "Seconds", 2);
          case i:
            return $2(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m2.$set = function(t3, e2) {
        var n2, o2 = O.p(t3), h4 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = h4 + "Date", n2[d] = h4 + "Date", n2[f] = h4 + "Month", n2[c] = h4 + "FullYear", n2[u] = h4 + "Hours", n2[s] = h4 + "Minutes", n2[i] = h4 + "Seconds", n2[r] = h4 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === f || o2 === c) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($2);
        return this.init(), this;
      }, m2.set = function(t3, e2) {
        return this.clone().$set(t3, e2);
      }, m2.get = function(t3) {
        return this[O.p(t3)]();
      }, m2.add = function(r2, h4) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $2 = O.p(h4), y2 = function y3(t3) {
          var e2 = w(l2);
          return O.w(e2.date(e2.date() + Math.round(t3 * r2)), l2);
        };
        if ($2 === f)
          return this.set(f, this.$M + r2);
        if ($2 === c)
          return this.set(c, this.$y + r2);
        if ($2 === a)
          return y2(1);
        if ($2 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t2, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return O.w(m3, this);
      }, m2.subtract = function(t3, e2) {
        return this.add(-1 * t3, e2);
      }, m2.format = function(t3) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h4 = function h5(t4, n3, i3, s3) {
          return t4 && (t4[n3] || t4(e2, r2)) || i3[n3].slice(0, s3);
        }, c2 = function c3(t4) {
          return O.s(s2 % 12 || 12, t4, "0");
        }, d2 = n2.meridiem || function(t4, e3, n3) {
          var r3 = t4 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        }, $2 = {
          YY: String(this.$y).slice(-2),
          YYYY: this.$y,
          M: a2 + 1,
          MM: O.s(a2 + 1, 2, "0"),
          MMM: h4(n2.monthsShort, a2, f2, 3),
          MMMM: h4(f2, a2),
          D: this.$D,
          DD: O.s(this.$D, 2, "0"),
          d: String(this.$W),
          dd: h4(n2.weekdaysMin, this.$W, o2, 2),
          ddd: h4(n2.weekdaysShort, this.$W, o2, 3),
          dddd: o2[this.$W],
          H: String(s2),
          HH: O.s(s2, 2, "0"),
          h: c2(1),
          hh: c2(2),
          a: d2(s2, u2, true),
          A: d2(s2, u2, false),
          m: String(u2),
          mm: O.s(u2, 2, "0"),
          s: String(this.$s),
          ss: O.s(this.$s, 2, "0"),
          SSS: O.s(this.$ms, 3, "0"),
          Z: i2
        };
        return r2.replace(y, function(t4, e3) {
          return e3 || $2[t4] || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, v2 = this - M3, g2 = O.m(this, M3);
        return g2 = ($2 = {}, $2[c] = g2 / 12, $2[f] = g2, $2[h3] = g2 / 3, $2[o] = (v2 - m3) / 6048e5, $2[a] = (v2 - m3) / 864e5, $2[u] = v2 / n, $2[s] = v2 / e, $2[i] = v2 / t2, $2)[y2] || v2, l2 ? g2 : O.a(g2);
      }, m2.daysInMonth = function() {
        return this.endOf(f).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t3, e2) {
        if (!t3)
          return this.$L;
        var n2 = this.clone(), r2 = S(t3, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return O.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), T = _.prototype;
    return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t3) {
      T[t3[1]] = function(e2) {
        return this.$g(e2, t3[0], t3[1]);
      };
    }), w.extend = function(t3, e2) {
      return t3.$i || (t3(e2, _, w), t3.$i = true), w;
    }, w.locale = S, w.isDayjs = p, w.unix = function(t3) {
      return w(1e3 * t3);
    }, w.en = D[g], w.Ls = D, w.p = {}, w;
  });
})(dayjs_min);
const dayjs = dayjs_minExports;
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var themeColor = ["#FFFFFF", "#000000", "#BFBFBF", "#323232", "#4472C4", "#ED7D31", "#A5A5A5", "#FFC000", "#5B9BD5", "#71AD47"];
var indexedColor = ["#000000", "#FFFFFF", "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF", "#000000", "#FFFFFF", "#FF0000", "#00FF00", "#0000FF", "#FFFF00", "#FF00FF", "#00FFFF", "#800000", "#008000", "#000080", "#808000", "#800080", "#008080", "#C0C0C0", "#808080", "#9999FF", "#993366", "#FFFFCC", "#CCFFFF", "#660066", "#FF8080", "#0066CC", "#CCCCFF", "#000080", "#FF00FF", "#FFFF00", "#00FFFF", "#800080", "#800000", "#008080", "#0000FF", "#00CCFF", "#CCFFFF", "#CCFFCC", "#FFFF99", "#99CCFF", "#FF99CC", "#CC99FF", "#FFCC99", "#3366FF", "#33CCCC", "#99CC00", "#FFCC00", "#FF9900", "#FF6600", "#666699", "#969696", "#003366", "#339966", "#003300", "#333300", "#993300", "#993366", "#333399", "#333333", "#FFFFFF"];
var defaultColWidth$1 = 80;
var defaultRowHeight$1 = 24;
function getData(src) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return requestExcel(getUrl(src), options);
}
function requestExcel(src, options) {
  return new Promise(function(resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.open(options.method || "GET", src, true);
    xhr.responseType = options.responseType || "arraybuffer";
    xhr.onload = function() {
      if (xhr.status === 200) {
        resolve(xhr.response);
      } else {
        reject(xhr.status);
      }
    };
    xhr.onerror = function() {
      reject(xhr.status);
    };
    xhr.withCredentials = options.withCredentials || false;
    if (options.headers) {
      Object.keys(options.headers).forEach(function(key) {
        xhr.setRequestHeader(key, options.headers[key]);
      });
    }
    xhr.send(options.body);
  });
}
function readExcelData(buffer) {
  try {
    var wb = new exceljsExports.Workbook();
    return wb.xlsx.load(buffer);
  } catch (e) {
    console.warn(e);
    return Promise.reject(e);
  }
}
function transferColumns(excelSheet, spreadSheet, options) {
  for (var i = 0; i < (excelSheet.columns || []).length; i++) {
    spreadSheet.cols[i.toString()] = {};
    if (excelSheet.columns[i].width) {
      spreadSheet.cols[i.toString()].width = excelSheet.columns[i].width * 6 + (options.widthOffset || 0);
    } else {
      spreadSheet.cols[i.toString()].width = defaultColWidth$1 + (options.widthOffset || 0);
    }
  }
  spreadSheet.cols.len = Math.max(Object.keys(spreadSheet.cols).length, options.minColLength || 0);
}
function getCellText(cell) {
  var numFmt = cell.numFmt, value = cell.value, type = cell.type;
  switch (type) {
    case 2:
      try {
        if (cell.style.numFmt) {
          if (cell.style.numFmt.endsWith("%")) {
            var precision = cell.style.numFmt.match(/\.(\d+)%/);
            if (precision) {
              return (value * 100).toFixed(precision[1].length) + "%";
            } else {
              return value * 100 + "%";
            }
          } else if (/0(\.0+)?/.test(cell.style.numFmt)) {
            var prefix = "";
            if (cell.style.numFmt.startsWith("$")) {
              prefix = "$";
            } else if (cell.style.numFmt.startsWith('"')) {
              prefix = "";
            }
            if (value === 0 && cell.style.numFmt.startsWith("_")) {
              return "-";
            }
            var _precision = cell.style.numFmt.match(/0\.(0+)(_|;|$)/);
            if (_precision) {
              _precision = _precision[1].length;
            } else {
              _precision = 0;
            }
            var result = value.toFixed(_precision) + "";
            if (cell.style.numFmt.includes("#,##")) {
              result = result.split(".");
              var number = result[0].split("").reverse();
              var newNumber = [];
              for (var i = 0; i < number.length; i++) {
                newNumber.push(number[i]);
                if ((i + 1) % 3 === 0 && i < number.length - 1 && number[i + 1] !== "-") {
                  newNumber.push(",");
                }
              }
              result[0] = newNumber.reverse().join("");
              result = result.join(".");
            }
            return prefix + result;
          }
        }
        return value + "";
      } catch (e) {
        return value;
      }
    case 3:
      return value;
    case 4:
      switch (numFmt) {
        case "yyyy-mm-dd;@":
          return dayjs(value).format("YYYY-MM-DD");
        case "mm-dd-yy":
          return dayjs(value).format("YYYY/MM/DD");
        case "[$-F800]dddd, mmmm dd, yyyy":
          return dayjs(value).format("YYYYMD ddd");
        case 'm""d"";@':
          return dayjs(value).format("MD");
        case "yyyy/m/d h:mm;@":
        case 'm/d/yy "h":mm':
          return dayjs(value).subtract(8, "hour").format("YYYY/M/DD HH:mm");
        case "h:mm;@":
          return dayjs(value).format("HH:mm");
        default:
          return dayjs(value).format("YYYY-MM-DD");
      }
    case 5:
      return value.text;
    case 6:
      return lodashExports.get(value, "result.error") || value.result;
    case 8:
      return cell.text;
    case 9:
      return cell.text.toUpperCase();
    default:
      return value;
  }
}
function transferArgbColor(originColor) {
  if (typeof originColor === "object") {
    return "#000000";
  }
  if (/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.test(originColor)) {
    return originColor.startsWith("#") ? originColor : "#" + originColor;
  }
  originColor = originColor.trim().toLowerCase();
  var color = {};
  try {
    var argb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(originColor);
    color.r = parseInt(argb[2], 16);
    color.g = parseInt(argb[3], 16);
    color.b = parseInt(argb[4], 16);
    color.a = parseInt(argb[1], 16) / 255;
    return tinycolor("rgba(".concat(color.r, ", ").concat(color.g, ", ").concat(color.b, ", ").concat(color.a, ")")).toHexString();
  } catch (e) {
    console.warn(e);
  }
}
function transferThemeColor(themeIndex, tint) {
  if (themeIndex > 9) {
    return "#C7C9CC";
  }
  if (typeof tint === "undefined") {
    return themeColor[themeIndex];
  } else if (tint > 0) {
    return getLightColor(themeColor[themeIndex], tint);
  } else {
    return getDarkColor(themeColor[themeIndex], Math.abs(tint));
  }
}
function getStyle(cell) {
  cell.style = lodashExports.cloneDeep(cell.style);
  var backGroundColor = null;
  if (cell.style.fill && cell.style.fill.fgColor) {
    if (cell.style.fill.fgColor.argb) {
      backGroundColor = transferArgbColor(cell.style.fill.fgColor.argb);
    } else if (cell.style.fill.fgColor.hasOwnProperty("theme")) {
      backGroundColor = transferThemeColor(cell.style.fill.fgColor.theme, cell.style.fill.fgColor.tint);
    } else if (cell.style.fill.fgColor.indexed) {
      backGroundColor = indexedColor[cell.style.fill.fgColor.indexed] || "#C7C9CC";
    } else {
      backGroundColor = "#C7C9CC";
    }
  }
  if (backGroundColor) {
    cell.style.bgcolor = backGroundColor;
  }
  var fontColor = null;
  if (cell.style.font && cell.style.font.color) {
    if (cell.style.font.color.argb) {
      fontColor = transferArgbColor(cell.style.font.color.argb);
    } else if (cell.style.font.color.hasOwnProperty("theme")) {
      fontColor = transferThemeColor(cell.style.font.color.theme, cell.style.font.color.tint);
    } else if (cell.style.font.color.indexed) {
      fontColor = indexedColor[cell.style.font.color.indexed] || "#000000";
    } else {
      fontColor = "#000000";
    }
  }
  if (fontColor) {
    cell.style.color = fontColor;
  }
  if (cell.style.alignment) {
    if (cell.style.alignment.horizontal) {
      cell.style.align = cell.style.alignment.horizontal;
    }
    if (cell.style.alignment.vertical) {
      cell.style.valign = cell.style.alignment.vertical;
    }
  }
  if (cell.style.alignment && cell.style.alignment.wrapText) {
    cell.style.textwrap = true;
  }
  if (cell.style.border) {
    var styleBorder = {};
    Object.keys(cell.style.border).forEach(function(position) {
      var originBorder = cell.style.border[position];
      var bordColor = "#000000";
      if (typeof originBorder.color === "string") {
        bordColor = originBorder.color;
      } else if (originBorder.color) {
        if (originBorder.color.argb) {
          bordColor = transferArgbColor(originBorder.color.argb);
        } else if (originBorder.color.hasOwnProperty("theme")) {
          bordColor = transferThemeColor(originBorder.color.theme, originBorder.color.tint);
        } else if (originBorder.color.indexed) {
          bordColor = indexedColor[originBorder.color.indexed];
        }
      }
      styleBorder[position] = [originBorder.style || "thin", bordColor];
    });
    cell.style.border2 = _objectSpread$1({}, cell.style.border);
    cell.style.border = styleBorder;
  }
  return cell.style;
}
function transferExcelToSpreadSheet(workbook, options) {
  var workbookData = [];
  console.log(workbook, "workbook");
  var sheets = [];
  workbook.eachSheet(function(sheet) {
    sheets.push(sheet);
    var sheetData = {
      name: sheet.name,
      styles: [],
      rows: {},
      cols: {},
      merges: [],
      media: []
    };
    var mergeAddressData = [];
    for (var mergeRange in sheet._merges) {
      sheetData.merges.push(sheet._merges[mergeRange].shortRange);
      var mergeAddress = {};
      mergeAddress.startAddress = sheet._merges[mergeRange].tl;
      mergeAddress.endAddress = sheet._merges[mergeRange].br;
      mergeAddress.YRange = sheet._merges[mergeRange].model.bottom - sheet._merges[mergeRange].model.top;
      mergeAddress.XRange = sheet._merges[mergeRange].model.right - sheet._merges[mergeRange].model.left;
      mergeAddressData.push(mergeAddress);
    }
    transferColumns(sheet, sheetData, options);
    (sheet._rows || []).forEach(function(row, spreadSheetRowIndex) {
      sheetData.rows[spreadSheetRowIndex] = {
        cells: {}
      };
      if (row.height) {
        sheetData.rows[spreadSheetRowIndex].height = row.height + (options.heightOffset || 0);
      } else {
        sheetData.rows[spreadSheetRowIndex].height = defaultRowHeight$1 + (options.heightOffset || 0);
      }
      (row._cells || []).forEach(function(cell, spreadSheetColIndex) {
        sheetData.rows[spreadSheetRowIndex].cells[spreadSheetColIndex] = {};
        var mergeAddress2 = lodashExports.find(mergeAddressData, function(o) {
          return o.startAddress == cell._address;
        });
        if (mergeAddress2 && cell.master.address != mergeAddress2.startAddress) {
          return;
        }
        if (mergeAddress2) {
          sheetData.rows[spreadSheetRowIndex].cells[spreadSheetColIndex].merge = [mergeAddress2.YRange, mergeAddress2.XRange];
        }
        sheetData.rows[spreadSheetRowIndex].cells[spreadSheetColIndex].text = getCellText(cell);
        sheetData.styles.push(getStyle(cell));
        sheetData.rows[spreadSheetRowIndex].cells[spreadSheetColIndex].style = sheetData.styles.length - 1;
      });
    });
    if (sheetData._media) {
      sheetData.media = sheetData._media;
    }
    var tempRowsKeys = Object.keys(sheetData.rows);
    sheetData.rows.len = Math.max(tempRowsKeys[tempRowsKeys.length - 1] + 1, 100);
    workbookData.push(sheetData);
  });
  workbook._worksheets = sheets;
  return {
    workbookData,
    workbookSource: workbook,
    medias: workbook.media || []
  };
}
var cache = [];
function renderImage(ctx, medias, sheet, offset) {
  if (sheet && sheet._media.length) {
    sheet._media.forEach(function(media) {
      var imageId = media.imageId, range = media.range, type = media.type;
      if (type === "image") {
        var position = calcPosition(sheet, range, offset);
        drawImage(ctx, imageId, medias[imageId], position);
      }
    });
  }
}
var clipWidth = 60;
var clipHeight = 25;
var defaultColWidth = 80;
var defaultRowHeight = 24;
var devicePixelRatio = window.devicePixelRatio;
function calcPosition(sheet, range, offset) {
  var _offset$scroll, _offset$scroll2;
  var _range$tl = range.tl, tl = _range$tl === void 0 ? {} : _range$tl, _range$br = range.br, br = _range$br === void 0 ? {} : _range$br;
  var nativeCol = tl.nativeCol, nativeColOff = tl.nativeColOff, nativeRow = tl.nativeRow, nativeRowOff = tl.nativeRowOff;
  var basicX = clipWidth;
  var basicY = clipHeight;
  for (var i = 0; i < nativeCol; i++) {
    var _sheet$_columns, _sheet$_columns$i;
    basicX += (sheet === null || sheet === void 0 ? void 0 : (_sheet$_columns = sheet._columns) === null || _sheet$_columns === void 0 ? void 0 : (_sheet$_columns$i = _sheet$_columns[i]) === null || _sheet$_columns$i === void 0 ? void 0 : _sheet$_columns$i.width) * 6 || defaultColWidth;
  }
  for (var _i = 0; _i < nativeRow; _i++) {
    var _sheet$_rows, _sheet$_rows$_i;
    basicY += (sheet === null || sheet === void 0 ? void 0 : (_sheet$_rows = sheet._rows) === null || _sheet$_rows === void 0 ? void 0 : (_sheet$_rows$_i = _sheet$_rows[_i]) === null || _sheet$_rows$_i === void 0 ? void 0 : _sheet$_rows$_i.height) || defaultRowHeight;
  }
  var x = basicX + nativeColOff / 12700;
  var y = basicY + nativeRowOff / 12700;
  var nativeColEnd = br.nativeCol, nativeColOffEnd = br.nativeColOff, nativeRowEnd = br.nativeRow, nativeRowOffEnd = br.nativeRowOff;
  var width2;
  if (nativeCol === nativeColEnd) {
    width2 = (nativeColOffEnd - nativeColOff) / 12700;
  } else {
    var _sheet$_columns2, _sheet$_columns2$nati;
    width2 = ((sheet === null || sheet === void 0 ? void 0 : (_sheet$_columns2 = sheet._columns) === null || _sheet$_columns2 === void 0 ? void 0 : (_sheet$_columns2$nati = _sheet$_columns2[nativeCol]) === null || _sheet$_columns2$nati === void 0 ? void 0 : _sheet$_columns2$nati.width) * 6 || defaultColWidth) - nativeColOff / 12700;
    for (var _i2 = nativeCol + 1; _i2 < nativeColEnd; _i2++) {
      var _sheet$_columns3, _sheet$_columns3$_i;
      width2 += (sheet === null || sheet === void 0 ? void 0 : (_sheet$_columns3 = sheet._columns) === null || _sheet$_columns3 === void 0 ? void 0 : (_sheet$_columns3$_i = _sheet$_columns3[_i2]) === null || _sheet$_columns3$_i === void 0 ? void 0 : _sheet$_columns3$_i.width) * 6 || defaultColWidth;
    }
    width2 += nativeColOffEnd / 12700;
  }
  var height2;
  if (nativeRow === nativeRowEnd) {
    height2 = (nativeRowOffEnd - nativeRowOff) / 12700;
  } else {
    var _sheet$_rows2, _sheet$_rows2$nativeR;
    height2 = ((sheet === null || sheet === void 0 ? void 0 : (_sheet$_rows2 = sheet._rows) === null || _sheet$_rows2 === void 0 ? void 0 : (_sheet$_rows2$nativeR = _sheet$_rows2[nativeRow]) === null || _sheet$_rows2$nativeR === void 0 ? void 0 : _sheet$_rows2$nativeR.height) || defaultRowHeight) - nativeRowOff / 12700;
    for (var _i3 = nativeRow + 1; _i3 < nativeRowEnd; _i3++) {
      var _sheet$_rows3, _sheet$_rows3$_i;
      height2 += (sheet === null || sheet === void 0 ? void 0 : (_sheet$_rows3 = sheet._rows) === null || _sheet$_rows3 === void 0 ? void 0 : (_sheet$_rows3$_i = _sheet$_rows3[_i3]) === null || _sheet$_rows3$_i === void 0 ? void 0 : _sheet$_rows3$_i.height) || defaultRowHeight;
    }
    height2 += nativeRowOffEnd / 12700;
  }
  return {
    x: (x - ((offset === null || offset === void 0 ? void 0 : (_offset$scroll = offset.scroll) === null || _offset$scroll === void 0 ? void 0 : _offset$scroll.x) || 0)) * devicePixelRatio,
    y: (y - ((offset === null || offset === void 0 ? void 0 : (_offset$scroll2 = offset.scroll) === null || _offset$scroll2 === void 0 ? void 0 : _offset$scroll2.y) || 0)) * devicePixelRatio,
    width: width2 * devicePixelRatio,
    height: height2 * devicePixelRatio
  };
}
function clearCache() {
  cache = [];
}
function drawImage(ctx, index2, data, position) {
  getImage(index2, data).then(function(image) {
    var sx = 0;
    var sy = 0;
    var sWidth = image.width;
    var sHeight = image.height;
    var dx = position.x;
    var dy = position.y;
    var dWidth = position.width;
    var dHeight = position.height;
    var scaleX = dWidth / sWidth;
    var scaleY = dHeight / sHeight;
    if (dx < clipWidth * devicePixelRatio) {
      var diff = clipWidth * devicePixelRatio - dx;
      dx = clipWidth * devicePixelRatio;
      dWidth -= diff;
      sWidth -= diff / scaleX;
      sx += diff / scaleX;
    }
    if (dy < clipHeight * devicePixelRatio) {
      var _diff = clipHeight * devicePixelRatio - dy;
      dy = clipHeight * devicePixelRatio;
      dHeight -= _diff;
      sHeight -= _diff / scaleY;
      sy += _diff / scaleY;
    }
    ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
  }).catch(function(e) {
    console.error(e);
  });
}
function getImage(index2, data) {
  return new Promise(function(resolve, reject) {
    if (cache[index2]) {
      return resolve(cache[index2]);
    }
    var buffer = data.buffer.buffer;
    var blob = new Blob([buffer], {
      type: "image/" + data.extension
    });
    var url = URL.createObjectURL(blob);
    var image = new Image();
    image.src = url;
    image.onload = function() {
      resolve(image);
      cache[index2] = image;
    };
    image.onerror = function(e) {
      reject(e);
    };
  });
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i >= o.length)
          return { done: true };
        return { done: false, value: o[i++] };
      }, e: function e(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s() {
    it = it.call(o);
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function readOnlyInput(root) {
  if (root) {
    var nodes = root.querySelectorAll("input");
    var _iterator = _createForOfIteratorHelper(nodes), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var node = _step.value;
        node && !node.readOnly && (node.readOnly = true);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    document.activeElement && document.activeElement.blur();
  }
}
var render13 = function render14() {
  var _vm = this;
  var _h = _vm.$createElement;
  var _c = _vm._self._c || _h;
  return _c("div", {
    ref: "wrapperRef",
    staticClass: "vue-office-excel"
  }, [_c("div", {
    ref: "rootRef",
    staticClass: "vue-office-excel-main"
  })]);
};
var staticRenderFns = [];
function normalizeComponent(scriptExports, render15, staticRenderFns2, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
  var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
  if (render15) {
    options.render = render15;
    options.staticRenderFns = staticRenderFns2;
    options._compiled = true;
  }
  if (functionalTemplate) {
    options.functional = true;
  }
  if (scopeId) {
    options._scopeId = "data-v-" + scopeId;
  }
  var hook;
  if (moduleIdentifier) {
    hook = function(context) {
      context = context || // cached call
      this.$vnode && this.$vnode.ssrContext || // stateful
      this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext;
      if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
        context = __VUE_SSR_CONTEXT__;
      }
      if (injectStyles) {
        injectStyles.call(this, context);
      }
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier);
      }
    };
    options._ssrRegister = hook;
  } else if (injectStyles) {
    hook = shadowMode ? function() {
      injectStyles.call(
        this,
        (options.functional ? this.parent : this).$root.$options.shadowRoot
      );
    } : injectStyles;
  }
  if (hook) {
    if (options.functional) {
      options._injectStyles = hook;
      var originalRender = options.render;
      options.render = function renderWithStyleInjection(h3, context) {
        hook.call(context);
        return originalRender(h3, context);
      };
    } else {
      var existing = options.beforeCreate;
      options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
    }
  }
  return {
    exports: scriptExports,
    options
  };
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
var defaultOptions = {
  minColLength: 20
};
var __vue2_script = defineComponent({
  name: "VueOfficeExcel",
  props: {
    src: [String, ArrayBuffer, Blob],
    requestOptions: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    options: {
      type: Object,
      default: function _default2() {
        return _objectSpread({}, defaultOptions);
      }
    }
  },
  emits: ["rendered", "error"],
  setup: function setup(props, _ref) {
    var emit = _ref.emit;
    console.log(props.options.transformData);
    var wrapperRef = ref(null);
    var rootRef = ref(null);
    var workbookDataSource = {
      _worksheets: []
    };
    var mediasSource = [];
    var sheetIndex = 0;
    var ctx = null;
    var xs = null;
    var offset = null;
    var fileData = null;
    function renderExcel(buffer) {
      fileData = buffer;
      readExcelData(buffer).then(function(workbook) {
        if (!workbook._worksheets || workbook._worksheets.length === 0) {
          throw new Error("");
        }
        var _transferExcelToSprea = transferExcelToSpreadSheet(workbook, _objectSpread(_objectSpread({}, defaultOptions), props.options)), workbookData = _transferExcelToSprea.workbookData, medias = _transferExcelToSprea.medias, workbookSource = _transferExcelToSprea.workbookSource;
        if (props.options.transformData && typeof props.options.transformData === "function") {
          workbookData = props.options.transformData(workbookData);
        }
        mediasSource = medias;
        workbookDataSource = workbookSource;
        offset = null;
        sheetIndex = 0;
        clearCache();
        xs.loadData(workbookData);
        renderImage(ctx, mediasSource, workbookDataSource._worksheets[sheetIndex], offset);
        emit("rendered");
      }).catch(function(e) {
        console.warn(e);
        mediasSource = [];
        workbookDataSource = {
          _worksheets: []
        };
        clearCache();
        xs && xs.loadData({});
        emit("error", e);
      });
    }
    var observerCallback = lodashExports.debounce(readOnlyInput, 200).bind(this, rootRef.value);
    var observer = new MutationObserver(observerCallback);
    var observerConfig = {
      attributes: true,
      childList: true,
      subtree: true
    };
    onMounted(function() {
      nextTick(function() {
        observer.observe(rootRef.value, observerConfig);
        observerCallback(rootRef);
        xs = new Spreadsheet(rootRef.value, {
          mode: "read",
          showToolbar: false,
          showContextmenu: props.options.showContextmenu || false,
          view: {
            height: function height2() {
              return wrapperRef.value && wrapperRef.value.clientHeight || 300;
            },
            width: function width2() {
              return wrapperRef.value && wrapperRef.value.clientWidth || 1200;
            }
          },
          row: {
            height: 24,
            len: 100
          },
          col: {
            len: 26,
            width: 80,
            indexWidth: 60,
            minWidth: 60
          },
          autoFocus: false
        }).loadData({});
        var swapFunc = xs.bottombar.swapFunc;
        xs.bottombar.swapFunc = function(index2) {
          swapFunc.call(xs.bottombar, index2);
          sheetIndex = index2;
          setTimeout(function() {
            xs.reRender();
            renderImage(ctx, mediasSource, workbookDataSource._worksheets[sheetIndex], offset);
          });
        };
        var clear = xs.sheet.editor.clear;
        xs.sheet.editor.clear = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          clear.apply(xs.sheet.editor, args);
          setTimeout(function() {
            renderImage(ctx, mediasSource, workbookDataSource._worksheets[sheetIndex], offset);
          });
        };
        var setOffset = xs.sheet.editor.setOffset;
        xs.sheet.editor.setOffset = function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          setOffset.apply(xs.sheet.editor, args);
          offset = args[0];
          renderImage(ctx, mediasSource, workbookDataSource._worksheets[sheetIndex], offset);
        };
        var canvas = rootRef.value.querySelector("canvas");
        ctx = canvas.getContext("2d");
        if (props.src) {
          getData(props.src, props.requestOptions).then(renderExcel).catch(function(e) {
            xs.loadData({});
            emit("error", e);
          });
        }
      });
    });
    onBeforeUnmount(function() {
      observer.disconnect();
      xs = null;
    });
    watch(function() {
      return props.src;
    }, function() {
      if (props.src) {
        getData(props.src, props.requestOptions).then(renderExcel).catch(function(e) {
          xs.loadData({});
          emit("error", e);
        });
      } else {
        xs.loadData({});
      }
    });
    function save(fileName) {
      download(fileName || "vue-office-excel-".concat((/* @__PURE__ */ new Date()).getTime(), ".xlsx"), fileData);
    }
    return {
      wrapperRef,
      rootRef,
      save
    };
  }
});
var __cssModules = {};
var __component__ = /* @__PURE__ */ normalizeComponent(__vue2_script, render13, staticRenderFns, false, __vue2_injectStyles, null, null, null);
function __vue2_injectStyles(context) {
  for (var o in __cssModules) {
    this[o] = __cssModules[o];
  }
}
const VueOfficeExcel = /* @__PURE__ */ function() {
  return __component__.exports;
}();
VueOfficeExcel.install = function(Vue) {
  Vue.component(VueOfficeExcel.name, VueOfficeExcel);
};
export {
  VueOfficeExcel as default
};
